<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<meta name="author" content="Ben Lauwens, Allen Downey">
<title>Think Julia: How to Think Like a Computer Scientist</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<style>
/* Pygments styles disabled. Pygments is not available. */
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Think Julia: How to Think Like a Computer Scientist</h1>
<div class="details">
<span id="author" class="author">Ben Lauwens</span><br>
<span id="email" class="email"><a href="mailto:ben.lauwens@gmail.com">ben.lauwens@gmail.com</a></span><br>
<span id="author2" class="author">Allen Downey</span><br>
<span id="email2" class="email"><a href="mailto:allendowney@gmail.com">allendowney@gmail.com</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_copyright">1. Copyright</a></li>
<li><a href="#_dedication">2. Dedication</a></li>
<li><a href="#_preface">3. Preface</a>
<ul class="sectlevel2">
<li><a href="#_why_julia">Why Julia?</a></li>
<li><a href="#_who_is_this_book_for">Who Is This Book For?</a></li>
<li><a href="#_conventions_used_in_this_book">Conventions Used in This Book</a></li>
<li><a href="#_using_code_examples">Using Code Examples</a></li>
<li><a href="#_acknowledgments">Acknowledgments</a></li>
<li><a href="#_contributor_list">Contributor List</a></li>
</ul>
</li>
<li><a href="#chap01">4. O Caminho da Programação</a>
<ul class="sectlevel2">
<li><a href="#_o_que_é_um_programa">O que é um Programa?</a></li>
<li><a href="#_executando_o_julia">Executando o Julia</a></li>
<li><a href="#_o_primeiro_programa">O Primeiro Programa</a></li>
<li><a href="#_operações_aritméticas">Operações Aritméticas</a></li>
<li><a href="#_valores_e_tipos">Valores e Tipos</a></li>
<li><a href="#_linguagens_formais_e_naturais">Linguagens Formais e Naturais</a></li>
<li><a href="#_debug">Debug</a></li>
<li><a href="#_glossário">Glossário</a></li>
<li><a href="#_exercícios">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap02">5. Variáveis, Expressões e Declarações</a>
<ul class="sectlevel2">
<li><a href="#_declarações_de_atribuição">Declarações de Atribuição</a></li>
<li><a href="#_nomes_de_variáveis">Nomes de variáveis</a></li>
<li><a href="#_expressões_e_declarações">Expressões e Declarações</a></li>
<li><a href="#_modo_script">Modo Script</a></li>
<li><a href="#_precedência_de_operadores">Precedência de Operadores</a></li>
<li><a href="#_operações_com_strings">Operações com Strings</a></li>
<li><a href="#_comentários">Comentários</a></li>
<li><a href="#_debugando">Debugando</a></li>
<li><a href="#_glossário_2">Glossário</a></li>
<li><a href="#_exercícios_2">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap03">6. Funções</a>
<ul class="sectlevel2">
<li><a href="#_chamadas_de_funções">Chamadas de funções</a></li>
<li><a href="#_funções_matemáticas">Funções matemáticas</a></li>
<li><a href="#_composição">Composição</a></li>
<li><a href="#_adicionando_novas_funções">Adicionando novas funções</a></li>
<li><a href="#_definições_e_usos">Definições e usos</a></li>
<li><a href="#_fluxo_de_execução">Fluxo de execução</a></li>
<li><a href="#_parâmetros_e_argumentos">Parâmetros e argumentos</a></li>
<li><a href="#_as_variáveis_e_os_parâmetros_são_locais">As variáveis e os parâmetros são locais</a></li>
<li><a href="#stack_diagrams">Diagramas de Pilha</a></li>
<li><a href="#_funções_produtivas_e_funções_nulas">Funções produtivas e funções nulas</a></li>
<li><a href="#_por_que_funções">Por que funções?</a></li>
<li><a href="#_debugging">Debugging</a></li>
<li><a href="#_glossário_3">Glossário</a></li>
<li><a href="#_exercícios_3">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap04">7. Case Study: Interface Design</a>
<ul class="sectlevel2">
<li><a href="#_turtles">Turtles</a></li>
<li><a href="#simple_repetition">Simple Repetition</a></li>
<li><a href="#_exercises">Exercises</a></li>
<li><a href="#_encapsulation">Encapsulation</a></li>
<li><a href="#_generalization">Generalization</a></li>
<li><a href="#_interface_design">Interface Design</a></li>
<li><a href="#refactoring">Refactoring</a></li>
<li><a href="#_a_development_plan">A Development Plan</a></li>
<li><a href="#_docstring">Docstring</a></li>
<li><a href="#_debugging_2">Debugging</a></li>
<li><a href="#_glossary">Glossary</a></li>
<li><a href="#_exercises_2">Exercises</a></li>
</ul>
</li>
<li><a href="#chap05">8. Conditionals and Recursion</a>
<ul class="sectlevel2">
<li><a href="#_floor_division_and_modulus">Floor Division and Modulus</a></li>
<li><a href="#_boolean_expressions">Boolean Expressions</a></li>
<li><a href="#_logical_operators">Logical Operators</a></li>
<li><a href="#_conditional_execution">Conditional Execution</a></li>
<li><a href="#_alternative_execution">Alternative Execution</a></li>
<li><a href="#_chained_conditionals">Chained Conditionals</a></li>
<li><a href="#_nested_conditionals">Nested Conditionals</a></li>
<li><a href="#recursion">Recursion</a></li>
<li><a href="#_stack_diagrams_for_recursive_functions">Stack Diagrams for Recursive Functions</a></li>
<li><a href="#_infinite_recursion">Infinite Recursion</a></li>
<li><a href="#_keyboard_input">Keyboard Input</a></li>
<li><a href="#_debugging_3">Debugging</a></li>
<li><a href="#_glossary_2">Glossary</a></li>
<li><a href="#_exercises_3">Exercises</a></li>
</ul>
</li>
<li><a href="#chap06">9. Fruitful Functions</a>
<ul class="sectlevel2">
<li><a href="#_return_values">Return Values</a></li>
<li><a href="#incremental_development">Incremental Development</a></li>
<li><a href="#_composition">Composition</a></li>
<li><a href="#boolean_functions">Boolean Functions</a></li>
<li><a href="#_more_recursion">More Recursion</a></li>
<li><a href="#_leap_of_faith">Leap of Faith</a></li>
<li><a href="#one_more_example">One More Example</a></li>
<li><a href="#_checking_types">Checking Types</a></li>
<li><a href="#deb06">Debugging</a></li>
<li><a href="#_glossary_3">Glossary</a></li>
<li><a href="#_exercises_4">Exercises</a></li>
</ul>
</li>
<li><a href="#chap07">10. Iteration</a>
<ul class="sectlevel2">
<li><a href="#_reassignment">Reassignment</a></li>
<li><a href="#_updating_variables">Updating Variables</a></li>
<li><a href="#_the_code_while_code_statement">The <code>while</code> Statement</a></li>
<li><a href="#__code_break_code"><code>break</code></a></li>
<li><a href="#__code_continue_code"><code>continue</code></a></li>
<li><a href="#square_roots">Square Roots</a></li>
<li><a href="#_algorithms">Algorithms</a></li>
<li><a href="#_debugging_4">Debugging</a></li>
<li><a href="#_glossary_4">Glossary</a></li>
<li><a href="#_exercises_5">Exercises</a></li>
</ul>
</li>
<li><a href="#chap08">11. Strings</a>
<ul class="sectlevel2">
<li><a href="#characters">Characters</a></li>
<li><a href="#_a_string_is_a_sequence">A String Is a Sequence</a></li>
<li><a href="#__code_length_code"><code>length</code></a></li>
<li><a href="#_traversal">Traversal</a></li>
<li><a href="#_string_slices">String Slices</a></li>
<li><a href="#_strings_are_immutable">Strings Are Immutable</a></li>
<li><a href="#_string_interpolation">String Interpolation</a></li>
<li><a href="#searching">Searching</a></li>
<li><a href="#looping_and_counting">Looping and Counting</a></li>
<li><a href="#_string_library">String Library</a></li>
<li><a href="#_the_code_code_operator">The <code>∈</code> Operator</a></li>
<li><a href="#_string_comparison">String Comparison</a></li>
<li><a href="#deb08">Debugging</a></li>
<li><a href="#_glossary_5">Glossary</a></li>
<li><a href="#_exercises_6">Exercises</a></li>
</ul>
</li>
<li><a href="#chap09">12. Case Study: Word Play</a>
<ul class="sectlevel2">
<li><a href="#reading_word_lists">Reading Word Lists</a></li>
<li><a href="#_exercises_7">Exercises</a></li>
<li><a href="#search">Search</a></li>
<li><a href="#_looping_with_indices">Looping with Indices</a></li>
<li><a href="#_debugging_5">Debugging</a></li>
<li><a href="#_glossary_6">Glossary</a></li>
<li><a href="#_exercises_8">Exercises</a></li>
</ul>
</li>
<li><a href="#chap10">13. Arrays</a>
<ul class="sectlevel2">
<li><a href="#_an_array_is_a_sequence">An Array is a Sequence</a></li>
<li><a href="#_arrays_are_mutable">Arrays Are Mutable</a></li>
<li><a href="#_traversing_an_array">Traversing an Array</a></li>
<li><a href="#_array_slices">Array Slices</a></li>
<li><a href="#_array_library">Array Library</a></li>
<li><a href="#_map_filter_and_reduce">Map, Filter and Reduce</a></li>
<li><a href="#_dot_syntax">Dot Syntax</a></li>
<li><a href="#_deleting_inserting_elements">Deleting (Inserting) Elements</a></li>
<li><a href="#_arrays_and_strings">Arrays and Strings</a></li>
<li><a href="#_objects_and_values">Objects and Values</a></li>
<li><a href="#_aliasing">Aliasing</a></li>
<li><a href="#_array_arguments">Array Arguments</a></li>
<li><a href="#_debugging_6">Debugging</a></li>
<li><a href="#_glossary_7">Glossary</a></li>
<li><a href="#_exercises_9">Exercises</a></li>
</ul>
</li>
<li><a href="#chap11">14. Dictionaries</a>
<ul class="sectlevel2">
<li><a href="#_a_dictionary_is_a_mapping">A Dictionary Is a Mapping</a></li>
<li><a href="#dictionary_collection_counters">Dictionary as a Collection of Counters</a></li>
<li><a href="#_looping_and_dictionaries">Looping and Dictionaries</a></li>
<li><a href="#_reverse_lookup">Reverse Lookup</a></li>
<li><a href="#_dictionaries_and_arrays">Dictionaries and Arrays</a></li>
<li><a href="#memos">Memos</a></li>
<li><a href="#global_variables">Global Variables</a></li>
<li><a href="#_debugging_7">Debugging</a></li>
<li><a href="#_glossary_8">Glossary</a></li>
<li><a href="#_exercises_10">Exercises</a></li>
</ul>
</li>
<li><a href="#chap12">15. Tuples</a>
<ul class="sectlevel2">
<li><a href="#_tuples_are_immutable">Tuples Are Immutable</a></li>
<li><a href="#_tuple_assignment">Tuple Assignment</a></li>
<li><a href="#_tuples_as_return_values">Tuples as Return Values</a></li>
<li><a href="#_variable_length_argument_tuples">Variable-length Argument Tuples</a></li>
<li><a href="#_arrays_and_tuples">Arrays and Tuples</a></li>
<li><a href="#_dictionaries_and_tuples">Dictionaries and Tuples</a></li>
<li><a href="#_sequences_of_sequences">Sequences of Sequences</a></li>
<li><a href="#_debugging_8">Debugging</a></li>
<li><a href="#_glossary_9">Glossary</a></li>
<li><a href="#_exercises_11">Exercises</a></li>
</ul>
</li>
<li><a href="#chap13">16. Case Study: Data Structure Selection</a>
<ul class="sectlevel2">
<li><a href="#_word_frequency_analysis">Word Frequency Analysis</a></li>
<li><a href="#_random_numbers">Random Numbers</a></li>
<li><a href="#_word_histogram">Word Histogram</a></li>
<li><a href="#_most_common_words">Most Common Words</a></li>
<li><a href="#_optional_parameters">Optional Parameters</a></li>
<li><a href="#dictionary_subtraction">Dictionary Subtraction</a></li>
<li><a href="#_random_words">Random Words</a></li>
<li><a href="#markov_analysis">Markov Analysis</a></li>
<li><a href="#_data_structures">Data Structures</a></li>
<li><a href="#_debugging_9">Debugging</a></li>
<li><a href="#_glossary_10">Glossary</a></li>
<li><a href="#_exercises_12">Exercises</a></li>
</ul>
</li>
<li><a href="#chap14">17. Files</a>
<ul class="sectlevel2">
<li><a href="#_persistence">Persistence</a></li>
<li><a href="#reading_and_writing">Reading and Writing</a></li>
<li><a href="#_formatting">Formatting</a></li>
<li><a href="#_filenames_and_paths">Filenames and Paths</a></li>
<li><a href="#catching_exceptions">Catching Exceptions</a></li>
<li><a href="#databases">Databases</a></li>
<li><a href="#_serialization">Serialization</a></li>
<li><a href="#_command_objects">Command Objects</a></li>
<li><a href="#_modules">Modules</a></li>
<li><a href="#_debugging_10">Debugging</a></li>
<li><a href="#_glossary_11">Glossary</a></li>
<li><a href="#_exercises_13">Exercises</a></li>
</ul>
</li>
<li><a href="#chap15">18. Estruturas e Objetos</a>
<ul class="sectlevel2">
<li><a href="#_tipos_compostos">Tipos Compostos</a></li>
<li><a href="#_structs_são_imutáveis">Structs são Imutáveis</a></li>
<li><a href="#_structs_mutáveis">Structs Mutáveis</a></li>
<li><a href="#_retângulos">Retângulos</a></li>
<li><a href="#_instâncias_como_argumentos">Instâncias como Argumentos</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_copyright">1. Copyright</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Copyright © 2018 Allen Downey, Ben Lauwens. All rights reserved.</p>
</div>
<div class="paragraph">
<p><em>Think Julia</em> is available under the Creative Commons Attribution-NonCommercial 3.0 Unported License. The authors maintain an online version at <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html" class="bare">https://benlauwens.github.io/ThinkJulia.jl/latest/book.html</a></p>
</div>
<div class="paragraph">
<p><strong>Ben Lauwens</strong> is a Professor of Mathematics at Royal Military Academy (RMA Belgium). He has a PhD in Engineering and Master’s degrees from KU Leuven and RMA and Bachelor’s degree from RMA.</p>
</div>
<div class="paragraph">
<p><strong>Allen Downey</strong> is a Professor of Computer Science at Olin College of Engineering. He has taught at Wellesley College, Colby College and U.C. Berkeley. He has a PhD in Computer Science from U.C. Berkeley and Master’s and Bachelor’s degrees from MIT.</p>
</div>
<div class="paragraph">
<p>A paper version of this book is published by O&#8217;Reilly Media: <a href="http://www.jdoqocy.com/click-9038105-11290546?url=http%3A%2F%2Fshop.oreilly.com%2Fproduct%2F0636920215707.do%3Fcmp%3Daf-strata-books-video-product_cj_0636920215707_%25zp&amp;cjsku=0636920215707">http://shop.oreilly.com/product/0636920215707.do</a> and can be bought on Amazon: <a href="https://www.amazon.com/Think-Julia-Like-Computer-Scientist/dp/1492045039" class="bare">https://www.amazon.com/Think-Julia-Like-Computer-Scientist/dp/1492045039</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dedication">2. Dedication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For Emeline, Arnaud and Tibo.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_preface">3. Preface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In January 2018 I started the preparation of a programming course targeting students without programming experience. I wanted to use Julia, but I found that there existed no book with the purpose of learning to program with Julia as the first programming language. There are wonderful tutorials that explain Julia&#8217;s key concepts, but none of them pay sufficient attention to learning how to think like a programmer.</p>
</div>
<div class="paragraph">
<p>I knew the book <a href="http://shop.oreilly.com/product/0636920045267.do"><em>Think Python</em></a> by Allen Downey, which contains all the key ingredients to learn to program properly. However, this book was based on the Python programming language. My first draft of the course notes was a melting pot of all kinds of reference works, but the longer I worked on it, the more the content started to resemble the chapters of <em>Think Python</em>. Soon, the idea of developing my course notes as a port of that book to Julia came to fruition.</p>
</div>
<div class="paragraph">
<p>All the material was available as Jupyter notebooks in a GitHub repository. After I posted a message on the Julia Discourse site about the progress of my course, the feedback was overwhelming. A book about basic programming concepts with Julia as the first programming language was apparently a missing link in the Julia universe. I contacted Allen to ask if I could start an official port of <em>Think Python</em> to Julia, and his answer was immediate: “Go for it!” He put me in touch with his editor at O&#8217;Reilly Media, and a year later I was putting the finishing touches on this book.</p>
</div>
<div class="paragraph">
<p>It was a bumpy ride. In August 2018 Julia v1.0 was released, and like all my fellow Julia programmers I had to do a migration of the code. All the examples in the book were tested during the conversion of the source files to O&#8217;Reilly-compatible AsciiDoc files. Both the toolchain and the example code had to be made Julia v1.0–compliant. Luckily, there are no lectures to give in August&#8230;&#8203;.</p>
</div>
<div class="paragraph">
<p>I hope you enjoy working with this book, and that it helps you learn to program and think like a computer scientist, at least a little bit.</p>
</div>
<div class="paragraph byline">
<p>Ben Lauwens</p>
</div>
<div class="sect2">
<h3 id="_why_julia">Why Julia?</h3>
<div class="paragraph">
<p>Julia was originally released in 2012 by Alan Edelman, Stefan Karpinski, Jeff Bezanson, and Viral Shah. It is a free and open source programming language.</p>
</div>
<div class="paragraph">
<p>Choosing a programming language is always subjective. For me, the following characteristics of Julia are decisive:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Julia is developed as a high-performance programming language.</p>
</li>
<li>
<p>Julia uses multiple dispatch, which allows the programmer to choose from different programming patterns adapted to the application.</p>
</li>
<li>
<p>Julia is a dynamically typed language that can easily be used interactively.</p>
</li>
<li>
<p>Julia has a nice high-level syntax that is easy to learn.</p>
</li>
<li>
<p>Julia is an optionally typed programming language whose (user-defined) data types make the code clearer and more robust.</p>
</li>
<li>
<p>Julia has an extended standard library and numerous third-party packages are available.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Julia is a unique programming language because it solves the so-called "two languages problem." No other programming language is needed to write high-performance code. This does not mean it happens automatically. It is the responsibility of the programmer to optimize the code that forms a bottleneck, but this can be done in Julia itself.</p>
</div>
</div>
<div class="sect2">
<h3 id="_who_is_this_book_for">Who Is This Book For?</h3>
<div class="paragraph">
<p>This book is for anyone who wants to learn to program. No formal prior knowledge is required.</p>
</div>
<div class="paragraph">
<p>New concepts are introduced gradually and more advanced topics are described in later chapters.</p>
</div>
<div class="paragraph">
<p><em>Think Julia</em> can be used for a one-semester course at the high school or college level.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conventions_used_in_this_book">Conventions Used in This Book</h3>
<div class="paragraph">
<p>The following typographical conventions are used in this book:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Italic</em></dt>
<dd>
<p>Indicates new terms, URLs, email addresses, filenames, and file extensions.</p>
</dd>
<dt class="hdlist1"><code>Constant width</code></dt>
<dd>
<p>Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.</p>
</dd>
<dt class="hdlist1"><strong><code>Constant width bold</code></strong></dt>
<dd>
<p>Shows commands or other text that should be typed literally by the user.</p>
</dd>
<dt class="hdlist1"><em><code>Constant width italic</code></em></dt>
<dd>
<p>Shows text that should be replaced with user-supplied values or by values determined by context.</p>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>This element signifies a tip or suggestion.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This element signifies a general note.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>This element indicates a warning or caution.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_using_code_examples">Using Code Examples</h3>
<div class="paragraph">
<p>All code used in this book is available from a Git repository on GitHub: <a href="https://github.com/BenLauwens/ThinkJulia.jl" class="bare">https://github.com/BenLauwens/ThinkJulia.jl</a>. If you are not familiar with Git, it is a version control system that allows you to keep track of the files that make up a project. A collection of files under Git&#8217;s control is called a “repository.” GitHub is a hosting service that provides storage for Git repositories and a convenient web interface.</p>
</div>
<div class="paragraph">
<p>A convenience package is provided that can be directly added to Julia. Just type <code>add <a href="https://github.com/BenLauwens/ThinkJulia.jl">https://github.com/BenLauwens/ThinkJulia.jl</a></code> in the REPL in Pkg mode, see <a href="#turtles">[turtles]</a>.</p>
</div>
<div class="paragraph">
<p>The easiest way to run Julia code is by going to <a href="https://juliabox.com" class="bare">https://juliabox.com</a> and starting a free session. Both the REPL and a notebook interface are available. If you want to have Julia locally installed on your computer, you can download <a href="https://juliacomputing.com/products/juliapro.html">JuliaPro</a> for free from Julia Computing. It consists of a recent Julia version, the Juno interactive development environment based on Atom, and a number of preinstalled Julia packages. If you are more adventurous, you can download Julia from <a href="https://julialang.org" class="bare">https://julialang.org</a>, install the editor you like (e.g., Atom or Visual Studio Code), and activate the plug-ins for Julia integration. To a local install, you can also add the <code>IJulia</code> package and run a Jupyter notebook on your computer.</p>
</div>
</div>
<div class="sect2">
<h3 id="_acknowledgments">Acknowledgments</h3>
<div class="paragraph">
<p>I really want to thank Allen for writing <em>Think Python</em> and allowing me to port his book to Julia. Your enthusiasm is contagious!</p>
</div>
<div class="paragraph">
<p>I would also like to thank the technical reviewers for this book, who made many helpful suggestions: Tim Besard, Bart Janssens, and David P. Sanders.</p>
</div>
<div class="paragraph">
<p>Thanks to Melissa Potter from O&#8217;Reilly Media, who made this a better book. You forced me to do things right and make this book as original as possible.</p>
</div>
<div class="paragraph">
<p>Thanks to Matt Hacker from O&#8217;Reilly Media, who helped me out with the Atlas toolchain and some syntax highlighting issues.</p>
</div>
<div class="paragraph">
<p>Thanks to all the students who worked with an early version of this book and all the contributors (listed below) who sent in corrections and suggestions.</p>
</div>
</div>
<div class="sect2">
<h3 id="_contributor_list">Contributor List</h3>
<div class="paragraph">
<p>If you have a suggestion or correction, please send email to <a href="mailto:ben.lauwens@gmail.com">ben.lauwens@gmail.com</a> or open an issue on <a href="https://github.com/BenLauwens/ThinkJulia.jl">GitHub</a>. If I make a change based on your feedback, I will add you to the contributor list (unless you ask to be omitted).</p>
</div>
<div class="paragraph">
<p>Let me know what version of the book you are working with, and what format. If you include at least part of the sentence the error appears in, that will make it easy for me to search. Page and section numbers are fine, too, but not quite as easy to work with. Thanks!</p>
</div>
<div class="openblock small">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Scott Jones pointed out the name change of <code>Void</code> to <code>Nothing</code>, and this started the migration to Julia v1.0.</p>
</li>
<li>
<p>Robin Deits found some typos in <a href="#chap02">Variáveis, Expressões e Declarações</a>.</p>
</li>
<li>
<p>Mark Schmitz suggested turning on syntax highlighting.</p>
</li>
<li>
<p>Zigu Zhao caught some bugs in <a href="#chap08">Strings</a>.</p>
</li>
<li>
<p>Oleg Soloviev caught an error in the URL to add the <code>ThinkJulia</code> package.</p>
</li>
<li>
<p>Aaron Ang found some rendering and naming issues.</p>
</li>
<li>
<p>Sergey Volkov caught a broken link in <a href="#chap07">Iteration</a>.</p>
</li>
<li>
<p>Sean McAllister suggested mentioning the excellent package <code>BenchmarkTools</code>.</p>
</li>
<li>
<p>Carlos Bolech sent a long list of corrections and suggestions.</p>
</li>
<li>
<p>Krishna Kumar corrected the Markov example in <a href="#chap18">[chap18]</a>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 pagenumrestart">
<h2 id="chap01">4. O Caminho da Programação</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O objetivo deste livro é ensinar você a pensar como um cientista da computação. Essa maneira de pensar combina algumas das melhores ferramentas da matemática, engenharia e ciências naturais. Como matemáticos, cientistas da computação usam linguagens formais para denotar ideias (especificamente cálculos). Como engenheiros, projetam coisas, montando componentes em sistemas e avaliando ganhos e perdas entre as alternativas. Como cientistas, observam o comportamento de sistemas complexos, formulam hipóteses e testam predições.</p>
</div>
<div class="paragraph">
<p>A habilidade mais importante para um cientista da computação é a resolução de problemas. Resolver problemas significa ter habilidade para formular problemas, pensar em soluções com criatividade, e expressar a solução clara e precisamente. Como se vê, o processo de aprendizagem para programar é uma excelente oportunidade de praticar a habilidade de resolução de problemas. Por essa razão esse capítulo tem como título "O caminho da programação".</p>
</div>
<div class="paragraph">
<p>Por um lado, você estará aprendendo a programar, uma habilidade muito útil por si só. Por outro, você usará a programação como um significado para alcançar um objetivo. Na medida que formos evoluindo, esse fim ficará mais claro.</p>
</div>
<div class="sect2">
<h3 id="_o_que_é_um_programa">O que é um Programa?</h3>
<div class="paragraph">
<p>Um <em>programa</em> é uma sequência de instruções que especifica como deve ser a computação. A computação poderá ser algo matemático, como resolver um sistema de equações ou encontrar as raízes de um polinômio, mas pode ser também uma computação simbólica, como uma busca ou substituição de texto num documento, ou algo gráfico, como o processamento de uma imagem ou reprodução de um vídeo.</p>
</div>
<div class="paragraph">
<p>Os  detalhes são diferentes em diferentes linguagens de programação, mas algumas instruções básicas aparecem em praticamente em todos os idiomas:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Entrada (<em>Input</em>)</dt>
<dd>
<p>Coleta os dados do teclado, de um arquivo, de uma rede ou de algum dispositivo.</p>
</dd>
<dt class="hdlist1">Saída (<em>Output</em>)</dt>
<dd>
<p>Exibe os dados na tela, salva em um documento, envia através da rede, etc.</p>
</dd>
<dt class="hdlist1">Matemáticos</dt>
<dd>
<p>Realiza operações matemática básicas como adição e multiplicação.</p>
</dd>
<dt class="hdlist1">Execução Condicional</dt>
<dd>
<p>Verifica certas condições e executa o código apropriado.</p>
</dd>
<dt class="hdlist1">Repetição</dt>
<dd>
<p>Realiza alguma ação repetidamente, geralmente com alguma variação.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Acredite ou não, isso é tudo que existe. Todo programa que você já usou, por mais complicado que seja, é composto de instruções que são muito similares a essas. Portanto, você pode pensar em programação como o processo de dividir uma tarefa grande e complexa em subtarefas cada vez menores até que as subtarefas sejam simples o suficiente para serem executadas com uma dessas instruções básicas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_executando_o_julia">Executando o Julia</h3>
<div class="paragraph">
<p>Um dos desafios de começar com o Julia é que talvez você precise instalá-lo e softwares relacionados no seu computador. Se você está familiarizado com o seu sistema operacional, e especificamente se você está confortável com a interface das linhas de comando, você não terá problemas em instalar o Julia. Mas, para iniciantes, pode ser assustador aprender sobre administração de sistemas operacionais e programação ao mesmo tempo.</p>
</div>
<div class="paragraph">
<p>Para evitar esse problema, eu recomendo que você comece a executar o Julia em um navegador. Depois, quando se sentir mais confortável com o Julia, eu irei sugerir instalar o Julia em seu computador.</p>
</div>
<div class="paragraph">
<p>No navegador, você pode executar o <a href="https://www.juliabox.com">JuliaBox</a>. Nenhuma instalação é necessária - Apenas escolha um navegador, faça o <em>log in</em> e comece a programar (veja <a href="#juliabox">[juliabox]</a>).</p>
</div>
<div class="paragraph">
<p>O <em>REPL</em> do Julia (Read-Eval-Print Loop, que traduzido ao pé da letra, significa Ler, Avaliar e Repetição de impressão) é um programa que lê e executa os códigos do Julia. Você pode começar o REPL abrindo o terminal no JuliaBox e escrevendo <strong><code>julia</code></strong> na linha de comando. Quando executar, você deverá ver uma saída como essa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.4.2 (2020-05-23)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |

julia&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>As primeiras linhas contém informações sobre o REPL, que deve ser diferente para você. Porém, você deve checar que o número da versão seja pelo menos 1.0.0.</p>
</div>
<div class="paragraph">
<p>A  última linha é um <em>prompt</em> que indica que o REPL está pronto para você inserir o código. Se você digitar uma linha de código e pressionar Enter, o REPL exibirá o seguinte resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; 1 + 1
2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Os trechos de códigos podem ser copiados e colados literalmente, incluindo o prompt julia&gt; e qualquer saída.</p>
</div>
<div class="paragraph">
<p>Agora você está pronto para começar. Daqui em diante, irei assumir que você sabe como iniciar o Julia REPL e executar o código.</p>
</div>
</div>
<div class="sect2">
<h3 id="_o_primeiro_programa">O Primeiro Programa</h3>
<div class="paragraph">
<p>Tradicionalmente, o primeiro programa que você escreve em uma nova linguagem de programação é chamado de "Olá, Mundo!" porque tudo que faz é exibir as palavras "Olá, Mundo!". Em Julia, se parece com isso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; println("Olá, Mundo!")
Olá, Mundo!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este é um exemplo de um comando de impressão, embora não imprima nada no papel. Ele exibe o resultado na tela.</p>
</div>
<div class="paragraph">
<p>As aspas no programa marcam o início e o final do texto a ser exibido; eles não aparecem no resultado.</p>
</div>
<div class="paragraph">
<p>Os parênteses indicam que <code>println</code> é uma função. Nós chegaremos em funções no <a href="#Capítulo 3">[Capítulo 3]</a>. </p>
</div>
</div>
<div class="sect2">
<h3 id="_operações_aritméticas">Operações Aritméticas</h3>
<div class="paragraph">
<p>Depois de "Olá, Mundo!" o próximo passo é a aritmética. Julia fornece  <em>operadores</em>, que são símbolos que representam cálculos como adição e multiplicação.</p>
</div>
<div class="paragraph">
<p>Os operadores operators <code>+</code>, <code>-</code>, and <code>*</code> executam adição, subtração e multiplicação, como nos seguintes exemplos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; 40 + 2
42
julia&gt; 43 - 1
42
julia&gt; 6 * 7
42</code></pre>
</div>
</div>
<div class="paragraph">
<p>O  operador <code>/</code> executa divisão:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; 84 / 2
42.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Talvez você deva estar se perguntando porquê o resultado é 42.0 invés de 42. Eu irei explicar na próxima seção.</p>
</div>
<div class="paragraph">
<p>Finalmente, o operador <code>^</code> executa exponenciação; isto é, eleva um número a uma potência:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; 6^2 + 6
42</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_valores_e_tipos">Valores e Tipos</h3>
<div class="paragraph">
<p>Um <em>valor</em>  é uma das coisas mais básicas que um programa trabalha, como uma letra ou um número. Alguns valores que vimos até agora são <code>2</code>, <code>42.0</code>, e <code>"Olá, Mundo!"</code>.</p>
</div>
<div class="paragraph">
<p>Esse valores pertencem a diferentes <em>tipos</em>: 2 é um <em>inteiro</em>, 42.0 é um <em>número de ponto flutuante</em>, e <code>"Olá, Mundo!"</code> é uma <em>string</em>, é chamada assim porque os caracteres que contém são amarrados.</p>
</div>
<div class="paragraph">
<p>Se  você não tem certeza de que tipo é um determinado valor, o REPL pode dizer a você:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; typeof(2)
Int64
julia&gt; typeof(42.0)
Float64
julia&gt; typeof("Hello, World!")
String</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inteiros pertencem ao tipo <code>Int64</code>, strings pertencem a <code>String</code>, e pontos flutuantes pertencem a <code>Float64</code>.</p>
</div>
<div class="paragraph">
<p>E quanto a valores como <code>"2"</code> e <code>"42.0"</code>? Eles parecem números, mas estão entre parênteses como strings. Eles também são strings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; typeof("2")
String
julia&gt; typeof("42.0")
String</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quando você digita um número inteiro grande, você pode ficar tentado a usar vírgulas entre os grupos de dígitos, como em 1,000,000. Isto não é um <em>inteiro</em> permitido em Julia, mas é permitido:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; 1,000,000
(1, 0, 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Não era o que esperávamos! Julia analisa <code>1,000,000</code> como uma sequência separada por vírgula de inteiros. Iremos aprender mais sobre este tipo de sequência depois.</p>
</div>
<div class="paragraph">
<p>Contudo,  você pode obter o resultado esperado usando <code>1_000_000</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_linguagens_formais_e_naturais">Linguagens Formais e Naturais</h3>
<div class="paragraph">
<p><em>Linguagens Naturais</em>  são aquelas linguagens que as pessoas falam, como Inglês, Espanhol, Português e o Francês. Elas não são projetadas por pessoas (embora pessoas tentem lhes impor alguma ordem); elas evoluíram naturalmente.</p>
</div>
<div class="paragraph">
<p><em>Linguagens Formais</em>  são linguagens projetadas por pessoas para aplicações específicas. Por exemplo, a notação que os matemáticos utilizam é uma linguagem formal que em particular é boa para denotar a relação entre números e símbolos. Químicos usam uma linguagem formal para representar a estrutura química das moléculas. E mais importante, linguagens de programação são linguagens formais projetadas para expressar cálculos.</p>
</div>
<div class="paragraph">
<p>Linguagens formais tendem a ter regras rígidas de <em>sintaxe</em> que governam a estrutura das declarações. Por exemplo, em matemática a declaração \(3 + 3 = 6\) tem sintaxe correta, mas \(3 += 3 \$ 6\) não. Em química, \(\mathrm{H_2O}\) é uma fórmula sintaticamente correta, mas \(\mathrm{_2Zz}\) não.</p>
</div>
<div class="paragraph">
<p>Regras de sintaxe são fornecidas em dois tipos, pertencentes a <em>símbolos</em> e <em>estruturas</em>. Símbolos são elementos básicos da linguagem, como palavras, números e elementos químicos. Um dos problemas com \(3 += 3 \$ 6\) é que \(\$\) não é um símbolo permitido em matemática (pelo menos até onde eu sei). Da mesma forma, \(\mathrm{_2Zz}\) não é permitido pois não há elemento com abreviação \(\mathrm{Zz}\).</p>
</div>
<div class="paragraph">
<p>O segundo tipo de regra de sintaxe pertence à maneira que símbolos são combinados. A equação \(3 +=3\) não é permitida porque mesmo que \(+\) e \(=\) sejam símbolos permitidos, você não pode ter um logo após o outro. Da mesma forma, em uma fórmula química, o subscrito vem depois do nome do elemento, e não antes.</p>
</div>
<div class="paragraph">
<p>Essa é um@ sentença bem estruturada em portuguê$ com 5ímb0l05 inválidos. Essa frase possui todos os símbolos válidos, mas com estrutura invalida.</p>
</div>
<div class="paragraph">
<p>Quando  você lê uma sentença em Português ou uma declaração numa linguagem formal, você tem que descrever a estrutura (apesar de que em uma linguagem natural você faz isso subconscientemente). Esse processo é chamado de <em>análise</em>.</p>
</div>
<div class="paragraph">
<p>Embora as linguagens formais e naturais tenham muito recursos em comuns — símbolos, estruturas, e sintaxes —  existem algumas diferenças:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Ambiguidade</dt>
<dd>
<p>As linguagens naturais são cheias de ambiguidades, com as quais as pessoas lidam usando pistas contextuais e outras informações. As linguagens formais são projetadas para serem quase ou completamente inequívocas, o que significa que qualquer afirmação tem exatamente um significado, independentemente do contexto.</p>
</dd>
<dt class="hdlist1">Redundância</dt>
<dd>
<p>Para compensar a ambiguidade e reduzir os mal-entendidos, as linguagens naturais empregam muita redundância. Como resultado, elas geralmente são detalhadas. Linguagens formais são menos redundantes e mais concisas.</p>
</dd>
<dt class="hdlist1">Literalidade</dt>
<dd>
<p>As línguas naturais estão cheias de expressões idiomáticas e metáforas. Se eu disser: "Caiu a ficha!", provavelmente não há ficha e nada está caindo (nesse idioma significa que alguém entendeu alguma coisa após um período de confusão). Linguagens formais significam exatamente o que dizem.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Como todos nós crescemos falando linguagens naturais, às vezes é difícil nos adaptarmos às línguas formais. A diferença entre linguagem formal e natural é como a diferença entre poesia e prosa, mas mais ainda:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Poesia</dt>
<dd>
<p>As palavras são usadas tanto pelos sons quanto pelo significado, e o poema inteiro cria um efeito ou resposta emocional. A ambiguidade não é apenas comum, mas muitas vezes deliberada.</p>
</dd>
<dt class="hdlist1">Prosa</dt>
<dd>
<p>O significado literal das palavras é mais importante e a estrutura contribui com mais significado. A prosa é mais passível de análise do que a poesia, mas ainda é ambígua.</p>
</dd>
<dt class="hdlist1">Programas</dt>
<dd>
<p>O significado de um programa de computador é inequívoco e literal e pode ser entendido inteiramente pela análise dos símbolos e da estrutura.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>As linguagens formais são mais densas que as linguagens naturais, por isso leva mais tempo para lê-las. Além disso, a estrutura é importante, portanto nem sempre é melhor ler de cima para baixo, da esquerda para a direita. Em vez disso, você aprenderá a analisar o programa em sua cabeça, identificando os símbolos e interpretando a estrutura. Finalmente, os detalhes são importantes. Pequenos erros de ortografia e pontuação, com os quais você pode se dar bem em idiomas naturais, podem fazer uma grande diferença na linguagem formal. </p>
</div>
</div>
<div class="sect2">
<h3 id="_debug">Debug</h3>
<div class="paragraph">
<p>Programadores cometem erros. Por motivos lúdicos, erros de programação são chamados de <em>bugs</em> e o processo de rastreá-lo é chamado de <em>debugar</em>.</p>
</div>
<div class="paragraph">
<p>A programação e, especialmente, a debugação, às vezes traz emoções fortes. Se você está lutando com um bug difícil, pode sentir raiva, desânimo ou vergonha.</p>
</div>
<div class="paragraph">
<p>Há evidências de que as pessoas respondem naturalmente aos computadores como se fossem pessoas. Quando eles funcionam bem, pensamos neles como companheiros de equipe e, quando são obstinados ou rudes, respondemos a eles da mesma maneira que respondemos a pessoas rudes e obstinadas.<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</sup></p>
</div>
<div class="paragraph">
<p>A preparação para essas reações pode ajudá-lo a lidar com elas. Uma abordagem é pensar no computador como um funcionário com certos pontos fortes, como velocidade e precisão, e pontos fracos particulares, como falta de empatia e incapacidade de entender o cenário geral.</p>
</div>
<div class="paragraph">
<p>Seu trabalho é ser um bom gerente: encontre maneiras de aproveitar os pontos fortes e atenuar os pontos fracos. E encontre maneiras de usar suas emoções para se envolver com o problema, sem deixar que suas reações interfiram na sua capacidade de trabalhar de maneira eficaz.</p>
</div>
<div class="paragraph">
<p>Aprender a depurar pode ser frustrante, mas é uma habilidade valiosa que é útil para muitas atividades além da programação. No final de cada capítulo, há uma seção, como esta, com minhas sugestões para debugar. Espero que eles ajudem!</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossário">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">resolução de problemas</dt>
<dd>
<p>É o  processo de formular o problema, encontrar uma solução e expressar-lo.</p>
</dd>
<dt class="hdlist1">programa</dt>
<dd>
<p>Um  é uma sequência de instruções que especifica um cálculo.</p>
</dd>
<dt class="hdlist1">REPL</dt>
<dd>
<p>Um  programa que repetidamente lê entradas, executa e exibe os resultados.</p>
</dd>
<dt class="hdlist1">prompt</dt>
<dd>
<p>Caratecteres exibido pelo REPL para indicar que está pronto para receber informações do usuário.</p>
</dd>
<dt class="hdlist1">declaração de impressão</dt>
<dd>
<p>Uma  instrução que faz com o que o Julia REPL exiba o valor na tela.</p>
</dd>
<dt class="hdlist1">operador</dt>
<dd>
<p>Um  símbolo que representa um simples cálculo como adição, multiplicação, ou uma concatenação de strings.</p>
</dd>
<dt class="hdlist1">valor</dt>
<dd>
<p>Uma ("valores" das unidades de dados mais básicas, como um número ou string, é o que um programa manipula.</p>
</dd>
<dt class="hdlist1">tipo</dt>
<dd>
<p>Uma  categoria de valores. Os tipos que vimos até agora são números inteiros (<code>Int64</code>), números de ponto flutuante (<code>Float64</code>) e seqüências de caracteres (<code>String</code>).</p>
</dd>
<dt class="hdlist1">inteiros</dt>
<dd>
<p>Um tipo de que representa todos os números.</p>
</dd>
<dt class="hdlist1">ponto-flutuante</dt>
<dd>
<p>Um  tipo que representa números com pontos decimais.</p>
</dd>
<dt class="hdlist1">string</dt>
<dd>
<p>Um  tipo que representa uma sequência de caracteres.</p>
</dd>
<dt class="hdlist1">linguagem natural</dt>
<dd>
<p>Qualquer  uma das linguagens que as pessoas falam que se envolvem naturalmente.</p>
</dd>
<dt class="hdlist1">linguagem formal</dt>
<dd>
<p>Qualquer  uma das linguagens que as pessoas foram desenvolvidas para propósitos específicos, como representar ideias matemáticas ou programas de computador. Todas  as linguagens de programação são formais.</p>
</dd>
<dt class="hdlist1">sintaxe</dt>
<dd>
<p>As  regras que governam a estrutura de um programa.</p>
</dd>
<dt class="hdlist1">símbolo</dt>
<dd>
<p>Um dos elementos mais básicos de uma estrutura de sintaxes de um programa, análogo a uma palavra numa linguagem natural.</p>
</dd>
<dt class="hdlist1">estrutura</dt>
<dd>
<p>A maneira que os símbolos são combinados.</p>
</dd>
<dt class="hdlist1">analisar</dt>
<dd>
<p>Para  examinar um programa e analisar uma estrutra de sintaxe.</p>
</dd>
<dt class="hdlist1">bug</dt>
<dd>
<p>Um  erro de um programa.</p>
</dd>
<dt class="hdlist1">debugar</dt>
<dd>
<p>O  processo de encontrar e corrigir bugs.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios">Exercícios</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>É uma boa ideia ler este livro na frente de um computador para que você possa experimentar os exemplos à medida que avança.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="ex01-1">Exercício 1-1</h5>
<div class="paragraph">
<p>Sempre que você estiver experimentando um novo recurso, tente cometer erros. Por exemplo, no programa "Olá, mundo!", o que acontece se você deixar de fora uma das aspas? E se você deixar de fora ambas? E se você soletrar <code>println</code> errado?</p>
</div>
<div class="paragraph">
<p>Esse tipo de experimento ajuda a lembrar o que você lê; também ajuda quando você está programando, porque você sabe o que significam as mensagens de erro. É melhor cometer erros agora e de propósito, e não mais tarde e acidentalmente.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Em um comando de impressão, o que acontece se você deixar de fora um dos parênteses ou ambos?</p>
</li>
<li>
<p>Se você estiver tentando imprimir uma sequência, o que acontece se você deixar de fora uma das aspas ou ambas?</p>
</li>
<li>
<p>Você pode usar um sinal de menos para fazer um número negativo como <code>-2</code>. O que acontece se você colocar um sinal de mais antes de um número? E a respeito de <code>2++2</code>?</p>
</li>
<li>
<p>Em notação matemática, zeros à esquerda estão corretos, como em <code>02</code>. O que acontece se você tentar isso em Julia?</p>
</li>
<li>
<p>O que acontece se você tem dois valores com nenhum operador entre eles?</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="ex01-2">Exercício 1-2</h5>
<div class="paragraph">
<p>Inicie o Julia REPL e use-o como uma calculadora.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Quantos segundos existem em 42 minutos e 42 segundos?</p>
</li>
<li>
<p>Quantas milhas existem em 10 quilômetros?</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Uma milha equivale a 1,61.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Se você corre uma corrida de 10 quilômetros em 37 minutos e 48 segundos, qual é o seu ritmo médio (tempo por milha em minutos e segundos)? Qual é a sua velocidade média em milhas por hora?</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap02">5. Variáveis, Expressões e Declarações</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Uma das caractereísticas mais poderosas de uma linguagem de programação é a sua habilidade de manipular <em>variáveis</em>. Uma variável é um nome que refere-se a um valor.</p>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="sect2">
<h3 id="_declarações_de_atribuição">Declarações de Atribuição</h3>
<div class="paragraph">
<p>Uma <em>declaração de atribuição</em> cria uma nova variável e da à ela um valor:</p>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; mensagem = "E agora para algo completamente diferente"
"E agora para algo completamente diferente"
julia&gt; n = 17
17
julia&gt; π_val = 3.141592653589793
3.141592653589793</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este exemplo faz três atribuições. A primeira atribui uma string à uma nova variável chamada <code>mensagem</code>; a segunda dá o inteiro <code>17</code> a <code>n</code>; a terceira atribui (aproximadamente) o valor de \(\pi\) a <code>π_val</code> (<strong><code>\pi TAB</code></strong>).</p>
</div>
<div class="paragraph">
<p>Um jeito comum de representar variáveis no papel é escrevendo o nome com uma flecha apontando para o seu valor. Este tipo de figura é denominado de <em>diagrama de estado</em> pois mostra em que estado cada variável encontra-se (imagine isso como sendo o estado de espirito da variável) <a href="#fig02-1">Diagrama de estado</a> mostra o resultado do exemplo anterior.</p>
</div>
<div class="paragraph">
<p></p>
</div>
<div id="fig02-1" class="imageblock">
<div class="content">
<img src="images/fig21.svg" alt="fig21">
</div>
<div class="title">Figure 1. Diagrama de estado</div>
</div>
</div>
<div class="sect2">
<h3 id="_nomes_de_variáveis">Nomes de variáveis</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Programadores geralmente escolhem nomes para suas variáveis que são significativos—eles documentam para o que a variável é usada.</p>
</div>
<div class="paragraph">
<p>Nomes de variáveis podem ser o quão longas você desejar. Eles podem conter quase todos os caracteres Unicode (veja <a href="#caracteres">[caracteres]</a>), mas não podem começar com um número. É permitido usar letras maiúsculas, mas é convencional utilizar somente letras minúsculas para nomes de variáveis.</p>
</div>
<div class="paragraph">
<p>caracteres Unicode podem ser inseridos através do autocompletar do tab de abreviações similares à LaTeX no REPL do Julia.
</p>
</div>
<div class="paragraph">
<p>O caractere sublinhado, <code>_</code>, pode aparecer em um nome. É comumente utilizado em nomes com multiplas palavras, como <code>seu_nome</code> ou <code>velocidade_de_uma_andorinha_sem_carga</code>.
</p>
</div>
<div class="paragraph">
<p>Se um nome inválido for dado a uma variável, recebemos um erro de sintaxe:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; 76trombones = "grande desfile"
ERROR: syntax: "76" is not a valid function argument name
julia&gt; mais@ = 1000000
ERROR: syntax: extra token "@" after end of expression
julia&gt; struct = "Zimologia Teórica Avançado"
ERROR: syntax: unexpected "="</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>76trombones</code> é inválido pois começa com um número. <code>mais@</code> é inválido pois contem um caractere inválido, <code>@</code>. Mas o que há de errado com <code>struct</code>?</p>
</div>
<div class="paragraph">
<p>Acontece que <code>struct</code> é uma das palavras chave do Julia. O REPL usa palavras chaves para reconhecer a estrutura do programa, e elas não podem ser usadas como nomes de variáveis.
</p>
</div>
<div class="paragraph">
<p>O Julia possui as seguintes palavras chave:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>abstract type   baremodule   begin    break            catch
const           continue     do       else             elseif
end             export       false    finally          for
function        global       if       import           let
local           macro        module   mutable struct   primitive type
quote           return       true     using            struct
while</pre>
</div>
</div>
<div class="paragraph">
<p>Nós não precisamos memorizar esta lista. Na maior parte dos ambientes desenvolvidos, palavras chave são exibidas em diferentes cores; se nós tentarmos utilizar uma como um nome de variável, saberemos.</p>
</div>
</div>
<div class="sect2">
<h3 id="_expressões_e_declarações">Expressões e Declarações</h3>
<div class="paragraph">
<p>Uma <em>expressão</em> é uma combinação de valores, variáveis e operadores. Um valor por si só é considerado uma expressão, assim como uma variável, então as expressões a seguir são todas válidas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; 42
42
julia&gt; n
17
julia&gt; n + 25
42</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quando nós digitamos uma expressão no prompt, o REPL a <em>avalia</em>, o que significa que ele acha o valor da expressão. Neste exemplo, <code>n</code> tem valor 17 e <code>n + 25</code> valor 42.
</p>
</div>
<div class="paragraph">
<p>Uma <em>declaração</em> é uma unidade de código que possui um efeito, como criar uma variável ou exibir um valor.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; n = 17
17
julia&gt; println(n)
17</code></pre>
</div>
</div>
<div class="paragraph">
<p>A primeira linha é uma declaração de atribuição que da valor a <code>n</code>. A segunda linha é uma declaração de impressão que exibe o valor de <code>n</code>.</p>
</div>
<div class="paragraph">
<p>Quando nós digitamos uma declaração, o REPL a <em>executa</em>, o que significa que ele faz o que a declaração diz.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_modo_script">Modo Script</h3>
<div class="paragraph">
<p>Até agora nós rodamos o Julia em <em>modo interativo</em>, o que significa que nós interagimos diretamente com o REPL. O modo interativo é uma boa maneira de começar, mas se nós estamos trabalhando com mais do que poucas linhas de código, ele pode ser inadequado.
</p>
</div>
<div class="paragraph">
<p>A alternativa é salvar o código em um arquivo chamado <em>script</em> e em seguida rodar o Julia em <em>modo script</em> para executar o script. Por convenção, scripts Julia possuem nomes que terminam com <em>.jl</em>.
</p>
</div>
<div class="paragraph">
<p>Se você sabe como criar e rodar um script no seu computador, você está pronto pra utilizar. No entanto eu recomendaria utilizar o JuliaBox novamente. Abrir um arquivo de texto, escrever um script e salvá-lo com a extensão <em>.jl</em>. O script pode ser executado em um terminal com o comando <strong><code>julia nome_do_script.jl</code></strong>.
</p>
</div>
<div class="paragraph">
<p>Como o Julia nos fornece ambos os modos, podemos testar pequenos trechos de código no modo interativo antes de colocá-los num script. Mas há diferenças entre o modo interativo e o modo script que podem ser um pouco confusas.</p>
</div>
<div class="paragraph">
<p>Por exemplo,  se nós estamos usando o Julia como uma calculadora, podemos digitar</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; milhas = 26.2
26.2
julia&gt; milhas * 1.61
42.182</code></pre>
</div>
</div>
<div class="paragraph">
<p>A primeira linha atribui um valor à <code>milhas</code> e exibe o seu valor. A segunda linha é uma expressão, então o REPL avalia-a e exibe o resultado. Acontece que uma maratona é aproximadamente 42 quilômetros.</p>
</div>
<div class="paragraph">
<p>Mas se digitarmos o mesmo código num script e rodá-lo, não temos resultado algum. No modo script uma expressão, por si só, não possui nenhum efeito visível. Na verdade o Julia avalia a expressão, mas não exibe o valor a não ser que nós mandemos-o:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">milhas = 26.2
println(milhas * 1.61)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse comportamente pode ser um pouco confuso no início.</p>
</div>
<div class="paragraph">
<p>Um script geralmente contém uma sequência de declarações. Se existe mais de uma declaração, os resultados aparecem um de cada vez conforme as declarações são executadas.</p>
</div>
<div class="paragraph">
<p>Por exemplo, o script</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">println(1)
x = 2
println(x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>produz o resultado</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1
2</pre>
</div>
</div>
<div class="paragraph">
<p>A declaração de atribuição não produz nenhum resultado.</p>
</div>
<div class="sect4">
<h5 id="_exercício_2_1">Exercício 2-1</h5>
<div class="paragraph">
<p>Para verificar o seu entendimento, digite a seguinte sequência de declarações no REPL do Julia e veja o que eles fazem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">5
x = 5
x + 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora coloque o mesmo trecho em um script e rode-o. Qual é o resultado? Modifique o script transformando cada expressão em uma declaração de impressão, e em seguida rode-o novamente.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_precedência_de_operadores">Precedência de Operadores</h3>
<div class="paragraph">
<p>Quando uma expressão contém mais de um operador, a ordem de avaliação depende da <em>precedência de operador</em>. Para operadores matemáticos, Julia segue convenções matemáticas. O acrônimo <em>PEMDAS</em> é uma maneira útil de lembrar as regras:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>P</em>arênteses possuem a maior precedência e podem ser usados para forçar uma expressão a ser avaliada na ordem que nós desejarmos. Já que expressões em parênteses são avaliadas primeiro, <code>2*(3-1)</code> é 4, e <code>(1+1)^(5-2)</code> é 8. Nós também podemos utilizar parênteses para fazer com que uma expressão seja mais fácil de ler, como em <code>(minuto * 100) / 60</code>, mesmo que não altere o resultado.
</p>
</li>
<li>
<p><em>E</em>xponenciação possui a próxima precedência, então <code>1+2^3</code> é 9, e não 27, e <code>2*3^2</code> é 18, não 36.
</p>
</li>
<li>
<p><em>M</em>ultiplicação e <em>D</em>ivisão possuem maior precedência que <em>A</em>dição e <em>S</em>ubtração. Então <code>2*3-1</code> é 5, não 4, e <code>6+4/2</code> é 8, não 5.
</p>
</li>
<li>
<p>Operadores com a mesma precedência são avaliados da esquerda à direita (exceto exponenciação). Então na expressão <code>graus / 2 * π</code>, a divisão acontece primeiro e o resultado é multiplicado por <code>π</code>. Para dividir por \(2\pi\), podemos usar parênteses, escrevendo <code>graus / 2 / π</code> ou <code>graus / 2π</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Não nos esforçamos muito para lembrar a precedência dos operadores. Se nós não consigormos lembrar ao olhar para a expressão, utilizamos parênteses para fazer com que seja óbvio.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_operações_com_strings">Operações com Strings</h3>
<div class="paragraph">
<p>Em geral, não podemos executar operações matemáticas em strings, mesmo se as strings pareçam-se com números, então o que se segue abaixo é inválido.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">"2" - "1"    "ovos" / "fácil"    "terceiro" + "um encanto"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mas existem duas exceções, <code>*</code> e <code>^</code>.
</p>
</div>
<div class="paragraph">
<p>O operador <code>*</code> executa a <em>concatenação de strings</em>, o que signifca que ele junta as strings ligando-as de ponta-a-ponta. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; primeira_str = "tanga"
"tanga"
julia&gt; segunda_str = "mandápio"
"mandápio"
julia&gt; primeira_str * segunda_str
"tangamandápio"</code></pre>
</div>
</div>
<div class="paragraph">
<p>O operador <code>^</code> também funciona em strings; ele executa a repetição. Por exemplo, <code>"Spam"^3</code> é <code>"SpamSpamSpam"</code>. Se um dos valores é uma string, o outro deve ser um inteiro.
</p>
</div>
<div class="paragraph">
<p>Este uso de <code>*</code> e <code>^</code> faz sentido com analogia à multiplicação e exponenciação. Assim como <code>4^3</code> é equivalente a <code>4*4*4</code>, nós esperamos que <code>"Spam"^3</code> seja igual a <code>"Spam"*"Spam"*"Spam"</code>, e é.</p>
</div>
</div>
<div class="sect2">
<h3 id="_comentários">Comentários</h3>
<div class="paragraph">
<p>À medida que os programas ficam maiores e mais complicados, eles ficam mais dificéis de ler. Linguagens formais são densas, e é comum ser difícil olhar para um pedaço de código e descobrir o que está acontecendo, ou por quê.</p>
</div>
<div class="paragraph">
<p>Por esta razão, é uma boa ideia adicionar anotações em nossos programas para explicar em uma linguagem natural o que o programa esta fazendo. Estas anotações são chamadas de <em>comentários</em>, e eles começam com o símbolo <code>#</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia"># calcula a porcentagem da hora que já se passou
porcentagem = (minuto * 100) / 60</code></pre>
</div>
</div>
<div class="paragraph">
<p>Neste caso, o comentário aparece numa linha por si só. Nós também podemos colocar comentários no final da linha:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">porcentagem = (minuto * 100) / 60   # porcentagem de uma hora</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tudo a partir do <code>#</code> até o final da linha é ignorado e não causa efeito algum na execução do programa.</p>
</div>
<div class="paragraph">
<p>Comentários são bastante utéis quando eles documentam caractereísticas não óbvias do código. É razoável assumir que o leitor consegue descobrir <em>o que</em> o código faz; é mais útil explicar o <em>por quê</em>.</p>
</div>
<div class="paragraph">
<p>Esse comentário é redundante com o código e inútil:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">v = 5   # atribui 5 a v</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse comentário contém informação útil que não está no código:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">v = 5   # velocidade em metros/segundo.</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Bons nomes de variável podem reduzir a necessidade de comentários, mas nomes longos podem fazer com que expressões complexas sejam dificéis de ler, então há uma compensação.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_debugando">Debugando</h3>
<div class="paragraph">
<p>Três tipos de erros podem ocorrer em um programa: erros de sintaxe, erros de execução e erros de semântica. É útil distinguir entre eles a fim de localizá-los mais rapidamente.
</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Erro de sintaxe</dt>
<dd>
<p>“sintaxe” refere-se à estrutura de um programa e as regras sobre esta estrutura. Por exemplo, parênteses precisam vir em pares correspondentes, então <code>(1 + 2)</code> é válido, mas <code>8)</code> é um erro de sintaxe.</p>
<div class="paragraph">
<p>Se existe algum erro de sintaxe em algum lugar do nosso programa, o Julia exibirá uma mensagem de erro e encerrará, e nós não poderemos rodar o programa. Durante as primeiras semanas da sua carreira de programador, você deverá passar bastante tempo localizando erros de sintaxe. Conforme você vai ganhando experiência, você irá cometer menos erros e achá-los mais rapidamente.
</p>
</div>
</dd>
<dt class="hdlist1">Erro de execução</dt>
<dd>
<p>O segundo tipo de erro é o erro de execução, assim denominado pois o erro não aparece até que o programa finalmente esteja rodando. Estes erros também são chamados de <em>exceções</em> pois eles geralmente indicam que algo excepcional (e ruim) aconteceu.</p>
<div class="paragraph">
<p>Erros de execução são raros nos programas simples que você verá nos primeiros capítulos, então pode demorar um pouco até que você encontre um.
</p>
</div>
</dd>
<dt class="hdlist1">Erros de semântica</dt>
<dd>
<p>O terceiro tipo de erro é o de “semântica”, o que significa que ele é relacionado a significado. Se há um erro de semântica no seu programa, ele irá rodar sem gerar nenhuma mensagem de erro, mas não irá fazer a coisa certa. Ele irá fazer outra coisa. Mais especificamente, ele irá fazer o que nós mandamos-o fazer.</p>
<div class="paragraph">
<p>Identificar erros de semântica pode ser complicado, pois requer que nós trabalhemos em sentido contrário ao olhar o resultado do programa e tentar descobrir o que ele está fazendo.
</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_2">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">variável</dt>
<dd>
<p>Um nome que refere-se a um valor.
</p>
</dd>
<dt class="hdlist1">atribuição</dt>
<dd>
<p>Uma declaração que atribui um valor a uma variável.
</p>
</dd>
<dt class="hdlist1">diagrama de estado</dt>
<dd>
<p>Uma representação gráfica de um conjunto de variáveis e os valores que elas referem-se.
</p>
</dd>
<dt class="hdlist1">palavra-chave</dt>
<dd>
<p>Uma palavra reservada que é usada para analisar o programa; você não pode usar palavras-chave como <code>if</code>, <code>function</code>, e <code>while</code> como nomes de variáveis.
</p>
</dd>
<dt class="hdlist1">operando</dt>
<dd>
<p>Um dos valores no qual um operador opera sobre.
</p>
</dd>
<dt class="hdlist1">expressão</dt>
<dd>
<p>Uma combinação de variáveis, operadores, e valores que representam um único resultado.
</p>
</dd>
<dt class="hdlist1">avaliar</dt>
<dd>
<p>Simplificar uma expressão através da execução de operações a fim de produzir um único valor.
</p>
</dd>
<dt class="hdlist1">declaração</dt>
<dd>
<p>Uma seção de código que representa um comando ou ação. Até agora, as declarações que nós vimos são atribuições e declarações de impressão.
</p>
</dd>
<dt class="hdlist1">executar</dt>
<dd>
<p>Rodar uma declaração e fazer o que ela indica.
</p>
</dd>
<dt class="hdlist1">modo interativo</dt>
<dd>
<p>Um modo de usar o REPL do Julia digitando código no prompt.
</p>
</dd>
<dt class="hdlist1">modo script</dt>
<dd>
<p>Um modo de usar o Julia para ler código de um script e executá-lo.
</p>
</dd>
<dt class="hdlist1">script</dt>
<dd>
<p>Um programa guardado em um arquivo.
</p>
</dd>
<dt class="hdlist1">precedência de operador</dt>
<dd>
<p>Regras que governam a ordem na qual as expressões que envolvem múltiplos operadores matemáticos são avaliados.
</p>
</dd>
<dt class="hdlist1">concatenar</dt>
<dd>
<p>Juntar duas strings ponta-a-ponta.
</p>
</dd>
<dt class="hdlist1">comentário</dt>
<dd>
<p>Informação em um programa destinada a outros programadores (ou qualquer um lendo o código fonte) que não tem nenhum efeito na execução do programa.
</p>
</dd>
<dt class="hdlist1">erro de sintaxe</dt>
<dd>
<p>Um erro em um programa que faz com que seja impossível analisar (e consequentemente interpretar).
</p>
</dd>
<dt class="hdlist1">erro de execução ou exceção</dt>
<dd>
<p>Um erro que é detectado enquanto um programa está rodando.
</p>
</dd>
<dt class="hdlist1">semântica</dt>
<dd>
<p>O significado de um programa.
</p>
</dd>
<dt class="hdlist1">erro de semântica</dt>
<dd>
<p>Um erro em um programa que faz com que ele faça algo diferente do que o programador pretendia.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_2">Exercícios</h3>
<div class="sect4">
<h5 id="ex02-1">Exercício 2-2</h5>
<div class="paragraph">
<p>Repetindo o conselho do capítulo anterior, sempre que você aprende novas funcionalidades, você deve experimentá-las no modo interativo e cometer erros de propósito para ver o que acontece de errado.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Nós vimos que <code>n = 42</code> é válido. E <code>42 = n</code> ?</p>
</li>
<li>
<p>E que tal <code>x = y = 1</code>?</p>
</li>
<li>
<p>Em algumas linguagens toda declaração acaba com um ponto e vírgula, <code>;</code>. O que acontece se você colocar um ponto e vírgula no final de uma declaração no Julia?
</p>
</li>
<li>
<p>E se você quiser colocar um ponto no final de uma declaração ?</p>
</li>
<li>
<p>Em notação matemática, você pode multiplicar <code>x</code> e <code>y</code> assim: <code>x y</code>. O que acontece se você tentar isso em Julia? E 5x?</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="ex02-2">Exercício 2-3</h5>
<div class="paragraph">
<p>Pratique usando o REPL do Julia como uma calculadora:
</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>O volume de uma esfera com raio \(r\) é \(\frac{4}{3} \pi r^3\). Qual é o volume de uma esfera de raio 5?</p>
</li>
<li>
<p>Suponha que o preço de cobertura de um livro é R$ 24,95, mas as livrarias possuem desconto de 40%. A entrega custa R$ 3,00 para a primeira cópia e R$ 0,75 para cada cópia adicional. Qual é o preço total do atacado para 60 cópias?</p>
</li>
<li>
<p>Se eu saio de casa às 6:52 da manhã e corro uma milha em um ritmo tranquilo (8min15s por milha), em seguida 3 milhas em ritmo (7min12seg por milha) e 1 milha em um ritmo tranquilo novamente, a que horas eu chego em casa para o café da manhã?</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap03">6. Funções</h2>
<div class="sectionbody">
<div class="paragraph">
<p>No contexto da programação, uma <em>função</em> é uma sequência nomeada de comandos que executa uma tarefa. Ao definir uma função, você especifica o nome e a sequência de comandos. Mais tarde, você pode "chamar" a função pelo nome dado.
</p>
</div>
<div class="sect2">
<h3 id="_chamadas_de_funções">Chamadas de funções</h3>
<div class="paragraph">
<p>Nós já vimos um exemplo de chamada de função:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; println("Olá, Mundo!")
Olá, Mundo!</code></pre>
</div>
</div>
<div class="paragraph">
<p>O nome da função é <code>println</code>. A expressão entre parênteses é o <em>argumento</em> da função.
</p>
</div>
<div class="paragraph">
<p>É comum dizer que uma função "pega" um argumento e "retorna" um resultado que também é chamado de <em>valor de retorno</em>.
</p>
</div>
<div class="paragraph">
<p>Julia fornece funções que convertem valores de um tipo para outro. A função <code>parse</code> recebe uma string e a converte em qualquer tipo de número se puder, ou dá erro caso contrário:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; parse(Int64, "32")
32
julia&gt; parse(Float64, "3.14159")
3.14159
julia&gt; parse(Int64, "Olá")
ERROR: ArgumentError: invalid base 10 digit 'O' in "Olá"</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>trunc</code> pode converter valores de ponto flutuante em valores inteiros, mas não os arredonda; o comando trunca a parte fracionária:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; trunc(Int64, 3.99999)
3
julia&gt; trunc(Int64, -2.3)
-2</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>float</code> converte números inteiros em números de ponto flutuante:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; float(32)
32.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por último, <code>string</code> converte o seu argumento em uma string:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; string(32)
"32"
julia&gt; string(3.14159)
"3.14159"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_funções_matemáticas">Funções matemáticas</h3>
<div class="paragraph">
<p>Em Julia, a maioria das funções matemáticas tradicionais estão diretamente disponíveis:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">razão = potência_sinal / potência_ruído
decibéis = 10 * log10(razão)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este primeiro exemplo usa <code>log10</code> para calcular uma relação sinal-ruído em decibéis (assumindo que <code>potência_sinal</code> e <code>potência_ruído</code> estão definidos). <code>log</code>, que calcula logaritmos naturais, também é dado.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">radianos = 0.7
altura = sin(radianos)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este segundo exemplo calcula o seno de <code>radianos</code>. O nome da variável é uma dica de que <code>sin</code> e de que as outras funções trigonométricas (<code>cos</code>, <code>tan</code>, etc.) recebem argumentos em radianos. Para converter de graus em radianos, divida por 180 e multiplique pelo \(\pi\):
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; graus = 45
45
julia&gt; radianos = graus / 180 * π
0.7853981633974483
julia&gt; sin(radianos)
0.7071067811865475</code></pre>
</div>
</div>
<div class="paragraph">
<p>O valor da variável <code>π</code> é uma aproximação do ponto flutuante de \(\pi\), com precisão de aproximadamente de 16 dígitos.
</p>
</div>
<div class="paragraph">
<p>Se você conhece trigonometria, pode verificar o resultado anterior comparando-o com a raiz quadrada de dois dividido por dois:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; sqrt(2) / 2
0.7071067811865476</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_composição">Composição</h3>
<div class="paragraph">
<p>Até este momento, vimos os elementos de um programa—variáveis, expressões e comandos—isoladamente, sem detalhar em como combiná-las.
</p>
</div>
<div class="paragraph">
<p>Um dos recursos mais úteis das linguagens de programação é a sua capacidade de manipular pequenos blocos de montar e compô-los. Por exemplo, o argumento de uma função pode ser qualquer tipo de expressão, incluindo operadores aritméticos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">x = sin(graus / 360 * 2 * π)</code></pre>
</div>
</div>
<div class="paragraph">
<p>E até mesmo as chamadas de função:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">x = exp(log(x+1))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em quase todos os lugares onde você pode colocar um valor, pode-se colocar uma expressão arbitrária, com uma exceção: o lado esquerdo de uma atribuição tem que ser um nome de variável. Qualquer outra expressão do lado esquerdo resulta em um erro de sintaxe (veremos exceções a esta regra mais tarde).
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; minutos = horas * 60 # correto
120
julia&gt; horas * 60 = minutos # errado!
ERROR: syntax: "60" is not a valid function argument name</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_adicionando_novas_funções">Adicionando novas funções</h3>
<div class="paragraph">
<p>Embora tenhamos usado só as funções que vêm com Julia até agora, também é possível adicionar novas funções. A <em>definição da função</em> especifica o nome de uma nova função e a sequência de comandos que são executados quando a função é chamada. Aqui está um exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function imprimir_letras()
    println("O cravo brigou com a rosa")
    println("Debaixo de uma sacada.")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>function</code> é uma palavra-chave que indica a definição de função. O nome da função é <code>imprimir_letras</code>. As regras para nomes de funções são as mesmas dos nomes de variáveis: eles podem conter quase todos os caracteres Unicode (veja <a href="#caracteres">[caracteres]</a>), mas o primeiro caracter não pode ser um número. Você não pode usar uma palavra-chave como nome de uma função, e evite ter uma variável e uma função com o mesmo nome.
</p>
</div>
<div class="paragraph">
<p>Os parênteses vazios após o nome da função indicam que esta função não recebe nenhum argumento.
</p>
</div>
<div class="paragraph">
<p>A primeira linha da definição da função é o <em>cabeçalho</em>; o restante é chamado de <em>corpo</em>. Finaliza-se o corpo com a palavra-chave <code>end</code> e pode conter qualquer número de comandos. Para facilitar a leitura, o corpo da função deve estar indentado.
</p>
</div>
<div class="paragraph">
<p>As aspas devem ser "aspas retas" (""), geralmente localizadas abaixo do Esc no teclado. As "aspas encaracoladas" ou "aspas inglesas" (“”), como as que estão nesta frase, não são legais em Julia.
</p>
</div>
<div class="paragraph">
<p>Se você definir uma função no modo interativo, o REPL indentará para informar que a definição não está finalizada:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; function imprimir_letras()
       println("O cravo brigou com a rosa")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para terminar a função, deve-se inserir <code>end</code>.</p>
</div>
<div class="paragraph">
<p>A sintaxe para chamar a nova função é a mesma das funções internas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; imprimir_letras()
O cravo brigou com a rosa
Debaixo de uma sacada.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma vez definida uma função, você pode usá-la dentro de outra função. Por exemplo, para repetir o refrão anterior, poderíamos escrever uma função chamada <code>repetir_letras</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function repetir_letras()
    imprimir_letras()
    imprimir_letras()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>E depois é só chamar <code>repetir_letras</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; repetir_letras()
O cravo brigou com a rosa
Debaixo de uma sacada.
O cravo brigou com a rosa
Debaixo de uma sacada.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mas não é bem assim que a música é.</p>
</div>
</div>
<div class="sect2">
<h3 id="_definições_e_usos">Definições e usos</h3>
<div class="paragraph">
<p>Reunindo os pedaços de código da seção anterior, o programa completo fica assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function imprimir_letras()
    println("O cravo brigou com a rosa")
    println("Debaixo de uma sacada.")
end

function repetir_letras()
    imprimir_letras()
    imprimir_letras()
end

repetir_letras()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este programa contém duas definições de funções: <code>imprimir_letras</code> e <code>repetir_letras</code>. As definições de funções são executadas exatamente como outros comandos, e o resultado é a criação de objetos do tipo função. Os comandos dentro da função não são executados até que a função seja chamada, e a definição da função não gera saída.</p>
</div>
<div class="paragraph">
<p>Como você pode esperar, deve-se criar uma função antes de poder executá-la. Em outras palavras, a definição da função tem que ser executada antes de chamá-la.</p>
</div>
<div class="sect4">
<h5 id="_exercício_3_1">Exercício 3-1</h5>
<div class="paragraph">
<p>Mova a última linha deste programa para o topo, para que a chamada de função apareça antes das definições. Execute o programa e veja qual mensagem de erro você recebe.</p>
</div>
<div class="paragraph">
<p>Agora mova a chamada de função de volta para a parte inferior e mova a definição de <code>imprimir_letras</code> após a definição de <code>repetir_letras</code>. Ao executar este programa, o que acontece?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fluxo_de_execução">Fluxo de execução</h3>
<div class="paragraph">
<p>Para garantir a definição de uma função antes de sua primeira chamada, é necessário conhecer a ordem dos comandos executados, conhecido como <em>fluxo de execução</em>.
</p>
</div>
<div class="paragraph">
<p>A execução é feita sempre a partir do primeiro comando do programa. Os comandos são executados uma de cada vez, de cima para baixo.</p>
</div>
<div class="paragraph">
<p>As definições das funções não mudam o fluxo de execução do programa, mas lembre-se que os comandos dentro da função são executados somente quando a função é chamada.</p>
</div>
<div class="paragraph">
<p>Quando a função é chamada, é como um desvio no fluxo de execução. Em vez de ir para o comando seguinte, o fluxo salta para o corpo da função, executa os comandos lá e depois volta para continuar de onde parou.</p>
</div>
<div class="paragraph">
<p>Isso parece bastante simples, até você lembrar que uma função pode chamar outra. Enquanto estiver no meio de uma função, o programa pode ter a necessidade de executar os comandos em uma outra função. Logo, ao executar essa nova função, o programa pode precisar executar outra função!</p>
</div>
<div class="paragraph">
<p>Felizmente, Julia é bom em monitorar seus passos, portanto, toda vez que uma função é concluída, o programa retoma de onde parou na função que a chamou. Chegando ao final do programa, ele é encerrado.</p>
</div>
<div class="paragraph">
<p>Em resumo, quando você lê um programa, nem sempre deseja ler de cima para baixo. Às vezes, é mais lógico seguir o fluxo de execução.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parâmetros_e_argumentos">Parâmetros e argumentos</h3>
<div class="paragraph">
<p>Algumas das funções que vimos exigem argumentos. Por exemplo, quando você chama <code>sin</code>, um número é passado como argumento. Algumas funções usam mais de um argumento: <code>parse</code> necessita de dois, um tipo de número e uma string.
</p>
</div>
<div class="paragraph">
<p>Dentro da função, os argumentos são atribuídos a variáveis denominadas <em>parâmetros</em>. Aqui está uma definição para uma função que exige um argumento:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function imprimir2vezes(bruno)
    println(bruno)
    println(bruno)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta função atribui o argumento a um parâmetro denominado <code>bruno</code>. Quando a função é chamada, imprime-se o valor do parâmetro (qualquer que seja) duas vezes.</p>
</div>
<div class="paragraph">
<p>Esta função funciona com qualquer valor que possa ser impresso.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; imprimir2vezes("Spam")
Spam
Spam
julia&gt; imprimir2vezes(42)
42
42
julia&gt; imprimir2vezes(π)
π
π</code></pre>
</div>
</div>
<div class="paragraph">
<p>As mesmas regras de composição que se aplicam às funções embutidas também se aplicam às funções definidas pelo programador, portanto podemos usar qualquer tipo de expressão como argumento para <code>imprimir2vezes</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; imprimir2vezes("Spam "^4)
Spam Spam Spam Spam
Spam Spam Spam Spam
julia&gt; imprimir2vezes(cos(π))
-1.0
-1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>O argumento é avaliado antes da chamada da função, de modo que nos exemplos as expressões <code>"Spam "^4</code> e <code>cos(π)</code> são avaliadas apenas uma vez.
</p>
</div>
<div class="paragraph">
<p>Também pode-se usar uma variável como argumento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; ana = "Uma andorinha sozinha não faz verão."
"Uma andorinha sozinha não faz verão."
julia&gt; imprimir2vezes(ana)
Uma andorinha sozinha não faz verão.
Uma andorinha sozinha não faz verão.</code></pre>
</div>
</div>
<div class="paragraph">
<p>O nome da variável que passamos como argumento (<code>ana</code>) não tem nada a ver com o nome do parâmetro (<code>bruno</code>). Para a função <code>imprimir2vezes</code>, todos os parâmetros são chamados <code>bruno</code>, independentemente do nome da variável que passamos como argumento (neste caso, <code>ana</code>)</p>
</div>
</div>
<div class="sect2">
<h3 id="_as_variáveis_e_os_parâmetros_são_locais">As variáveis e os parâmetros são locais</h3>
<div class="paragraph">
<p>Ao criar uma variável dentro de uma função, ela é <em>local</em>, isto é, ela existe apenas dentro da função. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function concat_imprimir2vezes(parte1, parte2)
    concat = parte1 * parte2
    imprimir2vezes(concat)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta função exige dois argumentos, concatena-os e imprime o resultado duas vezes. A seguir um exemplo que a usa:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; linha1 = "Lava outra, "
"Lava outra, "
julia&gt; linha2 = "lava uma."
"lava uma."
julia&gt; concat_imprimir2vezes(linha1, linha2)
Lava outra, lava uma.
Lava outra, lava uma.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Após o término de <code>concat_imprimir2vezes</code>, a variável <code>concat</code> é destruída. Se tentarmos imprimi-la, aparece uma exceção:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; println(concat)
ERROR: UndefVarError: concat not defined</code></pre>
</div>
</div>
<div class="paragraph">
<p>Os parâmetros também são locais. Por exemplo, fora do <code>imprimir2vezes</code>, não existe o <code>bruno</code>.
</p>
</div>
</div>
<div class="sect2">
<h3 id="stack_diagrams">Diagramas de Pilha</h3>
<div class="paragraph">
<p>Para verificar quais variáveis podem ser usadas e onde, às vezes é prático desenhar um <em>diagrama de pilha</em>. Da mesma maneira dos diagramas de estado, os diagramas de pilha mostram o valor de cada variável, e mostram também a função à qual cada variável pertence.
 </p>
</div>
<div class="paragraph">
<p>Cada função é indicada por um <em>quadro</em>, que é representado por uma caixa com o nome de uma função ao lado e os parâmetros e as variáveis da respectiva função dentro dele. O diagrama de pilha do exemplo anterior é ilustrado em <a href="#fig03-1">Stack diagram</a>.
</p>
</div>
<div id="fig03-1" class="imageblock">
<div class="content">
<img src="images/fig31.svg" alt="fig31">
</div>
<div class="title">Figure 2. Stack diagram</div>
</div>
<div class="paragraph">
<p>Os quadros são dispostos em uma pilha que mostra qual função é chamada por outra, e assim por diante. Neste exemplo, <code>imprimir2vezes</code> foi chamada por <code>concat_imprimir2vezes</code>, e <code>concat_imprimir2vezes</code> foi chamada por <code>Main</code>, que é um nome especial para o quadro superior. Criando uma variável fora de qualquer função, ela pertence a <code>Main</code>.</p>
</div>
<div class="paragraph">
<p>Cada parâmetro recebe o mesmo valor que o seu argumento correspondente. Logo, <code>parte1</code> tem o mesmo valor que <code>linha1</code>, da mesma forma que <code>parte2</code> tem o mesmo valor que <code>linha2</code>, e <code>bruno</code> tem o mesmo valor que <code>concat</code>.</p>
</div>
<div class="paragraph">
<p>Em um caso de erro durante uma chamada de função, Julia imprime o nome da função, o nome da função que a chamou, e o nome da função que chamou por ela, e assim por diante até chegar no <code>Main</code>.
</p>
</div>
<div class="paragraph">
<p>Por exemplo, se você tentar acessar <code>concat</code> de dentro de <code>imprimir2vezes</code>, você recebe um <code>UndefVarError</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ERROR: UndefVarError: concat not defined
Stacktrace:
 [1] imprimir2vezes at ./REPL[1]:2 [inlined]
 [2] concat_imprimir2vezes(::String, ::String) at ./REPL[2]:3</pre>
</div>
</div>
<div class="paragraph">
<p>Esta lista de funções é chamada de <em>rastreamento de pilha</em>, que informa em qual arquivo de programa ocorreu o erro, em qual linha e quais funções estavam sendo executadas no momento. Também indica a linha de código que causou o erro.
</p>
</div>
<div class="paragraph">
<p>A ordem das funções no rastreamento de pilha é a ordem inversa dos quadros no diagrama de pilha. A função atualmente em execução fica no topo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_funções_produtivas_e_funções_nulas">Funções produtivas e funções nulas</h3>
<div class="paragraph">
<p>Algumas das funções que usamos, como as funções matemáticas que retornam resultados; por falta de um nome melhor, chamaremos de <em>funções produtivas</em>. As outras funções, como <code>imprimir2vezes</code>, que executam uma ação sem retornar um valor chamaremos de <em>funções nulas</em>.
 </p>
</div>
<div class="paragraph">
<p>Quando você chama uma função produtiva, quase sempre deseja-se fazer algo com o resultado; por exemplo, atribuí-lo a uma variável ou usá-lo como parte de uma expressão:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">x = cos(radianos)
áurea = (sqrt(5) + 1) / 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ao chamar uma função no modo interativo, Julia exibe o seguinte resultado:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; sqrt(5)
2.23606797749979</code></pre>
</div>
</div>
<div class="paragraph">
<p>Porém em um script, se chamar uma função produtiva por si só, o valor de retorno será perdido para sempre!
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">sqrt(5)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2.23606797749979</pre>
</div>
</div>
<div class="paragraph">
<p>Este script calcula a raiz quadrada de 5, que não é armazenado e nem exibido o resultado, e assim, não é muito útil.</p>
</div>
<div class="paragraph">
<p>As funções nulas podem exibir algo na tela ou ter algum outro efeito, mas não retorna um valor. Se atribuir o resultado a uma variável, obterá um valor especial chamado <code>nothing</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; resultado = imprimir2vezes("Bing")
Bing
Bing
julia&gt; show(resultado)
nothing</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para imprimir o valor <code>nothing</code>, usa-se a função <code>show</code> que é similar a <code>print</code> mas que pode lidar com o valor <code>nothing</code>.
</p>
</div>
<div class="paragraph">
<p>O valor <code>nothing</code> não é o mesmo que a string <code>"nothing"</code>. Pois é um valor especial que tem seu próprio tipo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; typeof(nothing)
Nothing</code></pre>
</div>
</div>
<div class="paragraph">
<p>As funções que temos escrito até o momento são todas nulas. Começaremos a escrever funções produtivas em alguns capítulos.</p>
</div>
</div>
<div class="sect2">
<h3 id="_por_que_funções">Por que funções?</h3>
<div class="paragraph">
<p>Pode não estar claro o motivo de fragmentar um programa em funções, mas existem várias razões:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Criar uma nova função dá a oportunidade de nomear uma série de comandos, o que facilita a leitura e o debugging do programa.</p>
</li>
<li>
<p>As funções podem reduzir o tamanho de um programa, eliminando a repetição do código. Mais tarde, no caso de alguma mudança, é só modificá-lo em um único lugar.</p>
</li>
<li>
<p>Dividir um programa longo em funções permite o debugging das partes, uma de cada vez, e depois reuni-las em um programa mais funcional.</p>
</li>
<li>
<p>Funções bem programadas são frequentemente úteis para muitos outros programas. Depois de escrever e debugar um, você pode reutilizá-la.</p>
</li>
<li>
<p>Em Julia, as funções podem melhorar consideravelmente o desempenho.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_debugging">Debugging</h3>
<div class="paragraph">
<p>NTD: Debugging é oficialmente traduzido como "depuração". No entanto, o termo mais usado entre os programadores é a palavra em inglês.</p>
</div>
<div class="paragraph">
<p>Uma das habilidades mais significativas que você vai adquirir é o debugging. Ainda que possa ser frustrante, o debugging é uma das partes da programação mais intelectualmente rica, desafiadora e interessante.
</p>
</div>
<div class="paragraph">
<p>De certa forma, o debugging é como um trabalho de detetive. Você é confrontado com pistas e precisa inferir os processos e eventos que levaram aos resultados encontrados.</p>
</div>
<div class="paragraph">
<p>O debugging também é como uma ciência experimental. Uma vez que você tem uma ideia do que está dando errado, modifique seu programa e tente novamente. Se a sua hipótese estiver correta, pode-se prever o resultado da modificação e aproximar-se de um programa funcional. Se a sua hipótese estava errada, inventa-se uma nova. Como Sherlock Holmes apontou,</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Tendo eliminado o impossível, aquilo que resta, ainda que improvável, deve ser a verdade.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; A. Conan Doyle<br>
<cite>O Signo dos Quatro</cite>
</div>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Algumas pessoas consideram que a programação e o debugging são a mesma coisa, já que a programação é o processo de debugar gradualmente um programa até que ele faça o que o programador deseja. A ideia é começar com um programa funcional e fazer pequenas mudanças, debugando-as à medida que avança.</p>
</div>
<div class="paragraph">
<p>Por exemplo, o Linux é um sistema operacional com milhões de linhas de código, mas começou como um programa simples que Linus Torvalds usava para examinar o chip Intel 80386. De acordo com Larry Greenfield, "um dos primeiros projetos de Linus era um programa que alternava entre imprimir "AAAA" e "BBBB". Este mais tarde evoluiu para Linux. ” (<em>The Linux Users' Guide</em> Versão Beta 1).
 </p>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_3">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">função</dt>
<dd>
<p>Uma sequência nomeada de comandos que realiza alguma operação útil. As funções podem ou não nessitar de argumentos e podem ou não gerar um resultado.
</p>
</dd>
<dt class="hdlist1">definição de função</dt>
<dd>
<p>Um comando que cria uma nova função, e com especificação do seu nome, seus parâmetros e dos comandos que ela contém.
</p>
</dd>
<dt class="hdlist1">objeto do tipo função</dt>
<dd>
<p>Um valor criado por uma definição de função. O nome da função é uma variável que se refere a um objeto do tipo função.
</p>
</dd>
<dt class="hdlist1">cabeçalho</dt>
<dd>
<p>A primeira linha de uma definição de função.
</p>
</dd>
<dt class="hdlist1">corpo</dt>
<dd>
<p>A sequência de comandos dentro de uma definição de função.
</p>
</dd>
<dt class="hdlist1">parâmetro</dt>
<dd>
<p>Um nome usado dentro de uma função para se referir ao valor passado como argumento.
</p>
</dd>
<dt class="hdlist1">chamada de função</dt>
<dd>
<p>Um comando que executa uma função. Consiste no nome da função seguido de uma lista de argumentos entre parênteses.
</p>
</dd>
<dt class="hdlist1">argumento</dt>
<dd>
<p>Um valor fornecido a uma função quando a função é chamada. E este valor é atribuído ao parâmetro correspondente na função.
</p>
</dd>
<dt class="hdlist1">variável local</dt>
<dd>
<p>Uma variável definida dentro de uma função. Uma variável local só pode ser utilizada dentro de sua função.
</p>
</dd>
<dt class="hdlist1">valor de retorno</dt>
<dd>
<p>O resultado de uma função. Se uma chamada de função é utilizada como uma expressão, o valor de retorno é o valor da expressão.
</p>
</dd>
<dt class="hdlist1">função produtiva</dt>
<dd>
<p>Uma função que retorna um valor.
</p>
</dd>
<dt class="hdlist1">função nula</dt>
<dd>
<p>Uma função que sempre retorna <code>nothing</code>.
</p>
</dd>
<dt class="hdlist1"><code>nothing</code></dt>
<dd>
<p>Um valor especial devolvido por funções nulas.
</p>
</dd>
<dt class="hdlist1">composição</dt>
<dd>
<p>Usar uma expressão como parte de uma expressão maior ou um comando como parte de um comando maior.
</p>
</dd>
<dt class="hdlist1">fluxo de execução</dt>
<dd>
<p>A ordem da execução dos comandos.
</p>
</dd>
<dt class="hdlist1">diagrama da pilha</dt>
<dd>
<p>Representação gráfica de uma pilha de funções, suas variáveis e os valores a que se referem.
</p>
</dd>
<dt class="hdlist1">quadro</dt>
<dd>
<p>Uma caixa em um diagrama de pilha que representa uma chamada de função, além de conter as variáveis e parâmetros locais da função.
</p>
</dd>
<dt class="hdlist1">rastreamento de pilha</dt>
<dd>
<p>Uma lista das funções que estão sendo executadas, mostrada quando ocorre uma exceção.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_3">Exercícios</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Esses exercícios devem ser realizados usando apenas os comandos e outros recursos aprendidos até o momento.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="ex03-1">Exercício 3-2</h5>
<div class="paragraph">
<p>Escreva uma função denominada <code>alinhar_a_direita</code> que recebe uma string denominada <code>s</code> como parâmetro e imprime a string com espaços suficientes à esquerda de modo que a última letra da string esteja na coluna 70 da exibição.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; alinhar_a_direita("trapalhões")
ERROR: UndefVarError: alinhar_a_direita not defined</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Use concatenação e repetição de string. Além disso, Julia fornece uma função interna chamada <code>length</code> que retorna o comprimento de uma string, portanto o valor de <code>length("trapalhões")</code> é 10.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ex03-2">Exercício 3-3</h5>
<div class="paragraph">
<p>Um objeto do tipo função é um valor que você pode associar a uma variável ou passar como argumento. Por exemplo, <code>fazer2vezes</code> é uma função que pega um objeto do tipo função como argumento e o chama duas vezes:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function fazer2vezes(f)
    f()
    f()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Veja um exemplo que usa <code>fazer2vezes</code> para chamar a função <code>imprimir_spam</code> duas vezes.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function imprimir_spam()
    println("spam")
end

fazer2vezes(imprimir_spam)</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Copie este exemplo em um script e teste-o.</p>
</li>
<li>
<p>Modifique <code>fazer2vezes</code> para que ele receba dois argumentos, um objeto do tipo função e um valor, e chame a função duas vezes, passando o valor como argumento.</p>
</li>
<li>
<p>Copie a definição de <code>imprimir2vezes</code> apresentada no início deste capítulo para o seu script.</p>
</li>
<li>
<p>Use a versão modificada de <code>fazer2vezes</code> para chamar <code>imprimir2vezes</code> duas vezes, e passando <code>"spam"</code> como argumento.</p>
</li>
<li>
<p>Defina uma nova função chamada <code>fazer4vezes</code> que recebe um objeto do tipo função e um valor e chama a função quatro vezes, passando o valor como parâmetro. Esta função deve ter apenas dois comandos no corpo dessa função, e não quatro.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="ex03-3">Exercício 3-4</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escreva uma função <code>imprimir_grade</code> que desenha uma grade da seguinte maneira:
</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; imprimir_grade()
+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +</code></pre>
</div>
</div>
</li>
<li>
<p>Escreva uma função que desenhe uma grade semelhante, com quatro linhas e quatro colunas.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Crédito: este exercício é baseado em um exercício de Oualline, <em>Practical C Programming</em>, Terceira Edição, O´Reilly Media, 1997.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Para mostrar mais de um valor em uma linha, você pode imprimir uma sequência de valores separados por vírgula:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">println("+", "-")</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função <code>print</code> não avança para a linha seguinte:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">print("+ ")
println("-")</code></pre>
</div>
</div>
<div class="paragraph">
<p>A saída desses comandos é <code>"+ -"</code> na mesma linha. A saída do próximo comando é a impressão que começaria na seguinte linha.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap04">7. Case Study: Interface Design</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter presents a case study that demonstrates a process for designing functions that work together.</p>
</div>
<div class="paragraph">
<p>It introduces turtle graphics, a way to create programmatic drawings. Turtle graphics are not included in the Standard Library, so the ThinkJulia module has to be added to your Julia setup.</p>
</div>
<div class="paragraph">
<p>The examples in this chapter can be executed in a graphical notebook on JuliaBox, which combines code, formatted text, math, and multimedia in a single document (see <a href="#juliabox">[juliabox]</a>).
</p>
</div>
<div class="sect2">
<h3 id="_turtles">Turtles</h3>
<div class="paragraph">
<p>A <em>module</em> is a file that contains a collection of related functions. Julia provides some modules in its Standard Library. Additional functionality can be added from a growing collection of <em>packages</em> (<a href="https://juliaobserver.com" class="bare">https://juliaobserver.com</a>).
</p>
</div>
<div class="paragraph">
<p>Packages can be installed in the REPL by entering the Pkg REPL-mode using the key <code>]</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">(v1.0) pkg&gt; add https://github.com/BenLauwens/ThinkJulia.jl</code></pre>
</div>
</div>
<div class="paragraph">
<p>This can take some time.</p>
</div>
<div class="paragraph">
<p>Before we can use the functions in a module, we have to import it with an <code>using</code> statement:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; using ThinkJulia

julia&gt; 🐢 = Turtle()
Luxor.Turtle(0.0, 0.0, true, 0.0, (0.0, 0.0, 0.0))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ThinkJulia</code> module provides a function called <code>Turtle</code> that creates a <code>Luxor.Turtle</code> object, which we assign to a variable named <code>🐢</code> (<strong><code>\:turtle: TAB</code></strong>).
</p>
</div>
<div class="paragraph">
<p>Once you create a turtle, you can call a function to move it around a drawing. For example, to move the turtle forward:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">@svg begin
    forward(🐢, 100)
end</code></pre>
</div>
</div>
<div id="fig04-1" class="imageblock">
<div class="content">
<img src="images/fig41.svg" alt="fig41">
</div>
<div class="title">Figure 3. Moving the turtle forward</div>
</div>
<div class="paragraph">
<p>The <code>@svg</code> keyword runs a macro that draws a SVG picture. Macros are an important but advanced feature of Julia.
</p>
</div>
<div class="paragraph">
<p>The arguments of <code>forward</code> are the turtle and a distance in pixels, so the actual size depends on your display.</p>
</div>
<div class="paragraph">
<p>Another function you can call with a turtle as argument is <code>turn</code> for turning. The second argument for <code>turn</code> is an angle in degrees.
</p>
</div>
<div class="paragraph">
<p>Also, each turtle is holding a pen, which is either down or up; if the pen is down, the turtle leaves a trail when it moves. <a href="#fig04-1">Moving the turtle forward</a> shows the trail left behind by the turtle. The functions <code>penup</code> and <code>pendown</code> stand for “pen up” and “pen down”.
</p>
</div>
<div class="paragraph">
<p>To draw a right angle, modify the macro call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">🐢 = Turtle()
@svg begin
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
end</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_exercise_4_1">Exercise 4-1</h5>
<div class="paragraph">
<p>Now modify the macro to draw a square. Don’t go on until you’ve got it working!</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="simple_repetition">Simple Repetition</h3>
<div class="paragraph">
<p>Chances are you wrote something like this:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">🐢 = Turtle()
@svg begin
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can do the same thing more concisely with a <code>for</code> statement:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; for i in 1:4
          println("Hello!")
       end
Hello!
Hello!
Hello!
Hello!</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the simplest use of the <code>for</code> statement; we will see more later. But that should be enough to let you rewrite your square-drawing program. Don’t go on until you do.</p>
</div>
<div class="paragraph">
<p>Here is a <code>for</code> statement that draws a square:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">🐢 = Turtle()
@svg begin
    for i in 1:4
        forward(🐢, 100)
        turn(🐢, -90)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The syntax of a <code>for</code> statement is similar to a function definition. It has a header and a body that ends with the keyword <code>end</code>. The body can contain any number of statements.
</p>
</div>
<div class="paragraph">
<p>A <code>for</code> statement is also called a <em>loop</em> because the flow of execution runs through the body and then loops back to the top. In this case, it runs the body four times.
</p>
</div>
<div class="paragraph">
<p>This version is actually a little different from the previous square-drawing code because it makes another turn after drawing the last side of the square. The extra turn takes more time, but it simplifies the code if we do the same thing every time through the loop. This version also has the effect of leaving the turtle back in the starting position, facing in the starting direction.</p>
</div>
</div>
<div class="sect2">
<h3 id="_exercises">Exercises</h3>
<div class="paragraph">
<p>The following is a series of exercises using turtles. They are meant to be fun, but they have a point, too. While you are working on them, think about what the point is.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>The following sections have solutions to the exercises, so don’t look until you have finished (or at least tried).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="ex04-1">Exercise 4-2</h5>
<div class="paragraph">
<p>Write a function called <code>square</code> that takes a parameter named <code>t</code>, which is a turtle. It should use the turtle to draw a square.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex04-2">Exercise 4-3</h5>
<div class="paragraph">
<p>Write a function call that passes <code>t</code> as an argument to <code>square</code>, and then run the macro again.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex04-3">Exercise 4-4</h5>
<div class="paragraph">
<p>Add another parameter, named <code>len</code>, to square. Modify the body so length of the sides is <code>len</code>, and then modify the function call to provide a second argument. Run the macro again. Test with a range of values for <code>len</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex04-4">Exercise 4-5</h5>
<div class="paragraph">
<p>Make a copy of <code>square</code> and change the name to <code>polygon</code>. Add another parameter named <code>n</code> and modify the body so it draws an \(n\)-sided regular polygon.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>The exterior angles of an \(n\)-sided regular polygon are \(\frac{360}{n}\) degrees.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ex04-5">Exercise 4-6</h5>
<div class="paragraph">
<p>Write a function called <code>circle</code> that takes a turtle, <code>t</code>, and radius, <code>r</code>, as parameters and that draws an approximate circle by calling <code>polygon</code> with an appropriate length and number of sides. Test your function with a range of values of <code>r</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Figure out the circumference of the circle and make sure that <code>len * n == circumference</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ex04-6">Exercise 4-7</h5>
<div class="paragraph">
<p>Make a more general version of <code>circle</code> called <code>arc</code> that takes an additional parameter <code>angle</code>, which determines what fraction of a circle to draw. <code>angle</code> is in units of degrees, so when <code>angle = 360</code>, <code>arc</code> should draw a complete circle.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_encapsulation">Encapsulation</h3>
<div class="paragraph">
<p>The first exercise asks you to put your square-drawing code into a function definition and then call the function, passing the turtle as a parameter. Here is a solution:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function square(t)
    for i in 1:4
        forward(t, 100)
        turn(t, -90)
    end
end
🐢 = Turtle()
@svg begin
    square(🐢)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The innermost statements, <code>forward</code> and <code>turn</code> are indented twice to show that they are inside the <code>for</code> loop, which is inside the function definition.
</p>
</div>
<div class="paragraph">
<p>Inside the function, <code>t</code> refers to the same turtle <code>🐢</code>, so <code>turn(t, -90)</code> has the same effect as <code>turn(🐢, -90)</code>. In that case, why not call the parameter <code>🐢</code>? The idea is that <code>t</code> can be any turtle, not just <code>🐢</code>, so you could create a second turtle and pass it as an argument to <code>square</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">🐫 = Turtle()
@svg begin
    square(🐫)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wrapping a piece of code up in a function is called <em>encapsulation</em>. One of the benefits of encapsulation is that it attaches a name to the code, which serves as a kind of documentation. Another advantage is that if you re-use the code, it is more concise to call a function twice than to copy and paste the body!
</p>
</div>
</div>
<div class="sect2">
<h3 id="_generalization">Generalization</h3>
<div class="paragraph">
<p>The next step is to add a <code>len</code> parameter to <code>square</code>. Here is a solution:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function square(t, len)
    for i in 1:4
        forward(t, len)
        turn(t, -90)
    end
end
🐢 = Turtle()
@svg begin
    square(🐢, 100)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding a parameter to a function is called <em>generalization</em> because it makes the function more general: in the previous version, the square is always the same size; in this version it can be any size.
</p>
</div>
<div class="paragraph">
<p>The next step is also a generalization. Instead of drawing squares, <code>polygon</code> draws regular polygons with any number of sides. Here is a solution:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function polygon(t, n, len)
    angle = 360 / n
    for i in 1:n
        forward(t, len)
        turn(t, -angle)
    end
end
🐢 = Turtle()
@svg begin
    polygon(🐢, 7, 70)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example draws a 7-sided polygon with side length 70.</p>
</div>
</div>
<div class="sect2">
<h3 id="_interface_design">Interface Design</h3>
<div class="paragraph">
<p>The next step is to write <code>circle</code>, which takes a radius, <code>r</code>, as a parameter. Here is a simple solution that uses <code>polygon</code> to draw a 50-sided polygon:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function circle(t, r)
    circumference = 2 * π * r
    n = 50
    len = circumference / n
    polygon(t, n, len)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first line computes the circumference of a circle with radius \(r\) using the formula \(2 \pi r\). <code>n</code> is the number of line segments in our approximation of a circle, so <code>len</code> is the length of each segment. Thus, <code>polygon</code> draws a 50-sided polygon that approximates a circle with radius <code>r</code>.</p>
</div>
<div class="paragraph">
<p>One limitation of this solution is that <code>n</code> is a constant, which means that for very big circles, the line segments are too long, and for small circles, we waste time drawing very small segments. One solution would be to generalize the function by taking <code>n</code> as a parameter. This would give the user (whoever calls circle) more control, but the interface would be less clean.</p>
</div>
<div class="paragraph">
<p>The <em>interface</em> of a function is a summary of how it is used: what are the parameters? What does the function do? And what is the return value? An interface is “clean” if it allows the caller to do what they want without dealing with unnecessary details.
</p>
</div>
<div class="paragraph">
<p>In this example, <code>r</code> belongs in the interface because it specifies the circle to be drawn. <code>n</code> is less appropriate because it pertains to the details of how the circle should be rendered.</p>
</div>
<div class="paragraph">
<p>Rather than clutter up the interface, it is better to choose an appropriate value of <code>n</code> depending on <code>circumference</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function circle(t, r)
    circumference = 2 * π * r
    n = trunc(circumference / 3) + 3
    len = circumference / n
    polygon(t, n, len)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the number of segments is an integer near <code>circumference/3</code>, so the length of each segment is approximately 3, which is small enough that the circles look good, but big enough to be efficient, and acceptable for any size circle.</p>
</div>
<div class="paragraph">
<p>Adding 3 to <code>n</code> guarantees that the polygon has at least 3 sides.</p>
</div>
</div>
<div class="sect2">
<h3 id="refactoring">Refactoring</h3>
<div class="paragraph">
<p>When I wrote <code>circle</code>, I was able to re-use <code>polygon</code> because a many-sided polygon is a good approximation of a circle. But <code>arc</code> is not as cooperative; we can’t use <code>polygon</code> or <code>circle</code> to draw an arc.</p>
</div>
<div class="paragraph">
<p>One alternative is to start with a copy of <code>polygon</code> and transform it into <code>arc</code>. The result might look like this:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function arc(t, r, angle)
    arc_len = 2 * π * r * angle / 360
    n = trunc(arc_len / 3) + 1
    step_len = arc_len / n
    step_angle = angle / n
    for i in 1:n
        forward(t, step_len)
        turn(t, -step_angle)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second half of this function looks like <code>polygon</code>, but we can’t re-use <code>polygon</code> without changing the interface. We could generalize <code>polygon</code> to take an <code>angle</code> as a third argument, but then <code>polygon</code> would no longer be an appropriate name! Instead, let’s call the more general function <code>polyline</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function polyline(t, n, len, angle)
    for i in 1:n
        forward(t, len)
        turn(t, -angle)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can rewrite <code>polygon</code> and <code>arc</code> to use <code>polyline</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function polygon(t, n, len)
    angle = 360 / n
    polyline(t, n, len, angle)
end

function arc(t, r, angle)
    arc_len = 2 * π * r * angle / 360
    n = trunc(arc_len / 3) + 1
    step_len = arc_len / n
    step_angle = angle / n
    polyline(t, n, step_len, step_angle)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we can rewrite <code>circle</code> to use <code>arc</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function circle(t, r)
    arc(t, r, 360)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>This process—rearranging a program to improve interfaces and facilitate code re-use—is called <em>refactoring</em>. In this case, we noticed that there was similar code in <code>arc</code> and <code>polygon</code>, so we “factored it out” into <code>polyline</code>.
</p>
</div>
<div class="paragraph">
<p>If we had planned ahead, we might have written <code>polyline</code> first and avoided refactoring, but often you don’t know enough at the beginning of a project to design all the interfaces. Once you start coding, you understand the problem better. Sometimes refactoring is a sign that you have learned something.</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_development_plan">A Development Plan</h3>
<div class="paragraph">
<p>A <em>development plan</em> is a process for writing programs. The process we used in this case study is “encapsulation and generalization”. The steps of this process are:
</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start by writing a small program with no function definitions.</p>
</li>
<li>
<p>Once you get the program working, identify a coherent piece of it, encapsulate the piece in a function and give it a name.</p>
</li>
<li>
<p>Generalize the function by adding appropriate parameters.</p>
</li>
<li>
<p>Repeat steps 1–3 until you have a set of working functions. Copy and paste working code to avoid retyping (and re-debugging).</p>
</li>
<li>
<p>Look for opportunities to improve the program by refactoring. For example, if you have similar code in several places, consider factoring it into an appropriately general function.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This process has some drawbacks—we will see alternatives later—but it can be useful if you don’t know ahead of time how to divide the program into functions. This approach lets you design as you go along.</p>
</div>
</div>
<div class="sect2">
<h3 id="_docstring">Docstring</h3>
<div class="paragraph">
<p>A <em>docstring</em> is a string before a function that explains the interface (“doc” is short for “documentation”). Here is an example:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">"""
polyline(t, n, len, angle)

Draws n line segments with the given length and
angle (in degrees) between them.  t is a turtle.
"""
function polyline(t, n, len, angle)
    for i in 1:n
        forward(t, len)
        turn(t, -angle)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Documentation can be accessed in the REPL or in a notebook by typing ? followed by the name of a function or macro, and pressing <code>ENTER</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre>help?&gt; polyline
search:

  polyline(t, n, len, angle)

  Draws n line segments with the given length and angle (in degrees) between them. t is a turtle.</pre>
</div>
</div>
<div class="paragraph">
<p>Docstrings are often triple-quoted strings, also known as multiline strings because the triple quotes allow the string to span more than one line.</p>
</div>
<div class="paragraph">
<p>A docstring contains the essential information someone would need to use this function. It explains concisely what the function does (without getting into the details of how it does it). It explains what effect each parameter has on the behavior of the function and what type each parameter should be (if it is not obvious).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Writing this kind of documentation is an important part of interface design. A well-designed interface should be simple to explain; if you have a hard time explaining one of your functions, maybe the interface could be improved.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_debugging_2">Debugging</h3>
<div class="paragraph">
<p>An interface is like a contract between a function and a caller. The caller agrees to provide certain parameters and the function agrees to do certain work.
</p>
</div>
<div class="paragraph">
<p>For example, <code>polyline</code> requires four arguments: <code>t</code> has to be a turtle; <code>n</code> has to be an integer; <code>len</code> should be a positive number; and <code>angle</code> has to be a number, which is understood to be in degrees.</p>
</div>
<div class="paragraph">
<p>These requirements are called <em>preconditions</em> because they are supposed to be true before the function starts executing. Conversely, conditions at the end of the function are <em>postconditions</em>. Postconditions include the intended effect of the function (like drawing line segments) and any side effects (like moving the turtle or making other changes).
</p>
</div>
<div class="paragraph">
<p>Preconditions are the responsibility of the caller. If the caller violates a (properly documented!) precondition and the function doesn’t work correctly, the bug is in the caller, not the function.</p>
</div>
<div class="paragraph">
<p>If the preconditions are satisfied and the postconditions are not, the bug is in the function. If your pre- and postconditions are clear, they can help with debugging.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossary">Glossary</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">module</dt>
<dd>
<p>A file that contains a collection of related functions and other definitions.
</p>
</dd>
<dt class="hdlist1">package</dt>
<dd>
<p>An external library with additional functionality.
</p>
</dd>
<dt class="hdlist1">using statement</dt>
<dd>
<p>A statement that reads a module file and creates a module object.
</p>
</dd>
<dt class="hdlist1">loop</dt>
<dd>
<p>A part of a program that can run repeatedly.
</p>
</dd>
<dt class="hdlist1">encapsulation</dt>
<dd>
<p>The process of transforming a sequence of statements into a function definition.
</p>
</dd>
<dt class="hdlist1">generalization</dt>
<dd>
<p>The process of replacing something unnecessarily specific (like a number) with something appropriately general (like a variable or parameter).
</p>
</dd>
<dt class="hdlist1">interface</dt>
<dd>
<p>A description of how to use a function, including the name and descriptions of the arguments and return value.
</p>
</dd>
<dt class="hdlist1">refactoring</dt>
<dd>
<p>The process of modifying a working program to improve function interfaces and other qualities of the code.
</p>
</dd>
<dt class="hdlist1">development plan</dt>
<dd>
<p>A process for writing programs.
</p>
</dd>
<dt class="hdlist1">docstring</dt>
<dd>
<p>A string that appears at the top of a function definition to document the function’s interface.
</p>
</dd>
<dt class="hdlist1">precondition</dt>
<dd>
<p>A requirement that should be satisfied by the caller before a function starts.
</p>
</dd>
<dt class="hdlist1">postcondition</dt>
<dd>
<p>A requirement that should be satisfied by the function before it ends.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_2">Exercises</h3>
<div class="sect4">
<h5 id="ex04-7">Exercise 4-8</h5>
<div class="paragraph">
<p>Enter the code in this chapter in a notebook.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Draw a stack diagram that shows the state of the program while executing <code>circle(🐢, radius)</code>. You can do the arithmetic by hand or add print statements to the code.</p>
</li>
<li>
<p>The version of <code>arc</code> in <a href="#refactoring">Refactoring</a> is not very accurate because the linear approximation of the circle is always outside the true circle. As a result, the turtle ends up a few pixels away from the correct destination. My solution shows a way to reduce the effect of this error. Read the code and see if it makes sense to you. If you draw a diagram, you might see how it works.
</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">"""
arc(t, r, angle)

Draws an arc with the given radius and angle:

    t: turtle
    r: radius
    angle: angle subtended by the arc, in degrees
"""
function arc(t, r, angle)
    arc_len = 2 * π * r * abs(angle) / 360
    n = trunc(arc_len / 4) + 3
    step_len = arc_len / n
    step_angle = angle / n

    # making a slight left turn before starting reduces
    # the error caused by the linear approximation of the arc
    turn(t, -step_angle/2)
    polyline(t, n, step_len, step_angle)
    turn(t, step_angle/2)
end</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex04-8">Exercise 4-9</h5>
<div class="paragraph">
<p>Write an appropriately general set of functions that can draw flowers as in <a href="#fig04-2">Turtle flowers</a>.</p>
</div>
<div id="fig04-2" class="imageblock">
<div class="content">
<img src="images/fig42.svg" alt="fig42">
</div>
<div class="title">Figure 4. Turtle flowers</div>
</div>
</div>
<div class="sect4">
<h5 id="ex04-9">Exercise 4-10</h5>
<div class="paragraph">
<p>Write an appropriately general set of functions that can draw shapes as in <a href="#fig04-3">Turtle pies</a>.</p>
</div>
<div id="fig04-3" class="imageblock">
<div class="content">
<img src="images/fig43.svg" alt="fig43">
</div>
<div class="title">Figure 5. Turtle pies</div>
</div>
</div>
<div class="sect4">
<h5 id="ex04-10">Exercise 4-11</h5>
<div class="paragraph">
<p>The letters of the alphabet can be constructed from a moderate number of basic elements, like vertical and horizontal lines and a few curves. Design an alphabet that can be drawn with a minimal number of basic elements and then write functions that draw the letters.</p>
</div>
<div class="paragraph">
<p>You should write one function for each letter, with names <code>draw_a</code>, <code>draw_b</code>, etc., and put your functions in a file named <em>letters.jl</em>.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex04-11">Exercise 4-12</h5>
<div class="paragraph">
<p>Read about spirals at <a href="https://en.wikipedia.org/wiki/Spiral" class="bare">https://en.wikipedia.org/wiki/Spiral</a>; then write a program that draws an Archimedan spiral as in <a href="#fig04-4">Archimedan spiral</a>.</p>
</div>
<div id="fig04-4" class="imageblock">
<div class="content">
<img src="images/fig44.svg" alt="fig44">
</div>
<div class="title">Figure 6. Archimedan spiral</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap05">8. Conditionals and Recursion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main topic of this chapter is the <code>if</code> statement, which executes different code depending on the state of the program. But first I want to introduce two new operators: floor division and modulus.</p>
</div>
<div class="sect2">
<h3 id="_floor_division_and_modulus">Floor Division and Modulus</h3>
<div class="paragraph">
<p>The <em>floor division</em> operator, <code>÷</code> (<strong><code>\div TAB</code></strong>), divides two numbers and rounds down to an integer. For example, suppose the run time of a movie is 105 minutes. You might want to know how long that is in hours. Conventional division returns a floating-point number:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; minutes = 105
105
julia&gt; minutes / 60
1.75</code></pre>
</div>
</div>
<div class="paragraph">
<p>But we don’t normally write hours with decimal points. Floor division returns the integer number of hours, rounding down:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; hours = minutes ÷ 60
1</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get the remainder, you could subtract off one hour in minutes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; remainder = minutes - hours * 60
45</code></pre>
</div>
</div>
<div class="paragraph">
<p>An alternative is to use the <em>modulus operator</em>, <code>%</code>, which divides two numbers and returns the remainder.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; remainder = minutes % 60
45</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>The modulus operator is more useful than it seems. For example, you can check whether one number is divisible by another—if <code>x % y</code> is zero, then <code>x</code> is divisible by <code>y</code>.</p>
</div>
<div class="paragraph">
<p>Also, you can extract the right-most digit or digits from a number. For example, <code>x % 10</code> yields the right-most digit of an integer <code>x</code> (in base 10). Similarly <code>x % 100</code> yields the last two digits.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_boolean_expressions">Boolean Expressions</h3>
<div class="paragraph">
<p>A <em>boolean expression</em> is an expression that is either true or false. The following examples use the operator <code>==</code>, which compares two operands and produces <code>true</code> if they are equal and <code>false</code> otherwise:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; 5 == 5
true
julia&gt; 5 == 6
false</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>true</code> and <code>false</code> are special values that belong to the type <code>Bool</code>; they are not strings:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; typeof(true)
Bool
julia&gt; typeof(false)
Bool</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>==</code> operator is one of the relational operators; the others are:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">      x != y               # x is not equal to y
      x ≠ y                # (\ne TAB)
      x &gt; y                # x is greater than y
      x &lt; y                # x is less than y
      x &gt;= y               # x is greater than or equal to y
      x ≥ y                # (\ge TAB)
      x &lt;= y               # x is less than or equal to y
      x ≤ y                # (\le TAB)</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Although these operations are probably familiar to you, the Julia symbols are different from the mathematical symbols. A common error is to use a single equal sign (<code>=</code>) instead of a double equal sign (<code>==</code>). Remember that <code>=</code> is an assignment operator and <code>==</code> is a relational operator. There is no such thing as <code>=&lt;</code> or <code>=></code>.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_logical_operators">Logical Operators</h3>
<div class="paragraph">
<p>There are three <em>logical operators</em>: <code>&amp;&amp;</code> (and), <code>||</code> (or), and <code>!</code> (not). The semantics (meaning) of these operators is similar to their meaning in English. For example, <code>x &gt; 0 &amp;&amp; x &lt; 10</code> is true only if <code>x</code> is greater than <code>0</code> <em>and</em> less than <code>10</code>.
</p>
</div>
<div class="paragraph">
<p><code>n % 2 == 0 || n % 3 == 0</code> is true if <em>either or both</em> of the conditions is true, that is, if the number is divisible by 2 <em>or</em> 3.</p>
</div>
<div class="paragraph">
<p>Both <code>&amp;&amp;</code> and <code>||</code> associate to the right, but <code>&amp;&amp;</code> has higher precedence than <code>||</code> does.</p>
</div>
<div class="paragraph">
<p>Finally, the <code>!</code> operator negates a boolean expression, so <code>!(x &gt; y)</code> is true if <code>x &gt; y</code> is false, that is, if <code>x</code> is less than or equal to <code>y</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conditional_execution">Conditional Execution</h3>
<div class="paragraph">
<p>In order to write useful programs, we almost always need the ability to check conditions and change the behavior of the program accordingly. <em>Conditional statements</em> give us this ability. The simplest form is the <code>if</code> statement:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">if x &gt; 0
    println("x is positive")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The boolean expression after <code>if</code> is called the <em>condition</em>. If it is true, the indented statement runs. If not, nothing happens.
</p>
</div>
<div class="paragraph">
<p><code>if</code> statements have the same structure as function definitions: a header followed by body terminated with the keyword <code>end</code>. Statements like this are called <em>compound statements</em>.
</p>
</div>
<div class="paragraph">
<p>There is no limit on the number of statements that can appear in the body. Occasionally, it is useful to have a body with no statements (usually as a place keeper for code you haven’t written yet).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">if x &lt; 0
    # TODO: need to handle negative values!
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_alternative_execution">Alternative Execution</h3>
<div class="paragraph">
<p>A second form of the <code>if</code> statement is “alternative execution”, in which there are two possibilities and the condition determines which one runs. The syntax looks like this:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">if x % 2 == 0
    println("x is even")
else
    println("x is odd")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the remainder when <code>x</code> is divided by 2 is 0, then we know that <code>x</code> is even, and the program displays an appropriate message. If the condition is false, the second set of statements runs. Since the condition must be true or false, exactly one of the alternatives will run. The alternatives are called <em>branches</em>, because they are branches in the flow of execution.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_chained_conditionals">Chained Conditionals</h3>
<div class="paragraph">
<p>Sometimes there are more than two possibilities and we need more than two branches. One way to express a computation like that is a <em>chained conditional</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">if x &lt; y
    println("x is less than y")
elseif x &gt; y
    println("x is greater than y")
else
    println("x and y are equal")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, exactly one branch will run. There is no limit on the number of <code>elseif</code> statements. If there is an <code>else</code> clause, it has to be at the end, but there doesn’t have to be one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">if choice == "a"
    draw_a()
elseif choice == "b"
    draw_b()
elseif choice == "c"
    draw_c()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each condition is checked in order. If the first is false, the next is checked, and so on. If one of them is true, the corresponding branch runs and the statement ends. Even if more than one condition is true, only the first true branch runs.</p>
</div>
</div>
<div class="sect2">
<h3 id="_nested_conditionals">Nested Conditionals</h3>
<div class="paragraph">
<p>One conditional can also be nested within another. We could have written the example in the previous section like this:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">if x == y
    println("x and y are equal")
else
    if x &lt; y
        println("x is less than y")
    else
        println("x is greater than y")
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The outer conditional contains two branches. The first branch contains a simple statement. The second branch contains another <code>if</code> statement, which has two branches of its own. Those two branches are both simple statements, although they could have been conditional statements as well.</p>
</div>
<div class="paragraph">
<p>Although the non-compulsory indentation of the statements makes the structure apparent, <em>nested conditionals</em> become difficult to read very quickly. It is a good idea to avoid them when you can.
</p>
</div>
<div class="paragraph">
<p>Logical operators often provide a way to simplify nested conditional statements. For example, we can rewrite the following code using a single conditional:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">if 0 &lt; x
    if x &lt; 10
        println("x is a positive single-digit number.")
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>print</code> statement runs only if we make it past both conditionals, so we can get the same effect with the <code>&amp;&amp;</code> operator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">if 0 &lt; x &amp;&amp; x &lt; 10
    println("x is a positive single-digit number.")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>For this kind of condition, Julia provides a more concise syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">if 0 &lt; x &lt; 10
    println("x is a positive single-digit number.")
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="recursion">Recursion</h3>
<div class="paragraph">
<p>It is legal for one function to call another; it is also legal for a function to call itself. It may not be obvious why that is a good thing, but it turns out to be one of the most magical things a program can do. For example, look at the following function:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function countdown(n)
    if n ≤ 0
        println("Blastoff!")
    else
        print(n, " ")
        countdown(n-1)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>n</code> is 0 or negative, it outputs the word, <code>"Blastoff!"</code> Otherwise, it outputs <code>n</code> and then calls a function named <code>countdown</code>—itself—passing <code>n-1</code> as an argument.</p>
</div>
<div class="paragraph">
<p>What happens if we call this function like this?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; countdown(3)
3 2 1 Blastoff!</code></pre>
</div>
</div>
<div class="paragraph">
<p>The execution of <code>countdown</code> begins with <code>n = 3</code>, and since <code>n</code> is greater than 0, it outputs the value 3, and then calls itself &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;The execution of <code>countdown</code> begins with <code>n = 2</code>, and since <code>n</code> is greater than 0, <br/>&#8193;&#8193;it outputs the value 2, and then calls itself &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;The execution of <code>countdown</code> begins with <code>n = 1</code>, and since <code>n</code> is greater than 0, <br/>&#8193;&#8193;&#8193;it outputs the value 1, and then calls itself &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;&#8193;The execution of <code>countdown</code> begins with <code>n = 0</code>, and since <code>n</code> is not greater than <br/>&#8193;&#8193;&#8193;&#8193;0, it outputs the word, <code>"Blastoff!"</code> and then returns.</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;The countdown that got <code>n = 1</code> returns.</p>
</div>
<div class="paragraph">
<p>&#8193;The countdown that got <code>n = 2</code> returns.</p>
</div>
<div class="paragraph">
<p>The countdown that got <code>n = 3</code> returns.</p>
</div>
<div class="paragraph">
<p>And then you’re back in <code>Main</code>.</p>
</div>
<div class="paragraph">
<p>A function that calls itself is <em>recursive</em>; the process of executing it is called <em>recursion</em>.
</p>
</div>
<div class="paragraph">
<p>As another example, we can write a function that prints a string \(n\) times.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function printn(s, n)
    if n ≤ 0
        return
    end
    println(s)
    printn(s, n-1)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>n &lt;= 0</code> the <code>return</code> statement exits the function. The flow of execution immediately returns to the caller, and the remaining lines of the function don’t run.
</p>
</div>
<div class="paragraph">
<p>The rest of the function is similar to <code>countdown</code>: it displays <code>s</code> and then calls itself to display <code>s</code> \(n-1\) additional times. So the number of lines of output is \(1 + (n - 1)\), which adds up to \(n\).</p>
</div>
<div class="paragraph">
<p>For simple examples like this, it is probably easier to use a <code>for</code> loop. But we will see examples later that are hard to write with a <code>for</code> loop and easy to write with recursion, so it is good to start early.</p>
</div>
</div>
<div class="sect2">
<h3 id="_stack_diagrams_for_recursive_functions">Stack Diagrams for Recursive Functions</h3>
<div class="paragraph">
<p>In <a href="#stack_diagrams">Diagramas de Pilha</a>, we used a stack diagram to represent the state of a program during a function call. The same kind of diagram can help interpret a recursive function.
</p>
</div>
<div class="paragraph">
<p>Every time a function gets called, Julia creates a frame to contain the function’s local variables and parameters. For a recursive function, there might be more than one frame on the stack at the same time.
</p>
</div>
<div id="fig05-1" class="imageblock">
<div class="content">
<img src="images/fig51.svg" alt="fig51">
</div>
<div class="title">Figure 7. Stack diagram</div>
</div>
<div class="paragraph">
<p><a href="#fig05-1">Stack diagram</a> shows a stack diagram for <code>countdown</code> called with <code>n = 3</code>.</p>
</div>
<div class="paragraph">
<p>As usual, the top of the stack is the frame for <code>Main</code>. It is empty because we did not create any variables in <code>Main</code> or pass any arguments to it.</p>
</div>
<div class="paragraph">
<p>The four <code>countdown</code> frames have different values for the parameter <code>n</code>. The bottom of the stack, where <code>n = 0</code>, is called the <em>base case</em>. It does not make a recursive call, so there are no more frames.
</p>
</div>
<div class="sect4">
<h5 id="_exercise_5_1">Exercise 5-1</h5>
<div class="paragraph">
<p>As an exercise, draw a stack diagram for <code>printn</code> called with <code>s = "Hello"</code> and <code>n = 2</code>. Then write a function called <code>do_n</code> that takes a function object and a number, <code>n</code>, as arguments, and that calls the given function \(n\) times.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_infinite_recursion">Infinite Recursion</h3>
<div class="paragraph">
<p>If a recursion never reaches a base case, it goes on making recursive calls forever, and the program never terminates. This is known as <em>infinite recursion</em>, and it is generally not a good idea. Here is a minimal program with an infinite recursion:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function recurse()
    recurse()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>In most programming environments, a program with infinite recursion does not really run forever. Julia reports an error message when the maximum recursion depth is reached:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; recurse()
ERROR: StackOverflowError:
Stacktrace:
 [1] recurse() at ./REPL[1]:2 (repeats 80000 times)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This stacktrace is a little bigger than the one we saw in the previous chapter. When the error occurs, there are 80000 <code>recurse</code> frames on the stack!
</p>
</div>
<div class="paragraph">
<p>If you encounter an infinite recursion by accident, review your function to confirm that there is a base case that does not make a recursive call. And if there is a base case, check whether you are guaranteed to reach it.</p>
</div>
</div>
<div class="sect2">
<h3 id="_keyboard_input">Keyboard Input</h3>
<div class="paragraph">
<p>The programs we have written so far accept no input from the user. They just do the same thing every time.</p>
</div>
<div class="paragraph">
<p>Julia provides a built-in function called <code>readline</code> that stops the program and waits for the user to type something. When the user presses <code>RETURN</code> or <code>ENTER</code>, the program resumes and <code>readline</code> returns what the user typed as a string.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; text = readline()
What are you waiting for?
"What are you waiting for?"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Before getting input from the user, it is a good idea to print a prompt telling the user what to type:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; print("What...is your name? "); readline()
What...is your name? Arthur, King of the Britons!
"Arthur, King of the Britons!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>A semi-colon <code>;</code> allows to put multiple statements on the same line. In the REPL only the last statement returns its value.
</p>
</div>
<div class="paragraph">
<p>If you expect the user to type an integer, you can try to convert the return value to <code>Int64</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; println("What...is the airspeed velocity of an unladen swallow?"); speed = readline()
What...is the airspeed velocity of an unladen swallow?
42
"42"
julia&gt; parse(Int64, speed)
42</code></pre>
</div>
</div>
<div class="paragraph">
<p>But if the user types something other than a string of digits, you get an error:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; println("What...is the airspeed velocity of an unladen swallow? "); speed = readline()
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
"What do you mean, an African or a European swallow?"
julia&gt; parse(Int64, speed)
ERROR: ArgumentError: invalid base 10 digit 'W' in "What do you mean, an African or a European swallow?"
[...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will see how to handle this kind of error later.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_debugging_3">Debugging</h3>
<div class="paragraph">
<p>When a syntax or runtime error occurs, the error message contains a lot of information, but it can be overwhelming. The most useful parts are usually:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>What kind of error it was, and</p>
</li>
<li>
<p>Where it occurred.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Syntax errors are usually easy to find, but there are a few gotchas. In general, error messages indicate where the problem was discovered, but the actual error might be earlier in the code, sometimes on a previous line.</p>
</div>
<div class="paragraph">
<p>The same is true of runtime errors. Suppose you are trying to compute a signal-to-noise ratio in decibels. The formula is</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{SNR_{\mathrm{db}} = 10 \log_{10} \frac{P_{\mathrm{signal}}}{P_{\mathrm{noise}}}\ .}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>In Julia, you might write something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">signal_power = 9
noise_power = 10
ratio = signal_power ÷ noise_power
decibels = 10 * log10(ratio)
print(decibels)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And you get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">-Inf</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is not the result you expected.</p>
</div>
<div class="paragraph">
<p>To find the error, it might be useful to print the value of ratio, which turns out to be 0. The problem is in line 3, which uses floor division instead of floating-point division.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>You should take the time to read error messages carefully, but don’t assume that everything they say is correct.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_glossary_2">Glossary</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">floor division</dt>
<dd>
<p>An operator, denoted <code>÷</code>, that divides two numbers and rounds down (toward negative infinity) to an integer.
</p>
</dd>
<dt class="hdlist1">modulus operator</dt>
<dd>
<p>An operator, denoted with a percent sign (%), that works on integers and returns the remainder when one number is divided by another.
</p>
</dd>
<dt class="hdlist1">boolean expression</dt>
<dd>
<p>An expression whose value is either <code>true</code> or <code>false</code>.
</p>
</dd>
<dt class="hdlist1">relational operator</dt>
<dd>
<p>One of the operators that compares its operands: <code>==</code>, <code>≠</code> (<code>!=</code>), <code>&gt;</code>, <code>&lt;</code>, <code>≥</code> (<code>&gt;=</code>), and <code>≤</code> (<code>&lt;=</code>).
</p>
</dd>
<dt class="hdlist1">logical operator</dt>
<dd>
<p>One of the operators that combines boolean expressions: <code>&amp;&amp;</code> (and), <code>||</code> (or), and <code>!</code> (not).
</p>
</dd>
<dt class="hdlist1">conditional statement</dt>
<dd>
<p>A statement that controls the flow of execution depending on some condition.
</p>
</dd>
<dt class="hdlist1">condition</dt>
<dd>
<p>The boolean expression in a conditional statement that determines which branch runs.
</p>
</dd>
<dt class="hdlist1">compound statement</dt>
<dd>
<p>A statement that consists of a header and a body. The body is terminated with the keyword <code>end</code>.
</p>
</dd>
<dt class="hdlist1">branch</dt>
<dd>
<p>One of the alternative sequences of statements in a conditional statement.
</p>
</dd>
<dt class="hdlist1">chained conditional</dt>
<dd>
<p>A conditional statement with a series of alternative branches.
</p>
</dd>
<dt class="hdlist1">nested conditional</dt>
<dd>
<p>A conditional statement that appears in one of the branches of another conditional statement.
</p>
</dd>
<dt class="hdlist1">return statement</dt>
<dd>
<p>A statement that causes a function to end immediately and return to the caller.
</p>
</dd>
<dt class="hdlist1">recursion</dt>
<dd>
<p>The process of calling the function that is currently executing.
</p>
</dd>
<dt class="hdlist1">base case</dt>
<dd>
<p>A conditional branch in a recursive function that does not make a recursive call.
</p>
</dd>
<dt class="hdlist1">infinite recursion</dt>
<dd>
<p>A recursion that doesn’t have a base case, or never reaches it. Eventually, an infinite recursion causes a runtime error.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_3">Exercises</h3>
<div class="sect4">
<h5 id="ex05-1">Exercise 5-2</h5>
<div class="paragraph">
<p>The function <code>time</code> returns the current Greenwich Mean Time in seconds since “the epoch”, which is an arbitrary time used as a reference point. On UNIX systems, the epoch is 1 January 1970.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; time()
1.591832181539909e9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Write a script that reads the current time and converts it to a time of day in hours, minutes, and seconds, plus the number of days since the epoch.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex05-2">Exercise 5-3</h5>
<div class="paragraph">
<p>Fermat’s Last Theorem says that there are no positive integers \(a\), \(b\), and \(c\) such that
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{a^n + b^n = c^n}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>for any value of \(n\) greater than 2.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write a function named <code>checkfermat</code> that takes four parameters—<code>a</code>, <code>b</code>, <code>c</code> and <code>n</code>—and checks to see if Fermat’s theorem holds. If <code>n</code> is greater than 2 and <code>a^n + b^n == c^n</code> the program should print, “Holy smokes, Fermat was wrong!” Otherwise the program should print, “No, that doesn’t work.”
</p>
</li>
<li>
<p>Write a function that prompts the user to input values for <code>a</code>, <code>b</code>, <code>c</code> and <code>n</code>, converts them to integers, and uses <code>checkfermat</code> to check whether they violate Fermat’s theorem.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="ex05-3">Exercise 5-4</h5>
<div class="paragraph">
<p>If you are given three sticks, you may or may not be able to arrange them in a triangle. For example, if one of the sticks is 12 inches long and the other two are one inch long, you will not be able to get the short sticks to meet in the middle. For any three lengths, there is a simple test to see if it is possible to form a triangle:</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>If any of the three lengths is greater than the sum of the other two, then you cannot form a triangle. Otherwise, you can. (If the sum of two lengths equals the third, they form what is called a “degenerate” triangle.)</p>
</div>
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write a function named <code>istriangle</code> that takes three integers as arguments, and that prints either “Yes” or “No”, depending on whether you can or cannot form a triangle from sticks with the given lengths.
</p>
</li>
<li>
<p>Write a function that prompts the user to input three stick lengths, converts them to integers, and uses <code>istriangle</code> to check whether sticks with the given lengths can form a triangle.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="ex05-4">Exercise 5-5</h5>
<div class="paragraph">
<p>What is the output of the following program? Draw a stack diagram that shows the state of the program when it prints the result.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function recurse(n, s)
    if n == 0
        println(s)
    else
        recurse(n-1, n+s)
    end
end

recurse(3, 0)</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>What would happen if you called this function like this: <code>recurse(-1, 0)</code>?</p>
</li>
<li>
<p>Write a docstring that explains everything someone would need to know in order to use this function (and nothing else).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following exercises use the <code>ThinkJulia</code> module, described in <a href="#chap04">Case Study: Interface Design</a>:</p>
</div>
</div>
<div class="sect4">
<h5 id="ex05-5">Exercise 5-6</h5>
<div class="paragraph">
<p>Read the following function and see if you can figure out what it does (see the examples in <a href="#chap04">Case Study: Interface Design</a>). Then run it and see if you got it right.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function draw(t, length, n)
    if n == 0
        return
    end
    angle = 50
    forward(t, length*n)
    turn(t, -angle)
    draw(t, length, n-1)
    turn(t, 2*angle)
    draw(t, length, n-1)
    turn(t, -angle)
    forward(t, -length*n)
end</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex05-6">Exercise 5-7</h5>
<div id="fig05-2" class="imageblock">
<div class="content">
<img src="images/fig52.svg" alt="fig52">
</div>
<div class="title">Figure 8. A Koch curve</div>
</div>
<div class="paragraph">
<p>The Koch curve is a fractal that looks something like <a href="#fig05-2">A Koch curve</a>. To draw a Koch curve with length \(x\), all you have to do is
</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Draw a Koch curve with length \(\frac{x}{3}\).</p>
</li>
<li>
<p>Turn left 60 degrees.</p>
</li>
<li>
<p>Draw a Koch curve with length \(\frac{x}{3}\).</p>
</li>
<li>
<p>Turn right 120 degrees.</p>
</li>
<li>
<p>Draw a Koch curve with length \(\frac{x}{3}\).</p>
</li>
<li>
<p>Turn left 60 degrees.</p>
</li>
<li>
<p>Draw a Koch curve with length \(\frac{x}{3}\).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The exception is if \(x\) is less than 3: in that case, you can just draw a straight line with length \(x\).</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write a function called <code>koch</code> that takes a turtle and a length as parameters, and that uses the turtle to draw a Koch curve with the given length.
</p>
</li>
<li>
<p>Write a function called <code>snowflake</code> that draws three Koch curves to make the outline of a snowflake.
</p>
</li>
<li>
<p>The Koch curve can be generalized in several ways. See <a href="https://en.wikipedia.org/wiki/Koch_snowflake" class="bare">https://en.wikipedia.org/wiki/Koch_snowflake</a> for examples and implement your favorite.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap06">9. Fruitful Functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Many of the Julia functions we have used, such as the math functions, produce return values. But the functions we’ve written are all void: they have an effect, like printing a value or moving a turtle, but they return <code>nothing</code>. In this chapter you will learn to write fruitful functions.
</p>
</div>
<div class="sect2">
<h3 id="_return_values">Return Values</h3>
<div class="paragraph">
<p>Calling the function generates a return value, which we usually assign to a variable or use as part of an expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">e = exp(1.0)
height = radius * sin(radians)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The functions we have written so far are void. Speaking casually, they have no return value; more precisely, their return value is <code>nothing</code>. In this chapter, we are (finally) going to write fruitful functions. The first example is <code>area</code>, which returns the area of a circle with the given radius:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function area(radius)
    a = π * radius^2
    return a
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have seen the <code>return</code> statement before, but in a fruitful function the <code>return</code> statement includes an expression. This statement means: “Return immediately from this function and use the following expression as a return value.” The expression can be arbitrarily complicated, so we could have written this function more concisely:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function area(radius)
    π * radius^2
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the function definition.</p>
</div>
<div class="paragraph">
<p>On the other hand, <em>temporary variables</em> like <code>a</code> and explicit <code>return</code> statements can make debugging easier.
</p>
</div>
<div class="paragraph">
<p>Sometimes it is useful to have multiple <code>return</code> statements, one in each branch of a conditional:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function absvalue(x)
    if x &lt; 0
        return -x
    else
        return x
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since these return statements are in an alternative conditional, only one runs.
</p>
</div>
<div class="paragraph">
<p>As soon as a <code>return</code> statement runs, the function terminates without executing any subsequent statements. Code that appears after a <code>return</code> statement, or any other place the flow of execution can never reach, is called <em>dead code</em>.
</p>
</div>
<div class="paragraph">
<p>In a fruitful function, it is a good idea to ensure that every possible path through the program hits a return statement. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function absvalue(x)
    if x &lt; 0
        return -x
    end
    if x &gt; 0
        return x
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function is incorrect because if <code>x</code> happens to be 0, neither condition is true, and the function ends without hitting a <code>return</code> statement. If the flow of execution gets to the end of a function, the return value is <code>nothing</code>, which is not the absolute value of 0.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; show(absvalue(0))
nothing</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Julia provides a built-in function called <code>abs</code> that computes absolute values.
</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_exercise_6_1">Exercise 6-1</h5>
<div class="paragraph">
<p>Write a <code>compare</code> function takes two values, <code>x</code> and <code>y</code>, and returns <code>1</code> if <code>x &gt; y</code>, <code>0</code> if <code>x == y</code>, and <code>-1</code> if <code>x &lt; y</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="incremental_development">Incremental Development</h3>
<div class="paragraph">
<p>As you write larger functions, you might find yourself spending more time debugging.
</p>
</div>
<div class="paragraph">
<p>To deal with increasingly complex programs, you might want to try a process called <em>incremental development</em>. The goal of incremental development is to avoid long debugging sessions by adding and testing only a small amount of code at a time.
</p>
</div>
<div class="paragraph">
<p>As an example, suppose you want to find the distance between two points, given by the coordinates \(\left(x_1, y_1\right)\) and \(\left(x_2, y_2\right)\). By the Pythagorean theorem, the distance is:
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>The first step is to consider what a distance function should look like in Julia. In other words, what are the inputs (parameters) and what is the output (return value)?</p>
</div>
<div class="paragraph">
<p>In this case, the inputs are two points, which you can represent using four numbers. The return value is the distance represented by a floating-point value.</p>
</div>
<div class="paragraph">
<p>Immediately you can write an outline of the function:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function distance(x₁, y₁, x₂, y₂)
    0.0
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, this version doesn’t compute distances; it always returns zero. But it is syntactically correct, and it runs, which means that you can test it before you make it more complicated. The subscript numbers are available in the Unicode character encoding (<strong><code>\_1 TAB</code></strong>, <strong><code>\_2 TAB</code></strong>, etc.).
</p>
</div>
<div class="paragraph">
<p>To test the new function, call it with sample arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">distance(1, 2, 4, 6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>I chose these values so that the horizontal distance is 3 and the vertical distance is 4; that way, the result is 5, the hypotenuse of a 3-4-5 triangle. When testing a function, it is useful to know the right answer.</p>
</div>
<div class="paragraph">
<p>At this point we have confirmed that the function is syntactically correct, and we can start adding code to the body. A reasonable next step is to find the differences \(x_2 - x_1\) and \(y_2 - y_1\). The next version stores those values in temporary variables and prints them with the <code>@show</code> macro.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function distance(x₁, y₁, x₂, y₂)
    dx = x₂ - x₁
    dy = y₂ - y₁
    @show dx dy
    0.0
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the function is working, it should display <code>dx = 3</code> and <code>dy = 4</code>. If so, we know that the function is getting the right arguments and performing the first computation correctly. If not, there are only a few lines to check.</p>
</div>
<div class="paragraph">
<p>Next we compute the sum of squares of <code>dx</code> and <code>dy</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function distance(x₁, y₁, x₂, y₂)
    dx = x₂ - x₁
    dy = y₂ - y₁
    d² = dx^2 + dy^2
    @show d²
    0.0
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, you would run the program at this stage and check the output (which should be 25). Superscript numbers are also available (<strong><code>\^2 TAB</code></strong>). Finally, you can use <code>sqrt</code> to compute and return the result:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function distance(x₁, y₁, x₂, y₂)
    dx = x₂ - x₁
    dy = y₂ - y₁
    d² = dx^2 + dy^2
    sqrt(d²)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>If that works correctly, you are done. Otherwise, you might want to print the value of <code>sqrt(d²)</code> before the <code>return</code> statement.</p>
</div>
<div class="paragraph">
<p>The final version of the function doesn’t display anything when it runs; it only returns a value. The print statements we wrote are useful for debugging, but once you get the function working, you should remove them. Code like that is called <em>scaffolding</em> because it is helpful for building the program but is not part of the final product.
</p>
</div>
<div class="paragraph">
<p>When you start out, you should add only a line or two of code at a time. As you gain more experience, you might find yourself writing and debugging bigger chunks. Either way, incremental development can save you a lot of debugging time.</p>
</div>
<div class="paragraph">
<p>The key aspects of the process are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start with a working program and make small incremental changes. At any point, if there is an error, you should have a good idea where it is.</p>
</li>
<li>
<p>Use variables to hold intermediate values so you can display and check them.</p>
</li>
<li>
<p>Once the program is working, you might want to remove some of the scaffolding or consolidate multiple statements into compound expressions, but only if it does not make the program difficult to read.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_exercise_6_2">Exercise 6-2</h5>
<div class="paragraph">
<p>Use incremental development to write a function called <code>hypotenuse</code> that returns the length of the hypotenuse of a right triangle given the lengths of the other two legs as arguments. Record each stage of the development process as you go.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_composition">Composition</h3>
<div class="paragraph">
<p>As you should expect by now, you can call one function from within another. As an example, we’ll write a function that takes two points, the center of the circle and a point on the perimeter, and computes the area of the circle.
</p>
</div>
<div class="paragraph">
<p>Assume that the center point is stored in the variables <code>xc</code> and <code>yc</code>, and the perimeter point is in <code>xp</code> and <code>yp</code>. The first step is to find the radius of the circle, which is the distance between the two points. We just wrote a function, distance, that does that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">radius = distance(xc, yc, xp, yp)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next step is to find the area of a circle with that radius; we just wrote that, too:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">result = area(radius)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Encapsulating these steps in a function, we get:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function circlearea(xc, yc, xp, yp)
    radius = distance(xc, yc, xp, yp)
    result = area(radius)
    return result
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The temporary variables <code>radius</code> and <code>result</code> are useful for development and debugging, but once the program is working, we can make it more concise by composing the function calls:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function circlearea(xc, yc, xp, yp)
    area(distance(xc, yc, xp, yp))
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boolean_functions">Boolean Functions</h3>
<div class="paragraph">
<p>Functions can return booleans, which is often convenient for hiding complicated tests inside functions. For example:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function isdivisible(x, y)
    if x % y == 0
        return true
    else
        return false
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is common to give boolean functions names that sound like yes/no questions; <code>isdivisible</code> returns either <code>true</code> or <code>false</code> to indicate whether <code>x</code> is divisible by <code>y</code>.</p>
</div>
<div class="paragraph">
<p>Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; isdivisible(6, 4)
false
julia&gt; isdivisible(6, 3)
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result of the <code>==</code> operator is a boolean, so we can write the function more concisely by returning it directly:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function isdivisible(x, y)
    x % y == 0
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Boolean functions are often used in conditional statements:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">if isdivisible(x, y)
    println("x is divisible by y")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>It might be tempting to write something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">if isdivisible(x, y) == true
    println("x is divisible by y")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>But the extra comparison with <code>true</code> is unnecessary.</p>
</div>
<div class="sect4">
<h5 id="_exercise_6_3">Exercise 6-3</h5>
<div class="paragraph">
<p>Write a function <code>isbetween(x, y, z)</code> that returns <code>true</code> if <code>x ≤ y ≤ z</code> or <code>false</code> otherwise.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_more_recursion">More Recursion</h3>
<div class="paragraph">
<p>We have only covered a small subset of Julia, but you might be interested to know that this subset is a <em>complete</em> programming language, which means that anything that can be computed can be expressed in this language. Any program ever written could be rewritten using only the language features you have learned so far (actually, you would need a few commands to control devices like the mouse, disks, etc., but that’s all).
</p>
</div>
<div class="paragraph">
<p>Proving that claim is a nontrivial exercise first accomplished by Alan Turing, one of the first computer scientists (some would argue that he was a mathematician, but a lot of early computer scientists started as mathematicians). Accordingly, it is known as the Turing Thesis. For a more complete (and accurate) discussion of the Turing Thesis, I recommend Michael Sipser’s book <em>Introduction to the Theory of Computation</em>.
</p>
</div>
<div class="paragraph">
<p>To give you an idea of what you can do with the tools you have learned so far, we’ll evaluate a few recursively defined mathematical functions. A recursive definition is similar to a circular definition, in the sense that the definition contains a reference to the thing being defined. A truly circular definition is not very useful:
</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">vorpal</dt>
<dd>
<p>An adjective used to describe something that is vorpal.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>If you saw that definition in the dictionary, you might be annoyed. On the other hand, if you looked up the definition of the factorial function, denoted with the symbol \(!\), you might get something like this:
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{n! =
\begin{cases}
  1&amp; \textrm{if}\  n = 0 \\
  n (n-1)!&amp; \textrm{if}\  n &gt; 0
\end{cases}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>This definition says that the factorial of 0 is 1, and the factorial of any other value, \(n\), is \(n\) multiplied by the factorial of \(n-1\).</p>
</div>
<div class="paragraph">
<p>So \(3!\) is 3 times \(2!\), which is 2 times \(1!\), which is 1 times \(0!\). Putting it all together, \(3!\) equals 3 times 2 times 1 times 1, which is 6.</p>
</div>
<div class="paragraph">
<p>If you can write a recursive definition of something, you can write a Julia program to evaluate it. The first step is to decide what the parameters should be. In this case it should be clear that factorial takes an integer:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function fact(n) end</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the argument happens to be <code>0</code>, all we have to do is return <code>1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function fact(n)
    if n == 0
        return 1
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, and this is the interesting part, we have to make a recursive call to find the factorial of <code>n-1</code> and then multiply it by <code>n</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function fact(n)
    if n == 0
        return 1
    else
        recurse = fact(n-1)
        result = n * recurse
        return result
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The flow of execution for this program is similar to the flow of <code>countdown</code> in <a href="#recursion">Recursion</a>. If we call <code>fact</code> with the value <code>3</code>:
</p>
</div>
<div class="openblock small">
<div class="content">
<div class="paragraph">
<p>Since <code>3</code> is not <code>0</code>, we take the second branch and calculate the factorial of <code>n-1</code> &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;Since <code>2</code> is not <code>0</code>, we take the second branch and calculate the factorial of <code>n-1</code> &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;Since <code>1</code> is not <code>0</code>, we take the second branch and calculate the factorial of <code>n-1</code> &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;&#8193;Since <code>0</code> equals <code>0</code>, we take the first branch and return <code>1</code> without making any <br/>&#8193;&#8193;&#8193;&#8193;more recursive calls.</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;The return value, <code>1</code>, is multiplied by <code>n</code>, which is <code>1</code>, and the <code>result</code> is returned.</p>
</div>
<div class="paragraph">
<p>&#8193;The return value, <code>1</code>, is multiplied by <code>n</code>, which is <code>2</code>, and the <code>result</code> is returned.</p>
</div>
<div class="paragraph">
<p>The return value <code>2</code> is multiplied by <code>n</code>, which is <code>3</code>, and the result, <code>6</code>, becomes the return value of the function call that started the whole process.</p>
</div>
</div>
</div>
<div id="fig06-1" class="imageblock">
<div class="content">
<img src="images/fig61.svg" alt="fig61">
</div>
<div class="title">Figure 9. Stack diagram</div>
</div>
<div class="paragraph">
<p><a href="#fig06-1">Stack diagram</a> shows what the stack diagram looks like for this sequence of function calls.
</p>
</div>
<div class="paragraph">
<p>The return values are shown being passed back up the stack. In each frame, the return value is the value of <code>result</code>, which is the product of <code>n</code> and <code>recurse</code>.</p>
</div>
<div class="paragraph">
<p>In the last frame, the local variables <code>recurse</code> and <code>result</code> do not exist, because the branch that creates them does not run.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Julia provides the function <code>factorial</code> to calculate the factorial of an integer number.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_leap_of_faith">Leap of Faith</h3>
<div class="paragraph">
<p>Following the flow of execution is one way to read programs, but it can quickly become overwhelming. An alternative is what I call the “leap of faith”. When you come to a function call, instead of following the flow of execution, you <em>assume</em> that the function works correctly and returns the right result.
</p>
</div>
<div class="paragraph">
<p>In fact, you are already practicing this leap of faith when you use built-in functions. When you call <code>cos</code> or <code>exp</code>, you don’t examine the bodies of those functions. You just assume that they work because the people who wrote the built-in functions were good programmers.</p>
</div>
<div class="paragraph">
<p>The same is true when you call one of your own functions. For example, in <a href="#boolean_functions">Boolean Functions</a>, we wrote a function called <code>isdivisible</code> that determines whether one number is divisible by another. Once we have convinced ourselves that this function is correct—by examining the code and testing—we can use the function without looking at the body again.</p>
</div>
<div class="paragraph">
<p>The same is true of recursive programs. When you get to the recursive call, instead of following the flow of execution, you should assume that the recursive call works (returns the correct result) and then ask yourself, “Assuming that I can find the factorial of \(n-1\), can I compute the factorial of \(n\)?” It is clear that you can, by multiplying by \(n\).</p>
</div>
<div class="paragraph">
<p>Of course, it’s a bit strange to assume that the function works correctly when you haven’t finished writing it, but that’s why it’s called a leap of faith!</p>
</div>
</div>
<div class="sect2">
<h3 id="one_more_example">One More Example</h3>
<div class="paragraph">
<p>After factorial, the most common example of a recursively defined mathematical function is fibonacci, which has the following definition (see <a href="https://en.wikipedia.org/wiki/Fibonacci_number" class="bare">https://en.wikipedia.org/wiki/Fibonacci_number</a>):
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{fib(n) =
\begin{cases}
    0&amp; \textrm{if}\  n = 0 \\
    1&amp; \textrm{if}\  n = 1 \\
    fib(n-1) + fib(n-2)&amp; \textrm{if}\  n &gt; 1
\end{cases}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Translated into Julia, it looks like this:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function fib(n)
    if n == 0
        return 0
    elseif n == 1
        return 1
    else
        return fib(n-1) + fib(n-2)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you try to follow the flow of execution here, even for fairly small values of <code>n</code>, your head explodes. But according to the leap of faith, if you assume that the two recursive calls work correctly, then it is clear that you get the right result by adding them together.</p>
</div>
</div>
<div class="sect2">
<h3 id="_checking_types">Checking Types</h3>
<div class="paragraph">
<p>What happens if we call <code>fact</code> and give it <code>1.5</code> as an argument?
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; fact(1.5)
ERROR: StackOverflowError:
Stacktrace:
 [1] fact(::Float64) at ./REPL[3]:2</code></pre>
</div>
</div>
<div class="paragraph">
<p>It looks like an infinite recursion. How can that be? The function has a base case—when <code>n == 0</code>. But if <code>n</code> is not an integer, we can <em>miss</em> the base case and recurse forever.
</p>
</div>
<div class="paragraph">
<p>In the first recursive call, the value of <code>n</code> is <code>0.5</code>. In the next, it is <code>-0.5</code>. From there, it gets smaller (more negative), but it will never be <code>0</code>.</p>
</div>
<div class="paragraph">
<p>We have two choices. We can try to generalize the factorial function to work with floating-point numbers, or we can make <code>fact</code> check the type of its argument. The first option is called the gamma function and it’s a little beyond the scope of this book. So we’ll go for the second.
</p>
</div>
<div class="paragraph">
<p>We can use the built-in operator <code>isa</code> to verify the type of the argument. While we’re at it, we can also make sure the argument is positive:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function fact(n)
    if !(n isa Int64)
        error("Factorial is only defined for integers.")
    elseif n &lt; 0
        error("Factorial is not defined for negative integers.")
    elseif n == 0
        return 1
    else
        return n * fact(n-1)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first base case handles nonintegers; the second handles negative integers. In both cases, the program prints an error message and returns <code>nothing</code> to indicate that something went wrong:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; fact("fred")
ERROR: Factorial is only defined for integers.
julia&gt; fact(-2)
ERROR: Factorial is not defined for negative integers.</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we get past both checks, we know that <code>n</code> is positive or zero, so we can prove that the recursion terminates.</p>
</div>
<div class="paragraph">
<p>This program demonstrates a pattern sometimes called a <em>guardian</em>. The first two conditionals act as guardians, protecting the code that follows from values that might cause an error. The guardians make it possible to prove the correctness of the code.
</p>
</div>
<div class="paragraph">
<p>In <a href="#catching_exceptions">Catching Exceptions</a> we will see a more flexible alternative to printing an error message: raising an exception.</p>
</div>
</div>
<div class="sect2">
<h3 id="deb06">Debugging</h3>
<div class="paragraph">
<p>Breaking a large program into smaller functions creates natural checkpoints for debugging. If a function is not working, there are three possibilities to consider:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There is something wrong with the arguments the function is getting; a precondition is violated.
</p>
</li>
<li>
<p>There is something wrong with the function; a postcondition is violated.
</p>
</li>
<li>
<p>There is something wrong with the return value or the way it is being used.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To rule out the first possibility, you can add a print statement at the beginning of the function and display the values of the parameters (and maybe their types). Or you can write code that checks the preconditions explicitly.</p>
</div>
<div class="paragraph">
<p>If the parameters look good, add a print statement before each return statement and display the return value. If possible, check the result by hand. Consider calling the function with values that make it easy to check the result (as in <a href="#incremental_development">Incremental Development</a>).</p>
</div>
<div class="paragraph">
<p>If the function seems to be working, look at the function call to make sure the return value is being used correctly (or used at all!).</p>
</div>
<div class="paragraph">
<p>Adding print statements at the beginning and end of a function can help make the flow of execution more visible. For example, here is a version of <code>fact</code> with print statements:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function fact(n)
    space = " " ^ (4 * n)
    println(space, "factorial ", n)
    if n == 0
        println(space, "returning 1")
        return 1
    else
        recurse = fact(n-1)
        result = n * recurse
        println(space, "returning ", result)
        return result
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>space</code> is a string of space characters that controls the indentation of the output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; fact(4)
                factorial 4
            factorial 3
        factorial 2
    factorial 1
factorial 0
returning 1
    returning 1
        returning 2
            returning 6
                returning 24
24</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are confused about the flow of execution, this kind of output can be helpful. It takes some time to develop effective scaffolding, but a little bit of scaffolding can save a lot of debugging.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossary_3">Glossary</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">temporary variable</dt>
<dd>
<p>A variable used to store an intermediate value in a complex calculation.
</p>
</dd>
<dt class="hdlist1">dead code</dt>
<dd>
<p>Part of a program that can never run, often because it appears after a return statement.
</p>
</dd>
<dt class="hdlist1">incremental development</dt>
<dd>
<p>A program development plan intended to avoid debugging by adding and testing only a small amount of code at a time.
</p>
</dd>
<dt class="hdlist1">scaffolding</dt>
<dd>
<p>Code that is used during program development but is not part of the final version.
</p>
</dd>
<dt class="hdlist1">guardian</dt>
<dd>
<p>A programming pattern that uses a conditional statement to check for and handle circumstances that might cause an error.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_4">Exercises</h3>
<div class="sect4">
<h5 id="ex06-1">Exercise 6-4</h5>
<div class="paragraph">
<p>Draw a stack diagram for the following program. What does the program print?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function b(z)
    prod = a(z, z)
    println(z, " ", prod)
    prod
end

function a(x, y)
    x = x + 1
    x * y
end

function c(x, y, z)
    total = x + y + z
    square = b(total)^2
    square
end

x = 1
y = x + 1
println(c(x, y+3, x+y))</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex06-2">Exercise 6-5</h5>
<div class="paragraph">
<p>The Ackermann function, \(A(m, n)\), is defined:
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{A(m, n) =
\begin{cases}
              n+1&amp; \textrm{if}\ m = 0 \\
        A(m-1, 1)&amp; \textrm{if}\ m &gt; 0\ \textrm{and}\ n = 0 \\
A(m-1, A(m, n-1))&amp; \textrm{if}\ m &gt; 0\ \textrm{and}\ n &gt; 0.
\end{cases}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>See <a href="https://en.wikipedia.org/wiki/Ackermann_function" class="bare">https://en.wikipedia.org/wiki/Ackermann_function</a>. Write a function named <code>ack</code> that evaluates the Ackermann function. Use your function to evaluate <code>ack(3, 4)</code>, which should be 125. What happens for larger values of <code>m</code> and <code>n</code>?
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex06-3">Exercise 6-6</h5>
<div class="paragraph">
<p>A palindrome is a word that is spelled the same backward and forward, like “noon” and “redivider”. Recursively, a word is a palindrome if the first and last letters are the same and the middle is a palindrome.
</p>
</div>
<div class="paragraph">
<p>The following are functions that take a string argument and return the first, last, and middle letters:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function first(word)
    first = firstindex(word)
    word[first]
end

function last(word)
    last = lastindex(word)
    word[last]
end

function middle(word)
    first = firstindex(word)
    last = lastindex(word)
    word[nextind(word, first) : prevind(word, last)]
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>We’ll see how they work in <a href="#chap08">Strings</a></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Test these functions out. What happens if you call middle with a string with two letters? One letter? What about the empty string, which is written <code>""</code> and contains no letters?</p>
</li>
<li>
<p>Write a function called <code>ispalindrome</code> that takes a string argument and returns <code>true</code> if it is a palindrome and <code>false</code> otherwise. Remember that you can use the built-in function <code>length</code> to check the length of a string.
</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="ex06-4">Exercise 6-7</h5>
<div class="paragraph">
<p>A number, \(a\), is a power of \(b\) if it is divisible by \(b\) and \(\frac{a}{b}\) is a power of \(b\). Write a function called <code>ispower</code> that takes parameters <code>a</code> and <code>b</code> and returns <code>true</code> if <code>a</code> is a power of <code>b</code>.
</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>You will have to think about the base case.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ex06-5">Exercise 6-8</h5>
<div class="paragraph">
<p>The greatest common divisor (GCD) of \(a\) and \(b\) is the largest number that divides both of them with no remainder.</p>
</div>
<div class="paragraph">
<p>One way to find the GCD of two numbers is based on the observation that if \(r\) is the remainder when \(a\) is divided by \(b\), then <code>gcd(a, b) = gcd(b, r)</code>. As a base case, we can use <code>gcd(a, 0) = a</code>.</p>
</div>
<div class="paragraph">
<p>Write a function called <code>gcd</code> that takes parameters <code>a</code> and <code>b</code> and returns their greatest common divisor.
</p>
</div>
<div class="paragraph">
<p>Credit: This exercise is based on an example from Abelson and Sussman’s <em>Structure and Interpretation of Computer Programs</em>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap07">10. Iteration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter is about iteration, which is the ability to run a block of statements repeatedly. We saw a kind of iteration, using recursion, in <a href="#recursion">Recursion</a>. We saw another kind, using a <code>for</code> loop, in <a href="#simple_repetition">Simple Repetition</a>. In this chapter we’ll see yet another kind, using a <code>while</code> statement. But first I want to say a little more about variable assignment.
</p>
</div>
<div class="sect2">
<h3 id="_reassignment">Reassignment</h3>
<div class="paragraph">
<p>As you may have discovered, it is legal to make more than one assignment to the same variable. A new assignment makes an existing variable refer to a new value (and stop referring to the old value).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; x = 5
5
julia&gt; x = 7
7</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first time we display <code>x</code>, its value is 5; the second time, its value is 7.</p>
</div>
<div id="fig07-1" class="imageblock">
<div class="content">
<img src="images/fig71.svg" alt="fig71">
</div>
<div class="title">Figure 10. State diagram</div>
</div>
<div class="paragraph">
<p><a href="#fig07-1">State diagram</a> shows what <em>reassignment</em> looks like in a state diagram.
</p>
</div>
<div class="paragraph">
<p>At this point I want to address a common source of confusion. Because Julia uses the equal sign (<code>=</code>) for assignment, it is tempting to interpret a statement like <code>a = b</code> as a mathematical proposition of equality; that is, the claim that <code>a</code> and <code>b</code> are equal. But this interpretation is wrong.
</p>
</div>
<div class="paragraph">
<p>First, equality is a symmetric relationship and assignment is not. For example, in mathematics, if \(a=7\) then \(7=a\). But in Julia, the statement <code>a = 7</code> is legal and <code>7 = a</code> is not.</p>
</div>
<div class="paragraph">
<p>Also, in mathematics, a proposition of equality is either true or false for all time. If \(a=b\) now, then \(a\) will always equal \(b\). In Julia, an assignment statement can make two variables equal, but they don’t have to stay that way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; a = 5
5
julia&gt; b = a    # a and b are now equal
5
julia&gt; a = 3    # a and b are no longer equal
3
julia&gt; b
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>The third line changes the value of <code>a</code> but does not change the value of <code>b</code>, so they are no longer equal.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Reassigning variables is often useful, but you should use it with caution. If the values of variables change frequently, it can make the code difficult to read and debug.</p>
</div>
<div class="paragraph">
<p>It is illegal to define a function that has the same name as a previously defined variable.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_updating_variables">Updating Variables</h3>
<div class="paragraph">
<p>A common kind of reassignment is an update, where the new value of the variable depends on the old.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; x = x + 1
8</code></pre>
</div>
</div>
<div class="paragraph">
<p>This means “get the current value of <code>x</code>, add one, and then update <code>x</code> with the new value.”</p>
</div>
<div class="paragraph">
<p>If you try to update a variable that doesn’t exist, you get an error, because Julia evaluates the right side before it assigns a value to <code>x</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; y = y + 1
ERROR: UndefVarError: y not defined</code></pre>
</div>
</div>
<div class="paragraph">
<p>Before you can update a variable, you have to initialize it, usually with a simple assignment:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; y = 0
0
julia&gt; y = y + 1
1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Updating a variable by adding 1 is called an <em>increment</em>; subtracting 1 is called a <em>decrement</em>.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_code_while_code_statement">The <code>while</code> Statement</h3>
<div class="paragraph">
<p>Computers are often used to automate repetitive tasks. Repeating identical or similar tasks without making errors is something that computers do well and people do poorly. In a computer program, repetition is also called <em>iteration</em>.
</p>
</div>
<div class="paragraph">
<p>We have already seen two functions, <code>countdown</code> and <code>printn</code>, that iterate using recursion. Because iteration is so common, Julia provides language features to make it easier. One is the <code>for</code> statement we saw in <a href="#simple_repetition">Simple Repetition</a>. We’ll get back to that later.
</p>
</div>
<div class="paragraph">
<p>Another is the <code>while</code> <em>statement</em>. Here is a version of <code>countdown</code> that uses a <code>while</code> statement:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function countdown(n)
    while n &gt; 0
        print(n, " ")
        n = n - 1
    end
    println("Blastoff!")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can almost read the <code>while</code> statement as if it were English. It means, “While <code>n</code> is greater than 0, display the value of <code>n</code> and then decrement <code>n</code>. When you get to 0, display the word Blastoff!”
</p>
</div>
<div class="paragraph">
<p>More formally, here is the flow of execution for a <code>while</code> statement:
</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Determine whether the condition is true or false.</p>
</li>
<li>
<p>If false, exit the while statement and continue execution at the next statement.</p>
</li>
<li>
<p>If the condition is true, run the body and then go back to step 1.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This type of flow is called a loop because the third step loops back around to the top.
</p>
</div>
<div class="paragraph">
<p>The body of the loop should change the value of one or more variables so that the condition becomes false eventually and the loop terminates. Otherwise the loop will repeat forever, which is called an <em>infinite loop</em>. An endless source of amusement for computer scientists is the observation that the directions on shampoo bottles, “Lather, rinse, repeat”, are an infinite loop.
</p>
</div>
<div class="paragraph">
<p>In the case of <code>countdown</code>, we can prove that the loop terminates: if <code>n</code> is zero or negative, the loop never runs. Otherwise, <code>n</code> gets smaller each time through the loop, so eventually we have to get to 0.</p>
</div>
<div class="paragraph">
<p>For some other loops, it is not so easy to tell. For example:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function seq(n)
    while n != 1
        println(n)
        if n % 2 == 0        # n is even
            n = n / 2
        else                 # n is odd
            n = n*3 + 1
        end
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The condition for this loop is <code>n != 1</code>, so the loop will continue until <code>n</code> is 1, which makes the condition false.</p>
</div>
<div class="paragraph">
<p>Each time through the loop, the program outputs the value of <code>n</code> and then checks whether it is even or odd. If it is even, <code>n</code> is divided by 2. If it is odd, the value of <code>n</code> is replaced with <code>n*3 + 1</code>. For example, if the argument passed to sequence is 3, the resulting values of <code>n</code> are 3, 10, 5, 16, 8, 4, 2, 1.</p>
</div>
<div class="paragraph">
<p>Since <code>n</code> sometimes increases and sometimes decreases, there is no obvious proof that <code>n</code> will ever reach 1, or that the program terminates. For some particular values of <code>n</code>, we can prove termination. For example, if the starting value is a power of two, <code>n</code> will be even every time through the loop until it reaches 1. The previous example ends with such a sequence, starting with 16.</p>
</div>
<div class="paragraph">
<p>The hard question is whether we can prove that this program terminates for all positive values of <code>n</code>. So far, no one has been able to prove it or disprove it! (See <a href="https://en.wikipedia.org/wiki/Collatz_conjecture." class="bare">https://en.wikipedia.org/wiki/Collatz_conjecture.</a>)
</p>
</div>
<div class="sect4">
<h5 id="_exercise_7_1">Exercise 7-1</h5>
<div class="paragraph">
<p>Rewrite the function <code>printn</code> from <a href="#recursion">Recursion</a> using iteration instead of recursion.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="__code_break_code"><code>break</code></h3>
<div class="paragraph">
<p>Sometimes you don’t know it’s time to end a loop until you get half way through the body. In that case you can use the <em>break statement</em> to jump out of the loop.
</p>
</div>
<div class="paragraph">
<p>For example, suppose you want to take input from the user until they type done. You could write:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">while true
    print("&gt; ")
    line = readline()
    if line == "done"
        break
    end
    println(line)
end
println("Done!")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The loop condition is <code>true</code>, which is always true, so the loop runs until it hits the break statement.</p>
</div>
<div class="paragraph">
<p>Each time through, it prompts the user with an angle bracket. If the user types <code>done</code>, the break statement exits the loop. Otherwise the program echoes whatever the user types and goes back to the top of the loop. Here’s a sample run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>&gt; not done
not done
&gt; done
Done!</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way of writing while loops is common because you can check the condition anywhere in the loop (not just at the top) and you can express the stop condition affirmatively (“stop when this happens”) rather than negatively (“keep going until that happens”).</p>
</div>
</div>
<div class="sect2">
<h3 id="__code_continue_code"><code>continue</code></h3>
<div class="paragraph">
<p>The break statement exits the loop. When a <em>continue statement</em> is encountered inside a loop, control jumps to the beginning of the loop for the next iteration, skipping the execution of statements inside the body of the loop for the current iteration. For example:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">for i in 1:10
    if i % 3 == 0
        continue
    end
    print(i, " ")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1 2 4 5 7 8 10</pre>
</div>
</div>
<div class="paragraph">
<p>If <code>i</code> is divisible by 3, the continue statement stops the current iteration and the next iteration starts. Only the numbers in the range 1 to 10 not divisible by 3 are printed.</p>
</div>
</div>
<div class="sect2">
<h3 id="square_roots">Square Roots</h3>
<div class="paragraph">
<p>Loops are often used in programs that compute numerical results by starting with an approximate answer and iteratively improving it.</p>
</div>
<div class="paragraph">
<p>For example, one way of computing square roots is Newton’s method. Suppose that you want to know the square root of \(a\). If you start with almost any estimate, \(x\), you can compute a better estimate with the following formula:
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{y = \frac{1}{2}\left(x + \frac{a}{x}\right)}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>For example, if \(a\) is 4 and \(x\) is 3:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; a = 4
4
julia&gt; x = 3
3
julia&gt; y = (x + a/x) / 2
2.1666666666666665</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is closer to the correct answer (\(\sqrt 4 = 2\)). If we repeat the process with the new estimate, it gets even closer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; x = y
2.1666666666666665
julia&gt; y = (x + a/x) / 2
2.0064102564102564</code></pre>
</div>
</div>
<div class="paragraph">
<p>After a few more updates, the estimate is almost exact:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; x = y
2.0064102564102564
julia&gt; y = (x + a/x) / 2
2.0000102400262145
julia&gt; x = y
2.0000102400262145
julia&gt; y = (x + a/x) / 2
2.0000000000262146</code></pre>
</div>
</div>
<div class="paragraph">
<p>In general we don’t know ahead of time how many steps it takes to get to the right answer, but we know when we get there because the estimate stops changing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; x = y
2.0000000000262146
julia&gt; y = (x + a/x) / 2
2.0
julia&gt; x = y
2.0
julia&gt; y = (x + a/x) / 2
2.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>When <code>y == x</code>, we can stop. Here is a loop that starts with an initial estimate, <code>x</code>, and improves it until it stops changing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">while true
    println(x)
    y = (x + a/x) / 2
    if y == x
        break
    end
    x = y
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>For most values of a this works fine, but in general it is dangerous to test float equality. Floating-point values are only approximately right: most rational numbers, like \(\frac{1}{3}\), and irrational numbers, like \(\sqrt 2\), can’t be represented exactly with a <code>Float64</code>.</p>
</div>
<div class="paragraph">
<p>Rather than checking whether <code>x</code> and <code>y</code> are exactly equal, it is safer to use the built-in function <code>abs</code> to compute the absolute value, or magnitude, of the difference between them:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">if abs(y-x) &lt; ε
    break
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where <code>ε</code> (<strong><code>\varepsilon TAB</code></strong>) has a value like <code>0.0000001</code> that determines how close is close enough.</p>
</div>
</div>
<div class="sect2">
<h3 id="_algorithms">Algorithms</h3>
<div class="paragraph">
<p>Newton’s method is an example of an <em>algorithm</em>: it is a mechanical process for solving a category of problems (in this case, computing square roots).
</p>
</div>
<div class="paragraph">
<p>To understand what an algorithm is, it might help to start with something that is not an algorithm. When you learned to multiply single-digit numbers, you probably memorized the multiplication table. In effect, you memorized 100 specific solutions. That kind of knowledge is not algorithmic.</p>
</div>
<div class="paragraph">
<p>But if you were “lazy”, you might have learned a few tricks. For example, to find the product of \(n\) and 9, you can write \(n-1\) as the first digit and \(10-n\) as the second digit. This trick is a general solution for multiplying any single-digit number by 9. That’s an algorithm!</p>
</div>
<div class="paragraph">
<p>Similarly, the techniques you learned for addition with carrying, subtraction with borrowing, and long division are all algorithms. One of the characteristics of algorithms is that they do not require any intelligence to carry out. They are mechanical processes where each step follows from the last according to a simple set of rules.</p>
</div>
<div class="paragraph">
<p>Executing algorithms is boring, but designing them is interesting, intellectually challenging, and a central part of computer science.</p>
</div>
<div class="paragraph">
<p>Some of the things that people do naturally, without difficulty or conscious thought, are the hardest to express algorithmically. Understanding natural language is a good example. We all do it, but so far no one has been able to explain <em>how</em> we do it, at least not in the form of an algorithm.</p>
</div>
</div>
<div class="sect2">
<h3 id="_debugging_4">Debugging</h3>
<div class="paragraph">
<p>As you start writing bigger programs, you might find yourself spending more time debugging. More code means more chances to make an error and more places for bugs to hide.
</p>
</div>
<div class="paragraph">
<p>One way to cut your debugging time is “debugging by bisection”. For example, if there are 100 lines in your program and you check them one at a time, it would take 100 steps.
</p>
</div>
<div class="paragraph">
<p>Instead, try to break the problem in half. Look at the middle of the program, or near it, for an intermediate value you can check. Add a print statement (or something else that has a verifiable effect) and run the program.
</p>
</div>
<div class="paragraph">
<p>If the mid-point check is incorrect, there must be a problem in the first half of the program. If it is correct, the problem is in the second half.</p>
</div>
<div class="paragraph">
<p>Every time you perform a check like this, you halve the number of lines you have to search. After six steps (which is fewer than 100), you would be down to one or two lines of code, at least in theory.</p>
</div>
<div class="paragraph">
<p>In practice it is not always clear what the “middle of the program” is and not always possible to check it. It doesn’t make sense to count lines and find the exact midpoint. Instead, think about places in the program where there might be errors and places where it is easy to put a check. Then choose a spot where you think the chances are about the same that the bug is before or after the check.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossary_4">Glossary</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">reassignment</dt>
<dd>
<p>Assigning a new value to a variable that already exists.
</p>
</dd>
<dt class="hdlist1">update</dt>
<dd>
<p>An assignment where the new value of the variable depends on the old.
</p>
</dd>
<dt class="hdlist1">initialization</dt>
<dd>
<p>An assignment that gives an initial value to a variable that will be updated.
</p>
</dd>
<dt class="hdlist1">increment</dt>
<dd>
<p>An update that increases the value of a variable (often by one).
</p>
</dd>
<dt class="hdlist1">decrement</dt>
<dd>
<p>An update that decreases the value of a variable.
</p>
</dd>
<dt class="hdlist1">iteration</dt>
<dd>
<p>Repeated execution of a set of statements using either a recursive function call or a loop.
</p>
</dd>
<dt class="hdlist1">while statement</dt>
<dd>
<p>Statement that allows iterations controlled by a condition.
</p>
</dd>
<dt class="hdlist1">break statement</dt>
<dd>
<p>Statement allowing to jump out of a loop.
</p>
</dd>
<dt class="hdlist1">continue statement</dt>
<dd>
<p>Statement inside a loop that jumps to the beginning of the loop for the next iteration.
</p>
</dd>
<dt class="hdlist1">infinite loop</dt>
<dd>
<p>A loop in which the terminating condition is never satisfied.
</p>
</dd>
<dt class="hdlist1">algorithm</dt>
<dd>
<p>A general process for solving a category of problems.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_5">Exercises</h3>
<div class="sect4">
<h5 id="ex07-1">Exercise 7-2</h5>
<div class="paragraph">
<p>Copy the loop from <a href="#square_roots">Square Roots</a> and encapsulate it in a function called <code>mysqrt</code> that takes <code>a</code> as a parameter, chooses a reasonable value of <code>x</code>, and returns an estimate of the square root of <code>a</code>.
</p>
</div>
<div class="paragraph">
<p>To test it, write a function named <code>testsquareroot</code> that prints a table like this:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a   mysqrt             sqrt               diff
-   ------             ----               ----
1.0 1.0                1.0                0.0
2.0 1.414213562373095  1.4142135623730951 2.220446049250313e-16
3.0 1.7320508075688772 1.7320508075688772 0.0
4.0 2.0                2.0                0.0
5.0 2.23606797749979   2.23606797749979   0.0
6.0 2.449489742783178  2.449489742783178  0.0
7.0 2.6457513110645907 2.6457513110645907 0.0
8.0 2.82842712474619   2.8284271247461903 4.440892098500626e-16
9.0 3.0                3.0                0.0</pre>
</div>
</div>
<div class="paragraph">
<p>The first column is a number, <code>a</code>; the second column is the square root of a computed with <code>mysqrt</code>; the third column is the square root computed by <code>sqrt</code>; the fourth column is the absolute value of the difference between the two estimates.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex07-2">Exercise 7-3</h5>
<div class="paragraph">
<p>The built-in function <code>Meta.parse</code> takes a string and transforms it into an expression. This expression can be evaluated in Julia with the function <code>Core.eval</code>. For example:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; expr = Meta.parse("1+2*3")
:(1 + 2 * 3)
julia&gt; eval(expr)
7
julia&gt; expr = Meta.parse("sqrt(π)")
:(sqrt(π))
julia&gt; eval(expr)
1.7724538509055159</code></pre>
</div>
</div>
<div class="paragraph">
<p>Write a function called <code>evalloop</code> that iteratively prompts the user, takes the resulting input and evaluates it using <code>eval</code>, and prints the result. It should continue until the user enters <code>done</code>, and then return the value of the last expression it evaluated.</p>
</div>
<div class="paragraph">
<p></p>
</div>
</div>
<div class="sect4">
<h5 id="ex07-3">Exercise 7-4</h5>
<div class="paragraph">
<p>The mathematician Srinivasa Ramanujan found an infinite series that can be used to generate a numerical approximation of \(\frac{1}{\pi}\):</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{\frac{1}{\pi}=\frac{2\sqrt2}{9801}\sum_{k=0}^\infty\frac{(4k)!(1103+26390k)}{(k!)^4 396^{4k}}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Write a function called <code>estimatepi</code> that uses this formula to compute and return an estimate of π. It should use a while loop to compute terms of the summation until the last term is smaller than <code>1e-15</code> (which is Julia notation for \(10^{-15}\)). You can check the result by comparing it to <code>π</code>.
</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap08">11. Strings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Strings are not like integers, floats, and booleans. A string is a <em>sequence</em>, which means it is an ordered collection of other values. In this chapter you’ll see how to access the characters that make up a string, and you’ll learn about some of the string helper functions provided by Julia.
</p>
</div>
<div class="sect2">
<h3 id="characters">Characters</h3>
<div class="paragraph">
<p>English language speakers are familiar with characters such as the letters of the alphabet (A, B, C, &#8230;&#8203;), numerals, and common punctuation. These characters are standardized and mapped to integer values between 0 and 127 by the <em>ASCII standard</em> (American Standard Code for Information Interchange).
</p>
</div>
<div class="paragraph">
<p>There are, of course, many other characters used in non-English languages, including variants of the ASCII characters with accents and other modifications, related scripts such as Cyrillic and Greek, and scripts completely unrelated to ASCII and English, including Arabic, Chinese, Hebrew, Hindi, Japanese, and Korean.</p>
</div>
<div class="paragraph">
<p>The <em>Unicode standard</em> tackles the complexities of what exactly a character is, and is generally accepted as the definitive standard addressing this problem.  It provides a unique number for every character on a world-wide scale.
</p>
</div>
<div class="paragraph">
<p>A <code>Char</code> value represents a single character and is surrounded by single quotes:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)
julia&gt; '🍌'
'🍌': Unicode U+1F34C (category So: Symbol, other)
julia&gt; typeof('x')
Char</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even emojis are part of the Unicode standard. (<strong><code>\:banana: TAB</code></strong>)
</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_string_is_a_sequence">A String Is a Sequence</h3>
<div class="paragraph">
<p>A string is a sequence of characters. You can access the characters one at a time with the bracket operator:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; fruit = "banana"
"banana"
julia&gt; letter = fruit[1]
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second statement selects character number 1 from <code>fruit</code> and assigns it to <code>letter</code>.</p>
</div>
<div class="paragraph">
<p>The expression in brackets is called an <em>index</em>. The index indicates which character in the sequence you want (hence the name).
</p>
</div>
<div class="paragraph">
<p>All indexing in Julia is 1-based—the first element of any integer-indexed object is found at index 1 and the last element at index <code>end</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; fruit[end]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
<div class="paragraph">
<p>As an index you can use an expression that contains variables and operators:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; i = 1
1
julia&gt; fruit[i+1]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
julia&gt; fruit[end-1]
'n': ASCII/Unicode U+006E (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
<div class="paragraph">
<p>But the value of the index has to be an integer. Otherwise you get:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; letter = fruit[1.5]
ERROR: MethodError: no method matching getindex(::String, ::Float64)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="__code_length_code"><code>length</code></h3>
<div class="paragraph">
<p><code>length</code> is a built-in function that returns the number of characters in a string:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; fruits = "🍌 🍎 🍐"
"🍌 🍎 🍐"
julia&gt; len = length(fruits)
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get the last letter of a string, you might be tempted to try something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; last = fruits[len]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)</code></pre>
</div>
</div>
<div class="paragraph">
<p>But you might not get what you expect.</p>
</div>
<div class="paragraph">
<p>Strings are encoded using the <em>UTF-8 encoding</em>. UTF-8 is a variable-width encoding, meaning that not all characters are encoded in the same number of bytes.
</p>
</div>
<div class="paragraph">
<p>The function <code>sizeof</code> gives the number of bytes in a string:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; sizeof("🍌")
4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because an emoji is encoded in 4 bytes and string indexing is byte based, the 5th element of <code>fruits</code> is a <code>SPACE</code>.
</p>
</div>
<div class="paragraph">
<p>This means also that not every byte index into a UTF-8 string is necessarily a valid index for a character. If you index into a string at such an invalid byte index, an error is thrown:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; fruits[2]
ERROR: StringIndexError("🍌 🍎 🍐", 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the case of <code>fruits</code>, the character <code>🍌</code> is a four-byte character, so the indices 2, 3 and 4 are invalid and the next character&#8217;s index is 5; this next valid index can be computed by <code>nextind(fruits, 1)</code>, and the next index after that by <code>nextind(fruits, 5)</code> and so on.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_traversal">Traversal</h3>
<div class="paragraph">
<p>A lot of computations involve processing a string one character at a time. Often they start at the beginning, select each character in turn, do something to it, and continue until the end. This pattern of processing is called a <em>traversal</em>. One way to write a traversal is with a <code>while</code> loop:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">index = firstindex(fruits)
while index &lt;= sizeof(fruits)
    letter = fruits[index]
    println(letter)
    global index = nextind(fruits, index)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>This loop traverses the string and displays each letter on a line by itself. The loop condition is <code>index &lt;= sizeof(fruit)</code>, so when index is larger than the number of bytes in the string, the condition is <code>false</code>, and the body of the loop doesn’t run.</p>
</div>
<div class="paragraph">
<p>The function <code>firstindex</code> returns the first valid byte index. The keyword <code>global</code> before <code>index</code> indicates that we want to reassign the variable <code>index</code> defined in <code>Main</code> (see <a href="#global_variables">Global Variables</a>).
</p>
</div>
<div class="sect4">
<h5 id="_exercise_8_1">Exercise 8-1</h5>
<div class="paragraph">
<p>Write a function that takes a string as an argument and displays the letters backward, one per line.</p>
</div>
<div class="paragraph">
<p>Another way to write a traversal is with a <code>for</code> loop:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">for letter in fruits
    println(letter)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each time through the loop, the next character in the string is assigned to the variable <code>letter</code>. The loop continues until no characters are left.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use concatenation (string multiplication) and a <code>for</code> loop to generate an abecedarian series (that is, in alphabetical order). In Robert McCloskey’s book <em>Make Way for Ducklings</em>, the names of the ducklings are Jack, Kack, Lack, Mack, Nack, Ouack, Pack, and Quack. This loop outputs these names in order:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">prefixes = "JKLMNOPQ"
suffix = "ack"

for letter in prefixes
    println(letter * suffix)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack</pre>
</div>
</div>
<div class="paragraph">
<p>Of course, that’s not quite right because “Ouack” and “Quack” are misspelled.</p>
</div>
</div>
<div class="sect4">
<h5 id="_exercise_8_2">Exercise 8-2</h5>
<div class="paragraph">
<p>Modify the program to fix this error.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_string_slices">String Slices</h3>
<div class="paragraph">
<p>A segment of a string is called a <em>slice</em>. Selecting a slice is similar to selecting a character:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; str = "Julius Caesar";

julia&gt; str[1:6]
"Julius"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The operator <code>[n:m]</code> returns the part of the string from the <code>n</code>-th byte to the <code>m</code>-th byte. So the same caution is needed as for simple indexing.
</p>
</div>
<div class="paragraph">
<p>The <code>end</code> keyword can be used to indicate the last byte of the string:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; str[8:end]
"Caesar"</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the first index is greater than the second the result is an <em>empty string</em>, represented by two quotation marks:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; str[8:7]
""</code></pre>
</div>
</div>
<div class="paragraph">
<p>An empty string contains no characters and has length 0, but other than that, it is the same as any other string.</p>
</div>
<div class="sect4">
<h5 id="_exercise_8_3">Exercise 8-3</h5>
<div class="paragraph">
<p>Continuing this example, what do you think <code>str[:]</code> means? Try it and see.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_strings_are_immutable">Strings Are Immutable</h3>
<div class="paragraph">
<p>It is tempting to use the <code>[]</code> operator on the left side of an assignment, with the intention of changing a character in a string. For example:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; greeting = "Hello, world!"
"Hello, world!"
julia&gt; greeting[1] = 'J'
ERROR: MethodError: no method matching setindex!(::String, ::Char, ::Int64)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The reason for the error is that strings are <em>immutable</em>, which means you can’t change an existing string. The best you can do is create a new string that is a variation on the original:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; greeting = "J" * greeting[2:end]
"Jello, world!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example concatenates a new first letter onto a slice of greeting. It has no effect on the original string.</p>
</div>
</div>
<div class="sect2">
<h3 id="_string_interpolation">String Interpolation</h3>
<div class="paragraph">
<p>Constructing strings using concatenation can become a bit cumbersome. To reduce the need for these verbose calls to <code>string</code> or repeated multiplications, Julia allows <em>string interpolation</em> using <code>$</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; greet = "Hello"
"Hello"
julia&gt; whom = "World"
"World"
julia&gt; "$greet, $(whom)!"
"Hello, World!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is more readable and convenient than string concatenation: <code>greet * ", " * whom * "!"</code></p>
</div>
<div class="paragraph">
<p>The shortest complete expression after the <code>$</code> is taken as the expression whose value is to be interpolated into the string. Thus, you can interpolate any expression into a string using parentheses:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; "1 + 2 = $(1 + 2)"
"1 + 2 = 3"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="searching">Searching</h3>
<div class="paragraph">
<p>What does the following function do?
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function find(word, letter)
    index = firstindex(word)
    while index &lt;= sizeof(word)
        if word[index] == letter
            return index
        end
        index = nextind(word, index)
    end
    -1
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>In a sense, find is the inverse of the <code>[]</code> operator. Instead of taking an index and extracting the corresponding character, it takes a character and finds the index where that character appears. If the character is not found, the function returns -1.</p>
</div>
<div class="paragraph">
<p>This is the first example we have seen of a return statement inside a loop. If <code>word[index] == letter</code>, the function breaks out of the loop and returns immediately.</p>
</div>
<div class="paragraph">
<p>If the character doesn’t appear in the string, the program exits the loop normally and returns -1.</p>
</div>
<div class="paragraph">
<p>This pattern of computation—traversing a sequence and returning when we find what we are looking for—is called a <em>search</em>.
</p>
</div>
<div class="sect4">
<h5 id="_exercise_8_4">Exercise 8-4</h5>
<div class="paragraph">
<p>Modify <code>find</code> so that it has a third parameter, the index in <code>word</code> where it should start looking.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="looping_and_counting">Looping and Counting</h3>
<div class="paragraph">
<p>The following program counts the number of times the letter <code>a</code> appears in a string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">word = "banana"
counter = 0
for letter in word
    if letter == 'a'
        global counter = counter + 1
    end
end
println(counter)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This program demonstrates another pattern of computation called a <em>counter</em>. The variable <code>counter</code> is initialized to 0 and then incremented each time an <code>a</code> is found. When the loop exits, <code>counter</code> contains the result—the total number of <code>a</code>’s.
</p>
</div>
<div class="sect4">
<h5 id="_exercise_8_5">Exercise 8-5</h5>
<div class="paragraph">
<p>Encapsulate this code in a function named <code>count</code>, and generalize it so that it accepts the string and the letter as arguments.</p>
</div>
<div class="paragraph">
<p>Then rewrite the function so that instead of traversing the string, it uses the three-parameter version of <code>find</code> from the previous section.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_string_library">String Library</h3>
<div class="paragraph">
<p>Julia provides functions that perform a variety of useful operations on strings. For example, the function <code>uppercase</code> takes a string and returns a new string with all uppercase letters.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; uppercase("Hello, World!")
"HELLO, WORLD!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>As it turns out, there is a function named <code>findfirst</code> that is remarkably similar to the function <code>find</code> we wrote:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; findfirst("a", "banana")
2:2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Actually, the <code>findfirst</code> function is more general than our function; it can find substrings, not just characters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; findfirst("na", "banana")
3:4</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, <code>findfirst</code> starts at the beginning of the string, but the function <code>findnext</code> takes a third argument, the <code>index</code> where it should start:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; findnext("na", "banana", 4)
5:6</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_code_code_operator">The <code>∈</code> Operator</h3>
<div class="paragraph">
<p>The operator <code>∈</code> (<strong><code>\in TAB</code></strong>) is a boolean operator that takes a character and a string and returns <code>true</code> if the first appears in the second:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; 'a' ∈ "banana"    # 'a' in "banana"
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example, the following function prints all the letters from word1 that also appear in word2:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function inboth(word1, word2)
    for letter in word1
        if letter ∈ word2
            print(letter, " ")
        end
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>With well-chosen variable names, Julia sometimes reads like English. You could read this loop, “for (each) letter in (the first) word, if (the) letter is an element of (the second) word, print (the) letter.”</p>
</div>
<div class="paragraph">
<p>Here’s what you get if you compare <code>"apples"</code> and <code>"oranges"</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; inboth("apples", "oranges")
a e s</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_string_comparison">String Comparison</h3>
<div class="paragraph">
<p>The relational operators work on strings. To see if two strings are equal:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">word = "Pineapple"
if word == "banana"
    println("All right, bananas.")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Other relational operations are useful for putting words in alphabetical order:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">if word &lt; "banana"
    println("Your word, $word, comes before banana.")
elseif word &gt; "banana"
    println("Your word, $word, comes after banana.")
else
    println("All right, bananas.")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Julia does not handle uppercase and lowercase letters the same way people do. All the uppercase letters come before all the lowercase letters, so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Your word, Pineapple, comes before banana.</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>A common way to address this problem is to convert strings to a standard format, such as all lowercase, before performing the comparison.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="deb08">Debugging</h3>
<div class="paragraph">
<p>When you use indices to traverse the values in a sequence, it is tricky to get the beginning and end of the traversal right. Here is a function that is supposed to compare two words and return <code>true</code> if one of the words is the reverse of the other, but it contains two errors:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function isreverse(word1, word2)
    if length(word1) != length(word2)
        return false
    end
    i = firstindex(word1)
    j = lastindex(word2)
    while j &gt;= 0
        j = prevind(word2, j)
        if word1[i] != word2[j]
            return false
        end
        i = nextind(word1, i)
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first <code>if</code> statement checks whether the words are the same length. If not, we can return <code>false</code> immediately. Otherwise, for the rest of the function, we can assume that the words are the same length. This is an example of the guardian pattern.</p>
</div>
<div class="paragraph">
<p><code>i</code> and <code>j</code> are indices: <code>i</code> traverses <code>word1</code> forward while <code>j</code> traverses <code>word2</code> backward. If we find two letters that don’t match, we can return <code>false</code> immediately. If we get through the whole loop and all the letters match, we return <code>true</code>.</p>
</div>
<div class="paragraph">
<p>The function <code>lastindex</code> returns the last valid byte index of a string and <code>prevind</code> the previous valid index of a character.</p>
</div>
<div class="paragraph">
<p>If we test this function with the words "pots" and "stop", we expect the return value <code>true</code>, but we get <code>false</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; isreverse("pots", "stop")
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>For debugging this kind of error, my first move is to print the values of the indices:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">    while j &gt;= 0
        j = prevind(word2, j)
        @show i j
        if word1[i] != word2[j]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now when I run the program again, I get more information:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; isreverse("pots", "stop")
i = 1
j = 3
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first time through the loop, the value of <code>j</code> is 3, which has to be 4. This can be fixed by moving <code>j = prevind(word2, j)</code> to the end of the <code>while</code> loop.</p>
</div>
<div class="paragraph">
<p>If I fix that error and run the program again, I get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; isreverse("pots", "stop")
i = 1
j = 4
i = 2
j = 3
i = 3
j = 2
i = 4
j = 1
i = 5
j = 0
ERROR: BoundsError: attempt to access String
  at index [5]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This time a <code>BoundsError</code> has been thrown. The value of <code>i</code> is 5, which is out a range for the string <code>"pots"</code>.
</p>
</div>
<div class="sect4">
<h5 id="_exercise_8_6">Exercise 8-6</h5>
<div class="paragraph">
<p>Run the program on paper, changing the values of <code>i</code> and <code>j</code> during each iteration. Find and fix the second error in this function.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_glossary_5">Glossary</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">sequence</dt>
<dd>
<p>An ordered collection of values where each value is identified by an integer index.
</p>
</dd>
<dt class="hdlist1">ASCII standard</dt>
<dd>
<p>A character encoding standard for electronic communication specifying 128 characters.
</p>
</dd>
<dt class="hdlist1">Unicode standard</dt>
<dd>
<p>A computing industry standard for the consistent encoding, representation, and handling of text expressed in most of the world&#8217;s writing systems.
</p>
</dd>
<dt class="hdlist1">index</dt>
<dd>
<p>An integer value used to select an item in a sequence, such as a character in a string. In Julia indices start from 1.
</p>
</dd>
<dt class="hdlist1">UTF-8 encoding</dt>
<dd>
<p>A variable width character encoding capable of encoding all 1112064 valid code points in Unicode using one to four 8-bit bytes.
</p>
</dd>
<dt class="hdlist1">traverse</dt>
<dd>
<p>To iterate through the items in a sequence, performing a similar operation on each.
</p>
</dd>
<dt class="hdlist1">slice</dt>
<dd>
<p>A part of a string specified by a range of indices.
</p>
</dd>
<dt class="hdlist1">empty string</dt>
<dd>
<p>A string with no characters and length 0, represented by two quotation marks.
</p>
</dd>
<dt class="hdlist1">immutable</dt>
<dd>
<p>The property of a sequence whose items cannot be changed.
</p>
</dd>
<dt class="hdlist1">string interpolation</dt>
<dd>
<p>The process of evaluating a string containing one or more placeholders, yielding a result in which the placeholders are replaced with their corresponding values.
</p>
</dd>
<dt class="hdlist1">search</dt>
<dd>
<p>A pattern of traversal that stops when it finds what it is looking for.
</p>
</dd>
<dt class="hdlist1">counter</dt>
<dd>
<p>A variable used to count something, usually initialized to zero and then incremented.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_6">Exercises</h3>
<div class="sect4">
<h5 id="ex08-1">Exercise 8-7</h5>
<div class="paragraph">
<p>Read the documentation of the string functions at <a href="https://docs.julialang.org/en/v1/manual/strings/" class="bare">https://docs.julialang.org/en/v1/manual/strings/</a>. You might want to experiment with some of them to make sure you understand how they work. <code>strip</code> and <code>replace</code> are particularly useful.</p>
</div>
<div class="paragraph">
<p>The documentation uses a syntax that might be confusing. For example, in <code>search(string::AbstractString, chars::Chars, [start::Integer])</code>, the brackets indicate optional arguments. So <code>string</code> and <code>chars</code> are required, but <code>start</code> is optional.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex08-2">Exercise 8-8</h5>
<div class="paragraph">
<p>There is a built-in function called <code>count</code> that is similar to the function in <a href="#looping_and_counting">Looping and Counting</a>. Read the documentation of this function and use it to count the number of <code>a</code>’s in "banana".
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex08-3">Exercise 8-9</h5>
<div class="paragraph">
<p>A string slice can take a third index. The first specifies the start, the third the end and the second the “step size”; that is, the number of spaces between successive characters. A step size of 2 means every other character; 3 means every third, etc.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; fruit = "banana"
"banana"
julia&gt; fruit[1:2:6]
"bnn"</code></pre>
</div>
</div>
<div class="paragraph">
<p>A step size of -1 goes through the word backwards, so the slice <code>[end:-1:1]</code> generates a reversed string.</p>
</div>
<div class="paragraph">
<p>Use this idiom to write a one-line version of <code>ispalindrome</code> from <a href="#ex06-3">Exercise 6-6</a>.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex08-4">Exercise 8-10</h5>
<div class="paragraph">
<p>The following functions are all <em>intended</em> to check whether a string contains any lowercase letters, but at least some of them are wrong. For each function, describe what the function actually does (assuming that the parameter is a string).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function anylowercase1(s)
    for c in s
        if islowercase(c)
            return true
        else
            return false
        end
    end
end

function anylowercase2(s)
    for c in s
        if islowercase('c')
            return "true"
        else
            return "false"
        end
    end
end

function anylowercase3(s)
    for c in s
        flag = islowercase(c)
    end
    flag
end

function anylowercase4(s)
    flag = false
    for c in s
        flag = flag || islowercase(c)
    end
    flag
end

function anylowercase5(s)
    for c in s
        if !islowercase(c)
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex08-5">Exercise 8-11</h5>
<div class="paragraph">
<p>A Caesar cypher is a weak form of encryption that involves “rotating” each letter by a fixed number of places. To rotate a letter means to shift it through the alphabet, wrapping around to the beginning if necessary, so <code>’A’</code> rotated by 3 is <code>’D’</code> and <code>’Z’</code> rotated by 1 is <code>’A’</code>.
</p>
</div>
<div class="paragraph">
<p>To rotate a word, rotate each letter by the same amount. For example, <code>"cheer"</code> rotated by 7 is <code>"jolly"</code> and <code>"melon"</code> rotated by -10 is <code>"cubed"</code>. In the movie <em>2001: A Space Odyssey, the ship computer</em> is called HAL, which is IBM rotated by -1.</p>
</div>
<div class="paragraph">
<p>Write a function called <code>rotateword</code> that takes a string and an integer as parameters, and returns a new string that contains the letters from the original string rotated by the given amount.
</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>You might want to use the built-in function <code>Int</code>, which converts a character to a numeric code, and <code>Char</code>, which converts numeric codes to characters. Letters of the alphabet are encoded in alphabetical order, so for example:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; Int('c') - Int('a')
2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because <code><em>c</em></code> is the third letter of the alphabet. But beware: the numeric codes for uppercase letters are different.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; Char(Int('A') + 32)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Potentially offensive jokes on the Internet are sometimes encoded in ROT13, which is a Caesar cypher with rotation 13. If you are not easily offended, find and decode some of them.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap09">12. Case Study: Word Play</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter presents the second case study, which involves solving word puzzles by searching for words that have certain properties. For example, we’ll find the longest palindromes in English and search for words whose letters appear in alphabetical order. And I will present another program development plan: reduction to a previously solved problem.</p>
</div>
<div class="sect2">
<h3 id="reading_word_lists">Reading Word Lists</h3>
<div class="paragraph">
<p>For the exercises in this chapter we need a list of English words. There are lots of word lists available on the Web, but the one most suitable for our purpose is one of the word lists collected and contributed to the public domain by Grady Ward as part of the Moby lexicon project (see <a href="https://wikipedia.org/wiki/Moby_Project" class="bare">https://wikipedia.org/wiki/Moby_Project</a>). It is a list of 113809 official crosswords; that is, words that are considered valid in crossword puzzles and other word games. In the Moby collection, the filename is <em>113809of.fic</em>; you can download a copy, with the simpler name <em>words.txt</em>, from <a href="https://github.com/BenLauwens/ThinkJulia.jl/blob/master/data/words.txt" class="bare">https://github.com/BenLauwens/ThinkJulia.jl/blob/master/data/words.txt</a>.
</p>
</div>
<div class="paragraph">
<p>This file is in plain text, so you can open it with a text editor, but you can also read it from Julia. The built-in function <code>open</code> takes the name of the file as a parameter and returns a <em>file stream</em> you can use to read the file.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; fin = open("words.txt")
IOStream(&lt;file words.txt&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>fin</code> is a file stream used for input and when it is no longer needed, it has to be closed with <code>close(fin)</code>.</p>
</div>
<div class="paragraph">
<p>Julia provides several function for reading, including <code>readline</code>, which reads characters from the file until it gets to a <code>NEWLINE</code> and returns the result as a string:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; readline(fin)
"aa"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first word in this particular list is “aa”, which is a kind of lava.</p>
</div>
<div class="paragraph">
<p>The file stream keeps track of where it is in the file, so if you call readline again, you get the next word:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; readline(fin)
"aah"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next word is “aah”, which is a perfectly legitimate word, so stop looking at me like that.</p>
</div>
<div class="paragraph">
<p>You can also use a file as part of a <code>for</code> loop. This program reads <code>words.txt</code> and prints each word, one per line:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">for line in eachline("words.txt")
    println(line)
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_7">Exercises</h3>
<div class="sect4">
<h5 id="ex09-1">Exercise 9-1</h5>
<div class="paragraph">
<p>Write a program that reads <code>words.txt</code> and prints only the words with more than 20 characters (not counting whitespace).</p>
</div>
</div>
<div class="sect4">
<h5 id="ex09-2">Exercise 9-2</h5>
<div class="paragraph">
<p>In 1939 Ernest Vincent Wright published a 50,000 word novel called Gadsby that does not contain the letter <code><em>e</em></code>. Since <code><em>e</em></code> is the most common letter in English, that’s not easy to do.
</p>
</div>
<div class="paragraph">
<p>In fact, it is difficult to construct a solitary thought without using that most common symbol. It is slow going at first, but with caution and hours of training you can gradually gain facility.</p>
</div>
<div class="paragraph">
<p>All right, I’ll stop now.</p>
</div>
<div class="paragraph">
<p>Write a function called <code>hasno_e</code> that returns <code>true</code> if the given word doesn’t have the letter <code><em>e</em></code> in it.
</p>
</div>
<div class="paragraph">
<p>Modify your program from the previous section to print only the words that have no <code><em>e</em></code> and compute the percentage of the words in the list that have no <code><em>e</em></code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex09-3">Exercise 9-3</h5>
<div class="paragraph">
<p>Write a function named <code>avoids</code> that takes a word and a string of forbidden letters, and that returns <code>true</code> if the word doesn’t use any of the forbidden letters.
</p>
</div>
<div class="paragraph">
<p>Modify your program to prompt the user to enter a string of forbidden letters and then print the number of words that don’t contain any of them. Can you find a combination of 5 forbidden letters that excludes the smallest number of words?</p>
</div>
</div>
<div class="sect4">
<h5 id="ex09-4">Exercise 9-4</h5>
<div class="paragraph">
<p>Write a function named <code>usesonly</code> that takes a word and a string of letters, and that returns <code>true</code> if the word contains only letters in the list. Can you make a sentence using only the letters <code>acefhlo</code>? Other than <code>"Hoe alfalfa?"</code>
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex09-5">Exercise 9-5</h5>
<div class="paragraph">
<p>Write a function named <code>usesall</code> that takes a word and a string of required letters, and that returns <code>true</code> if the word uses all the required letters at least once. How many words are there that use all the vowels <code>aeiou</code>? How about <code>aeiouy</code>?
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex09-6">Exercise 9-6</h5>
<div class="paragraph">
<p>Write a function called <code>isabecedarian</code> that returns <code>true</code> if the letters in a word appear in alphabetical order (double letters are ok). How many abecedarian words are there?
</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search">Search</h3>
<div class="paragraph">
<p>All of the exercises in the previous section have something in common; they can be solved with the search pattern. The simplest example is:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function hasno_e(word)
    for letter in word
        if letter == 'e'
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>for</code> loop traverses the characters in word. If we find the letter <code><em>e</em></code>, we can immediately return <code>false</code>; otherwise we have to go to the next letter. If we exit the loop normally, that means we didn’t find an <code><em>e</em></code>, so we return <code>true</code>.</p>
</div>
<div class="paragraph">
<p>You could write this function more concisely using the <code>∉</code> (<strong><code>\notin TAB</code></strong>) operator, but I started with this version because it demonstrates the logic of the search pattern.
</p>
</div>
<div class="paragraph">
<p><code>avoids</code> is a more general version of <code>hasno_e</code> but it has the same structure:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function avoids(word, forbidden)
    for letter in word
        if letter ∈ forbidden
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can return <code>false</code> as soon as we find a forbidden letter; if we get to the end of the loop, we return <code>true</code>.</p>
</div>
<div class="paragraph">
<p><code>usesonly</code> is similar except that the sense of the condition is reversed:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function usesonly(word, available)
    for letter in word
        if letter ∉ available
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of an array of forbidden letters, we have an array of available letters. If we find a letter in <code>word</code> that is not in <code>available</code>, we can return <code>false</code>.</p>
</div>
<div class="paragraph">
<p><code>usesall</code> is similar except that we reverse the role of the word and the string of letters:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function usesall(word, required)
    for letter in required
        if letter ∉ word
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of traversing the letters in word, the loop traverses the required letters. If any of the required letters do not appear in the word, we can return <code>false</code>.</p>
</div>
<div class="paragraph">
<p>If you were really thinking like a computer scientist, you would have recognized that <code>usesall</code> was an instance of a previously solved problem, and you would have written:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function usesall(word, required)
    usesonly(required, word)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is an example of a program development plan called <em>reduction to a previously solved problem</em>, which means that you recognize the problem you are working on as an instance of a solved problem and apply an existing solution.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_looping_with_indices">Looping with Indices</h3>
<div class="paragraph">
<p>I wrote the functions in the previous section with <code>for</code> loops because I only needed the characters in the strings; I didn’t have to do anything with the indices.</p>
</div>
<div class="paragraph">
<p>For <code>isabecedarian</code> we have to compare adjacent letters, which is a little tricky with a <code>for</code> loop:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function isabecedarian(word)
    i = firstindex(word)
    previous = word[i]
    j = nextind(word, i)
    for c in word[j:end]
        if c &lt; previous
            return false
        end
        previous = c
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>An alternative is to use recursion:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function isabecedarian(word)
    if length(word) &lt;= 1
        return true
    end
    i = firstindex(word)
    j = nextind(word, i)
    if word[i] &gt; word[j]
        return false
    end
    isabecedarian(word[j:end])
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another option is to use a <code>while</code> loop:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function isabecedarian(word)
    i = firstindex(word)
    j = nextind(word, 1)
    while j &lt;= sizeof(word)
        if word[j] &lt; word[i]
            return false
        end
        i = j
        j = nextind(word, i)
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The loop starts at <code>i=1</code> and <code>j=nextind(word, 1)</code> and ends when <code>j&gt;sizeof(word)</code>. Each time through the loop, it compares the <code>i</code>th character (which you can think of as the current character) to the <code>j</code>th character (which you can think of as the next).</p>
</div>
<div class="paragraph">
<p>If the next character is less than (alphabetically before) the current one, then we have discovered a break in the abecedarian trend, and we return <code>false</code>.</p>
</div>
<div class="paragraph">
<p>If we get to the end of the loop without finding a fault, then the word passes the test. To convince yourself that the loop ends correctly, consider an example like <code>"flossy"</code>.</p>
</div>
<div class="paragraph">
<p>Here is a version of <code>ispalindrome</code> that uses two indices; one starts at the beginning and goes up; the other starts at the end and goes down.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function ispalindrome(word)
    i = firstindex(word)
    j = lastindex(word)
    while i&lt;j
        if word[i] != word[j]
            return false
        end
        i = nextind(word, i)
        j = prevind(word, j)
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or we could reduce to a previously solved problem and write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function ispalindrome(word)
    isreverse(word, word)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>isreverse</code> from <a href="#deb08">Debugging</a>.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_debugging_5">Debugging</h3>
<div class="paragraph">
<p>Testing programs is hard. The functions in this chapter are relatively easy to test because you can check the results by hand. Even so, it is somewhere between difficult and impossible to choose a set of words that test for all possible errors.
</p>
</div>
<div class="paragraph">
<p>Taking <code>hasno_e</code> as an example, there are two obvious cases to check: words that have an <code><em>e</em></code> should return <code>false</code>, and words that don’t should return <code>true</code>. You should have no trouble coming up with one of each.</p>
</div>
<div class="paragraph">
<p>Within each case, there are some less obvious subcases. Among the words that have an “e”, you should test words with an “e” at the beginning, the end, and somewhere in the middle. You should test long words, short words, and very short words, like the empty string. The empty string is an example of a <em>special case</em>, which is one of the non-obvious cases where errors often lurk.
</p>
</div>
<div class="paragraph">
<p>In addition to the test cases you generate, you can also test your program with a word list like <code>words.txt</code>. By scanning the output, you might be able to catch errors, but be careful: you might catch one kind of error (words that should not be included, but are) and not another (words that should be included, but aren’t).</p>
</div>
<div class="paragraph">
<p>In general, testing can help you find bugs, but it is not easy to generate a good set of test cases, and even if you do, you can’t be sure your program is correct. According to a legendary computer scientist:
</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Program testing can be used to show the presence of bugs, but never to show their absence!</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Edsger W. Dijkstra
</div>
</div>
</div>
<div class="sect2">
<h3 id="_glossary_6">Glossary</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">file stream</dt>
<dd>
<p>A value that represents an open file.
</p>
</dd>
<dt class="hdlist1">reduction to a previously solved problem</dt>
<dd>
<p>A way of solving a problem by expressing it as an instance of a previously solved problem.
</p>
</dd>
<dt class="hdlist1">special case</dt>
<dd>
<p>A test case that is atypical or non-obvious (and less likely to be handled correctly).
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_8">Exercises</h3>
<div class="sect4">
<h5 id="ex09-7">Exercise 9-7</h5>
<div class="paragraph">
<p>This question is based on a Puzzler that was broadcast on the radio program <em>Car Talk</em> (<a href="https://www.cartalk.com/puzzler/browse" class="bare">https://www.cartalk.com/puzzler/browse</a>):
</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Give me a word with three consecutive double letters. I’ll give you a couple of words that almost qualify, but don’t. For example, the word committee, c-o-m-m-i-t-t-e-e. It would be great except for the <em>i</em> that sneaks in there. Or Mississippi: M-i-s-s-i-s-s-i-p-p-i. If you could take out those i’s it would work. But there is a word that has three consecutive pairs of letters and to the best of my knowledge this may be the only word. Of course there are probably 500 more but I can only think of one. What is the word?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Write a program to find it.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex09-8">Exercise 9-8</h5>
<div class="paragraph">
<p>Here’s another <em>Car Talk</em> Puzzler (<a href="https://www.cartalk.com/puzzler/browse" class="bare">https://www.cartalk.com/puzzler/browse</a>):</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>I was driving on the highway the other day and I happened to notice my odometer. Like most odometers, it shows six digits, in whole miles only. So, if my car had 300000 miles, for example, I’d see 3-0-0-0-0-0.</p>
</div>
<div class="paragraph">
<p>Now, what I saw that day was very interesting. I noticed that the last 4 digits were palindromic; that is, they read the same forward as backward. For example, 5-4-4-5 is a palindrome, so my odometer could have read 3-1-5-4-4-5.</p>
</div>
<div class="paragraph">
<p>One mile later, the last 5 numbers were palindromic. For example, it could have read 3-6-5-4-5-6. One mile after that, the middle 4 out of 6 numbers were palindromic. And you ready for this? One mile later, all 6 were palindromic!</p>
</div>
<div class="paragraph">
<p>The question is, what was on the odometer when I first looked?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Write a Julia program that tests all the six-digit numbers and prints any numbers that satisfy these requirements.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex09-9">Exercise 9-9</h5>
<div class="paragraph">
<p>Here’s another <em>Car Talk</em> Puzzler you can solve with a search (<a href="https://www.cartalk.com/puzzler/browse" class="bare">https://www.cartalk.com/puzzler/browse</a>):</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Recently I had a visit with my mom and we realized that the two digits that make up my age when reversed resulted in her age. For example, if she’s 73, I’m 37. We wondered how often this has happened over the years but we got sidetracked with other topics and we never came up with an answer.</p>
</div>
<div class="paragraph">
<p>When I got home I figured out that the digits of our ages have been reversible six times so far. I also figured out that if we’re lucky it would happen again in a few years, and if we’re really lucky it would happen one more time after that. In other words, it would have happened 8 times over all. So the question is, how old am I now?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Write a Julia program that searches for solutions to this Puzzler.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>You might find the function <code>lpad</code> useful.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap10">13. Arrays</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter presents one of Julia’s most useful built-in types, arrays. You will also learn about objects and what can happen when you have more than one name for the same object.</p>
</div>
<div class="sect2">
<h3 id="_an_array_is_a_sequence">An Array is a Sequence</h3>
<div class="paragraph">
<p>Like a string, an <em>array</em> is a sequence of values. In a string, the values are characters; in an array, they can be any type. The values in an array are called <em>elements</em> or sometimes <em>items</em>.
</p>
</div>
<div class="paragraph">
<p>There are several ways to create a new array; the simplest is to enclose the elements in square brackets (<code>[ ]</code>):
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">[10, 20, 30, 40]
["crunchy frog", "ram bladder", "lark vomit"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first example is an array of four integers. The second is an array of three strings. The elements of an array don’t have to be the same type. The following array contains a string, a float, an integer, and another array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">["spam", 2.0, 5, [10, 20]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>An array within another array is <em>nested</em>.
</p>
</div>
<div class="paragraph">
<p>An array that contains no elements is called an empty array; you can create one with empty brackets, <code>[]</code>.
</p>
</div>
<div class="paragraph">
<p>As you might expect, you can assign array values to variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; cheeses = ["Cheddar", "Edam", "Gouda"];

julia&gt; numbers = [42, 123];

julia&gt; empty = [];

julia&gt; print(cheeses, " ", numbers, " ", empty)
["Cheddar", "Edam", "Gouda"] [42, 123] Any[]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function <code>typeof</code> can be used to find out the kind of the array:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; typeof(cheeses)
Array{String,1}
julia&gt; typeof(numbers)
Array{Int64,1}
julia&gt; typeof(empty)
Array{Any,1}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The kind of the array is specified between curly braces and is composed of a type and a number. The number indicates the dimensions. The array <code>empty</code> contains values of type <code>Any</code>., i.e. it can hold values of all types.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_arrays_are_mutable">Arrays Are Mutable</h3>
<div class="paragraph">
<p>The syntax for accessing the elements of an array is the same as for accessing the characters of a string—the bracket operator. The expression inside the brackets specifies the index. Remember that the indices start at 1:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; cheeses[1]
"Cheddar"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike strings, arrays are <em>mutable</em>. When the bracket operator appears on the left side of an assignment, it identifies the element of the array that will be assigned:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; numbers[2] = 5
5
julia&gt; print(numbers)
[42, 5]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second element of <code>numbers</code>, which used to be 123, is now 5.</p>
</div>
<div class="paragraph">
<p><a href="#fig10-1">State diagram</a> shows the state diagrams for <code>cheeses</code>, <code>numbers</code> and <code>empty</code>.
</p>
</div>
<div id="fig10-1" class="imageblock">
<div class="content">
<img src="images/fig101.svg" alt="fig101">
</div>
<div class="title">Figure 11. State diagram</div>
</div>
<div class="paragraph">
<p>Arrays are represented by boxes and the elements of the array inside. <code>cheeses</code> refers to an array with three elements indexed <code>1</code>, <code>2</code> and <code>3</code>. <code>numbers</code> contains two elements; the diagram shows that the value of the second element has been reassigned from <code>123</code> to <code>5</code>. <code>empty</code> refers to an array with no elements.</p>
</div>
<div class="paragraph">
<p>Array indices work the same way as string indices (but without UTF-8 caveats):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Any integer expression can be used as an index.</p>
</li>
<li>
<p>If you try to read or write an element that does not exist, you get a <code>BoundsError</code>.</p>
</li>
<li>
<p>The keyword <code>end</code> points to the last index of the array.
</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>∈</code> operator also works on arrays:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; "Edam" ∈ cheeses
true
julia&gt; "Brie" in cheeses
false</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_traversing_an_array">Traversing an Array</h3>
<div class="paragraph">
<p>The most common way to traverse the elements of an array is with a <code>for</code> loop. The syntax is the same as for strings:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">for cheese in cheeses
    println(cheese)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works well if you only need to read the elements of the array. But if you want to write or update the elements, you need the indices. A common way to do that is to use the built-in function <code>eachindex</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">for i in eachindex(numbers)
    numbers[i] = numbers[i] * 2
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>This loop traverses the array and updates each element. <code>length</code> returns the number of elements in the array. Each time through the loop <code>i</code> gets the index of the next element. The assignment statement in the body uses <code>i</code> to read the old value of the element and to assign the new value.</p>
</div>
<div class="paragraph">
<p>A <code>for</code> loop over an empty array never runs the body:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">for x in []
    println("This can never happens.")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although an array can contain another array, the nested array still counts as a single element. The length of this array is four:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">["spam", 1, ["Brie", "Roquefort", "Camembert"], [1, 2, 3]]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_array_slices">Array Slices</h3>
<div class="paragraph">
<p>The slice operator also works on arrays:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = ['a', 'b', 'c', 'd', 'e', 'f'];

julia&gt; print(t[1:3])
['a', 'b', 'c']
julia&gt; print(t[3:end])
['c', 'd', 'e', 'f']</code></pre>
</div>
</div>
<div class="paragraph">
<p>The slice operator <code>[:]</code>, makes a copy of the whole array:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; print(t[:])
['a', 'b', 'c', 'd', 'e', 'f']</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since arrays are mutable, it is often useful to make a copy before performing operations that modify arrays.</p>
</div>
<div class="paragraph">
<p>A slice operator on the left side of an assignment can update multiple elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t[2:3] = ['x', 'y'];

julia&gt; print(t)
['a', 'x', 'y', 'd', 'e', 'f']</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_array_library">Array Library</h3>
<div class="paragraph">
<p>Julia provides functions that operate on arrays. For example, <code>push!</code> adds a new element to the end of an array:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; push!(t, 'd');

julia&gt; print(t)
['a', 'b', 'c', 'd']</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>append!</code> add the elements of the second array to the end of the first:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t1 = ['a', 'b', 'c'];

julia&gt; t2 = ['d', 'e'];

julia&gt; append!(t1, t2);

julia&gt; print(t1)
['a', 'b', 'c', 'd', 'e']</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example leaves <code>t2</code> unmodified.</p>
</div>
<div class="paragraph">
<p><code>sort!</code> arranges the elements of the array from low to high:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = ['d', 'c', 'e', 'b', 'a'];

julia&gt; sort!(t);

julia&gt; print(t)
['a', 'b', 'c', 'd', 'e']</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>sort</code> returns a copy of the elements of the array in order:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t1 = ['d', 'c', 'e', 'b', 'a'];

julia&gt; t2 = sort(t1);

julia&gt; print(t1)
['d', 'c', 'e', 'b', 'a']
julia&gt; print(t2)
['a', 'b', 'c', 'd', 'e']</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>As a style convention in Julia, <code>!</code> is appended to names of functions that modify their arguments.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_map_filter_and_reduce">Map, Filter and Reduce</h3>
<div class="paragraph">
<p>To add up all the numbers in an array, you can use a loop like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function addall(t)
    total = 0
    for x in t
        total += x
    end
    total
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>total</code> is initialized to 0. Each time through the loop, <code>+=</code> gets one element from the array. The <code>+=</code> operator provides a short way to update a variable. This <em>augmented assignment statement</em>,
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">total += x</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">total = total + x</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the loop runs, <code>total</code> accumulates the sum of the elements; a variable used this way is sometimes called an <em>accumulator</em>.
</p>
</div>
<div class="paragraph">
<p>Adding up the elements of an array is such a common operation that Julia provides it as a built-in function, <code>sum</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = [1, 2, 3, 4];

julia&gt; sum(t)
10</code></pre>
</div>
</div>
<div class="paragraph">
<p>An operation like this that combines a sequence of elements into a single value is sometimes called a <em>reduce operation</em>.
</p>
</div>
<div class="paragraph">
<p>Often you want to traverse one array while building another. For example, the following function takes an array of strings and returns a new array that contains capitalized strings:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function capitalizeall(t)
    res = []
    for s in t
        push!(res, uppercase(s))
    end
    res
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>res</code> is initialized with an empty array; each time through the loop, we append the next element. So <code>res</code> is another kind of accumulator.</p>
</div>
<div class="paragraph">
<p>An operation like <code>capitalizeall</code> is sometimes called a <em>map</em> because it “maps” a function (in this case <code>uppercase</code>) onto each of the elements in a sequence.
</p>
</div>
<div class="paragraph">
<p>Another common operation is to select some of the elements from an array and return a subarray. For example, the following function takes an array of strings and returns an array that contains only the uppercase strings:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function onlyupper(t)
    res = []
    for s in t
        if s == uppercase(s)
            push!(res, s)
        end
    end
    res
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>An operation like <code>onlyupper</code> is called a <em>filter</em> because it selects some of the elements and filters out the others.
</p>
</div>
<div class="paragraph">
<p>Most common array operations can be expressed as a combination of map, filter and reduce.</p>
</div>
</div>
<div class="sect2">
<h3 id="_dot_syntax">Dot Syntax</h3>
<div class="paragraph">
<p>For every binary operator like <code>^</code>, there is a corresponding <em>dot operator</em> <code>.^</code> that is automatically defined to perform <code>^</code> element-by-element on arrays. For example, <code>&#91;1, 2, 3&#93; ^ 3</code> is not defined, but <code>&#91;1, 2, 3&#93; .^ 3</code> is defined as computing the elementwise result <code>&#91;1^3, 2^3, 3^3&#93;</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; print([1, 2, 3] .^ 3)
[1, 8, 27]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any Julia function <code>f</code> can be applied elementwise to any array with the <em>dot syntax</em>. For example to capitalize an array of strings, we don&#8217;t need an explicit loop:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = uppercase.(["abc", "def", "ghi"]);

julia&gt; print(t)
["ABC", "DEF", "GHI"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is an elegant way to create a map. The function <code>capitalizeall</code> can be implemented by a one-liner:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function capitalizeall(t)
    uppercase.(t)
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_deleting_inserting_elements">Deleting (Inserting) Elements</h3>
<div class="paragraph">
<p>There are several ways to delete elements from an array. If you know the index of the element you want, you can use <code>splice!</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; splice!(t, 2)
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)
julia&gt; print(t)
['a', 'c']</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>splice!</code> modifies the array and returns the element that was removed.</p>
</div>
<div class="paragraph">
<p><code>pop!</code> deletes and returns the last element:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; pop!(t)
'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)
julia&gt; print(t)
['a', 'b']</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>popfirst!</code> deletes and returns the first element:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; popfirst!(t)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
julia&gt; print(t)
['b', 'c']</code></pre>
</div>
</div>
<div class="paragraph">
<p>The functions <code>pushfirst!</code> and <code>push!</code> insert an element at the beginning, respectively at the end of the array.
</p>
</div>
<div class="paragraph">
<p>If you don’t need the removed value, you can use the function <code>deleteat!</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; print(deleteat!(t, 2))
['a', 'c']</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function <code>insert!</code> inserts an element at a given index:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; print(insert!(t, 2, 'x'))
['a', 'x', 'b', 'c']</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_arrays_and_strings">Arrays and Strings</h3>
<div class="paragraph">
<p>A string is a sequence of characters and an array is a sequence of values, but an array of characters is not the same as a string. To convert from a string to an array of characters, you can use the function <code>collect</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = collect("spam");

julia&gt; print(t)
['s', 'p', 'a', 'm']</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>collect</code> function breaks a string or another sequence into individual elements.</p>
</div>
<div class="paragraph">
<p>If you want to break a string into words, you can use the <code>split</code> function:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = split("pining for the fjords");

julia&gt; print(t)
SubString{String}["pining", "for", "the", "fjords"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>An <em>optional argument</em> called a <em>delimiter</em> specifies which characters to use as word boundaries. The following example uses a hyphen as a delimiter:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = split("spam-spam-spam", '-');

julia&gt; print(t)
SubString{String}["spam", "spam", "spam"]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>join</code> is the inverse of <code>split</code>. It takes an array of strings and concatenates the elements:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = ["pining", "for", "the", "fjords"];

julia&gt; s = join(t, ' ')
"pining for the fjords"</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the delimiter is a space character. To concatenate strings without spaces, you don&#8217;t specify a delimiter.</p>
</div>
</div>
<div class="sect2">
<h3 id="_objects_and_values">Objects and Values</h3>
<div class="paragraph">
<p>An <em>object</em> is something a variable can refer to. Until now, you could use “object” and “value” interchangeably.
</p>
</div>
<div class="paragraph">
<p>If we run these assignment statements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">a = "banana"
b = "banana"</code></pre>
</div>
</div>
<div class="paragraph">
<p>We know that <code>a</code> and <code>b</code> both refer to a string, but we don’t know whether they refer to the <em>same</em> string. There are two possible states, shown in Figure 10-2.
</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/fig102.svg" alt="fig102">
</div>
<div class="title">Figure 12. State diagrams.</div>
</div>
<div class="paragraph">
<p>In one case, <code>a</code> and <code>b</code> refer to two different objects that have the same value. In the second case, they refer to the same object.</p>
</div>
<div class="paragraph">
<p>To check whether two variables refer to the same object, you can use the <code>≡</code> (<strong><code>\equiv TAB</code></strong>) or <code>===</code> operator.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; a = "banana"
"banana"
julia&gt; b = "banana"
"banana"
julia&gt; a ≡ b
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, Julia only created one string object, and both <code>a</code> and <code>b</code> refer to it. But when you create two arrays, you get two objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; a = [1, 2, 3];

julia&gt; b = [1, 2, 3];

julia&gt; a ≡ b
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>So the state diagram looks like <a href="#fig10-3">State diagram</a>.
</p>
</div>
<div id="fig10-3" class="imageblock">
<div class="content">
<img src="images/fig103.svg" alt="fig103">
</div>
<div class="title">Figure 13. State diagram</div>
</div>
<div class="paragraph">
<p>In this case we would say that the two arrays are <em>equivalent</em>, because they have the same elements, but not <em>identical</em>, because they are not the same object. If two objects are identical, they are also equivalent, but if they are equivalent, they are not necessarily identical.
</p>
</div>
<div class="paragraph">
<p>To be precise an object has a value. If you evaluate <code>[1, 2, 3]</code>, you get an array object whose value is a sequence of integers. If another array has the same elements, we say it has the same value, but it is not the same object.</p>
</div>
</div>
<div class="sect2">
<h3 id="_aliasing">Aliasing</h3>
<div class="paragraph">
<p>If <code>a</code> refers to an object and you assign <code>b = a</code>, then both variables refer to the same object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; a = [1, 2, 3];

julia&gt; b = a;

julia&gt; b ≡ a
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>The state diagram looks like <a href="#fig10-4">State diagram</a>.</p>
</div>
<div id="fig10-4" class="imageblock">
<div class="content">
<img src="images/fig104.svg" alt="fig104">
</div>
<div class="title">Figure 14. State diagram</div>
</div>
<div class="paragraph">
<p>The association of a variable with an object is called a <em>reference</em>. In this example, there are two references to the same object.
</p>
</div>
<div class="paragraph">
<p>An object with more than one reference has more than one name, so we say that the object is <em>aliased</em>.
</p>
</div>
<div class="paragraph">
<p>If the aliased object is mutable, changes made with one alias affect the other:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; b[1] = 42
42
julia&gt; print(a)
[42, 2, 3]</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Although this behavior can be useful, it is error-prone. In general, it is safer to avoid aliasing when you are working with mutable objects.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For immutable objects like strings, aliasing is not as much of a problem. In this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">a = "banana"
b = "banana"</code></pre>
</div>
</div>
<div class="paragraph">
<p>It almost never makes a difference whether <code>a</code> and <code>b</code> refer to the same string or not.</p>
</div>
</div>
<div class="sect2">
<h3 id="_array_arguments">Array Arguments</h3>
<div class="paragraph">
<p>When you pass an array to a function, the function gets a reference to the array. If the function modifies the array, the caller sees the change. For example, <code>deletehead!</code> removes the first element from an array:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function deletehead!(t)
    popfirst!(t)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here’s how it is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; letters = ['a', 'b', 'c'];

julia&gt; deletehead!(letters);

julia&gt; print(letters)
['b', 'c']</code></pre>
</div>
</div>
<div class="paragraph">
<p>The parameter <code>t</code> and the variable <code>letters</code> are aliases for the same object. The stack diagram looks like <a href="#fig10-5">Stack diagram</a>.
</p>
</div>
<div id="fig10-5" class="imageblock">
<div class="content">
<img src="images/fig105.svg" alt="fig105">
</div>
<div class="title">Figure 15. Stack diagram</div>
</div>
<div class="paragraph">
<p>Since the array is shared by two frames, I drew it between them.</p>
</div>
<div class="paragraph">
<p>It is important to distinguish between operations that modify arrays and operations that create new arrays. For example, <code>push!</code> modifies an array, but <code>vcat</code> creates a new array.
</p>
</div>
<div class="paragraph">
<p>Here’s an example using <code>push!</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t1 = [1, 2];

julia&gt; t2 = push!(t1, 3);

julia&gt; print(t1)
[1, 2, 3]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>t2</code> is an alias of <code>t1</code>.</p>
</div>
<div class="paragraph">
<p>Here’s an example using <code>vcat</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t3 = vcat(t1, [4]);

julia&gt; print(t1)
[1, 2, 3]
julia&gt; print(t3)
[1, 2, 3, 4]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result of <code>vcat</code> is a new array, and the original array is unchanged.</p>
</div>
<div class="paragraph">
<p>This difference is important when you write functions that are supposed to modify arrays.</p>
</div>
<div class="paragraph">
<p>For example, this function <em>does not</em> delete the head of a array:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function baddeletehead(t)
    t = t[2:end]                # WRONG!
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The slice operator creates a new array and the assignment makes <code>t</code> refer to it, but that doesn’t affect the caller.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t4 = baddeletehead(t3);

julia&gt; print(t3)
[1, 2, 3, 4]
julia&gt; print(t4)
[2, 3, 4]</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the beginning of <code>baddeletehead</code>, <code>t</code> and <code>t3</code> refer to the same array. At the end, <code>t</code> refers to a new array, but <code>t3</code> still refers to the original, unmodified array.</p>
</div>
<div class="paragraph">
<p>An alternative is to write a function that creates and returns a new array. For example, <code>tail</code> returns all but the first element of an array:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function tail(t)
    t[2:end]
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function leaves the original array unmodified. Here’s how it is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; letters = ['a', 'b', 'c'];

julia&gt; rest = tail(letters);

julia&gt; print(rest)
['b', 'c']</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_debugging_6">Debugging</h3>
<div class="paragraph">
<p>Careless use of arrays (and other mutable objects) can lead to long hours of debugging. Here are some common pitfalls and ways to avoid them:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Most array functions modify the argument. This is the opposite of the string functions, which return a new string and leave the original alone.</p>
<div class="paragraph">
<p>If you are used to writing string code like this:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">new_word = strip(word)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is tempting to write array code like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">t2 = sort!(t1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because <code>sort!</code> returns the modified original array <code>t1</code>, <code>t2</code> is an alias of <code>t1</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Before using array functions and operators, you should read the documentation carefully and then test them in interactive mode.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Pick an idiom and stick with it.</p>
<div class="paragraph">
<p>Part of the problem with arrays is that there are too many ways to do things. For example, to remove an element from an array, you can use <code>pop!</code>, <code>popfirst!</code>, <code>delete_at</code>, or even a slice assignment. To add an element, you can use <code>push!</code>, <code>pushfirst!</code>, <code>insert!</code> or <code>vcat</code>. Assuming that <code>t</code> is an array and <code>x</code> is an array element, these are correct:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">insert!(t, 4, x)
push!(t, x)
append!(t, [x])</code></pre>
</div>
</div>
<div class="paragraph">
<p>And these are wrong:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">insert!(t, 4, [x])         # WRONG!
push!(t, [x])              # WRONG!</code></pre>
</div>
</div>
</li>
<li>
<p>Make copies to avoid aliasing.</p>
<div class="paragraph">
<p>If you want to use a function like <code>sort!</code> that modifies the argument, but you need to keep the original array as well, you can make a copy:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = [3, 1, 2];

julia&gt; t2 = t[:]; # t2 = copy(t)

julia&gt; sort!(t2);

julia&gt; print(t)
[3, 1, 2]
julia&gt; print(t2)
[1, 2, 3]</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example you could also use the built-in function <code>sort</code>, which returns a new, sorted array and leaves the original alone:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t2 = sort(t);

julia&gt; println(t)
[3, 1, 2]
julia&gt; println(t2)
[1, 2, 3]</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_glossary_7">Glossary</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">array</dt>
<dd>
<p>A sequence of values.
</p>
</dd>
<dt class="hdlist1">element</dt>
<dd>
<p>One of the values in an array (or other sequence), also called items.
</p>
</dd>
<dt class="hdlist1">nested array</dt>
<dd>
<p>An array that is an element of another array.
</p>
</dd>
<dt class="hdlist1">accumulator</dt>
<dd>
<p>A variable used in a loop to add up or accumulate a result.
</p>
</dd>
<dt class="hdlist1">augmented assignment</dt>
<dd>
<p>A statement that updates the value of a variable using an operator like <code>=</code>.
</p>
</dd>
<dt class="hdlist1">dot operator</dt>
<dd>
<p>Binary operator that is applied element-by-element to arrays.
</p>
</dd>
<dt class="hdlist1">dot syntax</dt>
<dd>
<p>Syntax used to apply a function elementwise to any array.
</p>
</dd>
<dt class="hdlist1">reduce operation</dt>
<dd>
<p>A processing pattern that traverses a sequence and accumulates the elements into a single result.
</p>
</dd>
<dt class="hdlist1">map</dt>
<dd>
<p>A processing pattern that traverses a sequence and performs an operation on each element.
</p>
</dd>
<dt class="hdlist1">filter</dt>
<dd>
<p>A processing pattern that traverses a sequence and selects the elements that satisfy some criterion.
</p>
</dd>
<dt class="hdlist1">object</dt>
<dd>
<p>Something a variable can refer to. An object has a type and a value.
</p>
</dd>
<dt class="hdlist1">equivalent</dt>
<dd>
<p>Having the same value.
</p>
</dd>
<dt class="hdlist1">identical</dt>
<dd>
<p>Being the same object (which implies equivalence).
</p>
</dd>
<dt class="hdlist1">reference</dt>
<dd>
<p>The association between a variable and its value.
</p>
</dd>
<dt class="hdlist1">aliasing</dt>
<dd>
<p>A circumstance where two or more variables refer to the same object.
</p>
</dd>
<dt class="hdlist1">optional arguments</dt>
<dd>
<p>arguments that are not required.
</p>
</dd>
<dt class="hdlist1">delimiter</dt>
<dd>
<p>A character or string used to indicate where a string should be split.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_9">Exercises</h3>
<div class="sect4">
<h5 id="ex10-1">Exercise 10-1</h5>
<div class="paragraph">
<p>Write a function called <code>nestedsum</code> that takes an array of arrays of integers and adds up the elements from all of the nested arrays. For example:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = [[1, 2], [3], [4, 5, 6]];

julia&gt; nestedsum(t)
21</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex10-2">Exercise 10-2</h5>
<div class="paragraph">
<p>Write a function called <code>cumulsum</code> that takes an array of numbers and returns the cumulative sum; that is, a new array where the \(i\)th element is the sum of the first \(i\) elements from the original array. For example:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = [1, 2, 3];

julia&gt; print(cumulsum(t))
Any[1, 3, 6]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex10-3">Exercise 10-3</h5>
<div class="paragraph">
<p>Write a function called <code>interior</code> that takes an array and returns a new array that contains all but the first and last elements. For example:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = [1, 2, 3, 4];

julia&gt; print(interior(t))
[2, 3]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex10-4">Exercise 10-4</h5>
<div class="paragraph">
<p>Write a function called <code>interior!</code> that takes an array, modifies it by removing the first and last elements, and returns <code>nothing</code>. For example:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = [1, 2, 3, 4];

julia&gt; interior!(t)

julia&gt; print(t)
[2, 3]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex10-5">Exercise 10-5</h5>
<div class="paragraph">
<p>Write a function called <code>issort</code> that takes an array as a parameter and returns <code>true</code> if the array is sorted in ascending order and <code>false</code> otherwise. For example:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; issort([1, 2, 2])
true
julia&gt; issort(['b', 'a'])
false</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex10-6">Exercise 10-6</h5>
<div class="paragraph">
<p>Two words are anagrams if you can rearrange the letters from one to spell the other. Write a function called <code>isanagram</code> that takes two strings and returns <code>true</code> if they are anagrams.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex10-7">Exercise 10-7</h5>
<div class="paragraph">
<p>Write a function called <code>hasduplicates</code> that takes an array and returns <code>true</code> if there is any element that appears more than once. It should not modify the original array.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex10-8">Exercise 10-8</h5>
<div class="paragraph">
<p>This exercise pertains to the so-called Birthday Paradox, which you can read about at <a href="https://en.wikipedia.org/wiki/Birthday_paradox" class="bare">https://en.wikipedia.org/wiki/Birthday_paradox</a>.
</p>
</div>
<div class="paragraph">
<p>If there are 23 students in your class, what are the chances that two of you have the same birthday? You can estimate this probability by generating random samples of 23 birthdays and checking for matches.
</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>You can generate random birthdays with <code>rand(1:365)</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ex10-9">Exercise 10-9</h5>
<div class="paragraph">
<p>Write a function that reads the file <code>words.txt</code> and builds an array with one element per word. Write two versions of this function, one using <code>push!</code> and the other using the idiom <code>t = [t..., x]</code>. Which one takes longer to run? Why?
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex10-10">Exercise 10-10</h5>
<div class="paragraph">
<p>To check whether a word is in the word array, you could use the <code>∈</code> operator, but it would be slow because it searches through the words in order.</p>
</div>
<div class="paragraph">
<p>Because the words are in alphabetical order, we can speed things up with a bisection search (also known as binary search), which is similar to what you do when you look a word up in the dictionary. You start in the middle and check to see whether the word you are looking for comes before the word in the middle of the array. If so, you search the first half of the array the same way. Otherwise you search the second half.</p>
</div>
<div class="paragraph">
<p>Either way, you cut the remaining search space in half. If the word array has 113,809 words, it will take about 17 steps to find the word or conclude that it’s not there.</p>
</div>
<div class="paragraph">
<p>Write a function called <code>inbisect</code> that takes a sorted array and a target value and returns <code>true</code> if the word is in the array and <code>false</code> if it’s not.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex10-11">Exercise 10-11</h5>
<div class="paragraph">
<p>Two words are a “reverse pair” if each is the reverse of the other. Write a program <code>reversepairs</code> that finds all the reverse pairs in the word array.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex10-12">Exercise 10-12</h5>
<div class="paragraph">
<p>Two words “interlock” if taking alternating letters from each forms a new word. For example, “shoe” and “cold” interlock to form “schooled”.
</p>
</div>
<div class="paragraph">
<p>Credit: This exercise is inspired by an example at <a href="http://puzzlers.org" class="bare">http://puzzlers.org</a>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write a program that finds all pairs of words that interlock.</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Don’t enumerate all pairs!</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Can you find any words that are three-way interlocked; that is, every third letter forms a word, starting from the first, second or third?</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap11">14. Dictionaries</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter presents another built-in type called a dictionary.</p>
</div>
<div class="sect2">
<h3 id="_a_dictionary_is_a_mapping">A Dictionary Is a Mapping</h3>
<div class="paragraph">
<p>A <em>dictionary</em> is like an array, but more general. In an array, the indices have to be integers; in a dictionary they can be (almost) any type.
</p>
</div>
<div class="paragraph">
<p>A dictionary contains a collection of indices, which are called <em>keys</em>, and a collection of values. Each key is associated with a single value. The association of a key and a value is called a <em>key-value pair</em> or sometimes an item.
</p>
</div>
<div class="paragraph">
<p>In mathematical language, a dictionary represents a <em>mapping</em> from keys to values, so you can also say that each key “maps to” a value. As an example, we’ll build a dictionary that maps from English to Spanish words, so the keys and the values are all strings.
</p>
</div>
<div class="paragraph">
<p>The function <code>Dict</code> creates a new dictionary with no items. Because <code>Dict</code> is the name of a built-in function, you should avoid using it as a variable name.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; eng2sp = Dict()
Dict{Any,Any} with 0 entries</code></pre>
</div>
</div>
<div class="paragraph">
<p>The kind of dictionary is surrounded by curly braces: the keys are of type <code>Any</code> and also the values are of type <code>Any</code>.
</p>
</div>
<div class="paragraph">
<p>The dictionary is empty. To add items to the dictionary, you can use square brackets:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; eng2sp["one"] = "uno";</code></pre>
</div>
</div>
<div class="paragraph">
<p>This line creates an item that maps from the key "one" to the value "uno". If we print the dictionary again, we see a key-value pair with an arrow <code>=&gt;</code> between the key and value:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; eng2sp
Dict{Any,Any} with 1 entry:
  "one" =&gt; "uno"</code></pre>
</div>
</div>
<div class="paragraph">
<p>This output format is also an input format. For example, you can create a new dictionary with three items:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; eng2sp = Dict("one" =&gt; "uno", "two" =&gt; "dos", "three" =&gt; "tres")
Dict{String,String} with 3 entries:
  "two"   =&gt; "dos"
  "one"   =&gt; "uno"
  "three" =&gt; "tres"</code></pre>
</div>
</div>
<div class="paragraph">
<p>All the initial keys and values are strings, so a <code>Dict{String,String}</code> is created.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>The order of the key-value pairs might not be the same. If you type the same example on your computer, you might get a different result. In general, the order of items in a dictionary is unpredictable.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>But that’s not a problem because the elements of a dictionary are never indexed with integer indices. Instead, you use the keys to look up the corresponding values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; eng2sp["two"]
"dos"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The key "two" always maps to the value "dos" so the order of the items doesn’t matter.</p>
</div>
<div class="paragraph">
<p>If the key isn’t in the dictionary, you get an exception:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; eng2sp["four"]
ERROR: KeyError: key "four" not found</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>length</code> function works on dictionaries; it returns the number of key-value pairs:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; length(eng2sp)
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function <code>keys</code> returns a collection with the keys of the dictionary:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; ks = keys(eng2sp);

julia&gt; print(ks)
["two", "one", "three"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you can use the <code>∈</code> operator to see whether something appears as a <em>key</em> in the dictionary:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; "one" ∈ ks
true
julia&gt; "uno" ∈ ks
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>To see whether something appears as a value in a dictionary, you can use the function <code>values</code>, which returns a collection of values, and then use the <code>∈</code> operator:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; vs = values(eng2sp);

julia&gt; "uno" ∈ vs
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>∈</code> operator uses different algorithms for arrays and dictionaries. For arrays, it searches the elements of the array in order, as in <a href="#searching">Searching</a>. As the array gets longer, the search time gets longer in direct proportion.</p>
</div>
<div class="paragraph">
<p>For dictionaries, Julia uses an algorithm called a <em>hash table</em> that has a remarkable property: the <code>∈</code> operator takes about the same amount of time no matter how many items are in the dictionary.
</p>
</div>
</div>
<div class="sect2">
<h3 id="dictionary_collection_counters">Dictionary as a Collection of Counters</h3>
<div class="paragraph">
<p>Suppose you are given a string and you want to count how many times each letter appears. There are several ways you could do it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You could create 26 variables, one for each letter of the alphabet. Then you could traverse the string and, for each character, increment the corresponding counter, probably using a chained conditional.</p>
</li>
<li>
<p>You could create an array with 26 elements. Then you could convert each character to a number (using the built-in function <code>Int</code>), use the number as an index into the array, and increment the appropriate counter.</p>
</li>
<li>
<p>You could create a dictionary with characters as keys and counters as the corresponding values. The first time you see a character, you would add an item to the dictionary. After that you would increment the value of an existing item.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each of these options performs the same computation, but each of them implements that computation in a different way.</p>
</div>
<div class="paragraph">
<p>An <em>implementation</em> is a way of performing a computation; some implementations are better than others. For example, an advantage of the dictionary implementation is that we don’t have to know ahead of time which letters appear in the string and we only have to make room for the letters that do appear.
</p>
</div>
<div class="paragraph">
<p>Here is what the code might look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function histogram(s)
    d = Dict()
    for c in s
        if c ∉ keys(d)
            d[c] = 1
        else
            d[c] += 1
        end
    end
    d
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The name of the function is <code>histogram</code>, which is a statistical term for a collection of counters (or frequencies).
</p>
</div>
<div class="paragraph">
<p>The first line of the function creates an empty dictionary. The <code>for</code> loop traverses the string. Each time through the loop, if the character <code>c</code> is not in the dictionary, we create a new item with key <code>c</code> and the initial value <code>1</code> (since we have seen this letter once). If <code>c</code> is already in the dictionary we increment <code>d[c]</code>.</p>
</div>
<div class="paragraph">
<p>Here’s how it works:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; h = histogram("brontosaurus")
Dict{Any,Any} with 8 entries:
  'n' =&gt; 1
  's' =&gt; 2
  'a' =&gt; 1
  'r' =&gt; 2
  't' =&gt; 1
  'o' =&gt; 2
  'u' =&gt; 2
  'b' =&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>The histogram indicates that the letters <code><em>a</em></code> and <code><em>b</em></code> appear once; <code><em>o</em></code> appears twice, and so on.</p>
</div>
<div class="paragraph">
<p>Dictionaries have a function called <code>get</code> that takes a key and a default value. If the key appears in the dictionary, <code>get</code> returns the corresponding value; otherwise it returns the default value. For example:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; h = histogram("a")
Dict{Any,Any} with 1 entry:
  'a' =&gt; 1
julia&gt; get(h, 'a', 0)
1
julia&gt; get(h, 'b', 0)
0</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_exercise_11_1">Exercise 11-1</h5>
<div class="paragraph">
<p>Use <code>get</code> to write <code>histogram</code> more concisely. You should be able to eliminate the <code>if</code> statement.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_looping_and_dictionaries">Looping and Dictionaries</h3>
<div class="paragraph">
<p>You can traverse the keys of the dictionary in a <code>for</code> statement. For example, <code>printhist</code> prints each key and the corresponding value:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function printhist(h)
    for c in keys(h)
        println(c, " ", h[c])
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here’s what the output looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; h = histogram("parrot");

julia&gt; printhist(h)
a 1
r 2
p 1
o 1
t 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, the keys are in no particular order. To traverse the keys in sorted order, you can combine <code>sort</code> and <code>collect</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; for c in sort(collect(keys(h)))
           println(c, " ", h[c])
       end
a 1
o 1
p 1
r 2
t 1</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reverse_lookup">Reverse Lookup</h3>
<div class="paragraph">
<p>Given a dictionary <code>d</code> and a key <code>k</code>, it is easy to find the corresponding value <code>v = d[k]</code>. This operation is called a <em>lookup</em>.
</p>
</div>
<div class="paragraph">
<p>But what if you have <code>v</code> and you want to find <code>k</code>? You have two problems: first, there might be more than one key that maps to the value <code>v</code>. Depending on the application, you might be able to pick one, or you might have to make an array that contains all of them. Second, there is no simple syntax to do a <em>reverse lookup</em>; you have to search.
</p>
</div>
<div class="paragraph">
<p>Here is a function that takes a value and returns the first key that maps to that value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function reverselookup(d, v)
    for k in keys(d)
        if d[k] == v
            return k
        end
    end
    error("LookupError")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function is yet another example of the search pattern, but it uses a function we haven’t seen before, <code>error</code>. The <code>error</code> function is used to produce an <code>ErrorException</code> that interrupts the normal flow of control. In this case it has the message <code>"LookupError"</code>, indicating that a key does not exist.
</p>
</div>
<div class="paragraph">
<p>If we get to the end of the loop, that means <code>v</code> doesn’t appear in the dictionary as a value, so we throw an exception.</p>
</div>
<div class="paragraph">
<p>Here is an example of a successful reverse lookup:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; h = histogram("parrot");

julia&gt; key = reverselookup(h, 2)
'r': ASCII/Unicode U+0072 (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And an unsuccessful one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; key = reverselookup(h, 3)
ERROR: LookupError</code></pre>
</div>
</div>
<div class="paragraph">
<p>The effect when you generate an exception is the same as when Julia throws one: it prints a stacktrace and an error message.</p>
</div>
<div class="paragraph">
<p>Julia provides an optimized way to do a reverse lookup: <code>findall(isequal(3), h)</code>.
</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>A reverse lookup is much slower than a forward lookup; if you have to do it often, or if the dictionary gets big, the performance of your program will suffer.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_dictionaries_and_arrays">Dictionaries and Arrays</h3>
<div class="paragraph">
<p>Arrays can appear as values in a dictionary. For example, if you are given a dictionary that maps from letters to frequencies, you might want to invert it; that is, create a dictionary that maps from frequencies to letters. Since there might be several letters with the same frequency, each value in the inverted dictionary should be an array of letters.</p>
</div>
<div class="paragraph">
<p>Here is a function that inverts a dictionary:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function invertdict(d)
    inverse = Dict()
    for key in keys(d)
        val = d[key]
        if val ∉ keys(inverse)
            inverse[val] = [key]
        else
            push!(inverse[val], key)
        end
    end
    inverse
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each time through the loop, <code>key</code> gets a key from <code>d</code> and <code>val</code> gets the corresponding value. If <code>val</code> is not in <code>inverse</code>, that means we haven’t seen it before, so we create a new item and initialize it with a <em>singleton</em> (an array that contains a single element). Otherwise we have seen this value before, so we append the corresponding key to the array.
</p>
</div>
<div class="paragraph">
<p>Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; hist = histogram("parrot");

julia&gt; inverse = invertdict(hist)
Dict{Any,Any} with 2 entries:
  2 =&gt; ['r']
  1 =&gt; ['a', 'p', 'o', 't']</code></pre>
</div>
</div>
<div id="fig11-1" class="imageblock">
<div class="content">
<img src="images/fig111.svg" alt="fig111">
</div>
<div class="title">Figure 16. State diagram</div>
</div>
<div class="paragraph">
<p><a href="#fig11-1">State diagram</a> is a state diagram showing <code>hist</code> and <code>inverse</code>. A dictionary is represented as a box with the key-value pairs inside. If the values are integers, floats or strings, I draw them inside the box, but I usually draw arrays outside the box, just to keep the diagram simple.
</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>I mentioned earlier that a dictionary is implemented using a hash table and that means that the keys have to be <em>hashable</em>.
</p>
</div>
<div class="paragraph">
<p>A <em>hash</em> is a function that takes a value (of any kind) and returns an integer. Dictionaries use these integers, called hash values, to store and look up key-value pairs.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="memos">Memos</h3>
<div class="paragraph">
<p>If you played with the <code>fibonacci</code> function from <a href="#one_more_example">One More Example</a>, you might have noticed that the bigger the argument you provide, the longer the function takes to run. Furthermore, the run time increases quickly.
</p>
</div>
<div class="paragraph">
<p>To understand why, consider <a href="#fig11-2">Call graph</a>, which shows the <em>call graph</em> for <code>fibonacci</code> with <code>n = 4</code>:
</p>
</div>
<div id="fig11-2" class="imageblock">
<div class="content">
<img src="images/fig112.svg" alt="fig112">
</div>
<div class="title">Figure 17. Call graph</div>
</div>
<div class="paragraph">
<p>A call graph shows a set of function frames, with lines connecting each frame to the frames of the functions it calls. At the top of the graph, <code>fibonacci</code> with <code>n = 4</code> calls <code>fibonacci</code> with  <code>n = 3</code> and <code>n = 2</code>. In turn, <code>fibonacci</code> with <code>n = 3</code> calls <code>fibonacci</code> with <code>n = 2</code> and <code>n = 1</code>. And so on.</p>
</div>
<div class="paragraph">
<p>Count how many times <code>fibonacci(0)</code> and <code>fibonacci(1)</code> are called. This is an inefficient solution to the problem, and it gets worse as the argument gets bigger.</p>
</div>
<div class="paragraph">
<p>One solution is to keep track of values that have already been computed by storing them in a dictionary. A previously computed value that is stored for later use is called a <em>memo</em>. Here is a “memoized” version of fibonacci:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">known = Dict(0=&gt;0, 1=&gt;1)

function fibonacci(n)
    if n ∈ keys(known)
        return known[n]
    end
    res = fibonacci(n-1) + fibonacci(n-2)
    known[n] = res
    res
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>known</code> is a dictionary that keeps track of the Fibonacci numbers we already know. It starts with two items: <code>0</code> maps to <code>0</code> and <code>1</code> maps to <code>1</code>.</p>
</div>
<div class="paragraph">
<p>Whenever <code>fibonacci</code> is called, it checks <code>known</code>. If the result is already there, it can return immediately. Otherwise it has to compute the new value, add it to the dictionary, and return it.</p>
</div>
<div class="paragraph">
<p>If you run this version of <code>fibonacci</code> and compare it with the original, you will find that it is much faster.</p>
</div>
</div>
<div class="sect2">
<h3 id="global_variables">Global Variables</h3>
<div class="paragraph">
<p>In the previous example, known is created outside the function, so it belongs to the special frame called <code>Main</code>. Variables in <code>Main</code> are sometimes called <em>global</em> because they can be accessed from any function. Unlike local variables, which disappear when their function ends, global variables persist from one function call to the next.
</p>
</div>
<div class="paragraph">
<p>It is common to use global variables for <em>flags</em>; that is, boolean variables that indicate (“flag”) whether a condition is true. For example, some programs use a flag named <code>verbose</code> to control the level of detail in the output:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">verbose = true

function example1()
    if verbose
        println("Running example1")
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you try to reassign a global variable, you might be surprised. The following example is supposed to keep track of whether the function has been called:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">been_called = false

function example2()
    been_called = true         # WRONG
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>But if you run it you will see that the value of <code>been_called</code> doesn’t change. The problem is that <code>example2</code> creates a new local variable named <code>been_called</code>. The local variable goes away when the function ends, and has no effect on the global variable.</p>
</div>
<div class="paragraph">
<p>To reassign a global variable inside a function you have to <em>declare</em> the variable global before you use it:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">been_called = false

function example2()
    global been_called
    been_called = true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>global statement</em> tells the interpreter something like, “In this function, when I say <code>been_called</code>, I mean the global variable; don’t create a local one.”
</p>
</div>
<div class="paragraph">
<p>Here’s an example that tries to update a global variable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">count = 0

function example3()
    count = count + 1          # WRONG
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you run it you get:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; example3()
ERROR: UndefVarError: count not defined</code></pre>
</div>
</div>
<div class="paragraph">
<p>Julia assumes that <code>count</code> is local, and under that assumption you are reading it before writing it. The solution, again, is to declare <code>count</code> global.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">count = 0

function example3()
    global count
    count += 1
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a global variable refers to a mutable value, you can modify the value without declaring the variable global:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">known = Dict(0=&gt;0, 1=&gt;1)

function example4()
    known[2] = 1
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>So you can add, remove and replace elements of a global array or dictionary, but if you want to reassign the variable, you have to declare it global:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">known = Dict(0=&gt;0, 1=&gt;1)

function example5()
    global known
    known = Dict()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>For performance reasons, you should declare a global variable constant. You can no longer reassign the variable but if it refers to a mutable value, you can modify the value.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">const known = Dict(0=&gt;0, 1=&gt;1)

function example4()
    known[2] = 1
end</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Global variables can be useful, but if you have a lot of them, and you modify them frequently, they can make programs hard to debug and perform badly.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_debugging_7">Debugging</h3>
<div class="paragraph">
<p>As you work with bigger datasets it can become unwieldy to debug by printing and checking the output by hand. Here are some suggestions for debugging large datasets:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Scale down the input:</p>
<div class="paragraph">
<p>If possible, reduce the size of the dataset. For example if the program reads a text file, start with just the first 10 lines, or with the smallest example you can find which errors. You should not edit the files themselves, but rather modify the program so it reads only the first \(n\) lines.
</p>
</div>
<div class="paragraph">
<p>If there is an error, you can reduce \(n\) to the smallest value that manifests the error, and then increase it gradually as you find and correct errors.</p>
</div>
</li>
<li>
<p>Check summaries and types:</p>
<div class="paragraph">
<p>Instead of printing and checking the entire dataset, consider printing summaries of the data: for example, the number of items in a dictionary or the total of an array of numbers.
</p>
</div>
<div class="paragraph">
<p>A common cause of runtime errors is a value that is not the right type. For debugging this kind of error, it is often enough to print the type of a value.</p>
</div>
</li>
<li>
<p>Write self-checks:</p>
<div class="paragraph">
<p>Sometimes you can write code to check for errors automatically. For example, if you are computing the average of an array of numbers, you could check that the result is not greater than the largest element in the array or less than the smallest. This is called a “sanity check”.
</p>
</div>
<div class="paragraph">
<p>Another kind of check compares the results of two different computations to see if they are consistent. This is called a “consistency check”.
</p>
</div>
</li>
<li>
<p>Format the output:</p>
<div class="paragraph">
<p>Formatting debugging output can make it easier to spot an error. We saw an example in <a href="#deb06">Debugging</a>.
</p>
</div>
<div class="paragraph">
<p>Again, time you spend building scaffolding can reduce the time you spend debugging.
</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_glossary_8">Glossary</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">mapping</dt>
<dd>
<p>A relationship in which each element of one set corresponds to an element of another set.
</p>
</dd>
<dt class="hdlist1">dictionary</dt>
<dd>
<p>A mapping from keys to their corresponding values.
</p>
</dd>
<dt class="hdlist1">key-value pair</dt>
<dd>
<p>The representation of the mapping from a key to a value.
</p>
</dd>
<dt class="hdlist1">item</dt>
<dd>
<p>In a dictionary, another name for a key-value pair.
</p>
</dd>
<dt class="hdlist1">key</dt>
<dd>
<p>An object that appears in a dictionary as the first part of a key-value pair.
</p>
</dd>
<dt class="hdlist1">value</dt>
<dd>
<p>An object that appears in a dictionary as the second part of a key-value pair. This is more specific than our previous use of the word “value”.
</p>
</dd>
<dt class="hdlist1">implementation</dt>
<dd>
<p>A way of performing a computation.
</p>
</dd>
<dt class="hdlist1">hash table</dt>
<dd>
<p>The algorithm used to implement Julia dictionaries.
</p>
</dd>
<dt class="hdlist1">hash function</dt>
<dd>
<p>A function used by a hash table to compute the location for a key.
</p>
</dd>
<dt class="hdlist1">hashable</dt>
<dd>
<p>A type that has a hash function.
</p>
</dd>
<dt class="hdlist1">lookup</dt>
<dd>
<p>A dictionary operation that takes a key and finds the corresponding value.
</p>
</dd>
<dt class="hdlist1">reverse lookup</dt>
<dd>
<p>A dictionary operation that takes a value and finds one or more keys that map to it.
</p>
</dd>
<dt class="hdlist1">singleton</dt>
<dd>
<p>An array (or other sequence) with a single element.
</p>
</dd>
<dt class="hdlist1">call graph</dt>
<dd>
<p>A diagram that shows every frame created during the execution of a program, with an arrow from each caller to each callee.
</p>
</dd>
<dt class="hdlist1">memo</dt>
<dd>
<p>A computed value stored to avoid unnecessary future computation.
</p>
</dd>
<dt class="hdlist1">global variable</dt>
<dd>
<p>A variable defined outside a function. Global variables can be accessed from any function.
</p>
</dd>
<dt class="hdlist1">global statement</dt>
<dd>
<p>A statement that declares a variable name global.
</p>
</dd>
<dt class="hdlist1">flag</dt>
<dd>
<p>A boolean variable used to indicate whether a condition is true.
</p>
</dd>
<dt class="hdlist1">declaration</dt>
<dd>
<p>A statement like <code>global</code> that tells the interpreter something about a variable.
</p>
</dd>
<dt class="hdlist1">constant global variable</dt>
<dd>
<p>A global variable that can not be reassigned.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_10">Exercises</h3>
<div class="sect4">
<h5 id="ex11-1">Exercise 11-2</h5>
<div class="paragraph">
<p>Write a function that reads the words in <em>words.txt</em> and stores them as keys in a dictionary. It doesn’t matter what the values are. Then you can use the <code>∈</code> operator as a fast way to check whether a string is in the dictionary.
</p>
</div>
<div class="paragraph">
<p>If you did <a href="#ex10-10">Exercise 10-10</a>, you can compare the speed of this implementation with the array <code>∈</code> operator and the bisection search.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex11-2">Exercise 11-3</h5>
<div class="paragraph">
<p>Read the documentation of the dictionary function <code>get!</code> and use it to write a more concise version of <code>invertdict</code>.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex11-3">Exercise 11-4</h5>
<div class="paragraph">
<p>Memoize the Ackermann function from <a href="#ex06-2">Exercise 6-5</a> and see if memoization makes it possible to evaluate the function with bigger arguments.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex11-4">Exercise 11-5</h5>
<div class="paragraph">
<p>If you did <a href="#ex10-7">Exercise 10-7</a>, you already have a function named <code>hasduplicates</code> that takes an array as a parameter and returns <code>true</code> if there is any object that appears more than once in the array.
</p>
</div>
<div class="paragraph">
<p>Use a dictionary to write a faster, simpler version of <code>hasduplicates</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex11-5">Exercise 11-6</h5>
<div class="paragraph">
<p>Two words are “rotate pairs” if you can rotate one of them and get the other (see <code>rotateword</code> in <a href="#ex08-5">Exercise 8-11</a>).
</p>
</div>
<div class="paragraph">
<p>Write a program that reads a word array and finds all the rotate pairs.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex11-6">Exercise 11-7</h5>
<div class="paragraph">
<p>Here’s another Puzzler from Car Talk (<a href="https://www.cartalk.com/puzzler/browse" class="bare">https://www.cartalk.com/puzzler/browse</a>):
</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>This was sent in by a fellow named Dan O’Leary. He came upon a common one-syllable, five-letter word recently that has the following unique property. When you remove the first letter, the remaining letters form a homophone of the original word, that is a word that sounds exactly the same. Replace the first letter, that is, put it back and remove the second letter and the result is yet another homophone of the original word. And the question is, what’s the word?</p>
</div>
<div class="paragraph">
<p>Now I’m going to give you an example that doesn’t work. Let’s look at the five-letter word, ‘wrack.’ W-R-A-C-K, you know like to ‘wrack with pain.’ If I remove the first letter, I am left with a four-letter word, ’R-A-C-K.’ As in, ‘Holy cow, did you see the rack on that buck! It must have been a nine-pointer!’ It’s a perfect homophone. If you put the ‘w’ back, and remove the ‘r,’ instead, you’re left with the word, ‘wack,’ which is a real word, it’s just not a homophone of the other two words.</p>
</div>
<div class="paragraph">
<p>But there is, however, at least one word that Dan and we know of, which will yield two homophones if you remove either of the first two letters to make two, new four-letter words. The question is, what’s the word?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>You can use the dictionary from <a href="#ex11-1">Exercise 11-2</a> to check whether a string is in the word array.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>To check whether two words are homophones, you can use the CMU Pronouncing Dictionary. You can download it from <a href="http://www.speech.cs.cmu.edu/cgi-bin/cmudict" class="bare">http://www.speech.cs.cmu.edu/cgi-bin/cmudict</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Write a program that lists all the words that solve the Puzzler.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap12">15. Tuples</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter presents one more built-in type, the tuple, and then shows how arrays, dictionaries, and tuples work together. I also present a useful feature for variable-length argument arrays, the gather and scatter operators.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>There is no consensus on how to pronounce “tuple”. Some people say “tuh-ple”, which rhymes with “supple”. But in the context of programming, most people say “too-ple”, which rhymes with “quadruple”.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_tuples_are_immutable">Tuples Are Immutable</h3>
<div class="paragraph">
<p>A tuple is a sequence of values. The values can be of any type, and they are indexed by integers, so in that respect tuples are a lot like arrays. The important difference is that tuples are immutable and that each element can have its own type.
</p>
</div>
<div class="paragraph">
<p>Syntactically, a tuple is a comma-separated list of values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = 'a', 'b', 'c', 'd', 'e'
('a', 'b', 'c', 'd', 'e')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although it is not necessary, it is common to enclose tuples in parentheses:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = ('a', 'b', 'c', 'd', 'e')
('a', 'b', 'c', 'd', 'e')</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create a tuple with a single element, you have to include a final comma:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t1 = ('a',)
('a',)
julia&gt; typeof(t1)
Tuple{Char}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>A value in parentheses without comma is not a tuple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t2 = ('a')
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
julia&gt; typeof(t2)
Char</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Another way to create a tuple is the built-in function tuple. With no argument, it creates an empty tuple:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; tuple()
()</code></pre>
</div>
</div>
<div class="paragraph">
<p>If multiple arguments are provided, the result is a tuple with the given arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t3 = tuple(1, 'a', pi)
(1, 'a', π)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because tuple is the name of a built-in function, you should avoid using it as a variable name.</p>
</div>
<div class="paragraph">
<p>Most array operators also work on tuples. The bracket operator indexes an element:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = ('a', 'b', 'c', 'd', 'e');

julia&gt; t[1]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the slice operator selects a range of elements:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t[2:4]
('b', 'c', 'd')</code></pre>
</div>
</div>
<div class="paragraph">
<p>But if you try to modify one of the elements of the tuple, you get an error:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t[1] = 'A'
ERROR: MethodError: no method matching setindex!(::NTuple{5,Char}, ::Char, ::Int64)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because tuples are immutable, you can’t modify the elements.</p>
</div>
<div class="paragraph">
<p>The relational operators work with tuples and other sequences; Julia starts by comparing the first element from each sequence. If they are equal, it goes on to the next elements, and so on, until it finds elements that differ. Subsequent elements are not considered (even if they are really big).
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; (0, 1, 2) &lt; (0, 3, 4)
true
julia&gt; (0, 1, 2000000) &lt; (0, 3, 4)
true</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tuple_assignment">Tuple Assignment</h3>
<div class="paragraph">
<p>It is often useful to swap the values of two variables. With conventional assignments, you have to use a temporary variable. For example, to swap a and b:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">temp = a
a = b
b = temp</code></pre>
</div>
</div>
<div class="paragraph">
<p>This solution is cumbersome; tuple assignment is more elegant:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">a, b = b, a</code></pre>
</div>
</div>
<div class="paragraph">
<p>The left side is a tuple of variables; the right side is a tuple of expressions. Each value is assigned to its respective variable. All the expressions on the right side are evaluated before any of the assignments.</p>
</div>
<div class="paragraph">
<p>The number of variables on the left has to be fewer than the number of values on the right:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; (a, b) = (1, 2, 3)
(1, 2, 3)
julia&gt; a, b, c = 1, 2
ERROR: BoundsError: attempt to access (1, 2)
  at index [3]</code></pre>
</div>
</div>
<div class="paragraph">
<p>More generally, the right side can be any kind of sequence (string, array or tuple). For example, to split an email address into a user name and a domain, you could write:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; addr = "julius.caesar@rome"
"julius.caesar@rome"
julia&gt; uname, domain = split(addr, '@');</code></pre>
</div>
</div>
<div class="paragraph">
<p>The return value from <code>split</code> is an array with two elements; the first element is assigned to <code>uname</code>, the second to <code>domain</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; uname
"julius.caesar"
julia&gt; domain
"rome"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tuples_as_return_values">Tuples as Return Values</h3>
<div class="paragraph">
<p>Strictly speaking, a function can only return one value, but if the value is a tuple, the effect is the same as returning multiple values. For example, if you want to divide two integers and compute the quotient and remainder, it is inefficient to compute <code>x ÷ y</code> and then <code>x % y</code>. It is better to compute them both at the same time.
</p>
</div>
<div class="paragraph">
<p>The built-in function <code>divrem</code> takes two arguments and returns a tuple of two values, the quotient and remainder. You can store the result as a tuple:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = divrem(7, 3)
(2, 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or use tuple assignment to store the elements separately:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; q, r = divrem(7, 3);

julia&gt; @show q r;
q = 2
r = 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is an example of a function that returns a tuple:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function minmax(t)
    minimum(t), maximum(t)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>maximum</code> and <code>minimum</code> are built-in functions that find the largest and smallest elements of a sequence. <code>minmax</code> computes both and returns a tuple of two values. The built-in function <code>extrema</code> is more efficient.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_variable_length_argument_tuples">Variable-length Argument Tuples</h3>
<div class="paragraph">
<p>Functions can take a variable number of arguments. A parameter name that ends with <code>...</code> <em>gathers</em> arguments into a tuple. For example, <code>printall</code> takes any number of arguments and prints them:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function printall(args...)
    println(args)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The gather parameter can have any name you like, but <code>args</code> is conventional. Here’s how the function works:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; printall(1, 2.0, '3')
(1, 2.0, '3')</code></pre>
</div>
</div>
<div class="paragraph">
<p>The complement of gather is <em>scatter</em>. If you have a sequence of values and you want to pass it to a function as multiple arguments, you can use the <code>...</code> operator. For example, <code>divrem</code> takes exactly two arguments; it doesn’t work with a tuple:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = (7, 3);

julia&gt; divrem(t)
ERROR: MethodError: no method matching divrem(::Tuple{Int64,Int64})</code></pre>
</div>
</div>
<div class="paragraph">
<p>But if you scatter the tuple, it works:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; divrem(t...)
(2, 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Many of the built-in functions use variable-length argument tuples. For example, <code>max</code> and <code>min</code> can take any number of arguments:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; max(1, 2, 3)
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>But <code>sum</code> does not:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; sum(1, 2, 3)
ERROR: MethodError: no method matching sum(::Int64, ::Int64, ::Int64)</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_exercise_12_1">Exercise 12-1</h5>
<div class="paragraph">
<p>Write a function called <code>sumall</code> that takes any number of arguments and returns their sum.
</p>
</div>
<div class="paragraph">
<p>In the Julia world, gather is often called “slurp” and scatter “splat”.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_arrays_and_tuples">Arrays and Tuples</h3>
<div class="paragraph">
<p><code>zip</code> is a built-in function that takes two or more sequences and returns a collection of tuples where each tuple contains one element from each sequence. The name of the function refers to a zipper, which joins and interleaves two rows of teeth.
</p>
</div>
<div class="paragraph">
<p>This example zips a string and an array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; s = "abc";

julia&gt; t = [1, 2, 3];

julia&gt; zip(s, t)
Base.Iterators.Zip{Tuple{String,Array{Int64,1}}}(("abc", [1, 2, 3]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is a <em>zip object</em> that knows how to iterate through the pairs. The most common use of <code>zip</code> is in a <code>for</code> loop:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; for pair in zip(s, t)
           println(pair)
       end
('a', 1)
('b', 2)
('c', 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A zip object is a kind of <em>iterator</em>, which is any object that iterates through a sequence. Iterators are similar to arrays in some ways, but unlike arrays, you can’t use an index to select an element from an iterator.
</p>
</div>
<div class="paragraph">
<p>If you want to use array operators and functions, you can use a zip object to make an array:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; collect(zip(s, t))
3-element Array{Tuple{Char,Int64},1}:
 ('a', 1)
 ('b', 2)
 ('c', 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is an array of tuples; in this example, each tuple contains a character from the string and the corresponding element from the array.</p>
</div>
<div class="paragraph">
<p>If the sequences are not the same length, the result has the length of the shorter one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; collect(zip("Anne", "Elk"))
3-element Array{Tuple{Char,Char},1}:
 ('A', 'E')
 ('n', 'l')
 ('n', 'k')</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use tuple assignment in a <code>for</code> loop to traverse an array of tuples:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = [('a', 1), ('b', 2), ('c', 3)];

julia&gt; for (letter, number) in t
           println(number, " ", letter)
       end
1 a
2 b
3 c</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each time through the loop, Julia selects the next tuple in the array and assigns the elements to letter and number. The parentheses around <code>(letter, number)</code> are compulsory.
</p>
</div>
<div class="paragraph">
<p>If you combine <code>zip</code>, <code>for</code> and tuple assignment, you get a useful idiom for traversing two (or more) sequences at the same time. For example, <code>hasmatch</code> takes two sequences, <code>t1</code> and <code>t2</code>, and returns <code>true</code> if there is an index <code>i</code> such that <code>t1[i] == t2[i]</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function hasmatch(t1, t2)
    for (x, y) in zip(t1, t2)
        if x == y
            return true
        end
    end
    false
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need to traverse the elements of a sequence and their indices, you can use the built-in function <code>enumerate</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; for (index, element) in enumerate("abc")
           println(index, " ", element)
       end
1 a
2 b
3 c</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result from <code>enumerate</code> is an enumerate object, which iterates a sequence of pairs; each pair contains an index (starting from 1) and an element from the given sequence.</p>
</div>
</div>
<div class="sect2">
<h3 id="_dictionaries_and_tuples">Dictionaries and Tuples</h3>
<div class="paragraph">
<p>Dictionaries can be used as iterators that iterate the key-value pairs. You can use it in a <code>for</code> loop like this:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; d = Dict('a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3);

julia&gt; for (key, value) in d
           println(key, " ", value)
       end
a 1
c 3
b 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you should expect from a dictionary, the items are in no particular order.</p>
</div>
<div class="paragraph">
<p>Going in the other direction, you can use an array of tuples to initialize a new dictionary:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = [('a', 1), ('c', 3), ('b', 2)];

julia&gt; d = Dict(t)
Dict{Char,Int64} with 3 entries:
  'a' =&gt; 1
  'c' =&gt; 3
  'b' =&gt; 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Combining <code>Dict</code> with <code>zip</code> yields a concise way to create a dictionary:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; d = Dict(zip("abc", 1:3))
Dict{Char,Int64} with 3 entries:
  'a' =&gt; 1
  'c' =&gt; 3
  'b' =&gt; 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is common to use tuples as keys in dictionaries. For example, a telephone directory might map from last-name, first-name pairs to telephone numbers. Assuming that we have defined <code>last</code>, <code>first</code> and <code>number</code>, we could write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">directory[last, first] = number</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression in brackets is a tuple. We could use tuple assignment to traverse this dictionary.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">for ((last, first), number) in directory
    println(first, " ", last, " ", number)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>This loop traverses the key-value pairs in <code>directory</code>, which are tuples. It assigns the elements of the key in each tuple to <code>last</code> and <code>first</code>, and the value to <code>number</code>, then prints the name and corresponding telephone number.</p>
</div>
<div class="paragraph">
<p>There are two ways to represent tuples in a state diagram. The more detailed version shows the indices and elements just as they appear in an array. For example, the tuple <code>("Cleese", "John")</code> would appear as in <a href="#fig12-1">State diagram</a>.
</p>
</div>
<div id="fig12-1" class="imageblock">
<div class="content">
<img src="images/fig121.svg" alt="fig121">
</div>
<div class="title">Figure 18. State diagram</div>
</div>
<div class="paragraph">
<p>But in a larger diagram you might want to leave out the details. For example, a diagram of the telephone directory might appear as in <a href="#fig12-2">State diagram</a>.
</p>
</div>
<div id="fig12-2" class="imageblock">
<div class="content">
<img src="images/fig122.svg" alt="fig122">
</div>
<div class="title">Figure 19. State diagram</div>
</div>
<div class="paragraph">
<p>Here the tuples are shown using Julia syntax as a graphical shorthand. The telephone number in the diagram is the complaints line for the BBC, so please don’t call it.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sequences_of_sequences">Sequences of Sequences</h3>
<div class="paragraph">
<p>I have focused on arrays of tuples, but almost all of the examples in this chapter also work with arrays of arrays, tuples of tuples, and tuples of arrays. To avoid enumerating the possible combinations, it is sometimes easier to talk about sequences of sequences.
</p>
</div>
<div class="paragraph">
<p>In many contexts, the different kinds of sequences (strings, arrays and tuples) can be used interchangeably. So how should you choose one over the others?
</p>
</div>
<div class="paragraph">
<p>To start with the obvious, strings are more limited than other sequences because the elements have to be characters. They are also immutable. If you need the ability to change the characters in a string (as opposed to creating a new string), you might want to use an array of characters instead.
</p>
</div>
<div class="paragraph">
<p>Arrays are more common than tuples, mostly because they are mutable. But there are a few cases where you might prefer tuples:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In some contexts, like a return statement, it is syntactically simpler to create a tuple than an array.</p>
</li>
<li>
<p>If you are passing a sequence as an argument to a function, using tuples reduces the potential for unexpected behavior due to aliasing.
</p>
</li>
<li>
<p>For performance reasons. The compiler can specialize on the type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Because tuples are immutable, they don’t provide functions like <code>sort!</code> and <code>reverse!</code>, which modify existing arrays. But Julia provides the built-in function <code>sort</code>, which takes an array and returns a new array with the same elements in sorted order, and <code>reverse</code>, which takes any sequence and returns a sequence of the same type in reverse order.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_debugging_8">Debugging</h3>
<div class="paragraph">
<p>Arrays, dictionaries and tuples are examples of <em>data structures</em>; in this lecture we are starting to see compound data structures, like arrays of tuples, or dictionaries that contain tuples as keys and arrays as values. Compound data structures are useful, but they are prone to what I call <em>shape errors</em>; that is, errors caused when a data structure has the wrong type, size, or structure. For example, if you are expecting an array with one integer and I give you a plain old integer (not in an array), it won’t work.
</p>
</div>
<div class="paragraph">
<p>Julia allows to attach a type to elements of a sequence. How this is done is detailed in <a href="#chap17">[chap17]</a>. Specifying the type eliminates a lot of shape errors.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossary_9">Glossary</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">tuple</dt>
<dd>
<p>An immutable sequence of elements where every element can have its own type.
</p>
</dd>
<dt class="hdlist1">tuple assignment</dt>
<dd>
<p>An assignment with a sequence on the right side and a tuple of variables on the left. The right side is evaluated and then its elements are assigned to the variables on the left.
</p>
</dd>
<dt class="hdlist1">gather</dt>
<dd>
<p>The operation of assembling a variable-length argument tuple.
</p>
</dd>
<dt class="hdlist1">scatter</dt>
<dd>
<p>The operation of treating a sequence as a list of arguments.
</p>
</dd>
<dt class="hdlist1">zip object</dt>
<dd>
<p>The result of calling a built-in function <code>zip</code>; an object that iterates through a sequence of tuples.
</p>
</dd>
<dt class="hdlist1">iterator</dt>
<dd>
<p>An object that can iterate through a sequence, but which does not provide array operators and functions.
</p>
</dd>
<dt class="hdlist1">data structure</dt>
<dd>
<p>A collection of related values, often organized in array, dictionaries, tuples, etc.
</p>
</dd>
<dt class="hdlist1">shape error</dt>
<dd>
<p>An error caused because a value has the wrong shape; that is, the wrong type or size.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_11">Exercises</h3>
<div class="sect4">
<h5 id="ex12-1">Exercise 12-2</h5>
<div class="paragraph">
<p>Write a function called <code>mostfrequent</code> that takes a string and prints the letters in decreasing order of frequency. Find text samples from several different languages and see how letter frequency varies between languages. Compare your results with the tables at <a href="https://en.wikipedia.org/wiki/Letter_frequencies" class="bare">https://en.wikipedia.org/wiki/Letter_frequencies</a>.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex12-2">Exercise 12-3</h5>
<div class="paragraph">
<p>More anagrams!</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write a program that reads a word list from a file (see <a href="#reading_word_lists">Reading Word Lists</a>) and prints all the sets of words that are anagrams.</p>
<div class="paragraph">
<p>Here is an example of what the output might look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">["deltas", "desalt", "lasted", "salted", "slated", "staled"]
["retainers", "ternaries"]
["generating", "greatening"]
["resmelts", "smelters", "termless"]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>You might want to build a dictionary that maps from a collection of letters to an array of words that can be spelled with those letters. The question is, how can you represent the collection of letters in a way that can be used as a key?</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Modify the previous program so that it prints the longest array of anagrams first, followed by the second longest, and so on.</p>
</li>
<li>
<p>In Scrabble a “bingo” is when you play all seven tiles in your rack, along with a letter on the board, to form an eight-letter word. What collection of 8 letters forms the most possible bingos?</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="ex12-3">Exercise 12-4</h5>
<div class="paragraph">
<p>Two words form a “metathesis pair” if you can transform one into the other by swapping two letters; for example, “converse” and “conserve”. Write a program that finds all of the metathesis pairs in the dictionary.
</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Don’t test all pairs of words, and don’t test all possible swaps.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Credit: This exercise is inspired by an example at <a href="http://puzzlers.org" class="bare">http://puzzlers.org</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex12-4">Exercise 12-5</h5>
<div class="paragraph">
<p>Here’s another Car Talk Puzzler (<a href="https://www.cartalk.com/puzzler/browse" class="bare">https://www.cartalk.com/puzzler/browse</a>):
</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>What is the longest English word, that remains a valid English word, as you remove its letters one at a time?</p>
</div>
<div class="paragraph">
<p>Now, letters can be removed from either end, or the middle, but you can’t rearrange any of the letters. Every time you drop a letter, you wind up with another English word. If you do that, you’re eventually going to wind up with one letter and that too is going to be an English word—one that’s found in the dictionary. I want to know what’s the longest word and how many letters does it have?</p>
</div>
<div class="paragraph">
<p>I’m going to give you a little modest example: Sprite. Ok? You start off with sprite, you take a letter off, one from the interior of the word, take the r away, and we’re left with the word spite, then we take the e off the end, we’re left with spit, we take the s off, we’re left with pit, it, and I.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Write a program to find all words that can be reduced in this way, and then find the longest one.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>This exercise is a little more challenging than most, so here are some suggestions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You might want to write a function that takes a word and computes an array of all the words that can be formed by removing one letter. These are the “children” of the word.</p>
</li>
<li>
<p>Recursively, a word is reducible if any of its children are reducible. As a base case, you can consider the empty string reducible.
</p>
</li>
<li>
<p>The word list I provided, <em>words.txt</em>, doesn’t contain single letter words. So you might want to add “I”, “a”, and the empty string.</p>
</li>
<li>
<p>To improve the performance of your program, you might want to memoize the words that are known to be reducible.
</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap13">16. Case Study: Data Structure Selection</h2>
<div class="sectionbody">
<div class="paragraph">
<p>At this point you have learned about Julia’s core data structures, and you have seen some of the algorithms that use them.</p>
</div>
<div class="paragraph">
<p>This chapter presents a case study with exercises that let you think about choosing data structures and practice using them.</p>
</div>
<div class="sect2">
<h3 id="_word_frequency_analysis">Word Frequency Analysis</h3>
<div class="paragraph">
<p>As usual, you should at least attempt the exercises before you read my solutions.</p>
</div>
<div class="sect4">
<h5 id="ex13-1">Exercise 13-1</h5>
<div class="paragraph">
<p>Write a program that reads a file, breaks each line into words, strips whitespace and punctuation from the words, and converts them to lowercase.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>The function <code>isletter</code> tests whether a character is alphabetic.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ex13-2">Exercise 13-2</h5>
<div class="paragraph">
<p>Go to Project Gutenberg (<a href="https://gutenberg.org" class="bare">https://gutenberg.org</a>) and download your favorite out-of-copyright book in plain text format.
</p>
</div>
<div class="paragraph">
<p>Modify your program from the previous exercise to read the book you downloaded, skip over the header information at the beginning of the file, and process the rest of the words as before.</p>
</div>
<div class="paragraph">
<p>Then modify the program to count the total number of words in the book, and the number of times each word is used.</p>
</div>
<div class="paragraph">
<p>Print the number of different words used in the book. Compare different books by different authors, written in different eras. Which author uses the most extensive vocabulary?</p>
</div>
</div>
<div class="sect4">
<h5 id="ex13-3">Exercise 13-3</h5>
<div class="paragraph">
<p>Modify the program from the previous exercise to print the 20 most frequently used words in the book.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex13-4">Exercise 13-4</h5>
<div class="paragraph">
<p>Modify the previous program to read a word list and then print all the words in the book that are not in the word list. How many of them are typos? How many of them are common words that should be in the word list, and how many of them are really obscure?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_random_numbers">Random Numbers</h3>
<div class="paragraph">
<p>Given the same inputs, most computer programs generate the same outputs every time, so they are said to be <em>deterministic</em>. Determinism is usually a good thing, since we expect the same calculation to yield the same result. For some applications, though, we want the computer to be unpredictable. Games are an obvious example, but there are more.
</p>
</div>
<div class="paragraph">
<p>Making a program truly nondeterministic turns out to be difficult, but there are ways to make it at least seem nondeterministic. One of them is to use algorithms that generate <em>pseudorandom</em> numbers. Pseudorandom numbers are not truly random because they are generated by a deterministic computation, but just by looking at the numbers it is all but impossible to distinguish them from random.
</p>
</div>
<div class="paragraph">
<p>The function <code>rand</code> returns a random float between <code>0.0</code> and <code>1.0</code> (including 0.0 but not 1.0). Each time you call <code>rand</code>, you get the next number in a long series. To see a sample, run this loop:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">for i in 1:10
    x = rand()
    println(x)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function <code>rand</code> can take an iterator or array as argument and returns a random element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">for i in 1:10
    x = rand(1:6)
    print(x, " ")
end</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="ex13-5">Exercise 13-5</h5>
<div class="paragraph">
<p>Write a function named <code>choosefromhist</code> that takes a histogram as defined in <a href="#dictionary_collection_counters">Dictionary as a Collection of Counters</a> and returns a random value from the histogram, chosen with probability in proportion to frequency. For example, for this histogram:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t = ['a', 'a', 'b'];

julia&gt; histogram(t)
Dict{Any,Any} with 2 entries:
  'a' =&gt; 2
  'b' =&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>your function should return <code>'a'</code> with probability \(\frac{2}{3}\) and <code>'b'</code> with probability \(\frac{1}{3}\).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_word_histogram">Word Histogram</h3>
<div class="paragraph">
<p>You should attempt the previous exercises before you go on. You will also need <a href="https://github.com/BenLauwens/ThinkJulia.jl/blob/master/data/emma.txt" class="bare">https://github.com/BenLauwens/ThinkJulia.jl/blob/master/data/emma.txt</a>.</p>
</div>
<div class="paragraph">
<p>Here is a program that reads a file and builds a histogram of the words in the file:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function processfile(filename)
    hist = Dict()
    for line in eachline(filename)
        processline(line, hist)
    end
    hist
end;

function processline(line, hist)
    line = replace(line, '-' =&gt; ' ')
    for word in split(line)
        word = string(filter(isletter, [word...])...)
        word = lowercase(word)
        hist[word] = get!(hist, word, 0) + 1
    end
end;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">hist = processfile("emma.txt");</code></pre>
</div>
</div>
<div class="paragraph">
<p>This program reads <em>emma.txt</em>, which contains the text of <em>Emma</em> by Jane Austen.
</p>
</div>
<div class="paragraph">
<p><code>processfile</code> loops through the lines of the file, passing them one at a time to <code>processline</code>. The histogram <code>hist</code> is being used as an accumulator.
</p>
</div>
<div class="paragraph">
<p><code>processline</code> uses the function <code>replace</code> to replace hyphens with spaces before using <code>split</code> to break the line into an array of strings. It traverses the array of words and uses <code>filter</code>, <code>isletter</code> and <code>lowercase</code> to remove punctuation and convert to lower case. (It is a shorthand to say that strings are “converted”; remember that strings are immutable, so a function like <code>lowercase</code> return new strings.)
</p>
</div>
<div class="paragraph">
<p>Finally, <code>processline</code> updates the histogram by creating a new item or incrementing an existing one.</p>
</div>
<div class="paragraph">
<p>To count the total number of words in the file, we can add up the frequencies in the histogram:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function totalwords(hist)
    sum(values(hist))
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The number of different words is just the number of items in the dictionary:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function differentwords(hist)
    length(hist)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is some code to print the results:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; println("Total number of words: ", totalwords(hist))
Total number of words: 162742

julia&gt; println("Number of different words: ", differentwords(hist))
Number of different words: 7380</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_most_common_words">Most Common Words</h3>
<div class="paragraph">
<p>To find the most common words, we can make an array of tuples, where each tuple contains a word and its frequency, and sort it. The following function takes a histogram and returns an array of word-frequency tuples:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function mostcommon(hist)
    t = []
    for (key, value) in hist
        push!(t, (value, key))
    end
    reverse(sort(t))
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>In each tuple, the frequency appears first, so the resulting array is sorted by frequency. Here is a loop that prints the 10 most common words:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">t = mostcommon(hist)
println("The most common words are:")
for (freq, word) in t[1:10]
    println(word, "\t", freq)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>I use a tab character (<code>'\t'</code>) as a “separator”, rather than a space, so the second column is lined up. Here are the results from <em>Emma</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The most common words are:
to	5295
the	5266
and	4931
of	4339
i	3191
a	3155
it	2546
her	2483
was	2400
she	2364</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>This code can be simplified using the <code>rev</code> keyword argument of the <code>sort</code> function. You can read about it at <a href="https://docs.julialang.org/en/v1/base/sort/#Base.sort" class="bare">https://docs.julialang.org/en/v1/base/sort/#Base.sort</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_optional_parameters">Optional Parameters</h3>
<div class="paragraph">
<p>We have seen built-in functions that take optional arguments. It is possible to write programmer-defined functions with optional arguments, too. For example, here is a function that prints the most common words in a histogram:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function printmostcommon(hist, num=10)
    t = mostcommon(hist)
    println("The most common words are: ")
    for (freq, word) in t[1:num]
        println(word, "\t", freq)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first parameter is required; the second is optional. The <em>default value</em> of <code>num</code> is <code>10</code>.
</p>
</div>
<div class="paragraph">
<p>If you only provide one argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">printmostcommon(hist)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>num</code> gets the default value. If you provide two arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">printmostcommon(hist, 20)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>num</code> gets the value of the argument instead. In other words, the optional argument <em>overrides</em> the default value.
</p>
</div>
<div class="paragraph">
<p>If a function has both required and optional parameters, all the required parameters have to come first, followed by the optional ones.</p>
</div>
</div>
<div class="sect2">
<h3 id="dictionary_subtraction">Dictionary Subtraction</h3>
<div class="paragraph">
<p>Finding the words from the book that are not in the word list from <code>words.txt</code> is a problem you might recognize as set subtraction; that is, we want to find all the words from one set (the words in the book) that are not in the other (the words in the list).</p>
</div>
<div class="paragraph">
<p><code>subtract</code> takes dictionaries <code>d1</code> and <code>d2</code> and returns a new dictionary that contains all the keys from <code>d1</code> that are not in <code>d2</code>. Since we don’t really care about the values, we set them all to <code>nothing</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function subtract(d1, d2)
    res = Dict()
    for key in keys(d1)
        if key ∉ keys(d2)
            res[key] = nothing
        end
    end
    res
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>To find the words in the book that are not in <code>words.txt</code>, we can use <code>processfile</code> to build a histogram for <code>words.txt</code>, and then <code>subtract</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">words = processfile("words.txt")
diff = subtract(hist, words)

println("Words in the book that aren't in the word list:")
for word in keys(diff)
    print(word, " ")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here are some of the results from <em>Emma</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>Words in the book that aren't in the word list:
outree quicksighted outwardly adelaide rencontre jeffereys unreserved dixons betweens ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some of these words are names and possessives. Others, like “rencontre”, are no longer in common use. But a few are common words that should really be in the list!</p>
</div>
<div class="sect4">
<h5 id="ex13-6">Exercise 13-6</h5>
<div class="paragraph">
<p>Julia provides a data structure called <code>Set</code> that provides many common set operations. You can read about them in <a href="#collections_and_data_structures">[collections_and_data_structures]</a>, or read the documentation at <a href="https://docs.julialang.org/en/v1/base/collections/#Set-Like-Collections-1" class="bare">https://docs.julialang.org/en/v1/base/collections/#Set-Like-Collections-1</a>.</p>
</div>
<div class="paragraph">
<p>Write a program that uses set subtraction to find words in the book that are not in the word list.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_random_words">Random Words</h3>
<div class="paragraph">
<p>To choose a random word from the histogram, the simplest algorithm is to build an array with multiple copies of each word, according to the observed frequency, and then choose from the array:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function randomword(h)
    t = []
    for (word, freq) in h
        for i in 1:freq
            push!(t, word)
        end
    end
    rand(t)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>This algorithm works, but it is not very efficient; each time you choose a random word, it rebuilds the array, which is as big as the original book. An obvious improvement is to build the array once and then make multiple selections, but the array is still big.</p>
</div>
<div class="paragraph">
<p>An alternative is:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use <code>keys</code> to get an array of the words in the book.</p>
</li>
<li>
<p>Build an array that contains the cumulative sum of the word frequencies (see <a href="#ex10-2">Exercise 10-2</a>). The last item in this array is the total number of words in the book, \(n\).</p>
</li>
<li>
<p>Choose a random number from 1 to \(n\). Use a bisection search (see <a href="#ex10-10">Exercise 10-10</a>) to find the index where the random number would be inserted in the cumulative sum.
</p>
</li>
<li>
<p>Use the index to find the corresponding word in the word array.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="ex13-7">Exercise 13-7</h5>
<div class="paragraph">
<p>Write a program that uses this algorithm to choose a random word from the book.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="markov_analysis">Markov Analysis</h3>
<div class="paragraph">
<p>If you choose words from the book at random, you can get a sense of the vocabulary, but you probably won’t get a sentence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>this the small regard harriet which knightley's it most things</code></pre>
</div>
</div>
<div class="paragraph">
<p>A series of random words seldom makes sense because there is no relationship between successive words. For example, in a real sentence you would expect an article like “the” to be followed by an adjective or a noun, and probably not a verb or adverb.</p>
</div>
<div class="paragraph">
<p>One way to measure these kinds of relationships is Markov analysis, which characterizes, for a given sequence of words, the probability of the words that might come next. For example, the song <em>Eric, the Half a Bee</em> (by Monty Python) begins:
</p>
</div>
<div class="verseblock">
<pre class="content">Half a bee, philosophically,
Must, ipso facto, half not be.
But half the bee has got to be
Vis a vis, its entity. D’you see?

But can a bee be said to be
Or not to be an entire bee
When half the bee is not a bee
Due to some ancient injury?</pre>
</div>
<div class="paragraph">
<p>In this text, the phrase “half the” is always followed by the word “bee”, but the phrase “the bee” might be followed by either “has” or “is”.</p>
</div>
<div class="paragraph">
<p>The result of Markov analysis is a mapping from each prefix (like “half the” and “the bee”) to all possible suffixes (like “has” and “is”).
</p>
</div>
<div class="paragraph">
<p>Given this mapping, you can generate a random text by starting with any prefix and choosing at random from the possible suffixes. Next, you can combine the end of the prefix and the new suffix to form the next prefix, and repeat.</p>
</div>
<div class="paragraph">
<p>For example, if you start with the prefix “Half a”, then the next word has to be “bee”, because the prefix only appears once in the text. The next prefix is “a bee”, so the next suffix might be “philosophically”, “be” or “due”.</p>
</div>
<div class="paragraph">
<p>In this example the length of the prefix is always two, but you can do Markov analysis with any prefix length.</p>
</div>
<div class="sect4">
<h5 id="ex13-8">Exercise 13-8</h5>
<div class="paragraph">
<p>Markov analysis:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write a program to read a text from a file and perform Markov analysis. The result should be a dictionary that maps from prefixes to a collection of possible suffixes. The collection might be an array, tuple, or dictionary; it is up to you to make an appropriate choice. You can test your program with prefix length two, but you should write the program in a way that makes it easy to try other lengths.</p>
</li>
<li>
<p>Add a function to the previous program to generate random text based on the Markov analysis. Here is an example from Emma with prefix length 2:</p>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>“He was very clever, be it sweetness or be angry, ashamed or only amused, at such a stroke. She had never thought of Hannah till you were never meant for me?" "I cannot make speeches, Emma:" he soon cut it all himself.”</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>For this example, I left the punctuation attached to the words. The result is almost syntactically correct, but not quite. Semantically, it almost makes sense, but not quite.</p>
</div>
<div class="paragraph">
<p>What happens if you increase the prefix length? Does the random text make more sense?</p>
</div>
</li>
<li>
<p>Once your program is working, you might want to try a mash-up:  if you combine text from two or more books, the random text you generate will blend the vocabulary and phrases from the sources in interesting ways.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Credit: This case study is based on an example from Kernighan and Pike, The Practice of Programming, Addison-Wesley, 1999.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>You should attempt this exercise before you go on.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_data_structures">Data Structures</h3>
<div class="paragraph">
<p>Using Markov analysis to generate random text is fun, but there is also a point to this exercise: data structure selection. In your solution to the previous exercises, you had to choose:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How to represent the prefixes.</p>
</li>
<li>
<p>How to represent the collection of possible suffixes.</p>
</li>
<li>
<p>How to represent the mapping from each prefix to the collection of possible suffixes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The last one is easy: a dictionary is the obvious choice for a mapping from keys to corresponding values.</p>
</div>
<div class="paragraph">
<p>For the prefixes, the most obvious options are string, array of strings, or tuple of strings.</p>
</div>
<div class="paragraph">
<p>For the suffixes, one option is an array; another is a histogram (dictionary).</p>
</div>
<div class="paragraph">
<p>How should you choose? The first step is to think about the operations you will need to implement for each data structure. For the prefixes, we need to be able to remove words from the beginning and add to the end. For example, if the current prefix is “Half a”, and the next word is “bee”, you need to be able to form the next prefix, “a bee”.</p>
</div>
<div class="paragraph">
<p>Your first choice might be an array, since it is easy to add and remove elements.</p>
</div>
<div class="paragraph">
<p>For the collection of suffixes, the operations we need to perform include adding a new suffix (or increasing the frequency of an existing one), and choosing a random suffix.</p>
</div>
<div class="paragraph">
<p>Adding a new suffix is equally easy for the array implementation or the histogram. Choosing a random element from an array is easy; choosing from a histogram is harder to do efficiently (see <a href="#ex13-7">Exercise 13-7</a>).</p>
</div>
<div class="paragraph">
<p>So far we have been talking mostly about ease of implementation, but there are other factors to consider in choosing data structures. One is run time. Sometimes there is a theoretical reason to expect one data structure to be faster than other; for example, I mentioned that the <code>in</code> operator is faster for dictionaries than for arrays, at least when the number of elements is large.</p>
</div>
<div class="paragraph">
<p>But often you don’t know ahead of time which implementation will be faster. One option is to implement both of them and see which is better. This approach is called <em>benchmarking</em>. A practical alternative is to choose the data structure that is easiest to implement, and then see if it is fast enough for the intended application. If so, there is no need to go on. If not, there are tools, like the <code>Profile</code> module, that can identify the places in a program that take the most time.
</p>
</div>
<div class="paragraph">
<p>The other factor to consider is storage space. For example, using a histogram for the collection of suffixes might take less space because you only have to store each word once, no matter how many times it appears in the text. In some cases, saving space can also make your program run faster, and in the extreme, your program might not run at all if you run out of memory. But for many applications, space is a secondary consideration after run time.</p>
</div>
<div class="paragraph">
<p>One final thought: in this discussion, I have implied that we should use one data structure for both analysis and generation. But since these are separate phases, it would also be possible to use one structure for analysis and then convert to another structure for generation. This would be a net win if the time saved during generation exceeded the time spent in conversion.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>The Julia package <code>DataStructures</code> (see <a href="https://github.com/JuliaCollections/DataStructures.jl" class="bare">https://github.com/JuliaCollections/DataStructures.jl</a>) implements a variety of data structures.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_debugging_9">Debugging</h3>
<div class="paragraph">
<p>When you are debugging a program, and especially if you are working on a hard bug, there are five things to try:
</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Reading</dt>
<dd>
<p>Examine your code, read it back to yourself, and check that it says what you meant to say.</p>
</dd>
<dt class="hdlist1">Running</dt>
<dd>
<p>Experiment by making changes and running different versions. Often if you display the right thing at the right place in the program, the problem becomes obvious, but sometimes you have to build scaffolding.</p>
</dd>
<dt class="hdlist1">Ruminating</dt>
<dd>
<p>Take some time to think! What kind of error is it: syntax, runtime, or semantic? What information can you get from the error messages, or from the output of the program? What kind of error could cause the problem you’re seeing? What did you change last, before the problem appeared?</p>
</dd>
<dt class="hdlist1">Rubberducking</dt>
<dd>
<p>If you explain the problem to someone else, you sometimes find the answer before you finish asking the question. Often you don’t need the other person; you could just talk to a rubber duck. And that’s the origin of the well-known strategy called rubber duck debugging. I am not making this up; see <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging" class="bare">https://en.wikipedia.org/wiki/Rubber_duck_debugging</a>.
</p>
</dd>
<dt class="hdlist1">Retreating</dt>
<dd>
<p>At some point, the best thing to do is back off, undoing recent changes, until you get back to a program that works and that you understand. Then you can start rebuilding.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Beginning programmers sometimes get stuck on one of these activities and forget the others. Each activity comes with its own failure mode.</p>
</div>
<div class="paragraph">
<p>For example, reading your code might help if the problem is a typographical error, but not if the problem is a conceptual misunderstanding. If you don’t understand what your program does, you can read it 100 times and never see the error, because the error is in your head.</p>
</div>
<div class="paragraph">
<p>Running experiments can help, especially if you run small, simple tests. But if you run experiments without thinking or reading your code, you might fall into a pattern I call “random walk programming”, which is the process of making random changes until the program does the right thing. Needless to say, random walk programming can take a long time.
</p>
</div>
<div class="paragraph">
<p>You have to take time to think. Debugging is like an experimental science. You should have at least one hypothesis about what the problem is. If there are two or more possibilities, try to think of a test that would eliminate one of them.</p>
</div>
<div class="paragraph">
<p>But even the best debugging techniques will fail if there are too many errors, or if the code you are trying to fix is too big and complicated. Sometimes the best option is to retreat, simplifying the program until you get to something that works and that you understand.</p>
</div>
<div class="paragraph">
<p>Beginning programmers are often reluctant to retreat because they can’t stand to delete a line of code (even if it’s wrong). If it makes you feel better, copy your program into another file before you start stripping it down. Then you can copy the pieces back one at a time.</p>
</div>
<div class="paragraph">
<p>Finding a hard bug requires reading, running, ruminating, and sometimes retreating. If you get stuck on one of these activities, try the others.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossary_10">Glossary</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">deterministic</dt>
<dd>
<p>Pertaining to a program that does the same thing each time it runs, given the same inputs.
</p>
</dd>
<dt class="hdlist1">pseudorandom</dt>
<dd>
<p>Pertaining to a sequence of numbers that appears to be random, but is generated by a deterministic program.
</p>
</dd>
<dt class="hdlist1">default value</dt>
<dd>
<p>The value given to an optional parameter if no argument is provided.
</p>
</dd>
<dt class="hdlist1">override</dt>
<dd>
<p>To replace a default value with an argument.
</p>
</dd>
<dt class="hdlist1">benchmarking</dt>
<dd>
<p>The process of choosing between data structures by implementing alternatives and testing them on a sample of the possible inputs.
</p>
</dd>
<dt class="hdlist1">rubber duck debugging</dt>
<dd>
<p>Debugging by explaining your problem to an inanimate object such as a rubber duck. Articulating the problem can help you solve it, even if the rubber duck doesn’t know Julia.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_12">Exercises</h3>
<div class="sect4">
<h5 id="ex13-9">Exercise 13-9</h5>
<div class="paragraph">
<p>The “rank” of a word is its position in an array of words sorted by frequency: the most common word has rank 1, the second most common has rank 2, etc.</p>
</div>
<div class="paragraph">
<p>Zipf’s law describes a relationship between the ranks and frequencies of words in natural languages (<a href="https://en.wikipedia.org/wiki/Zipf&apos;s_law" class="bare">https://en.wikipedia.org/wiki/Zipf&apos;s_law</a>). Specifically, it predicts that the frequency, \(f\), of the word with rank \(r\) is:
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{f = c r^{-s}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>where \(s\) and \(c\) are parameters that depend on the language and the text. If you take the logarithm of both sides of this equation, you get:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{\log f = \log c - s \log r}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>So if you plot \(\log f\) versus \(\log r\), you should get a straight line with slope \(-s\) and intercept \(\log c\).</p>
</div>
<div class="paragraph">
<p>Write a program that reads a text from a file, counts word frequencies, and prints one line for each word, in descending order of frequency, with \(\log f\) and \(\log r\).</p>
</div>
<div class="paragraph">
<p>Install a plotting library:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">(v1.0) pkg&gt; add Plots</code></pre>
</div>
</div>
<div class="paragraph">
<p>Its usage is very easy:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">using Plots
x = 1:10
y = x.^2
plot(x, y)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use the <code>Plots</code> library to plot the results and check whether they form a straight line.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap14">17. Files</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter introduces the idea of “persistent” programs that keep data in permanent storage, and shows how to use different kinds of permanent storage, like files and databases.</p>
</div>
<div class="sect2">
<h3 id="_persistence">Persistence</h3>
<div class="paragraph">
<p>Most of the programs we have seen so far are transient in the sense that they run for a short time and produce some output, but when they end, their data disappears. If you run the program again, it starts with a clean slate.
</p>
</div>
<div class="paragraph">
<p>Other programs are <em>persistent</em>: they run for a long time (or all the time); they keep at least some of their data in permanent storage (a hard drive, for example); and if they shut down and restart, they pick up where they left off.
</p>
</div>
<div class="paragraph">
<p>Examples of persistent programs are operating systems, which run pretty much whenever a computer is on, and web servers, which run all the time, waiting for requests to come in on the network.</p>
</div>
<div class="paragraph">
<p>One of the simplest ways for programs to maintain their data is by reading and writing <em>text files</em>. We have already seen programs that read text files; in this chapter we will see programs that write them.</p>
</div>
<div class="paragraph">
<p>An alternative is to store the state of the program in a database. In this chapter I will also present how to use a simple database.</p>
</div>
</div>
<div class="sect2">
<h3 id="reading_and_writing">Reading and Writing</h3>
<div class="paragraph">
<p>A text file is a sequence of characters stored on a permanent medium like a hard drive, or flash memory. We saw how to open and read a file in <a href="#reading_word_lists">Reading Word Lists</a>.</p>
</div>
<div class="paragraph">
<p>To write a file, you have to open it with mode <code>"w"</code> as a second parameter:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; fout = open("output.txt", "w")
IOStream(&lt;file output.txt&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the file already exists, opening it in write mode clears out the old data and starts fresh, so be careful! If the file doesn’t exist, a new one is created. <code>open</code> returns a file object and the <code>write</code> function puts data into the file.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; line1 = "This here's the wattle,\n";

julia&gt; write(fout, line1)
24</code></pre>
</div>
</div>
<div class="paragraph">
<p>The return value is the number of characters that were written. The file object keeps track of where it is, so if you call <code>write</code> again, it adds the new data to the end of the file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; line2 = "the emblem of our land.\n";

julia&gt; write(fout, line2)
24</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you are done writing, you should close the file.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; close(fout)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don’t close the file, it gets closed for you when the program ends.</p>
</div>
</div>
<div class="sect2">
<h3 id="_formatting">Formatting</h3>
<div class="paragraph">
<p>The argument of write has to be a string, so if we want to put other values in a file, we have to convert them to strings. The easiest way to do that is with <code>string</code> or string interpolation:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; fout = open("output.txt", "w")
IOStream(&lt;file output.txt&gt;)
julia&gt; write(fout, string(150))
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>An alternative is to use the <code>print(ln)</code> family of functions.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; camels = 42
42
julia&gt; println(fout, "I have spotted $camels camels.")</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>A more powerful alternative is the <code>@printf</code> macro that prints using a C style format specification string, which you can read about at <a href="https://docs.julialang.org/en/v1/stdlib/Printf/" class="bare">https://docs.julialang.org/en/v1/stdlib/Printf/</a>
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_filenames_and_paths">Filenames and Paths</h3>
<div class="paragraph">
<p>Files are organized into <em>directories</em> (also called “folders”). Every running program has a “current directory”, which is the default directory for most operations. For example, when you open a file for reading, Julia looks for it in the current directory.
</p>
</div>
<div class="paragraph">
<p>The function <code>pwd</code> returns the name of the current directory:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; cwd = pwd()
"/home/ben"</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>cwd</code> stands for “current working directory”. The result in this example is <code>/home/ben</code>, which is the home directory of a user named <code>ben</code>.</p>
</div>
<div class="paragraph">
<p>A string like <code>"/home/ben"</code> that identifies a file or directory is called a <em>path</em>.
</p>
</div>
<div class="paragraph">
<p>A simple filename, like <code>memo.txt</code> is also considered a path, but it is a <em>relative path</em> because it relates to the current directory. If the current directory is <code>/home/ben</code>, the filename <code>memo.txt</code> would refer to <code>/home/ben/memo.txt</code>.
</p>
</div>
<div class="paragraph">
<p>A path that begins with <code>/</code> does not depend on the current directory; it is called an <em>absolute path</em>. To find the absolute path to a file, you can use <code>abspath</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; abspath("memo.txt")
"/home/ben/memo.txt"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Julia provides other functions for working with filenames and paths. For example, <code>ispath</code> checks whether a file or directory exists:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; ispath("memo.txt")
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>If it exists, <code>isdir</code> checks whether it’s a directory:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; isdir("memo.txt")
false
julia&gt; isdir("/home/ben")
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, <code>isfile</code> checks whether it’s a file.
</p>
</div>
<div class="paragraph">
<p><code>readdir</code> returns an array of the files (and other directories) in the given directory:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; readdir(cwd)
3-element Array{String,1}:
 "memo.txt"
 "music"
 "photos"</code></pre>
</div>
</div>
<div class="paragraph">
<p>To demonstrate these functions, the following example “walks” through a directory, prints the names of all the files, and calls itself recursively on all the directories.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function walk(dirname)
    for name in readdir(dirname)
        path = joinpath(dirname, name)
        if isfile(path)
            println(path)
        else
            walk(path)
        end
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>joinpath</code> takes a directory and a file name and joins them into a complete path.
</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Julia provides a function called <code>walkdir</code> (see <a href="https://docs.julialang.org/en/v1/base/file/#Base.Filesystem.walkdir" class="bare">https://docs.julialang.org/en/v1/base/file/#Base.Filesystem.walkdir</a>) that is similar to this one but more versatile. As an exercise, read the documentation and use it to print the names of the files in a given directory and its subdirectories.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="catching_exceptions">Catching Exceptions</h3>
<div class="paragraph">
<p>A lot of things can go wrong when you try to read and write files. If you try to open a file that doesn’t exist, you get a <code>SystemError</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; fin = open("bad_file")
ERROR: SystemError: opening file "bad_file": No such file or directory</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don’t have permission to access a file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; fout = open("/etc/passwd", "w")
ERROR: SystemError: opening file "/etc/passwd": Permission denied</code></pre>
</div>
</div>
<div class="paragraph">
<p>To avoid these errors, you could use functions like <code>ispath</code> and <code>isfile</code>, but it would take a lot of time and code to check all the possibilities.</p>
</div>
<div class="paragraph">
<p>It is easier to go ahead and try—and deal with problems if they happen—which is exactly what the <code>try</code> statement does. The syntax is similar to an <code>if</code> statement:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">try
    fin = open("bad_file.txt")
catch exc
    println("Something went wrong: $exc")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Julia starts by executing the <code>try</code> clause. If all goes well, it skips the <code>catch</code> clause and proceeds. If an exception occurs, it jumps out of the <code>try</code> clause and runs the <code>catch</code> clause.</p>
</div>
<div class="paragraph">
<p>Handling an exception with a <code>try</code> statement is called <em>catching</em> an exception. In this example, the except clause prints an error message that is not very helpful. In general, catching an exception gives you a chance to fix the problem, or try again, or at least end the program gracefully.
</p>
</div>
<div class="paragraph">
<p>In code that performs state changes or uses resources like files, there is typically clean-up work (such as closing files) that needs to be done when the code is finished. Exceptions potentially complicate this task, since they can cause a block of code to exit before reaching its normal end. The <code>finally</code> keyword provides a way to run some code when a given block of code exits, regardless of how it exits:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">f = open("output.txt")
try
    line = readline(f)
    println(line)
finally
    close(f)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function <code>close</code> will always be executed.</p>
</div>
</div>
<div class="sect2">
<h3 id="databases">Databases</h3>
<div class="paragraph">
<p>A <em>database</em> is a file that is organized for storing data. Many databases are organized like a dictionary in the sense that they map from keys to values. The biggest difference between a database and a dictionary is that the database is on disk (or other permanent storage), so it persists after the program ends.
</p>
</div>
<div class="paragraph">
<p>ThinkJulia provides an interface to <code>GDBM</code> (GNU dbm) for creating and updating database files. As an example, I’ll create a database that contains captions for image files.
</p>
</div>
<div class="paragraph">
<p>Opening a database is similar to opening other files:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; using ThinkJulia

julia&gt; db = DBM("captions", "c")
DBM(&lt;captions&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The mode "c" means that the database should be created if it doesn’t already exist. The result is a database object that can be used (for most operations) like a dictionary.</p>
</div>
<div class="paragraph">
<p>When you create a new item, <code>GDBM</code> updates the database file:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; db["cleese.png"] = "Photo of John Cleese."
"Photo of John Cleese."</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you access one of the items, <code>GDBM</code> reads the file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; db["cleese.png"]
"Photo of John Cleese."</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you make another assignment to an existing key, <code>GDBM</code> replaces the old value:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; db["cleese.png"] = "Photo of John Cleese doing a silly walk."
"Photo of John Cleese doing a silly walk."
julia&gt; db["cleese.png"]
"Photo of John Cleese doing a silly walk."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some functions having a dictionary as argument, like <code>keys</code> and <code>values</code>, don’t work with database objects. But iteration with a <code>for</code> loop works:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">for (key, value) in db
    println(key, ": ", value)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with other files, you should close the database when you are done:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; close(db)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_serialization">Serialization</h3>
<div class="paragraph">
<p>A limitation of <code>GDBM</code> is that the keys and the values have to be strings or byte arrays. If you try to use any other type, you get an error.</p>
</div>
<div class="paragraph">
<p>The functions <code>serialize</code> and <code>deserialize</code> can help. They translate almost any type of object into a byte array (an iobuffer) suitable for storage in a database, and then translates byte arrays back into objects:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; using Serialization

julia&gt; io = IOBuffer();

julia&gt; t = [1, 2, 3];

julia&gt; serialize(io, t)
24
julia&gt; print(take!(io))
UInt8[0x37, 0x4a, 0x4c, 0x09, 0x04, 0x00, 0x00, 0x00, 0x15, 0x00, 0x08, 0xe2, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The format isn’t obvious to human readers; it is meant to be easy for Julia to interpret. <code>deserialize</code> reconstitutes the object:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; io = IOBuffer();

julia&gt; t1 = [1, 2, 3];

julia&gt; serialize(io, t1)
24
julia&gt; s = take!(io);

julia&gt; t2 = deserialize(IOBuffer(s));

julia&gt; print(t2)
[1, 2, 3]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>serialize</code> and <code>deserialize</code> write to and read from a iobuffer object which represents an in-memory I/O stream. The function <code>take!</code> fetches the contents of the iobuffer as a byte array and resets the iobuffer to its initial state.</p>
</div>
<div class="paragraph">
<p>Although the new object has the same value as the old, it is not (in general) the same object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; t1 == t2
true
julia&gt; t1 ≡ t2
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>In other words, serialization and then deserialization has the same effect as copying the object.
</p>
</div>
<div class="paragraph">
<p>You can use this to store non-strings in a database.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>In fact, the storage of non-string in a database is so common that it has been encapsulated in a package called <code>JLD2</code> (see <a href="https://github.com/JuliaIO/JLD2.jl" class="bare">https://github.com/JuliaIO/JLD2.jl</a>).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_command_objects">Command Objects</h3>
<div class="paragraph">
<p>Most operating systems provide a command-line interface, also known as a <em>shell</em>. Shells usually provide commands to navigate the file system and launch applications. For example, in Unix you can change directories with <code>cd</code>, display the contents of a directory with <code>ls</code>, and launch a web browser by typing (for example) <code>firefox</code>.
</p>
</div>
<div class="paragraph">
<p>Any program that you can launch from the shell can also be launched from Julia using a <em>command object</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; cmd = `echo hello`
`echo hello`</code></pre>
</div>
</div>
<div class="paragraph">
<p>Backticks are used to delimit the command.</p>
</div>
<div class="paragraph">
<p>The function <code>run</code> executes the command:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; run(cmd);
hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>hello</code> is the output of the echo command, sent to <code>STDOUT</code>. The <code>run</code> function itself returns a process object, and throws an <code>ErrorException</code> if the external command fails to run successfully.</p>
</div>
<div class="paragraph">
<p>If you want to read the output of the external command, <code>read</code> can be used instead:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; a = read(cmd, String)
"hello\n"</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example, most Unix systems provide a command called <code>md5sum</code> or <code>md5</code> that reads the contents of a file and computes a “checksum”. You can read about MD5 at <a href="https://en.wikipedia.org/wiki/Md5" class="bare">https://en.wikipedia.org/wiki/Md5</a>. This command provides an efficient way to check whether two files have the same contents. The probability that different contents yield the same checksum is very small (that is, unlikely to happen before the universe collapses).
</p>
</div>
<div class="paragraph">
<p>You can use a command object to run <code>md5</code> from Julia and get the result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; filename = "output.txt"
"output.txt"
julia&gt; cmd = `md5 $filename`
`md5 output.txt`
julia&gt; res = read(cmd, String)
ERROR: IOError: could not spawn `md5 output.txt`: no such file or directory (ENOENT)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_modules">Modules</h3>
<div class="paragraph">
<p>Suppose you have a file named <code>"wc.jl"</code> with the following code:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">function linecount(filename)
    count = 0
    for line in eachline(filename)
        count += 1
    end
    count
end

print(linecount("wc.jl"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you run this program, it reads itself and prints the number of lines in the file, which is 9. You can also include it in the REPL like this:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jl-con">julia&gt; include("wc.jl")
9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Julia introduces modules to create separate variable workspace, i.e. new global scopes.</p>
</div>
<div class="paragraph">
<p>A module starts with the keyword <code>module</code> and ends with <code>end</code>. Naming conflicts are avoided between your own top-level definitions and those found in somebody else&#8217;s code. <code>import</code> allows to control which names from other modules are visible and <code>export</code> specifies which of your names are public, i.e. can be used outside the module without being prefixed with the name of the module.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">module LineCount
    export linecount

    function linecount(filename)
        count = 0
        for line in eachline(filename)
            count += 1
        end
        count
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The module <code>LineCount</code> object provides <code>linecount</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">julia&gt; using LineCount

julia&gt; linecount("wc.jl")
11</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_exercise_14_1">Exercise 14-1</h5>
<div class="paragraph">
<p>Type this example into a file named <em>wc.jl</em>, include it into the REPL and enter <code>using LineCount</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>If you import a module that has already been imported, Julia does nothing. It does not re-read the file, even if it has changed.</p>
</div>
<div class="paragraph">
<p>If you want to reload a module, you have to restart the REPL. A package <code>Revise</code> exists that can keep your sessions running longer (see <a href="https://github.com/timholy/Revise.jl" class="bare">https://github.com/timholy/Revise.jl</a>).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_debugging_10">Debugging</h3>
<div class="paragraph">
<p>When you are reading and writing files, you might run into problems with whitespace. These errors can be hard to debug because spaces, tabs and newlines are normally invisible:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; s = "1 2\t 3\n 4";

julia&gt; println(s)
1 2     3
 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>The built-in functions <code>repr</code> or <code>dump</code> can help. It takes any object as an argument and returns a string representation of the object.</p>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; repr(s)
"\"1 2\\t 3\\n 4\""
julia&gt; dump(s)
String "1 2\t 3\n 4"</code></pre>
</div>
</div>
<div class="paragraph">
<p>This can be helpful for debugging.
</p>
</div>
<div class="paragraph">
<p>One other problem you might run into is that different systems use different characters to indicate the end of a line. Some systems use a newline, represented <code>\n</code>. Others use a return character, represented <code>\r</code>. Some use both. If you move files between different systems, these inconsistencies can cause problems.
</p>
</div>
<div class="paragraph">
<p>For most systems, there are applications to convert from one format to another. You can find them (and read more about this issue) at <a href="https://en.wikipedia.org/wiki/Newline" class="bare">https://en.wikipedia.org/wiki/Newline</a>. Or, of course, you could write one yourself.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossary_11">Glossary</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">persistent</dt>
<dd>
<p>Pertaining to a program that runs indefinitely and keeps at least some of its data in permanent storage.
</p>
</dd>
<dt class="hdlist1">text file</dt>
<dd>
<p>A sequence of characters stored in permanent storage like a hard drive.
</p>
</dd>
<dt class="hdlist1">directory</dt>
<dd>
<p>A named collection of files, also called a folder.
</p>
</dd>
<dt class="hdlist1">path</dt>
<dd>
<p>A string that identifies a file.
</p>
</dd>
<dt class="hdlist1">relative path</dt>
<dd>
<p>A path that starts from the current directory.
</p>
</dd>
<dt class="hdlist1">absolute path</dt>
<dd>
<p>A path that starts from the topmost directory in the file system.
</p>
</dd>
<dt class="hdlist1">catch</dt>
<dd>
<p>To prevent an exception from terminating a program using the <code>try ... catch ... finally</code> statements.
</p>
</dd>
<dt class="hdlist1">database</dt>
<dd>
<p>A file whose contents are organized like a dictionary with keys that correspond to values.
</p>
</dd>
<dt class="hdlist1">shell</dt>
<dd>
<p>A program that allows users to type commands and then executes them by starting other programs.
</p>
</dd>
<dt class="hdlist1">command object</dt>
<dd>
<p>An object that represents a shell command, allowing a Julia program to run commands and read the results.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_13">Exercises</h3>
<div class="sect4">
<h5 id="ex14-1">Exercise 14-2</h5>
<div class="paragraph">
<p>Write a function called <code>sed</code> that takes as arguments a pattern string, a replacement string, and two filenames; it should read the first file and write the contents into the second file (creating it if necessary). If the pattern string appears anywhere in the file, it should be replaced with the replacement string.
</p>
</div>
<div class="paragraph">
<p>If an error occurs while opening, reading, writing or closing files, your program should catch the exception, print an error message, and exit.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex14-2">Exercise 14-3</h5>
<div class="paragraph">
<p>If you have done <a href="#ex12-2">Exercise 12-3</a>, you’ll see that a dictionary is created that maps from a sorted string of letters to the array of words that can be spelled with those letters. For example, <code>"opst"</code> maps to the array <code>["opts", "post", "pots", "spot", "stop", "tops"]</code>.</p>
</div>
<div class="paragraph">
<p>Write a module that imports <code>anagramsets</code> and provides two new functions: <code>storeanagrams</code> should store the anagram dictionary using <code>JLD2</code>; <code>readanagrams</code> should look up a word and return an array of its anagrams.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex14-3">Exercise 14-4</h5>
<div class="paragraph">
<p>In a large collection of MP3 files, there may be more than one copy of the same song, stored in different directories or with different file names. The goal of this exercise is to search for duplicates.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write a program that searches a directory and all of its subdirectories, recursively, and returns an array of complete paths for all files with a given suffix (like <em>.mp3</em>).</p>
</li>
<li>
<p>To recognize duplicates, you can use <code>md5sum</code> or <code>md5</code> to compute a “checksum” for each files. If two files have the same checksum, they probably have the same contents.</p>
</li>
<li>
<p>To double-check, you can use the Unix command <code>diff</code>.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap15">18. Estruturas e Objetos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A esta altura, você sabe como usar funções para organizar o código e os tipos internos para organizar os dados. O próximo passo é aprender a criar seus próprios tipos para organizar tanto o código como os dados. Este é um tópico importante e serão necessários alguns capítulos para abordar o tema.</p>
</div>
<div class="sect2">
<h3 id="_tipos_compostos">Tipos Compostos</h3>
<div class="paragraph">
<p>Temos usado muitos tipos internos do Julia e agora definiremos um novo tipo. Como exemplo, vamos criar um tipo chamado <code>Ponto</code> que representa um ponto no espaço bidimensional.
</p>
</div>
<div class="paragraph">
<p>Na notação matemática, os pontos geralmente são escritos entre parênteses com uma vírgula separando as coordenadas. Por exemplo, \(\left(0,0\right)\) representa a origem e \(\left(x,y\right)\) representa o ponto \(x\) unidades à direita e \(y\) unidades acima da origem, se o ponto estiver no 1o. quadrante.</p>
</div>
<div class="paragraph">
<p>Existem diversas maneiras de representar pontos no Julia:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Podemos armazenar as coordenadas separadamente em duas variáveis, <code>x</code> e <code>y</code>.</p>
</li>
<li>
<p>Poderíamos armazenar as coordenadas como elementos de um vetor ou de uma tupla.</p>
</li>
<li>
<p>Poderíamos criar um novo tipo para representar os pontos como objetos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Criar um novo tipo é mais complicado que as outras opções, mas possui vantagens que serão mostradas em breve.</p>
</div>
<div class="paragraph">
<p>Um <em>tipo composto</em> definido pelo programador também é denominado de <em>estrutura</em>. A definição <code>struct</code> para um ponto é dada por:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">struct Ponto
    x
    y
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O cabeçalho indica que a nova struct é chamada de <code>Ponto</code> enquanto o corpo define os <em>atributos</em> ou os <em>campos</em> da struct. Nesse caso, a struct <code>Ponto</code> possui dois campos: <code>x</code> e <code>y</code>.
</p>
</div>
<div class="paragraph">
<p>A struct é como uma fábrica para criar os objetos. Para criar um ponto, chama-se <code>Ponto</code> como se fosse uma função tendo como argumentos os valores dos campos. Quando <code>Ponto</code> é usado como uma função, ele é chamado de <em>construtor</em>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; p = Ponto(3.0, 4.0)
Ponto(3.0, 4.0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>O valor de retorno é uma referência a um objeto <code>Ponto</code>, que atribuímos a <code>p</code>.
</p>
</div>
<div class="paragraph">
<p>A criação de um novo objeto é chamada <em>instanciação</em>, e o objeto é uma <em>instância</em> do tipo.
</p>
</div>
<div class="paragraph">
<p>Quando você imprime uma instância, o Julia informa a que tipo pertence e quais os valores dos atributos.</p>
</div>
<div class="paragraph">
<p>Todo objeto é uma instância de algum tipo; portanto, “objeto” e “instância” são permutáveis. Mas neste capítulo, eu uso “instância” para indicar que estou falando de um tipo definido pelo programador.</p>
</div>
<div class="paragraph">
<p>Um diagrama de estado que mostra um objeto e seus campos é denominado de <em>diagrama do objeto</em>, conforme <a href="#fig15-1">Diagrama do objeto</a>.
</p>
</div>
<div id="fig15-1" class="imageblock">
<div class="content">
<img src="images/fig151.svg" alt="fig151">
</div>
<div class="title">Figure 20. Diagrama do objeto</div>
</div>
</div>
<div class="sect2">
<h3 id="_structs_são_imutáveis">Structs são Imutáveis</h3>
<div class="paragraph">
<p>Você pode acessar os valores dos campos usando a notação <code>.</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; x = p.x
3.0
julia&gt; p.y
4.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>A expressão <code>p.x</code> significa: “Vá até a referência do objeto <code>p</code> e obtenha o valor de <code>x</code>.” No exemplo, atribuímos esse valor a uma variável <code>x</code>. Não há conflito entre a variável <code>x</code> e o campo <code>x</code>.</p>
</div>
<div class="paragraph">
<p>Você pode usar a notação do ponto como parte de qualquer expressão. Por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; distância = sqrt(p.x^2 + p.y^2)
5.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por padrão, as structs são imutáveis, isto é, após a construção, os campos não podem mudar de valor:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; p.y = 1.0
ERROR: setfield! immutable struct of type Ponto cannot be changed</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isso pode parecer estranho de início, mas tem várias vantagens:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Pode ser mais eficiente.</p>
</li>
<li>
<p>Não é possível violar os invariantes dos construtores do tipo (veja <a href="#constructor">[constructor]</a>).</p>
</li>
<li>
<p>O código que usa os objetos imutáveis pode ser mais fácil de ler e entender.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_structs_mutáveis">Structs Mutáveis</h3>
<div class="paragraph">
<p>Quando necessário, os tipos compostos mutáveis podem ser declarados com a palavra-chave <code>mutable struct</code>. Aqui está a definição de um ponto mutável:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">mutable struct MPonto
    x
    y
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Você pode atribuir valores a uma instância de uma struct mutável usando a notação de ponto:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; lacuna = MPonto(0.0, 0.0)
MPonto(0.0, 0.0)
julia&gt; lacuna.x = 3.0
3.0
julia&gt; lacuna.y = 4.0
4.0</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_retângulos">Retângulos</h3>
<div class="paragraph">
<p>Às vezes, é óbvio quais devem ser os campos de um objeto, mas outras vezes você precisa escolher entre as opções. Por exemplo, imagine que você está estruturando um tipo para representar retângulos. Quais campos você usaria para especificar a localização e o tamanho de um retângulo? Desconsidere o ângulo e para simplificar, suponha que o retângulo seja vertical ou horizontal.</p>
</div>
<div class="paragraph">
<p>Existem pelo menos duas possibilidades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Você poderia especificar um vértice do retângulo (ou o centro), a largura e a altura.</p>
</li>
<li>
<p>Você poderia especificar dois vértices opostos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Nesse momento, é difícil dizer se um é melhor que o outro e portanto, implementaremos o primeiro, apenas como exemplo.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia">"""
Representa um retângulo.

campos: largura, altura, vértice.
"""
struct Retângulo
    largura
    altura
    vértice
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O docstring lista os campos: a largura e a altura, que são números, e o vértice, que é um objeto <code>Ponto</code> que indica o vértice inferior esquerdo.
</p>
</div>
<div class="paragraph">
<p>Para a representação de um retângulo, você tem que instanciar um objeto <code>Retângulo</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="jlcon">julia&gt; origem = MPonto(0.0, 0.0)
MPonto(0.0, 0.0)
julia&gt; caixa = Retângulo(100.0, 200.0, origem)
Retângulo(100.0, 200.0, MPonto(0.0, 0.0))</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#fig15-2">Diagrama do objeto</a> mostra o estado deste objeto. Um objeto que é um campo de outro objeto é <em>embutido</em>. Perceba que o atributo <code>vértice</code> se refere a um objeto mutável, por isso ele é desenhado fora do objeto <code>Retângulo</code>.
</p>
</div>
<div id="fig15-2" class="imageblock">
<div class="content">
<img src="images/fig152.svg" alt="fig152">
</div>
<div class="title">Figure 21. Diagrama do objeto</div>
</div>
</div>
<div class="sect2">
<h3 id="_instâncias_como_argumentos">Instâncias como Argumentos</h3>
<div class="paragraph">
<p>Você pode passar uma instância como um argumento da maneira tradicional. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="julia"></code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    println("($(p.x), $(p.y))")
end</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>A função +imprimir_ponto+ recebe como argumento um +ponto+ e o apresenta em notação matemática. Para chamá-lo, você pode passar +p+ como argumento:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; imprimir_ponto(lacuna)
(3.0, 4.0)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Exercício 15-1

Escreva uma função chamada +distância_entre_pontos+ que recebe dois pontos como argumentos e retorna a distância entre eles.
(((distância_entre_pontos)))(((("função", "definido pelo programador", "distância_entre_pontos", see = "distância_entre_pontos")))

Se um objeto da struct mutável for passado para uma função como argumento, a função poderá modificar os campos do objeto. Por exemplo, +move_ponto!+ recebe um objeto mutável +MPonto+ e dois números +dx+ e +dy+, e adiciona os números respectivamente aos atributos +x+ e +y+ de +MPonto+:
(((move_ponto!)))((("função", "definido pelo programador", "move_ponto!", see="move_ponto!")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function move_ponto!(p, dx, dy)
    p.x += dx
    p.y += dy
    nothing
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Aqui está um exemplo que mostra o resultado:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; origem = MPonto(0.0, 0.0)
MPonto(0.0, 0.0)
julia&gt; move_ponto!(origem, 1.0, 2.0)</p>
</div>
<div class="paragraph">
<p>julia&gt; origem
MPonto(1.0, 2.0)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Dentro da função, +p+ é um alias (ou apelido) para +origem+, então quando a função modifica +p+, +origem+ também muda.
(((alias)))

Passar um objeto +Ponto+ imutável para +move_ponto!+ faz uma mensagem de erro aparecer:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; move_ponto!(p, 1.0, 2.0)
ERROR: setfield! immutable struct of type Ponto cannot be changed</p>
</div>
<div class="listingblock">
<div class="content">
<pre>No entanto, você pode modificar o valor de um atributo mutável de um objeto imutável. Por exemplo, +move_retângulo!+ tem como argumentos um objeto +Retângulo+ e dois números +dx+ e +dy+, e usa +move_ponto!+ para mover o canto do retângulo:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function move_retângulo!(ret, dx, dy)
  move_ponto!(ret.vértice, dx, dy)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Agora +p+ em +move_ponto!+ é um apelido para +ret.vértice+, então quando +p+ é modificado, +ret.vértice+ também muda:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; caixa
Retângulo(100.0, 200.0, MPonto(0.0, 0.0))
julia&gt; move_retângulo!(caixa, 1.0, 2.0)</p>
</div>
<div class="paragraph">
<p>julia&gt; caixa
Retângulo(100.0, 200.0, MPonto(1.0, 2.0))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[WARNING]
====
Você não pode reatribuir um atributo mutável a um objeto imutável:
(((reatribuição)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; caixa.vértice = MPonto(1.0, 2.0)
ERROR: setfield! immutable struct of type Retângulo cannot be changed</p>
</div>
<div class="listingblock">
<div class="content">
<pre>====

=== Instâncias como Valores de Retorno

Funções podem retornar instâncias. Por exemplo, +encontra_centro+ recebe um +Retângulo+ como argumento e retorna um +Ponto+ que contém as coordenadas do centro do retângulo:
(((encontra_centro)))((("função", "definido pelo programador", "encontra_centro", see="encontra_centro")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function encontra_centro(ret)
    Ponto(ret.vértice.x + ret.largura / 2, ret.vértice.y + ret.altura / 2)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A expressão +ret.vértice.x+ significa: “Vá ao objeto +ret+ e selecione o campo +vértice+; depois vá até esse objeto e selecione o campo +x+.”

Aqui está um exemplo que passa +caixa+ como argumento e atribui o +Ponto+ recebido ao +centro+:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; centro = encontra_centro(caixa)
Ponto(51.0, 102.0)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Cópia
//coloquei a definição de aliasing antes de traduzir o parágrafo
"Aliasing" é um termo que refere-se ao acesso de um mesmo local da memória por variáveis diferentes. Ele pode dificultar a leitura de um programa, pois as alterações em um local podem ter efeitos inesperados em outro local. É difícil acompanhar todas as variáveis que podem se referir a um objeto dado.
(((alias)))

A cópia de um objeto é muitas vezes uma alternativa ao aliasing. O Julia possui uma função chamada +deepcopy+ que pode duplicar qualquer objeto:
(((cópia)))(((deepcopy)))((("função", "Base", "deepcopy", see="deepcopy")))(((cópia profunda)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; p1 = MPonto(3.0, 4.0)
MPonto(3.0, 4.0)
julia&gt; p2 = deepcopy(p1)
MPonto(3.0, 4.0)
julia&gt; p1 ≡ p2
false
julia&gt; p1 == p2
false</p>
</div>
<div class="listingblock">
<div class="content">
<pre>O operador +≡+ indica que +p1+ e +p2+ não são o mesmo objeto, que é o que imaginávamos. Mas você pode ter pensado que +==+ devolvesse +true+ porque esses pontos contêm os mesmos dados. Nesse caso, você ficará desapontado ao saber que, para objetos mutáveis, o comportamento padrão do operador +==+ é o mesmo do operador +===+ pois verifica-se a identidade do objeto e não a equivalência do objeto. Isso ocorre porque, para tipos compostos mutáveis, o Julia não sabe o que deve ser considerado equivalente. Pelo menos, ainda não.
(((==)))(((≡)))

===== Exercício 15-2

Crie uma instância +Ponto+, faça uma cópia dela e verifique a equivalência e a igualdade de ambas. O resultado pode surpreendê-lo, além de explicar porque o alias não é um problema para um objeto imutável.


=== Depuração

Quando você começa a trabalhar com os objetos, é provável que encontre algumas novas exceções. Se você tentar acessar um campo que não existe, tem-se:
(((depuração)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; p = Ponto(3.0, 4.0)
Ponto(3.0, 4.0)
julia&gt; p.z = 1.0
ERROR: type Ponto has no field z
Stacktrace:
 [1] setproperty!(::Ponto, ::Symbol, ::Float64) at ./sysimg.jl:19
 [2] top-level scope at none:0</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Se você não tem certeza de qual é o tipo de objeto, pode-se perguntar:
(((typeof)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; typeof(p)
Ponto</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Você também pode usar +isa+ para verificar se um objeto é uma instância de um certo tipo:
(((isa)))((("operador", "Base", "isa", see="isa")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; p isa Ponto
true</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Se você não tem certeza se um objeto possui um determinado atributo, pode-se usar a função interna +fieldnames+:
(((deepcopy)))((("função", "Base", "deepcopy", see="deepcopy")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; fieldnames(Ponto)
(:x, :y)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ou a função +isdefined+:
(((isdefined)))((("função", "Base", "isdefined", see="isdefined")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; isdefined(p, :x)
true
julia&gt; isdefined(p, :z)
false</p>
</div>
<div class="listingblock">
<div class="content">
<pre>O primeiro argumento pode ser qualquer objeto enquanto o segundo argumento é um símbolo +:+ seguido do nome do campo.
(((:)))(((Símbolo)))((("tipo", "Base", "Símbolo", see="Símbolo")))

=== Glossário

struct::
Um tipo composto.
(((struct)))

construtor::
Uma função que tem o mesmo nome que um tipo e que cria as instâncias deste tipo.
(((construtor)))

instância::
Um objeto que pertence a um tipo.
(((instância)))

instanciar::
Criar um novo objeto.
(((instanciar)))

atributo ou campo::
Um dos valores nomeados associados a um objeto.
(((atributo)))

objeto embutido::
Um objeto que é armazenado como um campo de outro objeto.
(((objeto embutido)))

cópia profunda::
Cópia do conteúdo de um objeto, bem como quaisquer objetos embutidos e quaisquer objetos embutidos a eles, e assim por diante; é implementado pela função +deepcopy+.
(((cópia profunda)))

diagrama de objetos::
Um diagrama que mostra os objetos, os seus campos e os respectivos valores dos campos.
(((diagrama de objetos)))


=== Exercícios

[[ex15-1]]
===== Exercício 15-3

. Escreva uma definição para um tipo chamado +Círculo+ com os campos +centro+ e +raio+, em que +centro+ é um objeto +Ponto+ e +raio+ é um número.
(((Círculo)))((("tipo", "definido pelo programador", "Círculo", see="Círculo")))

. Instancie um objeto círculo que represente um círculo com seu centro em latexmath:[\(\left(150, 100\right)\)] e raio 75.

. Escreva uma função denominada +ponto_no_círculo+ que recebe um objeto +Círculo+ e um objeto +Ponto+ e retorna +true+ se o ponto estiver dentro ou no contorno do círculo.
(((ponto_no_círculo)))((("função", "definido pelo programador", "ponto_no_círculo", see="ponto_no_círculo")))

. Escreva uma função denominada +ret_no_círculo+ que recebe um objeto +Círculo+ e um objeto +Retângulo+ e retorna +true+ se o retângulo estiver inteiramente dentro ou nos contornos do círculo.
(((ret_no_círculo)))((("função", "definido pelo programador", "ret_no_círculo", see="ret_no_círculo")))

. Escreva uma função denominada +ret_círc_sobreposição+ que recebe um objeto +Círculo+ e um objeto +Retângulo+ e devolve +true+ se algum dos vértices do retângulo estiver dentro do círculo. Ou, como uma versão mais desafiadora, devolva +true+ se alguma parte do retângulo estiver dentro do círculo.
(((ret_círc_sobreposição)))((("função", "definido pelo programador", "ret_círc_sobreposição", see="ret_círc_sobreposição")))

[[ex15-2]]
===== Exercício 15-4

. Escreva uma função chamada +desenha_ret+ que recebe um objeto do tipo turtle e um objeto +Retângulo+ e use a tartaruga para desenhar o retângulo. Verifique o Capítulo 4 para os exemplos que usam os objetos +Turtle+.
(((desenha_ret)))((("função","definido pelo programador","desenha_ret", see="desenha_ret")))

. Escreva uma função chamada +desenha_círculo+ que recebe um objeto +Turtle+ e um objeto +Círculo+ e desenha o círculo.
(((desenha_círculo)))((("função", "definido pelo programador", "desenha_círculo", see="desenha_círculo")))

[[chap16]]
== Structs and Functions

Now that we know how to create new composite types, the next step is to write functions that take programmer-defined objects as parameters and return them as results. In this chapter I also present “functional programming style” and two new program development plans.

[[time]]
=== Time

As another example of a composite type, we’ll define a +struct+ called +MyTime+ that records the time of day. The struct definition looks like this:
(((MyTime)))((("type", "programmer-defined", "MyTime", see="MyTime")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>"""
Represents the time of day.</p>
</div>
<div class="paragraph">
<p>fields: hour, minute, second
"""
struct MyTime
    hour
    minute
    second
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The name +Time+ is already used in Julia and to avoid a name clash, I have chosen +MyTime+. We can create a new +MyTime+ object:
(((Time)))((("type", "Dates", "Time", see="Time")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; time = MyTime(11, 59, 30)
MyTime(11, 59, 30)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The object diagram for the +MyTime+ object looks like &lt;&lt;fig16-1&gt;&gt;.

[[fig16-1]]
.Object diagram
image::images/fig161.svg[]

===== Exercise 16-1

Write a function called +printtime+ that takes a +MyTime+ object and prints it in the form +hour:minute:second+. The +@printf+ macro of the StdLib module +Printf+ prints an integer with the format sequence `"%02d"` using at least two digits, including a leading zero if necessary.
(((printtime)))((("function", "programmer-defined", "printtime", see="printtime")))

===== Exercise 16-2

Write a boolean function called +isafter+ that takes two +MyTime+ objects, +t1+ and +t2+, and returns +true+ if +t1+ follows +t2+ chronologically and +false+ otherwise. Challenge: don’t use an +if+ statement.
(((isafter)))((("function", "programmer-defined", "isafter", see="isafter")))


=== Pure Functions

In the next few sections, we’ll write two functions that add time values. They demonstrate two kinds of functions: pure functions and modifiers. They also demonstrate a development plan I’ll call _prototype and patch_, which is a way of tackling a complex problem by starting with a simple prototype and incrementally dealing with the complications.
(((pure function)))(((prototype and patch)))

Here is a simple prototype of +addtime+:
(((addtime)))((("function", "programmer-defined", "addtime", see="addtime")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function addtime(t1, t2)
    MyTime(t1.hour + t2.hour, t1.minute + t2.minute, t1.second + t2.second)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The function creates a new +MyTime+ object, initializes its fields, and returns a reference to the new object. This is called a _pure function_ because it does not modify any of the objects passed to it as arguments and it has no effect, like displaying a value or getting user input, other than returning a value.

To test this function, I’ll create two +MyTime+ objects: +start+ contains the start time of a movie, like _Monty Python and the Holy Grail_, and +duration+ contains the run time of the movie, which is one hour 35 minutes.

+addtime+ figures out when the movie will be done.


[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; start = MyTime(9, 45, 0);</p>
</div>
<div class="paragraph">
<p>julia&gt; duration = MyTime(1, 35, 0);</p>
</div>
<div class="paragraph">
<p>julia&gt; done = addtime(start, duration);</p>
</div>
<div class="paragraph">
<p>julia&gt; printtime(done)
10:80:00</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The result, +10:80:00+ might not be what you were hoping for. The problem is that this function does not deal with cases where the number of seconds or minutes adds up to more than sixty. When that happens, we have to “carry” the extra seconds into the minute column or the extra minutes into the hour column. Here’s an improved version:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function addtime(t1, t2)
    second = t1.second + t2.second
    minute = t1.minute + t2.minute
    hour = t1.hour + t2.hour
    if second &gt;= 60
        second -= 60
        minute += 1
    end
    if minute &gt;= 60
        minute -= 60
        hour += 1
    end
    MyTime(hour, minute, second)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Although this function is correct, it is starting to get big. We will see a shorter alternative later.

[[modifiers]]
=== Modifiers

Sometimes it is useful for a function to modify the objects it gets as parameters. In that case, the changes are visible to the caller. Functions that work this way are called _modifiers_.
(((modifier)))

+increment!+, which adds a given number of seconds to a +MyTime+ object, can be written naturally as a modifier. Here is a rough draft:
(((increment!)))((("function", "programmer-defined", "increment!", see="increment!")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function increment!(time, seconds)
    time.second += seconds
    if time.second &gt;= 60
        time.second -= 60
        time.minute += 1
    end
    if time.minute &gt;= 60
        time.minute -= 60
        time.hour += 1
    end
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The first line performs the basic operation; the remainder deals with the special cases we saw before.

Is this function correct? What happens if +seconds+ is much greater than 60?

In that case, it is not enough to carry once; we have to keep doing it until +time.second+ is less than sixty. One solution is to replace the +if+ statements with +while+ statements. That would make the function correct, but not very efficient.

===== Exercise 16-3

Write a correct version of +increment!+ that doesn’t contain any loops.

Anything that can be done with modifiers can also be done with pure functions. In fact, some programming languages only allow pure functions. There is some evidence that programs that use pure functions are faster to develop and less error-prone than programs that use modifiers. But modifiers are convenient at times, and functional programs tend to be less efficient.

In general, I recommend that you write pure functions whenever it is reasonable and resort to modifiers only if there is a compelling advantage. This approach might be called a _functional programming style_.
(((functional programming style)))

===== Exercise 16-4

Write a “pure” version of +increment+ that creates and returns a new +MyTime+ object rather than modifying the parameter.


[[prototyping_versus_planning]]
=== Prototyping Versus Planning

The development plan I am demonstrating is called “prototype and patch”. For each function, I wrote a prototype that performed the basic calculation and then tested it, patching errors along the way.
(((program development plan)))(((prototyping and patch)))

This approach can be effective, especially if you don’t yet have a deep understanding of the problem. But incremental corrections can generate code that is unnecessarily complicated—since it deals with many special cases—and unreliable—since it is hard to know if you have found all the errors.

An alternative is _designed development_, in which high-level insight into the problem can make the programming much easier. In this case, the insight is that a Time object is really a three-digit number in base 60 (see https://en.wikipedia.org/wiki/Sexagesimal)! The second attribute is the “ones column”, the minute attribute is the “sixties column”, and the hour attribute is the “thirty-six hundreds column”.
(((designed development)))

When we wrote +addtime+ and +increment!+, we were effectively doing addition in base 60, which is why we had to carry from one column to the next.

This observation suggests another approach to the whole problem—we can convert +MyTime+ objects to integers and take advantage of the fact that the computer knows how to do integer arithmetic.

Here is a function that converts mytimes to integers:
(((timetoint)))((("function", "programmer-defined", "timetoint", see="timetoint")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function timetoint(time)
    minutes = time.hour * 60 + time.minute
    seconds = minutes * 60 + time.second
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>And here is a function that converts an integer to a +MyTime+ (recall that +divrem+ divides the first argument by the second and returns the quotient and remainder as a tuple):
(((inttotime)))((("function", "programmer-defined", "inttotime", see="inttotime")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function inttotime(seconds)
    (minutes, second) = divrem(seconds, 60)
    hour, minute = divrem(minutes, 60)
    MyTime(hour, minute, second)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>You might have to think a bit, and run some tests, to convince yourself that these functions are correct. One way to test them is to check that +timetoint(inttotime(x)) == x+ for many values of +x+. This is an example of a consistency check.

Once you are convinced they are correct, you can use them to rewrite +addtime+:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function addtime(t1, t2)
    seconds = timetoint(t1) + timetoint(t2)
    inttotime(seconds)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>This version is shorter than the original, and easier to verify.

===== Exercise 16-5

Rewrite +increment!+ using +timetoint+ and +inttotime+.

In some ways, converting from base 60 to base 10 and back is harder than just dealing with times. Base conversion is more abstract; our intuition for dealing with time values is better.

But if we have the insight to treat times as base 60 numbers and make the investment of writing the conversion functions (+timetoint+ and +inttotime+), we get a program that is shorter, easier to read and debug, and more reliable.

It is also easier to add features later. For example, imagine subtracting two +MyTime+s to find the duration between them. The naive approach would be to implement subtraction with borrowing. Using the conversion functions would be easier and more likely to be correct.

Ironically, sometimes making a problem harder (or more general) makes it easier (because there are fewer special cases and fewer opportunities for error).

[[chap16_debugging]]
=== Debugging

A +MyTime+ object is well-formed if the values of +minute+ and +second+ are between 0 and 60 (including 0 but not 60) and if +hour+ is positive. +hour+ and +minute+ should be integral values, but we might allow +second+ to have a fraction part.
(((debugging)))

Requirements like these are called _invariants_ because they should always be true. To put it a different way, if they are not true, something has gone wrong.
(((invariant)))

Writing code to check invariants can help detect errors and find their causes. For example, you might have a function like +isvalidtime+ that takes a +MyTime+ object and returns +false+ if it violates an invariant:
(((isvalidtime)))((("function", "programmer-defined", "isvalidtime", see="isvalidtime")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function isvalidtime(time)
    if time.hour &lt; 0 || time.minute &lt; 0 || time.second &lt; 0
        return false
    end
    if time.minute &gt;= 60 || time.second &gt;= 60
        return false
    end
    true
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>At the beginning of each function you could check the arguments to make sure they are valid:
(((addtime)))(((error)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function addtime(t1, t2)
    if !isvalidtime(t1) || !isvalidtime(t2)
        error("invalid MyTime object in add_time")
    end
    seconds = timetoint(t1) + timetoint(t2)
    inttotime(seconds)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Or you could use an +@assert+ macro, which checks a given invariant and throws an exception if it fails:
(((@assert)))((("macro", "Base", "@assert", see="@assert")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function addtime(t1, t2)
    @assert(isvalidtime(t1) &amp;&amp; isvalidtime(t2), "invalid MyTime object in add_time")
    seconds = timetoint(t1) + timetoint(t2)
    inttotime(seconds)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>+@assert+ macros are useful because they distinguish code that deals with normal conditions from code that checks for errors.


=== Glossary

prototype and patch::
A development plan that involves writing a rough draft of a program, testing, and correcting errors as they are found.
(((prototype and patch)))

designed development::
A development plan that involves high-level insight into the problem and more planning than incremental development or prototype development.
(((designed development)))

pure function::
A function that does not modify any of the objects it receives as arguments. Most pure functions are fruitful.
(((pure function)))

modifier::
A function that changes one or more of the objects it receives as arguments. Most modifiers are void; that is, they return +nothing+.
(((modifier)))

functional programming style::
A style of program design in which the majority of functions are pure.
(((functional programming style)))

invariant::
A condition that should never change during the execution of a program.
(((invariant)))


=== Exercises

[[ex16-1]]
===== Exercise 16-6

Write a function called +multime+ that takes a +MyTime+ object and a number and returns a new +MyTime+ object that contains the product of the original +MyTime+ and the number.
(((multime)))((("function", "programmer-defined", "multime", see="multime")))

Then use +multime+ to write a function that takes a +MyTime+ object that represents the finishing time in a race, and a number that represents the distance, and returns a +MyTime+ object that represents the average pace (time per mile).

[[ex16-2]]
===== Exercise 16-7

Julia provides time objects that are similar to the +MyTime+ objects in this chapter, but they provide a rich set of function and operators. Read the documentation at https://docs.julialang.org/en/v1/stdlib/Dates/.

. Write a program that gets the current date and prints the day of the week.

. Write a program that takes a birthday as input and prints the user’s age and the number of days, hours, minutes and seconds until their next birthday.

. For two people born on different days, there is a day when one is twice as old as the other. That’s their Double Day. Write a program that takes two birthdays and computes their Double Day.

. For a little more challenge, write the more general version that computes the day when one person is latexmath:[\(n\)] times older than the other.


[[chap17]]
== Multiple Dispatch

In Julia you have the ability to write code that can operate on different types. This is called generic programming.

In this chapter I will discuss the use of type declarations in Julia and I will introduce methods which are ways to implement different behavior for a function depending on the types of its arguments. This is called multiple dispatch.


=== Type Declarations

The +::+ operator attaches _type annotations_ to expressions and variables:
(((TypeError)))((("error", "Core", "TypeError", see="TypeError")))

[source,jlcon]</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">julia&gt; (1 + 2) </dt>
<dd>
<p>Float64
ERROR: TypeError: in typeassert, expected Float64, got Int64</p>
</dd>
<dt class="hdlist1">julia&gt; (1 + 2) </dt>
<dd>
<p>Int64
3</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre>This helps to confirm that your program works the way you expect.

The +::+ operator can also be appended to the left-hand side of an assignment, or as part of a declaration.
(((returnfloat)))((("function", "programmer-defined", "returnfloat", see="returnfloat")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; function returnfloat()
           x::Float64 = 100
           x
       end
returnfloat (generic function with 1 method)
julia&gt; x = returnfloat()
100.0
julia&gt; typeof(x)
Float64</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The variable +x+ is always of type +Float64+ and the value is converted to a floating point if needed.

A type annotation can also be attached to the header of a function definition:
(((sinc)))((("function", "programmer-defined", "sinc", see="sinc")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function sinc(x)::Float64
    if x == 0
        return 1
    end
    sin(x)/(x)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The return value of +sinc+ is always converted to type +Float64+.

The default behavior in Julia when types are omitted is to allow values to be of any type (+Any+).
(((Any)))


=== Methods

In &lt;&lt;chap16&gt;&gt;, we defined a struct named +MyTime+ and in &lt;&lt;time&gt;&gt;, you wrote a function named +printtime+:
(((MyTime)))(((printtime)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>using Printf</p>
</div>
<div class="paragraph">
<p>struct MyTime
    hour :: Int64
    minute :: Int64
    second :: Int64
end</p>
</div>
<div class="paragraph">
<p>function printtime(time)
    @printf("%02d:%02d:%02d", time.hour, time.minute, time.second)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>As you can see, type declarations can and should be added for performance reasons to the fields in a struct definition.

To call this function, you have to pass a +MyTime+ object as an argument:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; start = MyTime(9, 45, 0)
MyTime(9, 45, 0)
julia&gt; printtime(start)
09:45:00</p>
</div>
<div class="listingblock">
<div class="content">
<pre>To add a _method_ to the function +printtime+ that only accepts as argument a +MyTime+ object, all we have to do is append +::+ followed by +MyTime+ to the argument +time+ in the function definition:
(((method)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function printtime(time::MyTime)
    @printf("%02d:%02d:%02d", time.hour, time.minute, time.second)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A method is a function definition with a specific _signature_: +printtime+ has one argument of type +MyTime+.
(((signature)))

Calling the function +printtime+ with a +MyTime+ object yields the same result:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; printtime(start)
09:45:00</p>
</div>
<div class="listingblock">
<div class="content">
<pre>We can now redefine the first method without the +::+ type annotation allowing an argument of any type:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function printtime(time)
    println("I don&#8217;t know how to print the argument time.")
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>If you call the function +printtime+ with an object different from +MyTime+, you get now:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; printtime(150)
I don&#8217;t know how to print the argument time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Exercise 17-1

Rewrite +timetoint+ and +inttotime+ (from &lt;&lt;prototyping_versus_planning&gt;&gt;) to specify their argument.
(((timetoint)))(((inttotime)))



=== Additional Examples

Here’s a version of +increment+ (from &lt;&lt;modifiers&gt;&gt;) rewritten to specify its arguments:
(((increment)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function increment(time::MyTime, seconds::Int64)
    seconds += timetoint(time)
    inttotime(seconds)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Note that now, it is a pure function, not a modifier.

Here's how you would invoke increment:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; start = MyTime(9, 45, 0)
MyTime(9, 45, 0)
julia&gt; increment(start, 1337)
MyTime(10, 7, 17)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>If you put the arguments in the wrong order, you get an error:
(((MethodError)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; increment(1337, start)
ERROR: MethodError: no method matching increment(::Int64, ::MyTime)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The signature of the method is +increment(time::MyTime, seconds::Int64)+ and not +increment(seconds::Int64, time::MyTime)+.

Rewriting +isafter+ to act only on +MyTime+ objects is as easy:
(((isafter)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function isafter(t1::MyTime, t2::MyTime)
    (t1.hour, t1.minute, t1.second) &gt; (t2.hour, t2.minute, t2.second)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>By the way, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function f(a=1, b=2)
    a + 2b
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>translates to the following three methods:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>f(a, b) = a + 2b
f(a) = f(a, 2)
f() = f(1, 2)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>These expressions are valid Julia method definitions. This is a shorthand notation for defining functions/methods.

[[constructor]]
=== Constructors

A _constructor_ is a special function that is called to create an object. The default constructor methods of +MyTime+ have the following signatures:
(((constructor)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>MyTime(hour, minute, second)
MyTime(hour::Int64, minute::Int64, second::Int64)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>We can also add our own _outer constructor_ methods:
(((outer constructor)))((("constructor", "outer", see="outer constructor")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function MyTime(time::MyTime)
    MyTime(time.hour, time.minute, time.second)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>This method is called a _copy constructor_ because the new +MyTime+ object is a copy of its argument.
(((copy constructor)))((("constructor", "copy", see="copy constructor")))

To enforce invariants, we need _inner constructor_ methods:
(((inner constructor)))((("constructor", "inner", see="inner constructor")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>struct MyTime
    hour :: Int64
    minute :: Int64
    second :: Int64
    function MyTime(hour::Int64=0, minute::Int64=0, second::Int64=0)
        @assert(0 ≤ minute &lt; 60, "Minute is not between 0 and 60.")
        @assert(0 ≤ second &lt; 60, "Second is not between 0 and 60.")
        new(hour, minute, second)
    end
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The struct +MyTime+ has now 4 inner constructor methods:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>MyTime()
MyTime(hour::Int64)
MyTime(hour::Int64, minute::Int64)
MyTime(hour::Int64, minute::Int64, second::Int64)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>An inner constructor method is always defined inside the block of a type declaration and it has access to a special function called +new+ that creates objects of the newly declared type.

[WARNING]
====
The default constructor is not available if any inner constructor is defined. You have to write explicitly all the inner constructors you need.
====

A second method without arguments of the local function +new+ exists:
(((new)))((("function", "Base", "new", see="new")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>mutable struct MyTime
    hour :: Int
    minute :: Int
    second :: Int
    function MyTime(hour::Int64=0, minute::Int64=0, second::Int64=0)
        @assert(0 ≤ minute &lt; 60, "Minute is between 0 and 60.")
        @assert(0 ≤ second &lt; 60, "Second is between 0 and 60.")
        time = new()
        time.hour = hour
        time.minute = minute
        time.second = second
        time
    end
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>This allows to construct recursive data structures, i.e. a struct where one of the fields is the struct itself. In this case the struct has to be mutable because its fields are modified after instantiation.
(((recursive data structures)))


=== +show+

+show+ is a special function that returns a string representation of an object. For example, here is a +show+ method for +MyTime+ objects:
(((show)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>using Printf</p>
</div>
<div class="paragraph">
<p>function Base.show(io::IO, time::MyTime)
    @printf(io, "%02d:%02d:%02d", time.hour, time.minute, time.second)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The prefix +Base+ is needed because we want to add a new method to the +Base.show+ function.

When you print an object, Julia invokes the +show+ function:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; time = MyTime(9, 45)
09:45:00</p>
</div>
<div class="listingblock">
<div class="content">
<pre>When I write a new composite type, I almost always start by writing an outer constructor, which makes it easier to instantiate objects, and +show+, which is useful for debugging.

===== Exercise 17-2

Write an outer constructor method for the +Point+ class that takes +x+ and +y+ as optional parameters and assigns them to the corresponding fields.
(((Point)))



=== Operator Overloading

By defining operator methods, you can specify the behavior of operators on programmer-defined types. For example, if you define a method named +pass:[+]+ with two +MyTime+ arguments, you can use the +pass:[+]+ operator on +MyTime+ objects.

Here is what the definition might look like:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>import Base.+</p>
</div>
<div class="paragraph">
<p>function +(t1::MyTime, t2::MyTime)
    seconds = timetoint(t1) + timetoint(t2)
    inttotime(seconds)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The import statement adds the +pass:[+]+ operator to the local scope so that methods can be added.

And here is how you could use it:


[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; start = MyTime(9, 45)
09:45:00
julia&gt; duration = MyTime(1, 35, 0)
01:35:00
julia&gt; start + duration
11:20:00</p>
</div>
<div class="listingblock">
<div class="content">
<pre>When you apply the +pass:[+]+ operator to +MyTime+ objects, Julia invokes the newly added method. When the REPL shows the result, Julia invokes +show+. So there is a lot happening behind the scenes!

Adding to the behavior of an operator so that it works with programmer-defined types is called _operator overloading_.
(((operator overloading)))


=== Multiple Dispatch

In the previous section we added two +MyTime+ objects, but you also might want to add an integer to a +MyTime+ object:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function +(time::MyTime, seconds::Int64)
    increment(time, seconds)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Here is an example that uses the +pass:[+]+ operator with a +MyTime+ object and an integer:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; start = MyTime(9, 45)
09:45:00
julia&gt; start + 1337
10:07:17</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Addition is a commutative operator so we have to add another method.

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function +(seconds::Int64, time::MyTime)
  time + seconds
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>And we get the same result:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; 1337 + start
10:07:17</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The choice of which method to execute when a function is applied is called _dispatch_. Julia allows the dispatch process to choose which of a function's methods to call based on the number of arguments given, and on the types of all of the function's arguments.  Using all of a function's arguments to choose which method should be invoked is known as _multiple dispatch_.
(((dispatch)))(((multiple dispatch)))

===== Exercise 17-3

Write +pass:[+]+ methods for point objects:

* If both operands are point objects, the method should return a new point object whose +x+ coordinate is the sum of the +x+ coordinates of the operands, and likewise for the +y+ coordinates.

* If the first or the second operand is a tuple, the method should add the first element of the tuple to the +x+ coordinate and the second element to the +y+ coordinate, and return a new point object with the result.


=== Generic Programming

Multiple dispatch is useful when it is necessary, but (fortunately) it is not always necessary. Often you can avoid it by writing functions that work correctly for arguments with different types.

Many of the functions we wrote for strings also work for other sequence types. For example, in &lt;&lt;dictionary_collection_counters&gt;&gt; we used +histogram+ to count the number of times each letter appears in a word.
(((histogram)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function histogram(s)
    d = Dict()
    for c in s
        if c ∉ keys(d)
            d[c] = 1
        else
            d[c] += 1
        end
    end
    d
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>This function also works for lists, tuples, and even dictionaries, as long as the elements of +s+ are hashable, so they can be used as keys in +d+.

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; t = ("spam", "egg", "spam", "spam", "bacon", "spam")
("spam", "egg", "spam", "spam", "bacon", "spam")
julia&gt; histogram(t)
Dict{Any,Any} with 3 entries:
  "bacon" &#8658; 1
  "spam"  &#8658; 4
  "egg"   &#8658; 1</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Functions that work with several types are called _polymorphic_. Polymorphism can facilitate code reuse.
(((polymorphic)))

For example, the built-in function +sum+, which adds the elements of a sequence, works as long as the elements of the sequence support addition.
(((sum)))

Since a +pass:[+]+ method is provided for +MyTime+ objects, they work with +sum+:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; t1 = MyTime(1, 7, 2)
01:07:02
julia&gt; t2 = MyTime(1, 5, 8)
01:05:08
julia&gt; t3 = MyTime(1, 5, 0)
01:05:00
julia&gt; sumt1, t2, t3
03:17:10</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In general, if all of the operations inside a function work with a given type, the function works with that type.

The best kind of polymorphism is the unintentional kind, where you discover that a function you already wrote can be applied to a type you never planned for.
(((polymorphism)))


=== Interface and Implementation

One of the goals of multiple dispatch is to make software more maintainable, which means that you can keep the program working when other parts of the system change, and modify the program to meet new requirements.

A design principle that helps achieve that goal is to keep interfaces separate from implementations. This means that the methods having an argument annotated with a type should not depend on how the fields of that type are represented.
(((interface)))(((implementation)))

For example, in this chapter we developed a struct that represents a time of day. Methods having an argument annotated with this type include +timetoint+, +isafter+, and +pass:[+]+.

We could implement those methods in several ways. The details of the implementation depend on how we represent +MyTime+. In this chapter, the fields of a +MyTime+ object are +hour+, +minute+, and +second+.

As an alternative, we could replace these fields with a single integer representing the number of seconds since midnight. This implementation would make some functions, like +isafter+, easier to write, but it makes other functions harder.

After you deploy a new type, you might discover a better implementation. If other parts of the program are using your type, it might be time-consuming and error-prone to change the interface.

But if you designed the interface carefully, you can change the implementation without changing the interface, which means that other parts of the program don’t have to change.


=== Debugging

Calling a function with the correct arguments can be difficult when more than one method for the function is specified. Julia allows to introspect the signatures of the methods of a function.

To know what methods are available for a given function, you can use the function +methods+:
(((methods)))(((debugging)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; methods(printtime)
# 2 methods for generic function "printtime":
[1] printtime(time::MyTime) in Main at REPL[3]:2
[2] printtime(time) in Main at REPL[4]:2</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In this example, the function +printtime+ has 2 methods: one with a +MyTime+ argument and one with an +Any+ argument.


=== Glossary

type annotation::
The operator +::+ followed by a type indicating that an expression or a variable is of that type.
(((type annotation)))

method::
A definition of a possible behavior for a function.
(((method)))

dispatch::
The choice of which method to execute when a function is executed.
(((dispatch)))

signature::
The number and type of the arguments of a method allowing the dispatch to select the most specific method of a function during the function call.
(((signature)))

outer constructor::
Constructor defined outside the type definition to define convenience methods for creating an object.
(((outer constructor)))

inner constructor::
Constructor defined inside the type definition to enforce invariants or to construct self-referential objects.
(((inner constructor)))

default constructor::
Inner constructor that is available when no programmer-defined inner constructors are provided.
(((default constructor)))

copy constructor::
Outer constructor method of a type with as only argument an object of the type. It creates a new object that is a copy of the argument.
(((copy constructor)))

operator overloading::
Adding to the behavior of an operator like +pass:[+]+ so it works with a programmer-defined type.
(((operator overloading)))

multiple dispatch::
Dispatch based on all of a function's arguments.
(((multiple dispatch)))

generic programming::
Writing code that can work with more than one type.
(((generic programming)))


=== Exercises

[[ex17-1]]
===== Exercise 17-4

Change the fields of +MyTime+ to be a single integer representing seconds since midnight. Then modify the methods defined in this chapter to work with the new implementation.

[[ex17-2]]
===== Exercise 17-5

Write a definition for a type named +Kangaroo+ with a field named +pouchcontents+ of type +Array+ and the following methods:
(((Kangaroo)))((("type", "programmer-defined", "Kangaroo", see="Kangaroo")))

* A constructor that initializes +pouchcontents+ to an empty array.

* A method named +putinpouch+ that takes a +Kangaroo+ object and an object of any type and adds it to +pouchcontents+.
(((putinpouch)))((("function", "programmer-defined", "putinpouch", see="putinpouch")))

* A +show+ method that returns a string representation of the +Kangaroo+ object and the contents of the pouch.
(((show)))

Test your code by creating two +Kangaroo+ objects, assigning them to variables named +kanga+ and +roo+, and then adding +roo+ to the contents of +kanga+’s pouch.


[[chap18]]
== Subtyping

In the previous chapter we introduced the multiple dispatch mechanism and polymorphic methods. Not specifying the type of the arguments results in a method that can be called with arguments of any type. Specifying a subset of allowed types in the signature of a method is a logical next step.

In this chapter I demonstrate subtyping using types that represent playing cards, decks of cards, and poker hands.

If you don’t play poker, you can read about it at https://en.wikipedia.org/wiki/Poker, but you don’t have to; I’ll tell you what you need to know for the exercises.


=== Cards

There are fifty-two cards in a deck, each of which belongs to one of four suits and one of thirteen ranks. The suits are Spades (+♠+), Hearts (+♥+), Diamonds (+♦+), and Clubs (+♣+). The ranks are Ace (A), 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack (J), Queen (Q), and King (K). Depending on the game that you are playing, an Ace may be higher than King or lower than 2.

If we want to define a new object to represent a playing card, it is obvious what the attributes should be: rank and suit. It is not as obvious what type the attributes should be. One possibility is to use strings containing words like +"Spade"+ for suits and +"Queen"+ for ranks. One problem with this implementation is that it would not be easy to compare cards to see which had a higher rank or suit.

An alternative is to use integers to _encode_ the ranks and suits. In this context, “encode” means that we are going to define a mapping between numbers and suits, or between numbers and ranks. This kind of encoding is not meant to be a secret (that would be “encryption”).
(((encode)))

For example, this table shows the suits and the corresponding integer codes:

* +♠+  latexmath:[\(\mapsto\)]  4

* +♥+  latexmath:[\(\mapsto\)]  3

* +♦+  latexmath:[\(\mapsto\)]  2

* +♣+  latexmath:[\(\mapsto\)]  1

This code makes it easy to compare cards; because higher suits map to higher numbers, we can compare suits by comparing their codes.

I am using the latexmath:[\(\mapsto\)] symbol to make it clear that these mappings are not part of the Julia program. They are part of the program design, but they don’t appear explicitly in the code.

The struct definition for +Card+ looks like this:
(((Card)))((("type", "programmer-defined", "Card", see="Card")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>struct Card
    suit :: Int64
    rank :: Int64
    function Card(suit::Int64, rank::Int64)
        @assert(1 ≤ suit ≤ 4, "suit is not between 1 and 4")
        @assert(1 ≤ rank ≤ 13, "rank is not between 1 and 13")
        new(suit, rank)
    end
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>To create a +Card+, you call +Card+ with the suit and rank of the card you want:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; queen_of_diamonds = Card(2, 12)
Card(2, 12)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Global Variables

In order to print +Card+ objects in a way that people can easily read, we need a mapping from the integer codes to the corresponding ranks and suits. A natural way to do that is with arrays of strings:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>const suit_names = ["♣", "♦", "♥", "♠"]
const rank_names = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The variables +suit_names+ and +rank_names+ are global variables. The +const+ declaration means that the variable can only be assigned once. This solves the performance problem of global variables.
(((global statement)))(((const)))((("keyword", "const", see="const")))

Now we can implement an appropriate +show+ method:
(((show)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function Base.show(io::IO, card::Card)
    print(io, rank_names[card.rank], suit_names[card.suit])
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The expression +rank_names[card.rank]+ means “use the field +rank+ from the object +card+ as an index into the array +rank_names+, and select the appropriate string.”

With the methods we have so far, we can create and print cards:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; Card(3, 11)
J♥</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Comparing Cards

For built-in types, there are relational operators (+&lt;+, +&gt;+, +==+, etc.) that compare values and determine when one is greater than, less than, or equal to another. For programmer-defined types, we can override the behavior of the built-in operators by providing a method named: +&lt;+.

The correct ordering for cards is not obvious. For example, which is better, the 3 of Clubs or the 2 of Diamonds? One has a higher rank, but the other has a higher suit. In order to compare cards, you have to decide whether rank or suit is more important.

The answer might depend on what game you are playing, but to keep things simple, we’ll make the arbitrary choice that suit is more important, so all of the Spades outrank all of the Diamonds, and so on.

With that decided, we can write +&lt;+

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>import Base.&lt;</p>
</div>
<div class="paragraph">
<p>function &lt;(c1::Card, c2::Card)
    (c1.suit, c1.rank) &lt; (c2.suit, c2.rank)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Exercise 18-1

Write a +&lt;+ method for +MyTime+ objects. You can use tuple comparison, but you also might consider comparing integers.


=== Unit Testing


_Unit testing_ allows you to verify the correctness of your code by comparing the results of your code to what you expect. This can be useful to be sure that your code still is correct after modifications, and it is also a way to predefine the correct behaviour of your code during development.
(((unit testing)))

Simple unit testing can be performed with the +@test+ macros:
(((Test)))((("module", "Test", see="Test")))(((@test)))((("macro", "Test", "@test", see="@test")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; using Test</p>
</div>
<div class="paragraph">
<p>julia&gt; @test Card(1, 4) &lt; Card(2, 4)
Test Passed
julia&gt; @test Card(1, 3) &lt; Card(1, 4)
Test Passed</p>
</div>
<div class="listingblock">
<div class="content">
<pre>+@test+ returns a +"Test Passed"+ if the expression following it is +true+, a +"Test Failed"+ if it is +false+, and an +"Error Result"+ if it could not be evaluated.


=== Decks

Now that we have Cards, the next step is to define Decks. Since a deck is made up of cards, it is natural for each Deck to contain an array of cards as an attribute.

The following is a struct definition for +Deck+. The constructor creates the fields cards and generates the standard set of fifty-two cards:
(((Deck)))((("type", "programmer-defined", "Deck", see="Deck")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>struct Deck
    cards :: Array{Card, 1}
end</p>
</div>
<div class="paragraph">
<p>function Deck()
    deck = Deck(Card[])
    for suit in 1:4
        for rank in 1:13
            push!(deck.cards, Card(suit, rank))
        end
    end
    deck
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The easiest way to populate the deck is with a nested loop. The outer loop enumerates the suits from 1 to 4. The inner loop enumerates the ranks from 1 to 13. Each iteration creates a new +Card+ with the current suit and rank, and pushes it to +deck.cards+.

Here is a +show+ method for +Deck+:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function Base.show(io::IO, deck::Deck)
    for card in deck.cards
        print(io, card, " ")
    end
    println()
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Here’s what the result looks like:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; Deck()
A♣ 2♣ 3♣ 4♣ 5♣ 6♣ 7♣ 8♣ 9♣ 10♣ J♣ Q♣ K♣ A♦ 2♦ 3♦ 4♦ 5♦ 6♦ 7♦ 8♦ 9♦ 10♦ J♦ Q♦ K♦ A♥ 2♥ 3♥ 4♥ 5♥ 6♥ 7♥ 8♥ 9♥ 10♥ J♥ Q♥ K♥ A♠ 2♠ 3♠ 4♠ 5♠ 6♠ 7♠ 8♠ 9♠ 10♠ J♠ Q♠ K♠</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Add, Remove, Shuffle and Sort

To deal cards, we would like a function that removes a card from the deck and returns it. The function +pop!+ provides a convenient way to do that:
(((pop!)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function Base.pop!(deck::Deck)
    pop!(deck.cards)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Since +pop!+ removes the last card in the array, we are dealing from the bottom of the deck.

To add a card, we can use the function +push!+:
(((push!)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function Base.push!(deck::Deck, card::Card)
    push!(deck.cards, card)
    deck
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A method like this that uses another method without doing much work is sometimes called a _veneer_. The metaphor comes from woodworking, where a veneer is a thin layer of good quality wood glued to the surface of a cheaper piece of wood to improve the appearance.
(((veneer)))

In this case +push!+ is a “thin” method that expresses an array operation in terms appropriate for decks. It improves the appearance, or interface, of the implementation.

As another example, we can write a method named +shuffle!+ using the function +Random.shuffle!+:
(((Random)))((("module", "Random", see="Random")))(((shuffle!)))((("function", "Random", "shuffle!", see="shuffle!")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>using Random</p>
</div>
<div class="paragraph">
<p>function Random.shuffle!(deck::Deck)
    shuffle!(deck.cards)
    deck
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Exercise 18-2

Write a function named +sort!+ that uses the function +sort!+ to sort the cards in a Deck. +sort!+ uses the +isless+ method we defined to determine the order.
(((sort!)))


=== Abstract Types and Subtyping

We want a type to represent a “hand”, that is, the cards held by one player. A hand is similar to a deck: both are made up of a collection of cards, and both require operations like adding and removing cards.

A hand is also different from a deck; there are operations we want for hands that don’t make sense for a deck. For example, in poker we might compare two hands to see which one wins. In bridge, we might compute a score for a hand in order to make a bid.

So we need a way to group related _concrete types_. In Julia this is done by defining an _abstract type_ that serves as a parent for both +Deck+ and +Hand+. This is called _subtyping_
(((concrete type)))(((abstract type)))(((subtyping)))

Let's call this abstract type +CardSet+:
(((CardSet)))((("type", "programmer-defined", "CardSet", see="CardSet")))


[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>abstract type CardSet end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A new abstract type is created with the +abstract type+ keyword. An optional “parent” type can be specified by putting after the name +&lt;:+ followed by the name of an already-existing abstract type.
(((abstract type)))((("keyword", "abstract type", see="abstract type")))(((type)))

When no _supertype_ is given, the default supertype is +Any+ – a predefined abstract type that all objects are instances of and all types are _subtypes_ of.
(((supertype)))(((subtype)))

We can now express that +Deck+ is a descendant of +CardSet+:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>struct Deck &lt;: CardSet
    cards :: Array{Card, 1}
end</p>
</div>
<div class="paragraph">
<p>function Deck()
    deck = Deck(Card[])
    for suit in 1:4
        for rank in 1:13
            push!(deck.cards, Card(suit, rank))
        end
    end
    deck
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The operator +isa+ checks whether an object is of a given type:
(((isa)))((("operator", "Base", "isa", see="isa")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; deck = Deck();</p>
</div>
<div class="paragraph">
<p>julia&gt; deck isa CardSet
true</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A hand is also a kind of +CardSet+:
(((Hand)))((("type", "programmer-defined", "Hand", see="Hand")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>struct Hand &lt;: CardSet
    cards :: Array{Card, 1}
    label :: String
end</p>
</div>
<div class="paragraph">
<p>function Hand(label::String="")
    Hand(Card[], label)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Instead of populating the hand with 52 new cards, the constructor for +Hand+ initializes +cards+ with an empty array. An optional argument can be passed to the constructor giving a label to the +Hand+.

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; hand = Hand("new hand")
Hand(Card[], "new hand")</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Abstract Types and Functions

We can now express the common operations between +Deck+ and +Hand+ as functions having as argument +CardSet+:
(((show)))(((pop!)))(((push!)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function Base.show(io::IO, cs::CardSet)
    for card in cs.cards
        print(io, card, " ")
    end
end</p>
</div>
<div class="paragraph">
<p>function Base.pop!(cs::CardSet)
    pop!(cs.cards)
end</p>
</div>
<div class="paragraph">
<p>function Base.push!(cs::CardSet, card::Card)
    push!(cs.cards, card)
    nothing
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>We can use +pop!+ and +push!+ to deal a card:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; deck = Deck()
A♣ 2♣ 3♣ 4♣ 5♣ 6♣ 7♣ 8♣ 9♣ 10♣ J♣ Q♣ K♣ A♦ 2♦ 3♦ 4♦ 5♦ 6♦ 7♦ 8♦ 9♦ 10♦ J♦ Q♦ K♦ A♥ 2♥ 3♥ 4♥ 5♥ 6♥ 7♥ 8♥ 9♥ 10♥ J♥ Q♥ K♥ A♠ 2♠ 3♠ 4♠ 5♠ 6♠ 7♠ 8♠ 9♠ 10♠ J♠ Q♠ K♠
julia&gt; shuffle!(deck)
6♠ 7♥ K♥ 10♦ 10♥ 4♣ 9♣ 8♠ K♠ 6♣ K♦ J♣ 2♦ 3♥ 2♣ Q♣ 10♣ 2♥ 8♦ K♣ A♦ 4♠ 8♥ Q♦ 3♣ 6♥ A♥ 5♦ 5♣ J♠ 4♦ 9♥ 7♣ Q♥ 5♥ J♦ 9♠ 7♠ 8♣ 6♦ A♠ 9♦ J♥ 10♠ A♣ 5♠ Q♠ 2♠ 3♦ 3♠ 4♥ 7♦
julia&gt; card = pop!(deck)
7♦
julia&gt; push!(hand, card)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A natural next step is to encapsulate this code in a function called +move!+:
(((move!)))((("function", "programmer-defined", "move!", see="move!")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function move!(cs1::CardSet, cs2::CardSet, n::Int)
    @assert 1 ≤ n ≤ length(cs1.cards)
    for i in 1:n
        card = pop!(cs1)
        push!(cs2, card)
    end
    nothing
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>+move!+ takes three arguments, two +Cardset+ objects and the number of cards to deal. It modifies both +Cardset+ objects, and returns +nothing+.

In some games, cards are moved from one hand to another, or from a hand back to the deck. You can use +move!+ for any of these operations: +cs1+ and +cs2+ can be either a +Deck+ or a +Hand+.


=== Type Diagrams

So far we have seen stack diagrams, which show the state of a program, and object diagrams, which show the attributes of an object and their values. These diagrams represent a snapshot in the execution of a program, so they change as the program runs.

They are also highly detailed; for some purposes, too detailed. A _type diagram_ is a more abstract representation of the structure of a program. Instead of showing individual objects, it shows types and the relationships between them.
(((type diagram)))((("diagram", "type", see="type diagram")))

There are several kinds of relationship between types:

* Objects of a concrete type might contain references to objects of another type. For example, each Rectangle contains a reference to a Point, and each Deck contains references to an array of Cards. This kind of relationship is called _HAS-A_, as in, “a Rectangle has a Point”.
(((HAS-A)))

* A concrete type can have an abstract type as a supertype. This relationship is called _IS-A_, as in, “a Hand is a kind of a CardSet.”
(((IS-A)))

* One type might depend on another in the sense that objects of one type take objects of the second type as parameters, or use objects of the second type as part of a computation. This kind of relationship is called a _dependency_.
(((dependency)))

[[fig18-1]]
.Type diagram
image::images/fig181.svg[]

The arrow with a hollow triangle head represents an IS-A relationship; in this case it indicates that Hand has as supertype CardSet.

The standard arrow head represents a HAS-A relationship; in this case a Deck has references to Card objects.

The star (+pass:[*]+) near the arrow head is a _multiplicity_; it indicates how many Cards a Deck has. A multiplicity can be a simple number, like +52+, a range, +like 5:7+ or a star, which indicates that a Deck can have any number of Cards.
(((multiplicity)))

There are no dependencies in this diagram. They would normally be shown with a dashed arrow. Or if there are a lot of dependencies, they are sometimes omitted.

A more detailed diagram might show that a Deck actually contains an array of Cards, but built-in types like array and dictionnaries are usually not included in type diagrams.

[[interactive]]
=== Debugging

Subtyping can make debugging difficult because when you call a function with an object as argument, it might be hard to figure out which method will be invoked.

Suppose you are writing a function that works with +Hand+ objects. You would like it to work with all kinds of +Hand+s, like +PokerHand+s, +BridgeHand+s, etc. If you invoke a method like +sort!+, you might get the one defined for an abstract type +Hand+, but if a method +sort!+ with as argument any of the subtypes exists, you’ll get that version instead. This behavior is usually a good thing, but it can be confusing.

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function Base.sort!(hand::Hand)
    sort!(hand.cards)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Any time you are unsure about the flow of execution through your program, the simplest solution is to add print statements at the beginning of the relevant methods. If +shuffle!+ prints a message that says something like +Running shuffle! Deck+, then as the program runs it traces the flow of execution.

As better alternative, you can also use the +@which+ macro:
(((InteractiveUtils)))((("module", "InteractiveUtils", see="InteractiveUtils")))(((@which)))((("macro", "InteractiveUtils", "@which", see="@which")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; @which sort!(hand)
sort!(hand::Hand) in Main at REPL[5]:1</p>
</div>
<div class="listingblock">
<div class="content">
<pre>So the +sort!+ method for +hand+ is the one having as argument an object of type +Hand+.

Here’s a design suggestion: when you override a method, the interface of the new method should be the same as the old. It should take the same parameters, return the same type, and obey the same preconditions and postconditions. If you follow this rule, you will find that any function designed to work with an instance of a supertype, like a +CardSet+, will also work with instances of its subtypes +Deck+ and +Hand+.

If you violate this rule, which is called the “Liskov substitution principle”, your code will collapse like (sorry) a house of cards.
(((Liskov substitution principle)))

The function +supertype+ can be used to find the direct supertype of a type.
(((supertype)))((("function", "Base", "supertype", see="supertype")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; supertype(Deck)
CardSet</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Data Encapsulation

The previous chapters demonstrate a development plan we might call “type-oriented design”. We identified objects we needed—like +Point+, +Rectangle+ and +MyTime+—and defined structs to represent them. In each case there is an obvious correspondence between the object and some entity in the real world (or at least a mathematical world).
(((type-oriented design)))

But sometimes it is less obvious what objects you need and how they should interact. In that case you need a different development plan. In the same way that we discovered function interfaces by encapsulation and generalization, we can discover type interfaces by _data encapsulation_.
(((data encapsulation)))

Markov analysis, from &lt;&lt;markov_analysis&gt;&gt;, provides a good example. If you download my code from https://github.com/BenLauwens/ThinkJulia.jl/blob/master/src/solutions/chap13.jl, you’ll see that it uses two global variables—+suffixes+ and +prefix+—that are read and written from several functions.

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>suffixes = Dict()
prefix = []</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Because these variables are global, we can only run one analysis at a time. If we read two texts, their prefixes and suffixes would be added to the same data structures (which makes for some interesting generated text).

To run multiple analyses, and keep them separate, we can encapsulate the state of each analysis in an object. Here’s what that looks like:
(((Markov)))((("type", "programmer-defined", "Markov", see="Markov")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>struct Markov
    order :: Int64
    suffixes :: Dict{Tuple{String,Vararg{String}}, Array{String, 1}}
    prefix :: Array{String, 1}
end</p>
</div>
<div class="paragraph">
<p>function Markov(order::Int64=2)
    new(order, Dict{Tuple{String,Vararg{String}}, Array{String, 1}}(), Array{String, 1}())
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Next, we transform the functions into methods. For example, here’s +processword+:
(((processword)))((("function", "programmer-defined", "processword", see="processword")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function processword(markov::Markov, word::String)
    if length(markov.prefix) &lt; markov.order
        push!(markov.prefix, word)
        return
    end
    get!(markov.suffixes, (markov.prefix&#8230;&#8203;,), Array{String, 1}())
    push!(markov.suffixes[(markov.prefix&#8230;&#8203;,)], word)
    popfirst!(markov.prefix)
    push!(markov.prefix, word)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Transforming a program like this—changing the design without changing the behavior—is another example of refactoring (see &lt;&lt;refactoring&gt;&gt;).
(((refactoring)))(((program development plan)))

This example suggests a development plan for designing types:

* Start by writing functions that read and write global variables (when necessary).

* Once you get the program working, look for associations between global variables and the functions that use them.

* Encapsulate related variables as fields of a struct.

* Transform the associated functions into methods with as argument objects of the new type.

===== Exercise 18-3

Download my Markov code from https://github.com/BenLauwens/ThinkJulia.jl/blob/master/src/solutions/chap13.jl, and follow the steps described above to encapsulate the global variables as attributes of a new struct called +Markov+.


=== Glossary

encode::
To represent one set of values using another set of values by constructing a mapping between them.
(((encode)))

unit testing::
Standardized way to test the correctness of code.
(((unit testing)))

veneer::
A method or function that provides a different interface to another function without doing much computation.
(((veneer)))

subtyping::
The ability to define a hierarchy of related types.
(((subtyping)))

abstract type::
A type that can act as a parent for another type.
(((abstract type)))

concrete type::
A type that can be constructed.
(((concrete type)))

subtype::
A type that has as parent an abstract type.
(((subtype)))

supertype::
An abstract type that is the parent of another type.
(((supertype)))

IS-A relationship::
A relationship between a subtype and its supertype.
(((IS-A relationship)))

HAS-A relationship::
A relationship between two types where instances of one type contain references to instances of the other.
(((HAS-A relationship)))

dependency::
A relationship between two types where instances of one type use instances of the other type, but do not store them as fields.
(((dependency)))

type diagram::
A diagram that shows the types in a program and the relationships between them.
(((type diagram)))

multiplicity::
A notation in a type diagram that shows, for a HAS-A relationship, how many references there are to instances of another class.
(((multiplicity)))

data encapsulation::
A program development plan that involves a prototype using global variables and a final version that makes the global variables into instance fields.
(((data encapsulation)))


=== Exercises

[[ex18-1]]
===== Exercise 18-4

For the following program, draw a type diagram that shows these types and the relationships among them.

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>abstract type PingPongParent end</p>
</div>
<div class="paragraph">
<p>struct Ping &lt;: PingPongParent
    pong :: PingPongParent
end</p>
</div>
<div class="paragraph">
<p>struct Pong &lt;: PingPongParent
    pings :: Array{Ping, 1}
    function Pong(pings=Array{Ping, 1}())
        new(pings)
    end
end</p>
</div>
<div class="paragraph">
<p>function addping(pong::Pong, ping::Ping)
    push!(pong.pings, ping)
    nothing
end</p>
</div>
<div class="paragraph">
<p>pong = Pong()
ping = Ping(pong)
addping(pong, ping)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[[ex18-2]]
===== Exercise 18-5

Write a method called +deal!+ that takes three parameters, a +Deck+, the number of hands and the number of cards per hand. It should create the appropriate number of +Hand+ objects, deal the appropriate number of cards per hand, and return an array of +Hand+s.
(((deal!)))((("function", "programmer-defined", "deal!", see="deal!")))

[[ex18-3]]
===== Exercise 18-6

The following are the possible hands in poker, in increasing order of value and decreasing order of probability:

pair::
two cards with the same rank

two pair::
two pairs of cards with the same rank

three of a kind::
three cards with the same rank

straight::
five cards with ranks in sequence (aces can be high or low, so Ace-2-3-4-5 is a straight and so is 10-Jack-Queen-King-Ace, but Queen-King-Ace-2-3 is not.)

flush::
five cards with the same suit

full house::
three cards with one rank, two cards with another

four of a kind::
four cards with the same rank

straight flush::
five cards in sequence (as defined above) and with the same suit

The goal of this exercise is to estimate the probability of drawing these various hands.

. Add methods named +haspair+, +hastwopair+, etc. that return +true+ or +false+ according to whether or not the hand meets the relevant criteria. Your code should work correctly for “hands” that contain any number of cards (although 5 and 7 are the most common sizes).
(((haspair)))((("function", "programmer-defined", "haspair", see="haspair")))(((hastwopair)))((("function", "programmer-defined", "hastwopair", see="hastwopair")))

. Write a method named +classify+ that figures out the highest-value classification for a hand and sets the +label+ field accordingly. For example, a 7-card hand might contain a flush and a pair; it should be labeled “flush”.
(((classify)))((("function", "programmer-defined", "classify", see="classify")))

. When you are convinced that your classification methods are working, the next step is to estimate the probabilities of the various hands. Write a function that shuffles a deck of cards, divides it into hands, classifies the hands, and counts the number of times various classifications appear.

. Print a table of the classifications and their probabilities. Run your program with larger and larger numbers of hands until the output values converge to a reasonable degree of accuracy. Compare your results to the values at https://en.wikipedia.org/wiki/Hand_rankings.


[[chap19]]
== The Goodies: Syntax

One of my goals for this book has been to teach you as little Julia as possible. When there were two ways to do something, I picked one and avoided mentioning the other. Or sometimes I put the second one into an exercise.

Now I want to go back for some of the good bits that got left behind. Julia provides a number of features that are not really necessary—you can write good code without them—but with them you can sometimes write code that’s more concise, readable or efficient, and sometimes all three.

This chapter and the next discuss the things I have left out in the previous chapters:

* syntax supplements
* functions, types and macros directly available in +Base+
(((Base)))
* functions, types and macros in the Standard Library
(((Standard Library)))

=== Named Tuples

You can name the components of a tuple, creating a named tuple:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; x = (a=1, b=1+1)
(a = 1, b = 2)
julia&gt; x.a
1</p>
</div>
<div class="listingblock">
<div class="content">
<pre>With named tuples, fields can be accessed by name using dot syntax +(x.a)+.
(((named tuple)))(((dot syntax)))


=== Functions

Function in Julia can be defined by a compact syntax.

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; f(x,y) = x + y
f (generic function with 1 method)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[[anonymous_functions]]
==== Anonymous Functions

We can define a function without specifying a name:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; x &#8594; x^2 + 2x - 1
#1 (generic function with 1 method)
julia&gt; function (x)
           x^2 + 2x - 1
       end
#3 (generic function with 1 method)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>These are example of _anonymous functions_. Anonymous functions are often used as an argument to another function:
(((anonymous function)))(((Plots)))((("module", "Plots", see="Plots")))(((plot)))((("function", "Plots", "plot", see="plot")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; using Plots</p>
</div>
<div class="paragraph">
<p>julia&gt; plot(x &#8594; x^2 + 2x - 1, 0, 10, xlabel="x", ylabel="y")</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;&lt;fig19-1&gt;&gt; shows the output of the plotting command.

[[fig19-1]]
.Plot
image::images/fig191.svg[pdfwidth="10cm"]

==== Keyword Arguments

Function arguments can also be named:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; function myplot(x, y; style="solid", width=1, color="black")
           <mark>#</mark>
       end
myplot (generic function with 1 method)
julia&gt; myplot(0:10, 0:10, style="dotted", color="blue")</p>
</div>
<div class="listingblock">
<div class="content">
<pre>_Keyword arguments_ in a function are specified after a semicolon in the signature but can be called with a comma.
(((;)))(((keyword arguments)))

==== Closures

A _closure_ is a technique allowing a function to capture a variable defined outside the calling scope of the function.

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; foo(x) = ()&#8594;x
foo (generic function with 1 method)</p>
</div>
<div class="paragraph">
<p>julia&gt; bar = foo(1)
#1 (generic function with 1 method)</p>
</div>
<div class="paragraph">
<p>julia&gt; bar()
1</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In this example, the function +foo+ returns an anonymous function that has access to the +x+ argument of the function +foo+. +bar+ points to the anonymous function and returns the value of the argument of +foo+.


=== Blocks

A _block_ is a way to group a number of statements. A block starts with the keyword +begin+ and ends with +end+.
(((begin)))((("keyword", "begin", see="begin")))(((end)))(((block)))

In &lt;&lt;chap04&gt;&gt; the +@svg+ macro was introduced:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>🐢 = Turtle()
@svg begin
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In this example, the macro +@svg+ has a single argument, i.e. a block grouping 3 function calls.

==== +let+ Blocks

A +let+ block is useful to create new bindings, i.e. locations that can refer to values.

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; x, y, z = -1, -1, -1;</p>
</div>
<div class="paragraph">
<p>julia&gt; let x = 1, z
           @show x y z;
       end
x = 1
y = -1
ERROR: UndefVarError: z not defined
julia&gt; @show x y z;
x = -1
y = -1
z = -1</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In the example, the first +@show+ macro, shows the local +x+, the global +y+ and the undefined local +z+. The global variables are untouched.


==== +do+ Blocks

In &lt;&lt;reading_and_writing&gt;&gt; we had to close the file after when where done writing. This can be done automatically using a _do block_:
(((do)))((("keyword", "do", see="do")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; data = "This here&#8217;s the wattle,\nthe emblem of our land.\n"
"This here&#8217;s the wattle,\nthe emblem of our land.\n"
julia&gt; open("output.txt", "w") do fout
           write(fout, data)
       end
48</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In this example +fout+ is the file stream used for output.

This is functionally equivalent to

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; f = fout &#8594; begin
           write(fout, data)
       end
#3 (generic function with 1 method)
julia&gt; open(f, "output.txt", "w")
48</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The anonymous function is used as the first argument of the function +open+:
(((open)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function open(f::Function, args&#8230;&#8203;)
    io = open(args&#8230;&#8203;)
    try
        f(io)
    finally
        close(io)
    end
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A +do+ block can “capture” variables from its enclosing scope. For example, the variable +data+ in the above example of +open pass:[...] do+ is captured from the outer scope.


=== Control Flow

==== Ternary Operator

The _ternary operator_, +?:+, is an alternative to an +if-elseif+ statement used when you need to make a choice between single expression values.
(((?:)))((("operator", "Base", "?:", see="?:")))((("ternary operator", see="?:")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; a = 150
150
julia&gt; a % 2 == 0 ? println("even") : println("odd")
even</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The expression before the +?+ is a condition expression. If the condition is +true+, the expression before the +:+ is evaluated, otherwise, the expression after the +:+ is evaluated.

==== Short-Circuit Evaluation

The operators +&amp;&amp;+ and +||+ do a _short-circuit evaluation_: a next argument is only evaluated when it is needed to determine the final value.
(((&amp;&amp;)))(((||)))(((short-circuit evaluation)))

For example, a recursive factorial routine could be defined like this:
(((fact)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function fact(n::Integer)
    n &gt;= 0 || error("n must be non-negative")
    n == 0 &amp;&amp; return 1
    n * fact(n-1)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>==== Tasks (aka Coroutines)

A _task_ is a control structure that can pass cooperatively control without returning. In Julia, a task can be implemented as a function having as first argument a +Channel+ object. A channel is used to pass values from the function to the callee.

The Fibonnaci sequence can be generated using a task.
(((task)))(((Channel)))((("type", "Base", "Channel", see="Channel")))(((put!)))((("function", "Base", "put!", see="put!")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function fib(c::Channel)
    a = 0
    b = 1
    put!(c, a)
    while true
        put!(c, b)
        (a, b) = (b, a+b)
    end
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>+put!+ stores values in a channel object and +take!+ reads values from it:
(((take!)))((("function", "Base", "take!", see="take!")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; fib_gen = Channel(fib);</p>
</div>
<div class="paragraph">
<p>julia&gt; take!(fib_gen)
0
julia&gt; take!(fib_gen)
1
julia&gt; take!(fib_gen)
1
julia&gt; take!(fib_gen)
2
julia&gt; take!(fib_gen)
3</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The constructor +Channel+ creates the task. The function +fib+ is suspended after each call to +put!+ and resumed after +take!+. For performance reasons, several values of the sequence are buffered in the channel object during a resume/suspend cycle.

A channel object can also be used as an iterator:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; for val in Channel(fib)
           print(val, " ")
           val &gt; 20 &amp;&amp; break
       end
0 1 1 2 3 5 8 13 21</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Types

==== Primitive Types

A concrete type consisting of plain old bits is called a _primitive type_. Unlike most languages, with Julia you can declare your own primitive types. The standard primitive types are defined in the same way:
(((primitive type)))((("keyword", "primitive type", see="primitive type")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>primitive type Float64 &lt;: AbstractFloat 64 end
primitive type Bool &lt;: Integer 8 end
primitive type Char &lt;: AbstractChar 32 end
primitive type Int64 &lt;: Signed 64 end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The number in the statements specifies how many bits are required.

The following example creates a primitive type +Byte+ and a constructor:
(((Byte)))((("type", "programmer-defined", "Byte", see="Byte")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; primitive type Byte 8 end</p>
</div>
<div class="paragraph">
<p>julia&gt; Byte(val::UInt8) = reinterpret(Byte, val)
Byte
julia&gt; b = Byte(0x01)
Byte(0x01)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The function +reinterpret+ is used to store the bits of an unsigned integer with 8 bits (+UInt8+) into the byte.
(((reinterpret)))((("function", "Base", "reinterpret", see="reinterpret")))(((UInt8)))((("type", "Base", "UInt8", see="UInt8")))

==== Parametric Types

Julia's type system is _parametric_, meaning that types can have parameters.

Type parameters are introduced after the name of the type, surrounded by curly braces:
(((curly braces)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>struct Point{T&lt;:Real}
    x::T
    y::T
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>This defines a new parametric type, +Point{T&lt;:Real}+, holding two "coordinates" of type +T+, which can be any type having +Real+ as supertype.

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; Point(0.0, 0.0)
Point{Float64}(0.0, 0.0)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In addition to composite types, abstract types and primitive types can also have a type parameter.

[TIP]
====
Having concrete types for struct fields is absolutely recommended for performance reasons, so this is a good way to make +Point+ both fast and flexible.
====

==== Type Unions

A _type union_ is an abstract parametric type that can act as any of its argument types:
(((type union)))(((Union)))((("type", "Base", "Union", see="Union")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; IntOrString = Union{Int64, String}
Union{Int64, String}
julia&gt; 150 :: IntOrString
150
julia&gt; "Julia" :: IntOrString
"Julia"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A type union is in most computer language an internal construct for reasoning about types. Julia however exposes this feature to its users because efficient code can be generated when the type union has a small number of types. This feature gives the Julia programmer a tremendous flexibility for controlling dispatch.

=== Methods

==== Parametric Methods

Method definitions can also have type parameters qualifying their signature:
(((signature)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; isintpoint(p::Point{T}) where {T} = (T === Int64)
isintpoint (generic function with 1 method)
julia&gt; p = Point(1, 2)
Point{Int64}(1, 2)
julia&gt; isintpoint(p)
true</p>
</div>
<div class="listingblock">
<div class="content">
<pre>==== Function-like Objects

Any arbitrary Julia object can be made “callable”. Such “callable” objects are sometimes called _functors_.
(((functor)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>struct Polynomial{R}
    coeff::Vector{R}
end</p>
</div>
<div class="paragraph">
<p>function (p::Polynomial)(x)
    val = p.coeff[end]
    for coeff in p.coeff[end-1:-1:1]
        val = val * x + coeff
    end
    val
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>To evaluate the polynomial, we simply have to call it:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; p = Polynomial([1,10,100])
Polynomial{Int64}([1, 10, 100])
julia&gt; p(3)
931</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Constructors

Parametric types can be explicitly or implicitly constructed:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; Point(1,2)         # implicit T
Point{Int64}(1, 2)
julia&gt; Point{Int64}(1, 2) # explicit T
Point{Int64}(1, 2)
julia&gt; Point(1,2.5)       # implicit T
ERROR: MethodError: no method matching Point(::Int64, ::Float64)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Default inner and outer constructors are generated for each +T+:
(((constructor)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>struct Point{T&lt;:Real}
    x::T
    y::T
    Point{T}(x,y) where {T&lt;:Real} = new(x,y)
end</p>
</div>
<div class="paragraph">
<p>Point(x::T, y::T) where {T&lt;:Real} = Point{T}(x,y);</p>
</div>
<div class="listingblock">
<div class="content">
<pre>and both +x+ and +y+ have to be of the same type.

When +x+ and +y+ have a different type, the following outer constructor can be defined:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>Point(x::Real, y::Real) = Point(promote(x,y)&#8230;&#8203;);</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The +promote+ function is detailed in &lt;&lt;promotion&gt;&gt;.
(((promote)))((("function", "Base", "promote", see="promote")))

=== Conversion and Promotion

Julia has a system for promoting arguments to a common type. This is not done automatically but can be easily extended.

==== Conversion

A value can be converted from one type to another:
(((conversion)))(((convert)))((("function", "Base", "convert", see="convert")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; x = 12
12
julia&gt; typeof(x)
Int64
julia&gt; convert(UInt8, x)
0x0c
julia&gt; typeof(ans)
UInt8</p>
</div>
<div class="listingblock">
<div class="content">
<pre>We can add our own +convert+ methods:
[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; Base.convert(::Type{Point{T}}, x::Array{T, 1}) where {T&lt;:Real} = Point(x&#8230;&#8203;)</p>
</div>
<div class="paragraph">
<p>julia&gt; convert(Point{Int64}, [1, 2])
Point{Int64}(1, 2)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[[promotion]]
==== Promotion

_Promotion_ is the conversion of values of mixed types to a single common type:
(((promotion)))(((promote)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; promote(1, 2.5, 3)
(1.0, 2.5, 3.0)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Methods for the +promote+ function are normally not directly defined, but the auxiliary function +promote_rule+ is used to specify the rules for promotion:
(((promote_rule)))((("function", "Base", "promote_rule", see="promote_rule")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>promote_rule(::Type{Float64}, ::Type{Int32}) = Float64</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Metaprogramming

Julia code can be represented as a data structure of the language itself. This allows a program to transform and generate its own code.

==== Expressions

Every Julia program starts as a string:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; prog = "1 + 2"
"1 + 2"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The next step is to parse each string into an object called an _expression_, represented by the Julia type +Expr+:
(((expression)))(((Expr)))((("type", "Base", "Expr", see="Expr")))(((parse)))((("function", "Meta", "parse", see="parse")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; ex = Meta.parse(prog)
:(1 + 2)
julia&gt; typeof(ex)
Expr
julia&gt; dump(ex)
Expr
  head: Symbol call
  args: Array{Any}3,
    1: Symbol<br>
    2: Int64 1
    3: Int64 2</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The +dump+ function displays expr objects with annotations.
(((dump)))

Expressions can be constructed directly by prefixing with +:+ inside parentheses or using a quote block
(((:)))(((quote)))((("keyword", "quote", see="quote")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; ex = quote
           1 + 2
       end;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>==== +eval+

Julia can evaluate an expression object using +eval+:
(((eval)))((("function", "Core", "eval", see="eval")))


[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; eval(ex)
3</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Every module has its own +eval+ function that evaluates expressions in its scope.

[WARNING]
====
When you are using a lot of calls to the function +eval+, often this means that something is wrong. +eval+ is considered “evil”.
====

==== Macros

Macros can include generated code in a program. A _macro_ maps a tuple of +Expr+ objects directly to a compiled expression:
(((macro)))

Here is a simple macro:
(((@containervariable)))((("macro", "programmer-defined", "@containervariable", see="@containervariable")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>macro containervariable(container, element)
    return esc(:($(Symbol(container,element)) = $container[$element]))
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Macros are called by prefixing their name with the +@+ (at-sign). The macro call +@containervariable letters 1+ is replaced by:
(((@)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>:(letters1 = letters[1])</p>
</div>
<div class="listingblock">
<div class="content">
<pre>+@macroexpand @containervariable letters 1+  returns this expression which is extremely useful for debugging.
(((@macroexpand)))((("macro", "Base", "@macroexpand", see="@macroexpand")))

This example illustrates how a macro can access the name of its arguments, something a function can’t do. The return expression needs to be “escaped” with +esc+ because it has to be resolved in the macro call environment.
(((esc)))((("function", "Base", "esc", see="esc")))

[NOTE]
====
Why macros?

Macros generate and include fragments of customized code during parse time, thus _before_ the full program is run.
====

==== Generated Functions

The macro +@generated+ creates specialized code for methods depending on the types of the arguments:
(((generated functions)))(((@generated)))((("macro", "Base", "@generated", see="@generated")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>@generated function square(x)
    println(x)
    :(x * x)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The body returns a quoted expression like a macro.

For the caller, the _generated function_ behaves as a regular function:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; x = square(2); # note: output is from println() statement in the body
Int64
julia&gt; x              # now we print x
4
julia&gt; y = square("spam");
String
julia&gt; y
"spamspam"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Missing Values

_Missing values_ can be represented via the +missing+ object, which is the singleton instance of the type +Missing+.
(((missing values)))(((missing)))(((Missing)))((("type", "Base", "Missing", see="Missing")))

Arrays can contain missing values:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; a = [1, missing]
2-element Array{Union{Missing, Int64},1}:
 1
  missing</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The element type of such an array is +Union{Missing, T}+, with +T+ the type of the non-missing values.

Reduction functions return +missing+ when called on arrays which contain missing values

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; sum(a)
missing</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In this situation, use the +skipmissing+ function to skip missing values:
(((skipmissing)))((("function", "Base", "skipmissing", see="skipmissing")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; sum(skipmissing([1, missing]))
1</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Calling C and Fortran Code

A lot of code is written in C or Fortran. Reusing tested code is often better than writing your own version of an algorithm. Julia can call directly existing C or Fortran libraries using the +ccall+ syntax.
(((ccall)))((("function", "Base", "ccall", see="ccall")))

In &lt;&lt;databases&gt;&gt; we introduced a Julia interface to the GDBM library of database functions. The library is written in C. To close the database a function call to +close(db)+ has to be made:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>Base.close(dbm::DBM) = gdbm_close(dbm.handle)</p>
</div>
<div class="paragraph">
<p>function gdbm_close(handle::Ptr{Cvoid})
    ccall((:gdbm_close, "libgdbm"), Cvoid, (Ptr{Cvoid},), handle)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A dbm object has a field +handle+ of +Ptr{Cvoid}+ type. This field holds a C pointer that refers to the database. To close the database the C function +gdbm_close+ has to be called having as only argument the C pointer pointing to the database and no return value. Julia does this directly with the +ccall+ function having as arguments:
(((Ptr)))((("type", "Base", "Ptr", see="Ptr")))

* a tuple consisting of a symbol holding the name of the function we want to call: +:gdbm_close+ and the shared library specified as a string: +"libgdm"+,

* the return type: +Cvoid+,

* a tuple of argument types: +(Ptr{Cvoid},)+ and

* the argument values: +handle+.

The complete mapping of the GDBM library can be found as an example in the ThinkJulia sources.

=== Glossary

closure::
Function that captures variables from its defining scope.
(((closure)))

let block::
Block allocating new variable bindings.
(((let block)))

anonymous function::
Function defined without being given a name.
(((anonymous function)))

named tuple::
Tuple with named components.
(((named tuple)))

keyword arguments::
Arguments identified by name instead of only by position.
(((keyword arguments)))

do block::
Syntax construction used to define and call an anonymous function which looks like a normal code block.
(((do block)))

ternary operator::
Control flow operator taking three operands to specify a condition, an expression to be executed when the condition yields +true+ and an expression to be executed when the condition yields +false+.
(((ternary operator)))

short-circuit evaluation::
Evaluation of a boolean operator for which the second argument is executed or evaluated only if the first argument does not suffice to determine the value of the expression.
(((short-circuit evaluation)))

task (aka coroutine)::
Control flow feature that allows computations to be suspended and resumed in a flexible manner.
(((task)))

primitive type::
Concrete type whose data consists of plain old bits.
(((primitive type)))

type union::
Type which includes as objects all instances of any of its type parameters.
(((type union)))

parametric type::
Type that is parameterized.
(((parametric type)))

functor::
Object with an associated method, so that it is callable.
(((functor)))

conversion::
Conversion allows to convert a value from one type to another.
(((conversion)))

promotion::
Converting values of mixed types to a single common type.
(((promotion)))

expression::
Julia type that holds a language construct.
(((expression)))

macro::
Way to include generated code in the final body of a program.
(((macro)))

generated functions::
Functions capable of generating specialized code depending on the types of the arguments.
(((generated functions)))

missing values::
Instances that represent data points with no value.
(((missing values)))

[[chap20]]
== The Goodies: Base and Standard Library

Julia comes with batteries included. The +Base+ module contains the most useful functions, types and macros. These are directly available in Julia.
(((Base)))

Julia provides also a large number of specialized modules in its Standard Library (Dates, Distributed Computing, Linear Algebra, Profiling, Random Numbers, ...). Functions, types and macros defined in the Standard Library have to be imported before they can be used:

* +import _Module_+ imports the module, and +_Module.fn_(x)+ calls the function +_fn_+
(((import)))((("keyword", "import", see="import")))
* +using _Module_+ imports all exported +_Module_+ functions, types and macros.
(((using)))

Additional functionality can be added from a growing collection of packages (https://juliaobserver.com).

This chapter is not a replacement of the official Julia documentation. I give merely some examples to illustrate what is possible without being exhaustive.  Functions already introduced elsewhere are not included. A complete overview can be found in https://docs.julialang.org.

=== Measuring Performance

We have seen that some algorithms perform better than others. +fibonnaci+ in &lt;&lt;memos&gt;&gt; is a lot faster than +fib+ in &lt;&lt;one_more_example&gt;&gt;. The +@time+ macro allows to quantify the difference:
(((@time)))((("macro", "Base", "@time", see="@time")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; fib(1)
1
julia&gt; fibonacci(1)
1
julia&gt; @time fib(40)
  0.567546 seconds (5 allocations: 176 bytes)
102334155
julia&gt; @time fibonacci(40)
  0.000012 seconds (8 allocations: 1.547 KiB)
102334155</p>
</div>
<div class="listingblock">
<div class="content">
<pre>+@time+ prints the time the function took to execute, the number of allocations and the allocated memory before returning the result. The memoized version is effectively a lot faster but needs more memory.

[quote]
____
There ain't no such thing as a free lunch!
____

[TIP]
====
A function in Julia is compiled the first time it is executed. So to compare two algorithms, they have to be implemented as functions to get compiled and the first time they are called has to be excluded from the performance measure, otherwise the compilation time is measured as well.

The package +BenchmarkTools+ (https://github.com/JuliaCI/BenchmarkTools.jl) provides the macro +@btime+ that does benchmarking the right way. So just use it!
====


[[collections_and_data_structures]]
=== Collections and Data Structures

In &lt;&lt;dictionary_subtraction&gt;&gt; we used dictionaries to find the words that appear in a document but not in a word array. The function we wrote takes +d1+, which contains the words from the document as keys, and +d2+, which contains the array of words. It returns a dictionary that contains the keys from +d1+ that are not in +d2+.
(((subtract)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function subtract(d1, d2)
    res = Dict()
    for key in keys(d1)
        if key ∉ keys(d2)
            res[key] = nothing
        end
    end
    res
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In all of these dictionaries, the values are +nothing+ because we never use them. As a result, we waste some storage space.

Julia provides another built-in type, called a set, that behaves like a collection of dictionary keys with no values. Adding elements to a set is fast; so is checking membership. And sets provide functions and operators to compute common set operations.
(((Set)))((("type", "Base", "Set", see="Set")))

For example, set subtraction is available as a function called +setdiff+. So we can rewrite +subtract+ like this:
(((setdiff)))((("function", "Base", "setdiff", see="setdiff")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function subtract(d1, d2)
    setdiff(d1, d2)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The result is a set instead of a dictionary.

Some of the exercises in this book can be done concisely and efficiently with sets. For example, here is a solution to +hasduplicates+, from &lt;&lt;ex10-7&gt;&gt;, that uses a dictionary:
(((hasduplicates)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function hasduplicates(t)
    d = Dict()
    for x in t
        if x ∈ d
            return true
        end
        d[x] = nothing
    end
    false
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>When an element appears for the first time, it is added to the dictionary. If the same element appears again, the function returns +true+.

Using sets, we can write the same function like this:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function hasduplicates(t)
    length(Set(t)) &lt; length(t)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>An element can only appear in a set once, so if an element in +t+ appears more than once, the set will be smaller than +t+. If there are no duplicates, the set will be the same size as +t+.

We can also use sets to do some of the exercises in &lt;&lt;chap09&gt;&gt;. For example, here’s a version of +usesonly+ with a loop:
(((usesonly)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function usesonly(word, available)
    for letter in word
        if letter ∉ available
            return false
        end
    end
    true
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>+usesonly+ checks whether all letters in +word+ are in +available+. We can rewrite it like this:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function usesonly(word, available)
    Set(word) ⊆ Set(available)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The +⊆+ (*+\subseteq TAB+*) operator checks whether one set is a subset or another, including the possibility that they are equal, which is true if all the letters in +word+ appear in +available+.
(((⊆)))((("operator", "Base", "⊆", see="⊆")))

===== Exercise 20-1

Rewrite +avoids+ using sets.
(((avoids)))


=== Mathematics

Complex numbers are also supported in Julia. The global constant +im+ is bound to the complex number latexmath:[$\mathrm{i}$], representing the principal square root of latexmath:[$-1$].
(((complex numbers)))(((im)))

We can now verify Euler's identity,
(((Euler's identity)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; ℯ^(im*π)+1
0.0 + 1.2246467991473532e-16im</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The symbol +ℯ+ (*+\euler TAB+*) is the base of natural logarithms.
(((ℯ)))

Let's illustrate the complex nature of trigonometric functions:

[latexmath]
++++
\begin{equation}
{\cos\left(x\right)=\frac{\mathrm{e}^{\mathrm{i}x}+\mathrm{e}^{-\mathrm{i}x}}{2}\,.}
\end{equation}
++++

We can test this formula for different values of latexmath:[\(x\)].

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; x = 0:0.1:2π
0.0:0.1:6.2
julia&gt; cos.(x) == 0.5*(ℯ.<sup>(im*x)+ℯ.</sup>(-im*x))
true</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Here, another example of the dot operator is shown. Julia also allows numeric literals to be juxtaposed with identifiers as coefficients as in +2π+.

=== Strings

In &lt;&lt;chap08&gt;&gt; and &lt;&lt;chap09&gt;&gt;, we did some elementary searches in string objects. Julia can handle however Perl-compatible regular expressions (_regexes_), which eases the task of finding complex patterns in string objets.
(((regex)))

The +usesonly+ function can be implemented as a regex:
(((usesonly)))(((Regex)))((("type", "Base", "Regex", see="Regex")))(((occursin)))((("function", "Base", "occursin", see="occursin")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function usesonly(word, available)
  r = Regex("[^$(available)]")
  !occursin(r, word)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The regex looks for a character that is not in the +available+ string and +occursin+ returns +true+ if the pattern is found in +word+.

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; usesonly("banana", "abn")
true
julia&gt; usesonly("bananas", "abn")
false</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Regexes can also be constructed as non-standard string literals prefixed with +r+:
(((string)))(((match)))((("function", "Base", "match", see="match")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; match(r"[^abn]", "banana")</p>
</div>
<div class="paragraph">
<p>julia&gt; m = match(r"[^abn]", "bananas")
RegexMatch("s")</p>
</div>
<div class="listingblock">
<div class="content">
<pre>String interpolation is not allowed in this case. The +match+ function returns nothing if the pattern (a command) is not found and return a regexmatch object otherwise.
(((string interpolation)))(((RegexMatch)))((("type", "Base", "RegexMatch", see="RegexMatch")))

We can extract the following info from a regexmatch object:

* the entire substring matched: +m.match+
* the captured substrings as an array of strings: +m.captures+
* the offset at which the whole match begins: +m.offset+
* the offsets of the captured substrings as an array: +m.offsets+

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; m.match
"s"
julia&gt; m.offset
7</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Regexes are extremely powerful and the PERL manpage http://perldoc.perl.org/perlre.html provides all the details to construct the most exotic searches.

=== Arrays

In &lt;&lt;chap10&gt;&gt; we used an array object as a one-dimensional container with an index to address its elements. In Julia however, arrays are multi-dimensional collections.

Let's create a 2-by-3 zero _matrix_:
(((zeros)))((("function", "Base", "zeros", see="zeros")))(((matrix)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; z = zeros(Float64, 2, 3)
2×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
julia&gt; typeof(z)
Array{Float64,2}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The type of this matrix is an array holding floating points and having 2 dimensions.
(((dimension)))

The +size+ function returns a tuple with as elements the number of elements in each dimension:
(((size)))((("function", "Base", "size", see="size")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; size(z)
(2, 3)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The function +ones+ constructs a matrix with unit value elements:
(((ones)))((("function", "Base", "ones", see="ones")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; s = ones(String, 1, 3)
1×3 Array{String,2}:
 ""  ""  ""</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The string unit element is an empty string.

[WARNING]
====
+s+ is not a one-dimensional array:

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; s ==  ["", "", ""]
false</p>
</div>
<div class="listingblock">
<div class="content">
<pre>+s+ is a row matrix and +["", "", ""]+ is a column matrix.
====

A matrix can be entered directly using a space to separate elements in a row and a semicolon +;+ to separate rows:
(((;)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6</p>
</div>
<div class="listingblock">
<div class="content">
<pre>You can use square brackets to address individual elements:
(((square brackets)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; z[1,2] = 1
1
julia&gt; z[2,3] = 1
1
julia&gt; z
2×3 Array{Float64,2}:
 0.0  1.0  0.0
 0.0  0.0  1.0</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Slices can be used for each dimension to select a subgroup of elements:
(((slice)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; u = z[:,2:end]
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The +.+ operator broadcasts to all dimensions:
(((.)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; ℯ.^(im*u)
2×2 Array{Complex{Float64},2}:
 0.540302+0.841471im       1.0+0.0im
      1.0+0.0im       0.540302+0.841471im</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Interfaces

Julia specifies some informal interfaces to define behaviors, i.e. methods with a specific goal. When you extend such a method for a type, objects of that type can be used to build upon these behaviors.
(((interface)))

[quote]
____
If it looks like a duck, swims like a duck, and quacks like a duck, then it probably _is_ a duck.
____

In &lt;&lt;one_more_example&gt;&gt; we implemented the +fib+ function returning the latexmath:[\(n\)]th element of the Fibonnaci sequence.

Looping over the values of a collection, called iteration, is such an interface. Let's make an iterator that returns lazily the Fibonacci sequence:
(((iterator)))(((Fibonacci)))((("type", "programmer-defined", "Fibonacci", see="Fibonacci")))(((iterate)))((("function", "Base", "iterate", see="iterate")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>struct Fibonacci{T&lt;:Real} end
Fibonacci(d::DataType) = d&lt;:Real ? Fibonacci{d}() : error("No Real type!")</p>
</div>
<div class="paragraph">
<p>Base.iterate(::Fibonacci{T}) where {T&lt;:Real} = (zero(T), (one(T), one(T)))
Base.iterate(::Fibonacci{T}, state::Tuple{T, T}) where {T&lt;:Real} = (state[1], (state[2], state[1] + state[2]))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>We implemented a parametric type with no fields +Fibonacci+, an outer constructor and two methods +iterate+. The first is called to initialize the iterator and returns a tuple consisting of the first value, 0, and a state. The state in this case is a tuple containing the second and the third value, 1 and 1.

The second is called to get the next value of the Fibonacci sequence and returns a tuple having as first element the next value and as second element the state which is a tuple with the two following values.

We can use +Fibonacci+ now in a +for+ loop:
(((for statement)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; for e in Fibonacci(Int64)
           e &gt; 100 &amp;&amp; break
           print(e, " ")
       end
0 1 1 2 3 5 8 13 21 34 55 89</p>
</div>
<div class="listingblock">
<div class="content">
<pre>It looks like magic has happened but the explanation is simple. A +for+ loop in Julia

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>for i in iter
    # body
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>is translated into:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>next = iterate(iter)
while next !== nothing
    (i, state) = next
    # body
    next = iterate(iter, state)
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>This is a great example how a well defined interface allows an implementation to use all the functions that are aware of the interface.


=== Interactive Utilities

We have already met the +InteractiveUtils+ module in &lt;&lt;interactive&gt;&gt;. The +@which+ macro is only the tip of the iceberg.
(((InteractiveUtils)))(((@which)))

Julia code is transformed by the LLVM library to machinecode in multiple steps. We can directly visualize the output of each stage.

Let's give a simple example:
(((squaresum)))((("function", "programmer-defined", "squaresum", see="squaresum")))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>function squaresum(a::Float64, b::Float64)
    a^2 + b^2
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The first step is to look at the lowered code:
(((@code_lowered)))((("macro", "InteractiveUtils", "@code_lowered", see="@code_lowered")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; using InteractiveUtils</p>
</div>
<div class="paragraph">
<p>julia&gt; @code_lowered squaresum(3.0, 4.0)
CodeInfo(
1 ─ %1 = Core.apply_type(Base.Val, 2)
│   %2 = (%1)()
│   %3 = Base.literal_pow(:^, a, %2)
│   %4 = Core.apply_type(Base.Val, 2)
│   %5 = (%4)()
│   %6 = Base.literal_pow(:^, b, %5)
│   %7 = %3 + %6
└──      return %7
)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The +@code_lowered+ macro returns an array of an _intermediate representation_ of the code that is used by the compiler to generate optimised code.
(((intermediate representation)))

The next step adds type information:
(((@code_typed)))((("macro", "InteractiveUtils", "@code_typed", see="@code_typed")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; @code_typed squaresum(3.0, 4.0)
CodeInfo(
1 ─ %1 = Base.mul_float(a, a)::Float64
│   %2 = Base.mul_float(b, b)::Float64
│   %3 = Base.add_float(%1, %2)::Float64
└──      return %3
) &#8658; Float64</p>
</div>
<div class="listingblock">
<div class="content">
<pre>We see that the type of the intermediate results and the return value is correctly inferred.

This representation of the code is transformed into LLVM code:
(((LLVM code)))(((@code_llvm)))((("macro", "InteractiveUtils", "@code_llvm", see="@code_llvm")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; @code_llvm squaresum(3.0, 4.0)
;  @ none:2 within &#8216;squaresum&#8217;
define double @julia_squaresum_20490(double, double) {
top:
; ┌ @ intfuncs.jl:261 within &#8216;literal_pow&#8217;
; │┌ @ float.jl:405 within &#8216;*&#8217;
    %2 = fmul double %0, %0
    %3 = fmul double %1, %1
; └└
; ┌ @ float.jl:401 within &#8216;+&#8217;
   %4 = fadd double %2, %3
; └
  ret double %4
}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>And finally the _machine code_ is generated:
(((machine code)))(((@code_native)))((("macro", "InteractiveUtils", "@code_native", see="@code_native")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; @code_native squaresum(3.0, 4.0)
	.section	<em>TEXT,</em>text,regular,pure_instructions
; ┌ @ none:2 within &#8216;squaresum&#8217;
; │┌ @ intfuncs.jl:261 within &#8216;literal_pow&#8217;
; ││┌ @ none:2 within &#8216;*&#8217;
	vmulsd	%xmm0, %xmm0, %xmm0
	vmulsd	%xmm1, %xmm1, %xmm1
; │└└
; │┌ @ float.jl:401 within &#8216;+&#8217;
	vaddsd	%xmm1, %xmm0, %xmm0
; │└
	retq
	nopl	(%rax)
; └</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Debugging

The +Logging+ macros provide an alternative to scaffolding with print statements:
(((@warn)))((("macro", "Base", "@warn", see="@warn")))(((debugging)))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; @warn "Abandon printf debugging, all ye who enter here!"
┌ Warning: Abandon printf debugging, all ye who enter here!
└ @ Main REPL[1]:1</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The debug statements don't have to be removed from the source. For example, in contrast to the +@warn+ above
(((debug statement)))(((@debug)))((("macro", "Base", "@debug", see="@debug")))

[source,jlcon]</pre>
</div>
</div>
<div class="paragraph">
<p>julia&gt; @debug "The sum of some values $(sum(rand(100)))"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>will produce no output by default. In this case +sum(rand(100))+ will never be evaluated unless _debug logging_ is enabled.
(((debug logging)))

The level of logging can be selected by an environment variable +JULIA_DEBUG+:
(((environment variable)))

[source]</pre>
</div>
</div>
<div class="paragraph">
<p>$ JULIA_DEBUG=all julia -e <em>@debug "The sum of some values $(sum(rand(100)))"</em>
┌ Debug: The sum of some values 47.116520814555024
└ @ Main none:1</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Here, we have used +all+ to get all debug information, but you can also choose to generate only output for a specific file or module.


=== Glossary

regex::
Regular expression, a sequence of characters that define a search pattern.
(((regex)))

matrix::
Two-dimensional array.
(((matrix)))

intermediate representation::
Data structure used internally by a compiler to represent source code.
(((intermediate representation)))

machine code::
Language instructions that can be executed directly by a computer's central processing unit.
(((machine code)))

debug logging::
Storing debug messages in a log.
(((debug logging)))

[[chap21]]
== Debugging

When you are debugging, you should distinguish among different kinds of errors in order to track them down more quickly:

* Syntax errors are discovered by the interpreter when it is translating the source code into byte code. They indicate that there is something wrong with the structure of the program. Example: Omitting the +end+ keyword at the end of a function block generates the somewhat redundant message +ERROR: LoadError: syntax: incomplete: function requires end+.
(((syntax error)))

* Runtime errors are produced by the interpreter if something goes wrong while the program is running. Most runtime error messages include information about where the error occurred and what functions were executing. Example: An infinite recursion eventually causes the runtime error +ERROR: StackOverflowError+.
(((runtime error)))

* Semantic errors are problems with a program that runs without producing error messages but doesn’t do the right thing. Example: An expression may not be evaluated in the order you expect, yielding an incorrect result.
(((semantic error)))

The first step in debugging is to figure out which kind of error you are dealing with. Although the following sections are organized by error type, some techniques are applicable in more than one situation.


=== Syntax Errors

Syntax errors are usually easy to fix once you figure out what they are. Unfortunately, the error messages are often not helpful. The most common messages are +ERROR: LoadError: syntax: incomplete: premature end of input+ and +ERROR: LoadError: syntax: unexpected "="+, neither of which is very informative.

On the other hand, the message does tell you where in the program the problem occurred. Actually, it tells you where Julia noticed a problem, which is not necessarily where the error is. Sometimes the error is prior to the location of the error message, often on the preceding line.

If you are building the program incrementally, you should have a good idea about where the error is. It will be in the last line you added.

If you are copying code from a book, start by comparing your code to the book’s code very carefully. Check every character. At the same time, remember that the book might be wrong, so if you see something that looks like a syntax error, it might be.

Here are some ways to avoid the most common syntax errors:

. Make sure you are not using a Julia keyword for a variable name.

. Check that you have the +end+ keyword at the end of every compound statement, including +for+, +while+, +if+, and +function+ blocks.

. Make sure that any strings in the code have matching quotation marks. Make sure that all quotation marks are “straight quotes”, not “curly quotes”.

. If you have multiline strings with triple quotes , make sure you have terminated the string properly. An unterminated string may cause an invalid token error at the end of your program, or it may treat the following part of the program as a string until it comes to the next string. In the second case, it might not produce an error message at all!

. An unclosed opening operator—+(+, +{+, or +[+—makes Julia continue with the next line as part of the current statement. Generally, an error occurs almost immediately in the next line.

. Check for the classic +=+ instead of +==+ inside a conditional.

. If you have non-ASCII characters in the code (including strings and comments), that might cause a problem, although Julia usually handles non-ASCII characters. Be careful if you paste in text from a web page or other source.

If nothing works, move on to the next section...

==== I keep making changes and it makes no difference

If the REPL says there is an error and you don’t see it, that might be because you and the REPL are not looking at the same code. Check your programming environment to make sure that the program you are editing is the one Julia is trying to run.

If you are not sure, try putting an obvious and deliberate syntax error at the beginning of the program. Now run it again. If the REPL doesn’t find the new error, you are not running the new code.

There are a few likely culprits:

* You edited the file and forgot to save the changes before running it again. Some programming environments do this for you, but some don’t.

* You changed the name of the file, but you are still running the old name.

* Something in your development environment is configured incorrectly.

* If you are writing a module and using +using+, make sure you don’t give your module the same name as one of the standard Julia modules.

* If you are using +using+ to import a module, remember that you have to restart the REPL when you modify the code in the module. If you import the module again, it doesn’t do anything.

If you get stuck and you can’t figure out what is going on, one approach is to start again with a new program like “Hello, World!”, and make sure you can get a known program to run. Then gradually add the pieces of the original program to the new one.


=== Runtime Errors

Once your program is syntactically correct, Julia can read it and at least start running it. What could possibly go wrong?

==== My program does absolutely nothing

This problem is most common when your file consists of functions and classes but does not actually invoke a function to start execution. This may be intentional if you only plan to import this module to supply classes and functions.

If it is not intentional, make sure there is a function call in the program, and make sure the flow of execution reaches it (see &lt;&lt;flow_of_execution&gt;&gt;).
(((flow of execution)))

==== My program hangs

If a program stops and seems to be doing nothing, it is “hanging”. Often that means that it is caught in an infinite loop or infinite recursion.

* If there is a particular loop that you suspect is the problem, add a print statement immediately before the loop that says “entering the loop” and another immediately after that says “exiting the loop”.
+
Run the program. If you get the first message and not the second, you’ve got an infinite loop. Go to &lt;&lt;infinite_loop&gt;&gt; below.
(((infinite loop)))

* Most of the time, an infinite recursion will cause the program to run for a while and then produce a +ERROR: LoadError: StackOverflowError+ error. If that happens, go to &lt;&lt;infinite_recursion&gt;&gt; below.
+
If you are not getting this error but you suspect there is a problem with a recursive method or function, you can still use the techniques in &lt;&lt;infinite_recursion&gt;&gt;.
(((infinite recursion)))

* If neither of those steps works, start testing other loops and other recursive functions and methods.

* If that doesn’t work, then it is possible that you don’t understand the flow of execution in your program. Go to &lt;&lt;flow_of_execution&gt;&gt; below.

[[infinite_loop]]
===== Infinite Loop

If you think you have an infinite loop and you think you know what loop is causing the problem, add a print statement at the end of the loop that prints the values of the variables in the condition and the value of the condition.

For example:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>while x &gt; 0 &amp;&amp; y &lt; 0
    # do something to x
    # do something to y
    @debug "variables" x y
    @debug "condition" x &gt; 0 &amp;&amp; y &lt; 0
end</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Now when you run the program in debug mode, you will see the value of the variables and the condition for each time through the loop. The last time through the loop, the condition should be +false+. If the loop keeps going, you will be able to see the values of +x+ and +y+, and you might figure out why they are not being updated correctly.

[[infinite_recursion]]
===== Infinite Recursion

Most of the time, infinite recursion causes the program to run for a while and then produce a +ERROR: LoadError: StackOverflowError+ error.
(((StackOverflowError)))

If you suspect that a function is causing an infinite recursion, make sure that there is a base case. There should be some condition that causes the function to return without making a recursive invocation. If not, you need to rethink the algorithm and identify a base case.

If there is a base case but the program doesn’t seem to be reaching it, add a print statement at the beginning of the function that prints the parameters. Now when you run the program, you will see a few lines of output every time the function is invoked, and you will see the parameter values. If the parameters are not moving toward the base case, you will get some ideas about why not.

[[flow_of_execution]]
===== Flow of Execution

If you are not sure how the flow of execution is moving through your program, add print statements to the beginning of each function with a message like “entering function foo”, where foo is the name of the function.

Now when you run the program, it will print a trace of each function as it is invoked.

==== When I run the program I get an exception

If something goes wrong during runtime, Julia prints a message that includes the name of the exception, the line of the program where the problem occurred, and a stacktrace.

The stacktrace identifies the function that is currently running, and then the function that called it, and then the function that called that, and so on. In other words, it traces the sequence of function calls that got you to where you are, including the line number in your file where each call occurred.

The first step is to examine the place in the program where the error occurred and see if you can figure out what happened. These are some of the most common runtime errors:

ArgumentError::
One of the arguments to a function call is not in the expected state.
(((ArgumentError)))

BoundsError::
An indexing operation into an array tried to access an out-of-bounds element.
(((BoundsError)))

DomainError::
The argument to a function or constructor is outside the valid domain.
(((DomainError)))((("error", "Core", "DomainError", see="DomainError")))

DivideError::
Integer division was attempted with a denominator value of 0.
(((DivideError)))((("error", "Core", "DivideError", see="DivideError")))

EOFError::
No more data was available to read from a file or stream.
(((EOFError)))((("error", "Base", "EOFError", see="EOFError")))

InexactError::
Cannot exactly convert to a type.
(((InexactError)))((("error", "Core", "InexactError", see="InexactError")))

KeyError::
An indexing operation into an +AbstractDict+ (+Dict+) or +Set+ like object tried to access or delete a non-existent element.
(((KeyError)))

MethodError::
A method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.
(((MethodError)))

OutOfMemoryError::
An operation allocated too much memory for either the system or the garbage collector to handle properly.
(((OutOfMemoryError)))((("error", "Core", "OutOfMemoryError", see="OutOfMemoryError")))

OverflowError::
The result of an expression is too large for the specified type and will cause a wraparound.
(((OverflowError)))((("error", "Core", "OverflowError", see="OverflowError")))

StackOverflowError::
The function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.
(((StackOverflowError)))

StringIndexError::
An error occurred when trying to access a string at an index that is not valid.
(((StringIndexError)))

SystemError::
A system call failed with an error code.
(((SystemError)))

TypeError::
A type assertion failure, or calling an intrinsic function with an incorrect argument type.
(((TypeError)))

UndefVarError::
A symbol in the current scope is not defined.
(((UndefVarError)))

==== I added so many print statements I get inundated with output

One of the problems with using print statements for debugging is that you can end up buried in output. There are two ways to proceed: simplify the output or simplify the program.

To simplify the output, you can remove or comment out print statements that aren’t helping, or combine them, or format the output so it is easier to understand.

To simplify the program, there are several things you can do. First, scale down the problem the program is working on. For example, if you are searching a list, search a small list. If the program takes input from the user, give it the simplest input that causes the problem.

Second, clean up the program. Remove dead code and reorganize the program to make it as easy to read as possible. For example, if you suspect that the problem is in a deeply nested part of the program, try rewriting that part with simpler structure. If you suspect a large function, try splitting it into smaller functions and testing them separately.
(((dead code)))

Often the process of finding the minimal test case leads you to the bug. If you find that a program works in one situation but not in another, that gives you a clue about what is going on.

Similarly, rewriting a piece of code can help you find subtle bugs. If you make a change that you think shouldn’t affect the program, and it does, that can tip you off.


=== Semantic Errors

In some ways, semantic errors are the hardest to debug, because the interpreter provides no information about what is wrong. Only you know what the program is supposed to do.

The first step is to make a connection between the program text and the behavior you are seeing. You need a hypothesis about what the program is actually doing. One of the things that makes that hard is that computers run so fast.

You will often wish that you could slow the program down to human speed. Inserting a few well-placed print statements is often quicker than setting up a debugger, inserting and removing breakpoints, and “stepping” the program to where the error is occurring.

==== My program doesn’t work

You should ask yourself these questions:

* Is there something the program was supposed to do but which doesn’t seem to be happening? Find the section of the code that performs that function and make sure it is executing when you think it should.

* Is something happening that shouldn’t? Find code in your program that performs that function and see if it is executing when it shouldn’t.

* Is a section of code producing an effect that is not what you expected? Make sure that you understand the code in question, especially if it involves functions or methods in other Julia modules. Read the documentation for the functions you call. Try them out by writing simple test cases and checking the results.

In order to program, you need a mental model of how programs work. If you write a program that doesn’t do what you expect, often the problem is not in the program; it’s in your mental model.
(((mental model)))

The best way to correct your mental model is to break the program into its components (usually the functions and methods) and test each component independently. Once you find the discrepancy between your model and reality, you can solve the problem.

Of course, you should be building and testing components as you develop the program. If you encounter a problem, there should be only a small amount of new code that is not known to be correct.

==== I’ve got a big hairy expression and it doesn’t do what I expect

Writing complex expressions is fine as long as they are readable, but they can be hard to debug. It is often a good idea to break a complex expression into a series of assignments to temporary variables.

For example:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>addcard(game.hands[i], popcard(game.hands[findneighbor(game, i)]))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>This can be rewritten as:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>neighbor = findneighbor(game, i)
pickedcard = popcard(game.hands[neighbor])
addcard(game.hands[i], pickedcard)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The explicit version is easier to read because the variable names provide additional documentation, and it is easier to debug because you can check the types of the intermediate variables and display their values.

Another problem that can occur with big expressions is that the order of evaluation may not be what you expect. For example, if you are translating the expression latexmath:[\(\frac{x}{2\pi}\)] into Julia, you might write:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>y = x / 2 * π</p>
</div>
<div class="listingblock">
<div class="content">
<pre>That is not correct because multiplication and division have the same precedence and are evaluated from left to right. So this expression computes latexmath:[\(\frac{x\pi}{2}\)].

A good way to debug expressions is to add parentheses to make the order of evaluation explicit:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>y = x / (2 * π)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Whenever you are not sure of the order of evaluation, use parentheses. Not only will the program be correct (in the sense of doing what you intended), it will also be more readable for other people who haven’t memorized the order of operations.

==== I’ve got a function that doesn’t return what I expect

If you have a return statement with a complex expression, you don’t have a chance to print the result before returning. Again, you can use a temporary variable. For example, instead of:
(((temporary variable)))

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>return removematches(game.hands[i])</p>
</div>
<div class="listingblock">
<div class="content">
<pre>you could write:

[source,julia]</pre>
</div>
</div>
<div class="paragraph">
<p>count = removematches(game.hands[i])
return count</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Now you have the opportunity to display the value of +count+ before returning.

==== I’m really, really stuck and I need help

First, try getting away from the computer for a few minutes. Working with a computer can cause these symptoms:

* Frustration and rage.

* Superstitious beliefs (“the computer hates me”) and magical thinking (“the program only works when I wear my hat backward”).

* Random walk programming (the attempt to program by writing every possible program and choosing the one that does the right thing).

If you find yourself suffering from any of these symptoms, get up and go for a walk. When you are calm, think about the program. What is it doing? What are some possible causes of that behavior? When was the last time you had a working program, and what did you do next?

Sometimes it just takes time to find a bug. I often find bugs when I am away from the computer and let my mind wander. Some of the best places to find bugs are trains, showers, and in bed, just before you fall asleep.

==== No, I really need help

It happens. Even the best programmers occasionally get stuck. Sometimes you work on a program so long that you can’t see the error. You need a fresh pair of eyes.

Before you bring someone else in, make sure you are prepared. Your program should be as simple as possible, and you should be working on the smallest input that causes the error. You should have print statements in the appropriate places (and the output they produce should be comprehensible). You should understand the problem well enough to describe it concisely.

When you bring someone in to help, be sure to give them the information they need:

* If there is an error message, what is it and what part of the program does it indicate?

* What was the last thing you did before this error occurred? What were the last lines of code that you wrote, or what is the new test case that fails?

* What have you tried so far, and what have you learned?

When you find the bug, take a second to think about what you could have done to find it faster. Next time you see something similar, you will be able to find the bug more quickly.

Remember, the goal is not just to make the program work. The goal is to learn how to make the program work.


[appendix]
== Unicode Input

The following table lists a few Unicode characters out of many that can be entered via tab completion of LaTeX-like abbreviations in the Julia REPL (and in various other editing environments).
(((Unicode character)))(((LaTeX-like abbreviations)))(((REPL)))

[options="header"]
|====
|Character|Tab completion sequence|ASCII representation
|+²+|*+\^2+*|
|+₁+|*+\_1+*|
|+₂+|*+\_2+*|
|+🍎+|*+\:apple:+*|
|+🍌+|*+\:banana:+*|
|+🐫+|*+\:camel:+*|
|+🍐+|*+\:pear:+*|
|+🐢+|*+\:turtle:+*|
|+∩+|*+\cap+*|
|+≡+|*+\equiv+*|+===+
|+ℯ+|*+\euler+*|
|+∈+|*+\in+*|+in+
|+≥+|*+\ge+*|+&gt;=+
|+≤+|*+\le+*|+pass:[&amp;lt;=]+
|+≠+|*+\ne+*|+!=+
|+∉+|*+\notin+*|
|+π+|*+\pi+*|+pi+
|+⊆+|*+\subseteq+*|
|+ε+|*+\varepsilon+*|
|====

[appendix]
[[juliabox]]
== JuliaBox

JuliaBox allows you to run Julia in your browser. Enter the url https://www.juliabox.com, login and start using the Jupyter environment.

The initial screen is shown in &lt;&lt;figb-1&gt;&gt;. The new button allows the creation of a Julia notebook, a text file, a folder or a terminal session.

In a terminal session, the command *+julia+* starts the REPL as shown in &lt;&lt;figb-2&gt;&gt;.

The notebook interface allows to mix text in Markdown markup and highlighted code with associated output. &lt;&lt;figb-3&gt;&gt; shows an example.

Further documentation can be found on the website of Jupyter: http://jupyter.org/documentation.

[[figb-1]]
.Initial screen
image::images/screenshot0.png[]

[[figb-2]]
.Terminal session
image::images/screenshot1.png[]

[[figb-3]]
.Notebook
image::images/screenshot2.png[]

[index]
== Index</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. Reeves, Byron, e Clifford Ivar Nass. 1996. “The Media Equation: How People Treat Computers, Television, and New Media Like Real People and Places.” Chicago, IL: Center for the Study of Language and Information; New York: Cambridge University Press.
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-06-10 23:36:18 UTC
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.0/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>