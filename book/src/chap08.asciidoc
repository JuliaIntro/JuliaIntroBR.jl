[[chap08]]
== Strings

Strings n√£o s√£o como inteiros, pontos flutuante, e tipos booleanos. Uma string √© uma _sequ√™ncia_, o que significa que ela est√° em uma cole√ß√£o ordenada de outros valores. Neste cap√≠tulo voc√™ ver√° como acessar os caracteres que comp√µem uma string, e voc√™ ir√° aprender sobre algumas fun√ß√µes auxiliares de strings fornecidas pelo Julia.
(((string)))(((sequ√™ncia)))

[[characters]]
=== Caracteres

Falantes da l√≠ngua portuguesa est√£o familiarizados com caracteres como as letras do alfabeto (A, B, C, ...), numerais, e a pontua√ß√£o comum. Esses caracteres s√£o padronizados e mapeados para valores inteiros entre 0 e 127 pelo _padr√£o ASCII_ (American Standard Code for Information ou "C√≥digo Padr√£o Americano de Interc√¢mbio de Informa√ß√µes")
(((padr√£o ASCII)))

Existem, √© claro, muitos outros caracteres usados em l√≠nguas diferentes do Portugu√™s, incluindo variantes dos caracteres ASCII com acentos e outras modifica√ß√µes, scripts relacionados como o Cir√≠lico e o Grego, e scripts completamente n√£o relacionados ao ASCII e ao Portugu√™s, incluindo √Årabe, Chin√™s, Hebreu, Hindi, Japon√™s, e Koreano.
O _padr√£o Unicode_ lida com as complexidades do que exatamente √© um caractere, e √© geralmente aceitado como o padr√£o definitivo que resolve esse problema. Ele fornece um n√∫mero √∫nico para todo caractere em uma escala mundial.
(((padr√£o Unicode)))

Um valor +Char+ representa um √∫nico caractere e est√° cercado por aspas √∫nicas:
(((Char)))((("tipo", "Base", "Char", see="Char")))

[source,@julia-repl-test]
----
julia> 'x'
'x': ASCII/Unicode U+0078 (category Ll: letra, lowercase)
julia> 'üçå'
'üçå': Unicode U+1F34C (category So: Symbol, other)
julia> typeof('x')
Char
----

At√© mesmo emojis fazem parte do padr√£o Unicode. (*+\:banana: TAB+*)
(((emoji)))


=== Uma string √© uma sequ√™ncia

Uma string √© uma sequ√™ncia de caracteres. Voc√™ pode acessar os caracteres um de cada vez com o operador colchetes:
(((string)))(((String)))(((sequ√™ncia)))(((operador colchetes)))((("[]", see="operador colchetes")))((("operador", "Base", "[]", see="operador colchetes")))

[source,@julia-repl-test chap08]
----
julia> fruta = "banana"
"banana"
julia> letra = fruta[1]
'b': ASCII/Unicode U+0062 (category Ll: letter, lowercase)
----

A segunda declara√ß√£o seleciona o caractere n√∫mero 1 de +fruta+ e o atribui para +letra+.

A express√£o em colchetes √© chamada de _ind√≠ce_. O ind√≠ce indica qual caractere da sequ√™ncia voc√™ deseja (por isso o nome).
(((ind√≠ce)))

Toda indexa√ß√£o no Julia come√ßa em 1, o primeiro elemento de qualquer objeto inteiramente indexado √© encontrado no ind√≠ce 1 e o √∫ltimo no ind√≠ce +end+:
(((end)))

[source,@julia-repl-test chap08]
----
julia> fruta[end]
'a': ASCII/Unicode U+0061 (category Ll: letra, lowercase)
----

Voc√™ pode usar como ind√≠ce uma express√£o que cont√©m vari√°veis e operadores:

[source,@julia-repl-test chap08]
----
julia> i = 1
1
julia> fruta[i+1]
'a': ASCII/Unicode U+0061 (category Ll: letter, lowercase)
julia> fruta[end-1]
'n': ASCII/Unicode U+006E (category Ll: letter, lowercase)
----

Mas o valor do ind√≠ce precisa ser um inteiro. Caso contr√°rio voc√™ recebe:
(((MethodError)))((("erro", "Core", "MethodError", see="MethodError")))

[source,@julia-repl-test chap08]
----
julia> letra = fruta[1.5]
ERROR: MethodError: no method matching getindex(::String, ::Float64)
----


=== +length+
+length+ √© uma fun√ß√£o embutida que retorna o n√∫mero de caracteres em uma string:
(((length)))

[source,@julia-repl-test chap08]
----
julia> frutas = "üçå üçé üçê"
"üçå üçé üçê"
julia> len = length(frutas)
5
----

Para obter a √∫ltima letra da string, voc√™ pode ficar tentado a fazer algo como:

[source,@julia-repl-test chap08]
----
julia> last = frutas[len]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)
----

Mas voc√™ pode n√£o conseguir o que espera.

Strings s√£o codificadas usando a _codifica√ß√£o UTF-8_. UTF-8 √© uma codifica√ß√£o de largura vari√°vel, o que significa que nem todos os caracteres est√£o codificados com o mesmo n√∫mero de bytes.
(((codifica√ß√£o UTF-8)))

A fun√ß√£o +sizeof+ retorna o n√∫mero de bytes em uma string:
(((sizeof)))((("fun√ß√£o", "Base", "sizeof", see="sizeof")))

[source,@julia-repl-test chap08]
----
julia> sizeof("üçå")
4
----

Como um emoji √© codificado em 4 bytes e a indexa√ß√£o de strings √© baseado em bytes, o quinto elemento de +frutas+ √© um +ESPA√áO+.
(((emoji)))

Isso significa tamb√©m que nem todo ind√≠ce de bytes em uma string UTF-8 √© necessariamente um ind√≠ce v√°lido para um caractere. Se voc√™ indexar em uma string com um ind√≠ce de bytes inv√°lido, ser√° gerado um erro:
(((StringIndexError)))((("erro", "Base", "StringIndexError", see="StringIndexError")))

[source,@julia-repl-test chap08]
----
julia> frutas[2]
ERROR: StringIndexError("üçå üçé üçê", 2)
----

No caso de +frutas+, o caractere +üçå+ √© um caractere de quatro bytes, ent√£o os ind√≠ces 2,3 e 4 s√£o inv√°lido e o ind√≠ce do pr√≥ximo caractere √© 5; esse pr√≥ximo ind√≠ce v√°lido pode ser calculado por +nextind(frutas, 1)+, e o ind√≠ce depois dele por +nextind(frutas, 5)+ e assim por diante.
(((nextind)))((("fun√ß√£o", "Base", "nextind", see="nextind")))


=== Travessia

Muitos c√°lculos envolvem o processamento de uma string, um caractere de cada vez. Comumente eles come√ßam no in√≠cio, selecionando cada caractere por vez, fazendo algo com ele, e continuando at√© o final. Esse padr√£o de processamento √© denominado de _travessia_. Um jeito de escrever uma travessia √© com um loop +while+:
(((travessia)))(((declara√ß√£o while)))

[source,@julia-setup chap08]
----
ind√≠ce = firstindex(frutas)
while ind√≠ce <= sizeof(frutas)
    letra = frutas[ind√≠ce]
    println(letra)
    global ind√≠ce = nextind(frutas, ind√≠ce)
end
----

Esse loop faz a travessia da string e exibe cada letra em uma linha por si s√≥. A condi√ß√£o do loop √© +index pass:[&lt;=] sizeof(fruta)+, ent√£o quando o ind√≠ce √© maior que o n√∫mero de bytes em uma string, a condi√ß√£o √© +false+, e o corpo do loop n√£o executa.

A fun√ß√£o +firstindex+ retorna o primeiro ind√≠ce de bytes v√°lido. A palavra-chave +global+ antes de +ind√≠ce+ indica que n√≥s queremos re-atribuir a vari√°vel +ind√≠ce+ definida em +Main+ (ver <<global_variables>>).
(((global)))(((firstindex)))((("fun√ß√£o", "Base", "firstindex", see="firstindex")))

===== Exerc√≠cio 8-1

Escreva uma fun√ß√£o que recebe uma string como argumento e exibe as letras ao contr√°rio, uma por linha.

Outro jeito de escrever uma travessia √© com o loop +for+:
(((declara√ß√£o for)))(((in)))

[source,@julia-setup chap08]
----
for letra in frutas
    println(letra)
end
----

Cada vez que o loop √© percorrido, o pr√≥ximo caractere na string √© atribuido para a vari√°vel +letra+. O loop continua at√© que n√£o hajam mais caracteres sobrando.

O pr√≥ximo exemplo mostra como usar concatena√ß√£o (multiplica√ß√£o de strings) e um loop +for+ para gerar s√©ries abeced√°rias (isto √©, em ordem alfab√©tica). No livro de Robert McCloskey, _Make way for Ducklings_ (Abra caminho para os patinhos), os nomes dos patinhos s√£o Jack, Kack, Lack, Mack, Nack, Ouack, Pack, e Quack. Esse loop gera os nomes em ordem:

[source,@julia chap08-3]
----
prefixos = "JKLMNOPQ"
sufixo = "ack"

for letra in prefixos
    println(letra * sufixo)
end
----

√â claro, isto n√£o est√° completamente correto pois, ‚ÄúOuack‚Äù E ‚ÄúQuack‚Äù est√£o incorretos.

===== Exerc√≠cio 8-2

Modifique o programa para consertar esse erro.


=== Fatias de Strings

Um segmento de uma string √© chamado de _fatia_. Selecionar uma fatia √© similar a selecionar um caractere:
(((fatia)))

[source,@julia-repl-test chap08]
----
julia> str = "J√∫lio C√©sar";

julia> str[1:5]
"J√∫lio"
----

O operador +[n:m]+ retorna a parte da string do +n+-√©simo byte at√© o +m+-√©simo byte. Ent√£o o mesmo cuidado √© necess√°rio como para a indexa√ß√£o simples.
(((operador colchetes)))

A palavra-chave +end+ pode ser usada para indicar o √∫ltimo byte da string:
(((end)))

[source,@julia-repl-test chap08]
----
julia> str[8:end]
"Caesar"
----

Se o primeiro ind√≠ce √© maior que o segundo, o resultado √© uma _string vazia_, representada por duas aspas:
(((string vazia)))((("&quot;&quot;", see="string vazia")))

[source,@julia-repl-test chap08]
----
julia> str[8:7]
""
----

Uma string vazia n√£o cont√©m nenhum caractere e possui tamanho 0, mas diferente disso, √© igual a qualquer outra string.

===== Exerc√≠cio 8-3

Continuando este exemplo, o que voc√™ acha que +str[:]+ significa? Experiemente e veja.


=== String s√£o Imut√°veis

√â tentador usar o operador +[]+ no lado esquerdo da atribui√ß√£o, com a inten√ß√£o de mudar um caractere de uma string. Por exemplo:
(((operador colchetes)))(((MethodError)))

[source,@julia-repl-test chap08]
----
julia> cumprimento = "Ol√°, Mundo!"
"Ol√°, Mundo!"
julia> cumprimento[1] = 'E'
ERROR: MethodError: no method matching setindex!(::String, ::Char, ::Int64)
----

O motivo deste erro √© de que strings s√£o _imut√°veis_, o que significa que voc√™ n√£o pode mudar uma string existente. O melhor que voc√™ pode fazer √© criar uma nova string que √© uma varia√ß√£o da original:
(((imut√°vel)))

[source,@julia-repl-test chap08]
----
julia> cumprimento = "E" * cumprimento[2:end]
"El√°, Mundo!"
----

Esse exemplo concatena uma nova primeira letra em uma fatia de cumprimento. Ele n√£o tem efeito algum na string original.


=== Interpola√ß√£o de Strings

Construir strings usando concatena√ß√£o pode vir a ser um inc√≥modo. Para reduzir a necessidade dessas chamadas verbosas para +string+ ou multiplica√ß√µes repetidas, O Julia permite _interpola√ß√£o de strings_ usando +$+:
(((interpola√ß√£o de strings)))((("$", see="interpola√ß√£o de strings")))

[source,@julia-repl-test]
----
julia> cumprimento = "Ol√°"
"Ol√°"
julia> quem = "Mundo"
"Mundo"
julia> "$cumprimento, $(quem)!"
"Ol√°, Mundo!"
----

Isso √© mais leg√≠vel e conveniente do que concatena√ß√£o de strings: +pass:[cumprimento * ", " * quem * "!"]+

O valor da menor express√£o inteira ap√≥s o +$+ √© tomado como o valor que deve ser interpolado na sequ√™ncia. Assim, voc√™ pode interpolar qualquer express√£o em uma string usando par√™nteses:

[source,@julia-repl-test]
----
julia> "1 + 2 = $(1 + 2)"
"1 + 2 = 3"
----

[[searching]]
=== Buscando

O que a fun√ß√£o a seguir faz?
(((buscar)))((("fun√ß√£o", "definido pelo programador", "buscar", see="buscar")))

[source,@julia-setup]
----
function buscar(palavra, letra)
    ind√≠ce = firstindex(palavra)
    while ind√≠ce <= sizeof(palavra)
        if palavra[ind√≠ce] == letra
            return ind√≠ce
        end
        ind√≠ce = nextind(palavra, ind√≠ce)
    end
    -1
end
----

De certo modo, buscar √© o inverso do operador +[]+. Ao inv√©s de pegar um ind√≠ce e extrair o caractere correspondente, ela recebe o caractere e busca o ind√≠ce aonde este caractere aparece. Se o caractere n√£o √© achado, a fun√ß√£o retorna -1.

Esse √© o primeiro exemplo que n√≥s vimos de uma declara√ß√£o return dentro de um loop. Se +palavra[ind√≠ce] == letra+, a fun√ß√£o sai do loop e retorna imediatamente.

Se o caractere n√£o aparece na string, o programa sai do loop normalmente e retorna -1.

Esse padr√£o de computa√ß√£o-percorrendo a sequ√™ncia e retornando quando achamos o que estamos procurando-√© chamado de _busca_.
(((busca)))

===== Exerc√≠cio 8-4

Modifique +busca+ para que ela tenha um terceiro par√¢metro, o ind√≠ce em +palavra+ aonde ela deve come√ßar a procurar.


[[looping_and_counting]]
=== Dando loop e contando

O seguinte programa conta o n√∫mero de vezes que a letra +a+ aparece em uma string:

[source,@julia-setup]
----
palavra = "banana"
countador = 0
for letra in palavra
    if letra == 'a'
        global contador = contador + 1
    end
end
println(contador)
----

Esse programa demonstra outro padr√£o de computa√ß√£o chamado _contador_. A vari√°vel +contador+ √© inicializada com 0 e incrementada toda vez que um +a+ √© achado. Quando a fun√ß√£o sai do loop, +contador+ cont√©m o resultado-o n√∫mero total de +a+‚Äôs.
(((contador)))

===== Exerc√≠cio 8-5

Encapsule esse c√≥digo em uma fun√ß√£o chamada +conte+, e a generealize para que ela aceite a string e a letra como argumentos.

Depois reescreva a fun√ß√£o de modo que ao inv√©s de percorrer a string, ela usa a vers√£o com tr√™s par√¢metros de +busca+ da se√ß√£o anterior.


=== Biblioteca String

O Julia fornece fun√ß√µes que executam uma variedade de opera√ß√µes ut√©is com strings. Por exemplo, a fun√ß√£o +uppercase+ recebe uma string e retorna uma nova string com todas suas letras mai√∫sculas.
(((mai√∫scula)))((("fun√ß√£o", "Base", "mai√∫scula", see="mai√∫scula")))

[source,@julia-repl-test]
----
julia> uppercase("Ol√°, Mundo!")
"OL√Å, MUNDO!"
----

Acontece que, existe uma fun√ß√£o chamada +findfirst+ que √© bastante similar a fun√ß√£o +busca+ que n√≥s escrevemos:
(((findfirst)))((("fun√ß√£o", "definido pelo programador", "findfirst", see="findfirst")))

[source,@julia-repl-test]
----
julia> findfirst("a", "banana")
2:2
----

Na verdade, a fun√ß√£o +findfirst+ √© mais geral que a nossa fun√ß√£o; ela pode achar substrings, n√£o apenas caracteres:

[source,@julia-repl-test]
----
julia> findfirst("na", "banana")
3:4
----

Por padr√£o, +findfirst+ come√ßa no in√≠cio da string, mas a fun√ß√£o +findnext+ recebe um terceiro argumento, o +ind√≠ce+ onde ela deve come√ßar:
(((findnext)))((("fun√ß√£o", "definido pelo programador", "findnext", see="findnext")))

[source,@julia-repl-test]
----
julia> findnext("na", "banana", 4)
5:6
----


=== O operador +‚àà+

O operador +‚àà+ (*+\in TAB+*) √© um operador booleano que recebe um caractere e uma string e retorna +true+ se o caractere aparece na string:
((("‚àà", see="in")))((("operador", "Base", "in", see="in")))((("operador", "Base", "‚àà", see="in")))

[source,@julia-repl-test]
----
julia> 'a' ‚àà "banana"    # 'a' em "banana"
true
----

Por exemplo, a seguinte fun√ß√£o imprime todas as letras da palavra1 que tamb√©m aparecem na palavra2:
(((emambos)))((("fun√ß√£o", "definido pelo programador", "emambos", see="emambos")))

[source,@julia-setup chap08-2]
----
function emambos(palavra1, palavra2)
    for letra in palavra1
        if letra ‚àà palavra2
            print(letra, " ")
        end
    end
end
----

Com vari√°veis de nomes bem escolhidos, o Julia as vezes l√™ como Ingl√™s. Voc√™ poderia ler este loop, ‚Äúpara (cada) letra na (primeira) palavra, se (a) letra √© um elemento da (segunda) palavra, imprima (a) letra‚Äù

Isso √© o que voc√™ recebe se voc√™ compara +"ma√ß√£s"+ e +"laranjas"+:

[source,@julia-repl-test chap08-2]
----
julia> emambos("ma√ß√£s", "laranjas")
a s
----


=== Compara√ß√£o de Strings

O operador relacional funciona em strings. Para ver se duas strings s√£o iguais:
(((compara√ß√£o de strings)))(((==)))

[source,@julia-setup chap08]
----
palavra = "Abacaxi"
if palavra == "banana"
    println("Tudo certo, bananas.")
end
----

Outras opera√ß√µes relacionais s√£o ut√©is para colocar palavras em ordem alfab√©tica:
(((ordem alfab√©tica)))

[source,@julia-setup chap08]
----
if palavra < "banana"
    println("Sua palavra, $palavra, vem antes de banana.")
elseif palavra > "banana"
    println("Sua palavra, $palavra, vem depois de banana.")
else
    println("Tudo certo, bananas.")
end
----

Julia n√£o lida letras mai√∫sculas e min√∫sculas do mesmo jeito que as pessoas lidam. Todas as letras mai√∫sculas vem antes de todas as letras min√∫sculas, ent√£o:

[source,@julia-eval chap08]
----
if palavra < "banana"
    println("Sua palavra, $palavra, vem antes de banana.")
elseif palavra > "banana"
    println("Sua palavra, $palavra, vem depois de banana.")
else
    println("Tudo certo, bananas.")
end
----

[TIP]
====
Um jeito comum de resolver este problema √© convertendo strings para um formato padr√£o, como todas min√∫sculas, antes de efetuar a compara√ß√£o.
====


[[deb08]]
=== Debugando

Quando voc√™ usa ind√≠ces para percorrer os valores em uma sequ√™ncia, √© dif√≠cil de obter o come√ßo e o fim da travessia direito. Aqui est√° uma fun√ß√£o que deveria comparar duas palavras e retornar +true+ se uma das palavras √© o inverso da outra, mas ela cont√©m dois erros:
(((debugando)))(((travessia)))(((√©inversa)))((("fun√ß√£o", "definido pelo programador", "√©inversa", see="√©inversa")))

[source,@julia-setup chap08]
----
function √©inversa(palavra1, palavra2)
    if length(palavra1) != length(palavra2)
        return false
    end
    i = firstindex(palavra1)
    j = lastindex(palavra2)
    while j >= 0
        j = prevind(palavra2, j)
        if palavra1[i] != palavra2[j]
            return false
        end
        i = nextind(palavra1, i)
    end
    true
end
----

A primeira declara√ß√£o +if+ verifica se as palavras s√£o do mesmo tamanho. Se n√£o, n√≥s podemos retornar +false+ imediatamente. Caso contr√°rio, para o resto da fun√ß√£o, n√≥s podemos assumir que as palavras s√£o do mesmo tamanho. Isso √© um exemplo do padr√£o guardi√£o.

+i+ e +j+ s√£o ind√≠ces: +i+ percorre a +palavra1+ de frente para tr√°s, enquanto +j+ percorre a +palavra2+ de tr√°s para frente. Se n√≥s acharmos duas letras que n√£o s√£o iguais, n√≥s podemos retornar +false+ imediatamente. Se n√≥s passarmos pelo loop inteiro e todas as letras forem iguais, n√≥s retornamos +true+.

A fun√ß√£o +lastindex+ retorna o √∫ltimo ind√≠ce de bytes v√°lido de uma string e +prevind+ o √∫ltimo ind√≠ce v√°lido de um caractere.

Se n√≥s testarmos essa fun√ß√£o com as palavras "pots" e "stop", n√≥s esperamos que o valor de retorno seja +true+, mas n√≥s obtemos +false+:

[source,@julia-repl-test chap08]
----
julia> √©inversa("pots", "stop")
false
----

Para debugar esse tipo de erro, o primeiro passo √© imprimir os valores dos ind√≠ces:

[source,julia]
----
    while j >= 0
        j = prevind(palavra2, j)
        @show i j
        if palavra1[i] != palavra2[j]
----

[source,@julia-eval chap08]
----
function √©inversa(palavra1, palavra2)
    if length(palavra1) != length(palavra2)
        return false
    end
    i = firstindex(palavra1)
    j = lastindex(palavra2)
    while j >= 0
        j = prevind(palavra2, j)
        @show i j
        if palavra1[i] != palavra2[j]
            return false
        end
        i = nextind(palavra1, i)
    end
    true
end;
----

Agora quando executamos novamente o programa, obtemos mais informa√ß√£o:

[source,@julia-repl-test chap08]
----
julia> √©inversa("pots", "stop")
i = 1
j = 3
false
----

A primeira vez dentro do loop, o valor de +j+ √© 3, que tem que ser 4. Isso pode ser consertado movendo +j = prevind(palavra2, j)+ para o final do loop +while+.

Se consertamos este erro e executamos novamente o programa, obtemos:

[source,@julia-eval chap08]
----
function √©inversa(palavra1, palavra2)
    if length(palavra1) != length(palavra2)
        return false
    end
    i = firstindex(palavra1)
    j = lastindex(palavra2)
    while j >= 0
        @show i j
        if palavra1[i] != palavra2[j]
            return false
        end
        i = nextind(palavra1, i)
        j = prevind(palavra2, j)
    end
    true
end;
----

[source,@julia-repl-test chap08]
----
julia> √©inversa("pots", "stop")
i = 1
j = 4
i = 2
j = 3
i = 3
j = 2
i = 4
j = 1
i = 5
j = 0
ERROR: BoundsError: attempt to access String
  at index [5]
----

Desta vez um +BoundsError+ foi gerado. O valor de +i+ √© 5, que est√° fora do alcance para a string +"pots"+.
(((BoundsError)))((("erro", "Core", "BoundsError", see="BoundsError")))

===== Exerc√≠cio 8-6

Execute o programa em papel, mudando os valores de +i+ e +j+ durante cada itera√ß√£o. Encontre e conserte o segundo erro nesta fun√ß√£o.


=== Gloss√°rio

sequ√™ncia::
Uma cole√ß√£o ordenada de valores no qual cada valor √© identificado por um ind√≠ce inteiro.
(((sequ√™ncia)))

Padr√£o ASCII::
Um padr√£o de codifica√ß√£o de caracteres para comunica√ß√£o eletr√¥nica que especifica 128 caracteres.
(((Padr√£o ASCII)))

Padr√£o Unicode::
Um padr√£o da ind√∫stria da computa√ß√£o para a codifica√ß√£o consistente, representa√ß√£o, e tratamento de texto expressado na maioria dos sistemas de escrita do mundo.
(((Padr√£o Unicode)))

ind√≠ce::
Um valor inteiro usado para selecionar um item em uma sequ√™ncia, como um caractere em uma string. Em Julia ind√≠ces come√ßam em 1.
(((ind√≠ce)))

Codifica√ß√£o UTF-8::
Uma codifica√ß√£o de comprimento vari√°vel de caractere capaz de codificar todas as 1112064 pontos de c√≥digo usando um a quatro bytes de 8-bit.
(((Codifica√ß√£o UTF-8)))

travessia::
Iterar sobre os items de uma sequ√™ncia, realizando opera√ß√µes similares em cada um deles.
(((travessia)))

fatia::
Uma parte de uma string especificado por um alcance de ind√≠ces.
(((fatia)))

string vazia::
Uma string sem caracteres e comprimento 0, representada por duas aspas.
(((string vazia)))

imut√°vel::
A propriedade de uma sequ√™ncia no qual seus items n√£o podem ser mudados.
(((imut√°vel)))

interpola√ß√£o de strings::
O processo de avaliar uma string que cont√©m um ou mais espa√ßos reservados, produzindo um resultado no qual os espa√ßos reservados s√£o substituidos por seus valores correspondentes.
(((interpola√ß√£o de strings)))

busca::
Um padr√£o de travessia que para quando acha o que est√° procurando.
(((busca)))

contador::
Uma vari√°vel usada para contar algo, geralmente inicializada para zero e em seguida incrementada.
(((contador)))


=== Exerc√≠cios

[[ex08-1]]
===== Exerc√≠cio 8-7

Leia a documenta√ß√£o das fun√ß√µes string em https://docs.julialang.org/en/v1/manual/strings/. Voc√™ pode querer experimentar com algumas delas para garantir que voc√™ entende como elas funcionam. +strip+ e +replace+ s√£o particulamente ut√©is.

A documenta√ß√£o usa uma sintaxe que pode ser confusa. Por exemplo, em +search(string::AbstractString, chars::Chars, [start::Integer])+, os colchetes indicam argumentos opcionais. Ent√£o +string+ e +chars+ s√£o obrigat√≥rios, mas +start+ √© opcional.
(((busca)))((("fun√ß√£o", "Base", "busca", see="busca")))

[[ex08-2]]
===== Exerc√≠cio 8-8

Existe uma fun√ß√£o embutida chamada +count+ que √© similar √† fun√ß√£o em <<looping_and_counting>>. Leia a documenta√ß√£o desta fun√ß√£o e a use para contar o n√∫mero de +a+‚Äôs em "banana".
(((contar)))((("fun√ß√£o","Base", "contar", see="contar")))

[[ex08-3]]
===== Exerc√≠cio 8-9

Uma fatia de string pode receber um terceiro ind√≠ce. O primeiro especifica o come√ßo, o terceiro o fim e o segundo o ‚Äútamanho do passo‚Äù; isto √©, o n√∫mero de espa√ßos entre caracteres sucessivos. Um tamanho de passo de 2 significa que andamos de dois em dois; 3 significa de tr√™s em tr√™s, etc.
(((fatia)))

[source,@julia-repl-test]
----
julia> fruta = "banana"
"banana"
julia> fruta[1:2:6]
"bnn"
----

Um tamanho de passo -1 percorre a palavra ao contr√°rio, ent√£o a fatia +[end:-1:1]+ gera uma string reversa.

Use esse idioma para escrever uma vers√£o de uma linha de +ispalindrome+ do <<ex06-3>>.
(((ispalindrome)))

[[ex08-4]]
===== Exerc√≠cio 8-10

As seguintes fun√ß√£o s√£o todas _planejadas_ para checar se a string cont√©m alguma letra min√∫scula, mas pelo menos algumas delas est√£o erradas. Para cada fun√ß√£o, descreva o que a fun√ß√£o faz de fato (assumindo que o par√¢metro √© uma string).

[source,@julia-setup]
----
function qualquermin√∫scula1(s)
    for c in s
        if islowercase(c)
            return true
        else
            return false
        end
    end
end

function qualquermin√∫scula2(s)
    for c in s
        if islowercase('c')
            return "true"
        else
            return "false"
        end
    end
end

function qualquermin√∫scula3(s)
    for c in s
        flag = islowercase(c)
    end
    flag
end

function qualquermin√∫scula4(s)
    flag = false
    for c in s
        flag = flag || islowercase(c)
    end
    flag
end

function qualquermin√∫scula5(s)
    for c in s
        if !islowercase(c)
            return false
        end
    end
    true
end
----

[[ex08-5]]
===== Exerc√≠cio 8-11
Uma cifra de C√©sar √© uma forma fraca de criptografia que envolve ‚Äúrotacionar‚Äù cada letra por um n√∫mero fixo de lugares. Rotacionar uma letra significa deslocar ela atrav√©s do alfabeto, retornando ao come√ßo se necess√°rio, ent√£o +‚ÄôA‚Äô+ rotacionada por 3 √© +‚ÄôD‚Äô+ e +‚ÄôZ‚Äô+ rotacionada por 1 √© +‚ÄôA‚Äô+.
(((cifra de C√©sar)))

Para rotacionar uma palavra, rotacione cada letra pelo mesmo valor. Por exemplo +"cheer"+ rotacionado por 7 √© +"jolly"+ e +"melon"+ rotacionado por -10 √© +"cubed"+. No filme _2001: Odisseia no espa√ßo, o computador de bordo_ √© chamado de HAL, que √© IBM rotacionado por -1.

Escreva uma fun√ß√£o chamada +rotacionapalavra+ que recebe uma string e um inteiro como par√¢metros, e retorna uma nova string que cont√©m as letras da string original rotacionada pela inteiro fornecido.
(((rotacionapalavra)))((("fun√ß√£o","definido pelo programador", "rotacionapalavra", see="rotacionapalavra")))

[TIP]
====
Voc√™ pode querer usar as fun√ß√µes embutidas +Int+, que converte um caractere para um c√≥digo num√©rico, e +Char+, que converte c√≥digos num√©ricos para caracteres. Letras do alfabeto s√£o codificadas em ordem alfab√©tica, ent√£o por exemplo:
(((Int)))(((Char)))

[source,@julia-repl-test]
----
julia> Int('c') - Int('a')
2
----

Por qu√™ +'c'+ √© a terceira letra do alfabeto. Mas tome cuidado: os c√≥digos num√©ricos para letras mai√∫sculas s√£o diferentes.

[source,@julia-repl-test]
----
julia> Char(Int('A') + 32)
'a': ASCII/Unicode U+0061 (category Ll: letra, lowercase)
----
====

Piadas potencialmente ofensivas na internet s√£o algumas vezes codificadas em ROT13, que √© uma cifra de C√©sar com rota√ß√£o 13. Se voc√™ n√£o √© fac√≠lmente ofendido, encontre e codifique algumas delas.
