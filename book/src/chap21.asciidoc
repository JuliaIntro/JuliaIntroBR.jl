[[chap21]]
== Depuração

Na depuração, você deve distinguir entre os diferentes tipos de erros a fim de rastreá-los mais rapidamente:

* Os erros de sintaxe são descobertos pelo interpretador quando ele está traduzindo o código fonte em código byte. Eles sinalizam que há algo errado com a estrutura do programa. Exemplo: omitir a palavra-chave +end+ no final de um bloco de funções gera a mensagem um tanto redundante +ERROR: LoadError: syntax: incomplete: function requires end+.
(((erro de sintaxe)))

* Erros de tempo de execução são produzidos pelo interpretador se algo der errado durante a execução do programa. A maioria das mensagens de erro de tempo de execução inclui as informações sobre o local da ocorrência do erro e sobre quais funções que estavam sendo executadas. Exemplo: Uma recursão infinita eventualmente gera o erro de tempo de execução +ERROR: StackOverflowError+.
(((erro de tempo de execução)))

* Erros semânticos são problemas com um programa que embora rode sem produzir mensagens de erro, não faz a coisa certa. Exemplo: Uma expressão pode não ser avaliada na ordem que você espera, produzindo um resultado incorreto.
(((erro semântico)))

O primeiro passo na depuração é descobrir com qual o tipo de erro você está lidando. Apesar das seções seguintes sejam organizadas pelo tipo de erro, algumas técnicas são aplicáveis em mais de uma situação.


=== Erros de Sintaxe

Geralmente, os erros de sintaxe são fáceis de corrigir depois de você descobrir quais são eles. Infelizmente, as mensagens de erro muitas vezes não são úteis. As mensagens mais comuns são +ERROR: LoadError: syntax: incomplete: premature end of input+ e +ERROR: LoadError: syntax: unexpected "="+, que não são muito informativo.

Por outro lado, a mensagem te informa onde o problema ocorreu no programa. Na verdade, ela informa onde o Julia notou um problema, que não é necessariamente onde está o erro. Às vezes, o erro é anterior ao local da mensagem de erro, geralmente na linha anterior.

Se você está construindo o programa de forma incremental, deve ter uma boa idéia de onde o erro está. Ele estará na última linha que você adicionou.

Caso você esteja copiando o código de um livro, comece comparando seu código com o código do livro com muito cuidado. Verifique todos os caracteres. Ao mesmo tempo, lembre-se de que o livro pode estar errado, portanto, se você vir algo que parece um erro de sintaxe, talvez seja.

Eis algumas maneiras de evitar os erros de sintaxe mais comuns:

. Certifique-se que você não está usando uma palavra-chave do Julia para um nome de variável.

. Certifique-se que você tem a palavra-chave +end+ no final de cada comando composto, incluindo os blocos de +for+, +while+, +if+, e +function+.

. Assegure-se de que quaisquer strings no código estejam entre aspas. Certifique-se de que todas as aspas são “aspas retas”, e não as “aspas encaracoladas” (ou “aspas inglesas”).

. Se você tiver strings de múltiplas linhas com aspas triplas, confira se a string foi finalizada corretamente. Uma string não terminada pode causar um erro de token inválido no final do seu programa, ou pode tratar a parte seguinte do programa como uma string até chegar à próxima string. No segundo caso, pode não produzir uma mensagem de erro!

. Quando não se fecha um operador aberto —+(+, +{+, or +[+—faz com que o Julia continue com a próxima linha como parte do comando atual. Geralmente, um erro ocorre quase imediatamente na próxima linha.

. Confira o clássico +=+ em vez de +==+ dentro de um condicional.

. Se você tem caracteres que não ASCII no código (incluindo as strings e os comentários), isso pode causar um problema, embora o Julia geralmente lide com caracteres não ASCII. Tenha cuidado quando você colar texto de uma página da web ou de outra fonte.

Se nada funcionar, passe para a próxima seção...

==== Eu Continuo Fazendo Mudanças e Não Há Diferença

Se o REPL diz que há um erro e você não o vê, talvez seja porque você e o REPL não estão visualizando o mesmo código. Verifique o seu ambiente de programação para garantir que o programa que você está editando é o mesmo que o Julia está tentando executar.

Se você não tiver certeza, tente colocar um erro de sintaxe óbvio e intencional no início do programa. Agora execute-o novamente. Se o REPL não encontrar o novo erro, você não está executando o novo código.

Existem alguns prováveis culpados:

* Você editou o arquivo e esqueceu de salvar as alterações antes de executá-lo novamente. Alguns ambientes de programação fazem isso por você, mas outros não.

* Você alterou o nome do arquivo, mas ainda está executando o nome antigo.

* Algo em seu ambiente de desenvolvimento está configurado erroneamente.

* Se você estiver escrevendo um módulo e usando +using+, certifique-se de não nomear o seu módulo com o mesmo nome de um dos módulos padrões do Julia.

* Caso você esteja utilizando +using+ para importar um módulo, lembre-se de que é necessário reiniciar o REPL ao modificar o código no módulo. Se você importar o módulo novamente, ele não faz nada.

Se você ficar preso e não conseguir descobrir o que está acontecendo, uma abordagem é começar novamente com um novo programa como “Olá, Mundo!”, e ter certeza de que você consegue executar um programa conhecido. Depois, acrescente gradualmente as peças do programa original ao novo programa.


=== Erros de Tempo de Execução

Quando seu programa estiver sintaticamente correto, o Julia poderá lê-lo e, pelo menos, começar a executá-lo. O que poderia dar errado?

==== Meu programa Não Faz Absolutamente Nada

Esse problema é mais comum quando seu arquivo consiste em funções e classes, mas na verdade não invoca uma função para iniciar a execução. Isto pode ser intencional se você planeja importar este módulo apenas para fornecer as classes e funções.

Se não for intencional, certifique-se de que há uma chamada de função no programa, e certifique-se de que o fluxo de execução chega até ele (veja <<flow_of_execution>>).
(((fluxo de execução)))

==== Meu Programa Trava

Se um programa para e parece não estar fazendo nada, ele está "travando". Frequentemente isso significa que ele está detido em um loop infinito ou em uma repetição infinita.

* Se houver um laço em particular que você suspeita ser o problema, adicione uma declaração print logo antes do laço que diz “entrando no laço” e outra logo depois que diz “saindo do laço”.
+
Execute o programa. Caso receba a primeira mensagem e não a segunda, então você tem um laço infinito. Vá para a subseção <<infinite_loop>> mais adiante.
(((laço infinito)))

* Na maioria das vezes, uma recursão infinita fará com que o programa funcione por um tempo e depois aparecerá uma mensagem de erro +ERROR: LoadError: StackOverflowError+. Se isso acontecer, vá para a subseção <<infinite_recursion>> mais adiante.
+
Se você não estiver recebendo esse erro, mas desconfia que há um problema com um método ou uma função recursiva, ainda assim poderá usar as técnicas de <<infinite_recursion>>.
(((recursão infinita)))

* Caso nenhum desses passos dê certo, comece a testar outros laços e outras funções e métodos recursivos.

* Caso isso não funcione, então é possível que você não esteja entendendo o fluxo de execução do seu programa. Vá para <<flow_of_execution>> mais adiante.

[[infinite_loop]]
===== Laço Infinito

Se você acha que tem um laço infinito e acha que sabe qual laço está causando o problema, adicione uma declaração de print no final do laço que imprime os valores das variáveis na condição e o valor da condição.

Por exemplo:

[source,julia]
----
while x > 0 && y < 0
    # faça algo para x
    # faça algo para y
    @debug "variáveis" x y
    @debug "condições" x > 0 && y < 0
end
----

Agora, quando você executar o programa no modo de depuração, verá o valor das variáveis e a condição em cada iteração do laço. A última vez que o laço for percorrido, a condição deve ser +false+. Se o laço continuar, você poderá ver os valores de +x+ e +y+ e poderá descobrir por que eles não estão sendo atualizados corretamente.

[[infinite_recursion]]
===== Recursão Infinita

Na maioria das vezes, a recursão infinita faz com que o programa funcione por um tempo e depois aparece uma mensagem de erro +ERROR: LoadError: StackOverflowError+.
(((StackOverflowError)))

Se você desconfia que uma função está causando uma recursão infinita, certifique-se de que há um caso base. Deve haver alguma condição que causa o retorno da função sem fazer uma invocação recursiva. Caso contrário, você precisa repensar o algoritmo e identificar um caso base.

Se existe um caso base mas o programa não parece alcançá-lo, adicione uma declaração print no começo da função para imprimir os parâmetros. E quando você executar o programa, verá algumas linhas de saída toda vez que a função for chamada, e verá também os valores dos parâmetros. Caso  os parâmetros não estiverem se movendo em direção ao caso base, você terá algumas idéias sobre por que isso ocorre.

[[flow_of_execution]]
===== Fluxo de Execução

Se você não tem certeza de como o fluxo de execução está se movendo pelo seu programa, adicione delcarações prints no início de cada função com uma mensagem como “inserindo a função foo”, sendo foo o nome da função.

E quando você executar o programa, ele imprimirá cada função que for chamada.

==== Quando Executo o Programa, Recebo uma Exceção

Se algo der errado durante o tempo de execução, o Julia imprime uma mensagem que inclui o nome da exceção, a linha do programa onde o problema ocorreu e um rastreamento de pilha.

O rastreamento de pilha identifica a função que está em execução no momento, e depois a função que a chamou, e depois a função que chamou isso e assim por diante. Em outras palavras, ele rastreia a sequência de chamadas de função que o levaram aonde você está, juntamente com o número da linha no seu arquivo onde cada chamada ocorreu.

O primeiro passo é examinar o local no programa onde ocorreu o erro e verificar se você consegue descobrir o que aconteceu. Listamos alguns dos erros de tempo de execução mais comuns:

ArgumentError::
Um dos argumentos para uma chamada de função não está no estado esperado.
(((ArgumentError)))

BoundsError::
Uma operação de indexação em uma lista que tentou acessar um elemento fora dos limites.
(((BoundsError)))

DomainError::
O argumento para uma função ou construtor está fora do domínio válido.
(((DomainError)))((("error", "Core", "DomainError", see="DomainError")))

DivideError::
Tentativa de divisão inteira por um denominador de valor 0.
(((DivideError)))((("error", "Core", "DivideError", see="DivideError")))

EOFError::
Não havia mais dados disponíveis para a leitura de um arquivo ou fluxo.
(((EOFError)))((("error", "Base", "EOFError", see="EOFError")))

InexactError::
Não é possível converter exatamente para um tipo.
(((InexactError)))((("error", "Core", "InexactError", see="InexactError")))

KeyError::
Uma operação de indexação em um +AbstractDict+ (+Dict+) ou +Set+ como se um objeto tentasse acessar ou apagar um elemento inexistente.
(((KeyError)))

MethodError::
Um método com a assinatura de tipo requerida não existe na função genérica em questão. Como alternativa, não existe um método mais específico.
(((MethodError)))

OutOfMemoryError::
Uma operação com muita memória alocada tanto para o sistema quanto para o coletor de lixo para manusear corretamente.
(((OutOfMemoryError)))((("error", "Core", "OutOfMemoryError", see="OutOfMemoryError")))

OverflowError::
O resultado de uma expressão é muito grande para o tipo especificado e causará uma explosão. The result of an expression is too large for the specified type and will cause a wraparound.
(((OverflowError)))((("error", "Core", "OverflowError", see="OverflowError")))

StackOverflowError::
A chamada de função cresceu além do tamanho da pilha de chamadas. Isso geralmente acontece quando uma chamada cai em uma recursão infinita.
(((StackOverflowError)))

StringIndexError::
Ocorrência de um erro ao tentar acessar um índice inválido em uma string.
(((StringIndexError)))

SystemError::
Uma chamada de sistema falhou devido a um código errado.
(((SystemError)))

TypeError::
Uma falha de asserção de tipo ou chamada de uma função intrínseca com um tipo de argumento incorreto.
(((TypeError)))

UndefVarError::
Um símbolo no escopo atual não está definido.
(((UndefVarError)))

==== Adicionei Tantas declarações print que Sou Inundado com a Saída

Um dos problemas com o uso de declarações print para a depuração é que você pode acabar soterrado pelas mensagens na saída. Existem duas maneiras de proceder: simplificar a saída ou simplificar o programa.

Para simplificar a saída, você pode remover ou comentar as declarações print que não estão ajudando, ou combiná-las, ou formatar a saída para facilitar a compreensão.

Para simplificar o programa, existem muitas coisas que você pode fazer. Primeiro, reduza o problema no qual o programa está trabalhando. Por exemplo, se você estiver fazendo uma busca em uma lista, busque em uma pequena lista. Caso o programa receba a entrada do usuário, passe a entrada mais simples que causa o problema.

Segundo, limpe o programa. Remova o código morto e reorganize o programa para torná-lo o mais fácil possível de ler. Por exemplo, se você suspeita que o problema está em uma parte profundamente aninhada do programa, tente reescrever essa parte com uma estrutura mais simples. Mas se você suspeitar de uma função grande, tente dividi-la em funções menores e testá-las separadamente.
(((código morto)))

Freqüentemente, o processo de encontrar o menor caso de teste leva você ao erro. Se você achar que um programa funciona em uma situação, mas não em outra, isso lhe dará uma pista sobre o que está acontecendo.

Da mesma forma, reescrever uma parte do código pode te ajudar a encontrar erros sutis. Se fizer uma mudança que você acha que não deve afetar o programa, e ela afeta, isso pode te dar uma dica.


=== Erros Semânticos

De certa forma, os erros semânticos são os mais difíceis de depurar, porque o interpretador não fornece informações sobre o que está errado. Só você sabe o que o programa deve fazer.

O primeiro passo é conectar o texto do programa ao comportamento que você está vendo. Você precisa de uma hipótese sobre o que o programa está realmente fazendo. Um dos fatores que dificulta isso é que os computadores executam muito rápido.

Muitas vezes você vai desejar diminuir a velocidade do programa para a velocidade humana. Inserir algumas bem colocadas declarações print é muitas vezes mais rápido do que configurar um depurador, inserir e remover pontos de interrupção e “andar” pelo programa até onde o erro está ocorrendo.

==== Meu Programa Não Funciona

You should ask yourself these questions:

* Is there something the program was supposed to do but which doesn’t seem to be happening? Find the section of the code that performs that function and make sure it is executing when you think it should.

Você deve se perguntar:

Você deve fazer a si mesmo estas perguntas:

**Você deve se perguntar o seguinte:

    **Há algo que o programa deveria fazer, mas que não parece acontecer? Encontre a seção do código que executa a função em questão e confira se está sendo executada quando você acha que deveria.


* Existe algo que o programa deveria ter feito, mas que não parece estar acontecendo? Encontre a seção do código que executa essa função e certifique-se de que ele está executando quando você acha que deve.

* Existe algo que o programa deveria fazer, mas que não parece estar acontecendo? Encontre a seção do código que executa essa função e verifique se ela está sendo executada quando você acha que deveria.

* Is something happening that shouldn’t? Find code in your program that performs that function and see if it is executing when it shouldn’t.

* Is a section of code producing an effect that is not what you expected? Make sure that you understand the code in question, especially if it involves functions or methods in other Julia modules. Read the documentation for the functions you call. Try them out by writing simple test cases and checking the results.

In order to program, you need a mental model of how programs work. If you write a program that doesn’t do what you expect, often the problem is not in the program; it’s in your mental model.
(((mental model)))

The best way to correct your mental model is to break the program into its components (usually the functions and methods) and test each component independently. Once you find the discrepancy between your model and reality, you can solve the problem.

Of course, you should be building and testing components as you develop the program. If you encounter a problem, there should be only a small amount of new code that is not known to be correct.

==== I’ve got a big hairy expression and it doesn’t do what I expect

Writing complex expressions is fine as long as they are readable, but they can be hard to debug. It is often a good idea to break a complex expression into a series of assignments to temporary variables.

For example:

[source,julia]
----
addcard(game.hands[i], popcard(game.hands[findneighbor(game, i)]))
----

This can be rewritten as:

[source,julia]
----
neighbor = findneighbor(game, i)
pickedcard = popcard(game.hands[neighbor])
addcard(game.hands[i], pickedcard)
----

The explicit version is easier to read because the variable names provide additional documentation, and it is easier to debug because you can check the types of the intermediate variables and display their values.

Another problem that can occur with big expressions is that the order of evaluation may not be what you expect. For example, if you are translating the expression latexmath:[\(\frac{x}{2\pi}\)] into Julia, you might write:

[source,julia]
----
y = x / 2 * π
----

That is not correct because multiplication and division have the same precedence and are evaluated from left to right. So this expression computes latexmath:[\(\frac{x\pi}{2}\)].

A good way to debug expressions is to add parentheses to make the order of evaluation explicit:

[source,julia]
----
y = x / (2 * π)
----

Whenever you are not sure of the order of evaluation, use parentheses. Not only will the program be correct (in the sense of doing what you intended), it will also be more readable for other people who haven’t memorized the order of operations.

==== I’ve got a function that doesn’t return what I expect

If you have a return statement with a complex expression, you don’t have a chance to print the result before returning. Again, you can use a temporary variable. For example, instead of:
(((temporary variable)))

[source,julia]
----
return removematches(game.hands[i])
----

you could write:

[source,julia]
----
count = removematches(game.hands[i])
return count
----

Now you have the opportunity to display the value of +count+ before returning.

==== I’m really, really stuck and I need help

First, try getting away from the computer for a few minutes. Working with a computer can cause these symptoms:

* Frustration and rage.

* Superstitious beliefs (“the computer hates me”) and magical thinking (“the program only works when I wear my hat backward”).

* Random walk programming (the attempt to program by writing every possible program and choosing the one that does the right thing).

If you find yourself suffering from any of these symptoms, get up and go for a walk. When you are calm, think about the program. What is it doing? What are some possible causes of that behavior? When was the last time you had a working program, and what did you do next?

Sometimes it just takes time to find a bug. I often find bugs when I am away from the computer and let my mind wander. Some of the best places to find bugs are trains, showers, and in bed, just before you fall asleep.

==== No, I really need help

It happens. Even the best programmers occasionally get stuck. Sometimes you work on a program so long that you can’t see the error. You need a fresh pair of eyes.

Before you bring someone else in, make sure you are prepared. Your program should be as simple as possible, and you should be working on the smallest input that causes the error. You should have print statements in the appropriate places (and the output they produce should be comprehensible). You should understand the problem well enough to describe it concisely.

When you bring someone in to help, be sure to give them the information they need:

* If there is an error message, what is it and what part of the program does it indicate?

* What was the last thing you did before this error occurred? What were the last lines of code that you wrote, or what is the new test case that fails?

* What have you tried so far, and what have you learned?

When you find the bug, take a second to think about what you could have done to find it faster. Next time you see something similar, you will be able to find the bug more quickly.

Remember, the goal is not just to make the program work. The goal is to learn how to make the program work.
