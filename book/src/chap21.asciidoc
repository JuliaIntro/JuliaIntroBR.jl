[[chap21]]
== Depuração

Na depuração, você deve distinguir entre os diferentes tipos de erros a fim de rastreá-los mais rapidamente:

* Os erros de sintaxe são descobertos pelo interpretador quando ele está traduzindo o código fonte em código byte. Eles sinalizam que há algo errado com a estrutura do programa. Exemplo: omitir a palavra-chave +end+ no final de um bloco de funções gera a mensagem um tanto redundante +ERROR: LoadError: syntax: incomplete: function requires end+.
(((erro de sintaxe)))

* Erros de tempo de execução são produzidos pelo interpretador se algo der errado durante a execução do programa. A maioria das mensagens de erro de tempo de execução inclui as informações sobre o local da ocorrência do erro e sobre quais funções que estavam sendo executadas. Exemplo: Uma recursão infinita eventualmente gera o erro de tempo de execução +ERROR: StackOverflowError+.
(((erro de tempo de execução)))

* Erros semânticos são problemas com um programa que embora rode sem produzir mensagens de erro, não faz a coisa certa. Exemplo: Uma expressão pode não ser avaliada na ordem que você espera, produzindo um resultado incorreto.
(((erro semântico)))

O primeiro passo na depuração é descobrir com qual o tipo de erro você está lidando. Apesar das seções seguintes sejam organizadas pelo tipo de erro, algumas técnicas são aplicáveis em mais de uma situação.


=== Erros de Sintaxe

Geralmente, os erros de sintaxe são fáceis de corrigir depois de você descobrir quais são eles. Infelizmente, as mensagens de erro muitas vezes não são úteis. As mensagens mais comuns são +ERROR: LoadError: syntax: incomplete: premature end of input+ e +ERROR: LoadError: syntax: unexpected "="+, que não são muito informativo.

Por outro lado, a mensagem te informa onde o problema ocorreu no programa. Na verdade, ela informa onde o Julia notou um problema, que não é necessariamente onde está o erro. Às vezes, o erro é anterior ao local da mensagem de erro, geralmente na linha anterior.

Se você está construindo o programa de forma incremental, deve ter uma boa idéia de onde o erro está. Ele estará na última linha que você adicionou.

Caso você esteja copiando o código de um livro, comece comparando seu código com o código do livro com muito cuidado. Verifique todos os caracteres. Ao mesmo tempo, lembre-se de que o livro pode estar errado, portanto, se você vir algo que parece um erro de sintaxe, talvez seja.

Eis algumas maneiras de evitar os erros de sintaxe mais comuns:

. Certifique-se que você não está usando uma palavra-chave do Julia para um nome de variável.

. Certifique-se que você tem a palavra-chave +end+ no final de cada comando composto, incluindo os blocos de +for+, +while+, +if+, e +function+.

. Assegure-se de que quaisquer strings no código estejam entre aspas. Certifique-se de que todas as aspas são “aspas retas”, e não as “aspas encaracoladas” (ou “aspas inglesas”).

. Se você tiver strings de múltiplas linhas com aspas triplas, confira se a string foi finalizada corretamente. Uma string não terminada pode causar um erro de token inválido no final do seu programa, ou pode tratar a parte seguinte do programa como uma string até chegar à próxima string. No segundo caso, pode não produzir uma mensagem de erro!

. Quando não se fecha um operador aberto —+(+, +{+, or +[+—faz com que o Julia continue com a próxima linha como parte do comando atual. Geralmente, um erro ocorre quase imediatamente na próxima linha.

. Confira o clássico +=+ em vez de +==+ dentro de um condicional.

. Se você tem caracteres que não ASCII no código (incluindo as strings e os comentários), isso pode causar um problema, embora o Julia geralmente lide com caracteres não ASCII. Tenha cuidado quando você colar texto de uma página da web ou de outra fonte.

Se nada funcionar, passe para a próxima seção...

==== Eu Continuo Fazendo Mudanças e Não Há Diferença

Se o REPL diz que há um erro e você não o vê, talvez seja porque você e o REPL não estão visualizando o mesmo código. Verifique o seu ambiente de programação para garantir que o programa que você está editando é o mesmo que o Julia está tentando executar.

Se você não tiver certeza, tente colocar um erro de sintaxe óbvio e intencional no início do programa. Agora execute-o novamente. Se o REPL não encontrar o novo erro, você não está executando o novo código.

Existem alguns prováveis culpados:

* Você editou o arquivo e esqueceu de salvar as alterações antes de executá-lo novamente. Alguns ambientes de programação fazem isso por você, mas outros não.

* Você alterou o nome do arquivo, mas ainda está executando o nome antigo.

* Algo em seu ambiente de desenvolvimento está configurado erroneamente.

* Se você estiver escrevendo um módulo e usando +using+, certifique-se de não nomear o seu módulo com o mesmo nome de um dos módulos padrões do Julia.

* Caso você esteja utilizando +using+ para importar um módulo, lembre-se de que é necessário reiniciar o REPL ao modificar o código no módulo. Se você importar o módulo novamente, ele não faz nada.

Se você ficar preso e não conseguir descobrir o que está acontecendo, uma abordagem é começar novamente com um novo programa como “Olá, Mundo!”, e ter certeza de que você consegue executar um programa conhecido. Depois, acrescente gradualmente as peças do programa original ao novo programa.


=== Erros de Tempo de Execução

Quando seu programa estiver sintaticamente correto, o Julia poderá lê-lo e, pelo menos, começar a executá-lo. O que poderia dar errado?

==== Meu programa Não Faz Absolutamente Nada

Esse problema é mais comum quando seu arquivo consiste em funções e classes, mas na verdade não invoca uma função para iniciar a execução. Isto pode ser intencional se você planeja importar este módulo apenas para fornecer as classes e funções.

Se não for intencional, certifique-se de que há uma chamada de função no programa, e certifique-se de que o fluxo de execução chega até ele (veja <<flow_of_execution>>).
(((fluxo de execução)))

==== Meu Programa Trava

Se um programa para e parece não estar fazendo nada, ele está "travando". Frequentemente isso significa que ele está detido em um loop infinito ou em uma repetição infinita.

* Se houver um laço em particular que você suspeita ser o problema, adicione uma declaração print logo antes do laço que diz “entrando no laço” e outra logo depois que diz “saindo do laço”.
+
Execute o programa. Caso receba a primeira mensagem e não a segunda, então você tem um laço infinito. Vá para a subseção <<infinite_loop>> mais adiante.
(((laço infinito)))

* Na maioria das vezes, uma recursão infinita fará com que o programa funcione por um tempo e depois aparecerá uma mensagem de erro +ERROR: LoadError: StackOverflowError+. Se isso acontecer, vá para a subseção <<infinite_recursion>> mais adiante.
+
Se você não estiver recebendo esse erro, mas desconfia que há um problema com um método ou uma função recursiva, ainda assim poderá usar as técnicas de <<infinite_recursion>>.
(((recursão infinita)))

* Caso nenhum desses passos dê certo, comece a testar outros laços e outras funções e métodos recursivos.

* Caso isso não funcione, então é possível que você não esteja entendendo o fluxo de execução do seu programa. Vá para <<flow_of_execution>> mais adiante.

[[infinite_loop]]
===== Laço Infinito

Se você acha que tem um laço infinito e acha que sabe qual laço está causando o problema, adicione uma declaração de print no final do laço que imprime os valores das variáveis na condição e o valor da condição.

Por exemplo:

[source,julia]
----
while x > 0 && y < 0
    # faça algo para x
    # faça algo para y
    @debug "variáveis" x y
    @debug "condições" x > 0 && y < 0
end
----

Agora, quando você executar o programa no modo de depuração, verá o valor das variáveis e a condição em cada iteração do laço. A última vez que o laço for percorrido, a condição deve ser +false+. Se o laço continuar, você poderá ver os valores de +x+ e +y+ e poderá descobrir por que eles não estão sendo atualizados corretamente.

[[infinite_recursion]]
===== Recursão Infinita

Na maioria das vezes, a recursão infinita faz com que o programa funcione por um tempo e depois aparece uma mensagem de erro +ERROR: LoadError: StackOverflowError+.
(((StackOverflowError)))

Se você desconfia que uma função está causando uma recursão infinita, certifique-se de que há um caso base. Deve haver alguma condição que causa o retorno da função sem fazer uma invocação recursiva. Caso contrário, você precisa repensar o algoritmo e identificar um caso base.

Se existe um caso base mas o programa não parece alcançá-lo, adicione uma declaração print no começo da função para imprimir os parâmetros. E quando você executar o programa, verá algumas linhas de saída toda vez que a função for chamada, e verá também os valores dos parâmetros. Caso  os parâmetros não estiverem se movendo em direção ao caso base, você terá algumas idéias sobre por que isso ocorre.

[[flow_of_execution]]
===== Fluxo de Execução

Se você não tem certeza de como o fluxo de execução está se movendo pelo seu programa, adicione delcarações prints no início de cada função com uma mensagem como “inserindo a função foo”, sendo foo o nome da função.

E quando você executar o programa, ele imprimirá cada função que for chamada.

==== Quando Executo o Programa, Recebo uma Exceção

If something goes wrong during runtime, Julia prints a message that includes the name of the exception, the line of the program where the problem occurred, and a stacktrace.

The stacktrace identifies the function that is currently running, and then the function that called it, and then the function that called that, and so on. In other words, it traces the sequence of function calls that got you to where you are, including the line number in your file where each call occurred.

Se algo der errado durante o tempo de execução, Julia imprime uma mensagem que inclui o nome da exceção, a linha do programa em que o problema ocorreu e um rastreamento de pilha.

Se algo correr mal durante a execução, Julia imprime uma mensagem que inclui o nome da exceção, a linha do programa onde o problema ocorreu e um stacktrace.

**Se algo der errado durante o tempo de execução, o Python exibe uma mensagem que inclui o nome da exceção, a linha do programa onde o problema ocorreu, e um traceback.

**O traceback identifica a função que está rodando atualmente, e a função que a chamou, assim como a função que chamou esta, e assim por diante. Em outras palavras, ele traça a sequência de chamadas de função que fez com que você chegasse onde está, incluindo o número da linha no seu arquivo onde cada chamada ocorreu.

O stacktrace identifica a função que está sendo executada atualmente, e depois a função que a chamou, e depois a função que a chamou, e assim por diante. Em outras palavras, ele rastreia a sequência de chamadas de função que o levaram até onde você está, incluindo o número da linha no seu arquivo onde cada chamada ocorreu.

O rastreamento de pilha identifica a função que está em execução no momento e, em seguida, a função que a chamou e, em seguida, a função que chamou isso e assim por diante. Em outras palavras, ele rastreia a sequência de chamadas de função que o levaram aonde você está, incluindo o número da linha no seu arquivo em que cada chamada ocorreu.

The first step is to examine the place in the program where the error occurred and see if you can figure out what happened. These are some of the most common runtime errors:

ArgumentError::
One of the arguments to a function call is not in the expected state.
(((ArgumentError)))

BoundsError::
An indexing operation into an array tried to access an out-of-bounds element.
(((BoundsError)))

DomainError::
The argument to a function or constructor is outside the valid domain.
(((DomainError)))((("error", "Core", "DomainError", see="DomainError")))

DivideError::
Integer division was attempted with a denominator value of 0.
(((DivideError)))((("error", "Core", "DivideError", see="DivideError")))

EOFError::
No more data was available to read from a file or stream.
(((EOFError)))((("error", "Base", "EOFError", see="EOFError")))

InexactError::
Cannot exactly convert to a type.
(((InexactError)))((("error", "Core", "InexactError", see="InexactError")))

KeyError::
An indexing operation into an +AbstractDict+ (+Dict+) or +Set+ like object tried to access or delete a non-existent element.
(((KeyError)))

MethodError::
A method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.
(((MethodError)))

OutOfMemoryError::
An operation allocated too much memory for either the system or the garbage collector to handle properly.
(((OutOfMemoryError)))((("error", "Core", "OutOfMemoryError", see="OutOfMemoryError")))

OverflowError::
The result of an expression is too large for the specified type and will cause a wraparound.
(((OverflowError)))((("error", "Core", "OverflowError", see="OverflowError")))

StackOverflowError::
The function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.
(((StackOverflowError)))

StringIndexError::
An error occurred when trying to access a string at an index that is not valid.
(((StringIndexError)))

SystemError::
A system call failed with an error code.
(((SystemError)))

TypeError::
A type assertion failure, or calling an intrinsic function with an incorrect argument type.
(((TypeError)))

UndefVarError::
A symbol in the current scope is not defined.
(((UndefVarError)))

==== I added so many print statements I get inundated with output

One of the problems with using print statements for debugging is that you can end up buried in output. There are two ways to proceed: simplify the output or simplify the program.

To simplify the output, you can remove or comment out print statements that aren’t helping, or combine them, or format the output so it is easier to understand.

To simplify the program, there are several things you can do. First, scale down the problem the program is working on. For example, if you are searching a list, search a small list. If the program takes input from the user, give it the simplest input that causes the problem.

Second, clean up the program. Remove dead code and reorganize the program to make it as easy to read as possible. For example, if you suspect that the problem is in a deeply nested part of the program, try rewriting that part with simpler structure. If you suspect a large function, try splitting it into smaller functions and testing them separately.
(((dead code)))

Often the process of finding the minimal test case leads you to the bug. If you find that a program works in one situation but not in another, that gives you a clue about what is going on.

Similarly, rewriting a piece of code can help you find subtle bugs. If you make a change that you think shouldn’t affect the program, and it does, that can tip you off.


=== Semantic Errors

In some ways, semantic errors are the hardest to debug, because the interpreter provides no information about what is wrong. Only you know what the program is supposed to do.

The first step is to make a connection between the program text and the behavior you are seeing. You need a hypothesis about what the program is actually doing. One of the things that makes that hard is that computers run so fast.

You will often wish that you could slow the program down to human speed. Inserting a few well-placed print statements is often quicker than setting up a debugger, inserting and removing breakpoints, and “stepping” the program to where the error is occurring.

==== My program doesn’t work

You should ask yourself these questions:

* Is there something the program was supposed to do but which doesn’t seem to be happening? Find the section of the code that performs that function and make sure it is executing when you think it should.

* Is something happening that shouldn’t? Find code in your program that performs that function and see if it is executing when it shouldn’t.

* Is a section of code producing an effect that is not what you expected? Make sure that you understand the code in question, especially if it involves functions or methods in other Julia modules. Read the documentation for the functions you call. Try them out by writing simple test cases and checking the results.

In order to program, you need a mental model of how programs work. If you write a program that doesn’t do what you expect, often the problem is not in the program; it’s in your mental model.
(((mental model)))

The best way to correct your mental model is to break the program into its components (usually the functions and methods) and test each component independently. Once you find the discrepancy between your model and reality, you can solve the problem.

Of course, you should be building and testing components as you develop the program. If you encounter a problem, there should be only a small amount of new code that is not known to be correct.

==== I’ve got a big hairy expression and it doesn’t do what I expect

Writing complex expressions is fine as long as they are readable, but they can be hard to debug. It is often a good idea to break a complex expression into a series of assignments to temporary variables.

For example:

[source,julia]
----
addcard(game.hands[i], popcard(game.hands[findneighbor(game, i)]))
----

This can be rewritten as:

[source,julia]
----
neighbor = findneighbor(game, i)
pickedcard = popcard(game.hands[neighbor])
addcard(game.hands[i], pickedcard)
----

The explicit version is easier to read because the variable names provide additional documentation, and it is easier to debug because you can check the types of the intermediate variables and display their values.

Another problem that can occur with big expressions is that the order of evaluation may not be what you expect. For example, if you are translating the expression latexmath:[\(\frac{x}{2\pi}\)] into Julia, you might write:

[source,julia]
----
y = x / 2 * π
----

That is not correct because multiplication and division have the same precedence and are evaluated from left to right. So this expression computes latexmath:[\(\frac{x\pi}{2}\)].

A good way to debug expressions is to add parentheses to make the order of evaluation explicit:

[source,julia]
----
y = x / (2 * π)
----

Whenever you are not sure of the order of evaluation, use parentheses. Not only will the program be correct (in the sense of doing what you intended), it will also be more readable for other people who haven’t memorized the order of operations.

==== I’ve got a function that doesn’t return what I expect

If you have a return statement with a complex expression, you don’t have a chance to print the result before returning. Again, you can use a temporary variable. For example, instead of:
(((temporary variable)))

[source,julia]
----
return removematches(game.hands[i])
----

you could write:

[source,julia]
----
count = removematches(game.hands[i])
return count
----

Now you have the opportunity to display the value of +count+ before returning.

==== I’m really, really stuck and I need help

First, try getting away from the computer for a few minutes. Working with a computer can cause these symptoms:

* Frustration and rage.

* Superstitious beliefs (“the computer hates me”) and magical thinking (“the program only works when I wear my hat backward”).

* Random walk programming (the attempt to program by writing every possible program and choosing the one that does the right thing).

If you find yourself suffering from any of these symptoms, get up and go for a walk. When you are calm, think about the program. What is it doing? What are some possible causes of that behavior? When was the last time you had a working program, and what did you do next?

Sometimes it just takes time to find a bug. I often find bugs when I am away from the computer and let my mind wander. Some of the best places to find bugs are trains, showers, and in bed, just before you fall asleep.

==== No, I really need help

It happens. Even the best programmers occasionally get stuck. Sometimes you work on a program so long that you can’t see the error. You need a fresh pair of eyes.

Before you bring someone else in, make sure you are prepared. Your program should be as simple as possible, and you should be working on the smallest input that causes the error. You should have print statements in the appropriate places (and the output they produce should be comprehensible). You should understand the problem well enough to describe it concisely.

When you bring someone in to help, be sure to give them the information they need:

* If there is an error message, what is it and what part of the program does it indicate?

* What was the last thing you did before this error occurred? What were the last lines of code that you wrote, or what is the new test case that fails?

* What have you tried so far, and what have you learned?

When you find the bug, take a second to think about what you could have done to find it faster. Next time you see something similar, you will be able to find the bug more quickly.

Remember, the goal is not just to make the program work. The goal is to learn how to make the program work.
