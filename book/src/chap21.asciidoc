[[chap21]]
== Depuração

Na depuração, você deve distinguir entre os diferentes tipos de erros a fim de rastreá-los mais rapidamente:

* Os erros de sintaxe são descobertos pelo interpretador quando ele está traduzindo o código fonte em código byte. Eles sinalizam que há algo errado com a estrutura do programa. Exemplo: omitir a palavra-chave +end+ no final de um bloco de funções gera a mensagem um tanto redundante +ERROR: LoadError: syntax: incomplete: function requires end+.
(((erro de sintaxe)))

* Erros de tempo de execução são produzidos pelo interpretador se algo der errado durante a execução do programa. A maioria das mensagens de erro de tempo de execução inclui as informações sobre o local da ocorrência do erro e sobre quais funções que estavam sendo executadas. Exemplo: Uma recursão infinita eventualmente gera o erro de tempo de execução +ERROR: StackOverflowError+.
(((erro de tempo de execução)))

* Erros semânticos são problemas com um programa que embora rode sem produzir mensagens de erro, não faz a coisa certa. Exemplo: Uma expressão pode não ser avaliada na ordem que você espera, produzindo um resultado incorreto.
(((erro semântico)))

O primeiro passo na depuração é descobrir com qual o tipo de erro você está lidando. Apesar das seções seguintes sejam organizadas pelo tipo de erro, algumas técnicas são aplicáveis em mais de uma situação.


=== Erros de Sintaxe

Geralmente, os erros de sintaxe são fáceis de corrigir depois de você descobrir quais são eles. Infelizmente, as mensagens de erro muitas vezes não são úteis. As mensagens mais comuns são +ERROR: LoadError: syntax: incomplete: premature end of input+ e +ERROR: LoadError: syntax: unexpected "="+, que não são muito informativo.

Por outro lado, a mensagem te informa onde o problema ocorreu no programa. Na verdade, ela informa onde o Julia notou um problema, que não é necessariamente onde está o erro. Às vezes, o erro é anterior ao local da mensagem de erro, geralmente na linha anterior.

Se você está construindo o programa de forma incremental, deve ter uma boa idéia de onde o erro está. Ele estará na última linha que você adicionou.

Caso você esteja copiando o código de um livro, comece comparando seu código com o código do livro com muito cuidado. Verifique todos os caracteres. Ao mesmo tempo, lembre-se de que o livro pode estar errado, portanto, se você vir algo que parece um erro de sintaxe, talvez seja.

Eis algumas maneiras de evitar os erros de sintaxe mais comuns:

. Certifique-se que você não está usando uma palavra-chave do Julia para um nome de variável.

. Certifique-se que você tem a palavra-chave +end+ no final de cada comando composto, incluindo os blocos de +for+, +while+, +if+, e +function+.

. Assegure-se de que quaisquer strings no código estejam entre aspas. Certifique-se de que todas as aspas são “aspas retas”, e não as “aspas encaracoladas” (ou “aspas inglesas”).

. Se você tiver strings de múltiplas linhas com aspas triplas, confira se a string foi finalizada corretamente. Uma string não terminada pode causar um erro de token inválido no final do seu programa, ou pode tratar a parte seguinte do programa como uma string até chegar à próxima string. No segundo caso, pode não produzir uma mensagem de erro!

. Quando não se fecha um operador aberto —+(+, +{+, or +[+—faz com que o Julia continue com a próxima linha como parte do comando atual. Geralmente, um erro ocorre quase imediatamente na próxima linha.

. Confira o clássico +=+ em vez de +==+ dentro de um condicional.

. Se você tem caracteres que não ASCII no código (incluindo as strings e os comentários), isso pode causar um problema, embora o Julia geralmente lide com caracteres não ASCII. Tenha cuidado quando você colar texto de uma página da web ou de outra fonte.

Se nada funcionar, passe para a próxima seção...

==== Eu Continuo Fazendo Mudanças e Não Há Diferença

Se o REPL diz que há um erro e você não o vê, talvez seja porque você e o REPL não estão visualizando o mesmo código. Verifique o seu ambiente de programação para garantir que o programa que você está editando é o mesmo que o Julia está tentando executar.

Se você não tiver certeza, tente colocar um erro de sintaxe óbvio e intencional no início do programa. Agora execute-o novamente. Se o REPL não encontrar o novo erro, você não está executando o novo código.

Existem alguns prováveis culpados:

* Você editou o arquivo e esqueceu de salvar as alterações antes de executá-lo novamente. Alguns ambientes de programação fazem isso por você, mas outros não.

* Você alterou o nome do arquivo, mas ainda está executando o nome antigo.

* Algo em seu ambiente de desenvolvimento está configurado erroneamente.

* Se você estiver escrevendo um módulo e usando +using+, certifique-se de não nomear o seu módulo com o mesmo nome de um dos módulos padrões do Julia.

* Caso você esteja utilizando +using+ para importar um módulo, lembre-se de que é necessário reiniciar o REPL ao modificar o código no módulo. Se você importar o módulo novamente, ele não faz nada.

Se você ficar preso e não conseguir descobrir o que está acontecendo, uma abordagem é começar novamente com um novo programa como “Olá, Mundo!”, e ter certeza de que você consegue executar um programa conhecido. Depois, acrescente gradualmente as peças do programa original ao novo programa.


=== Erros de Tempo de Execução

Quando seu programa estiver sintaticamente correto, o Julia poderá lê-lo e, pelo menos, começar a executá-lo. O que poderia dar errado?

==== My program does absolutely nothing

This problem is most common when your file consists of functions and classes but does not actually invoke a function to start execution. This may be intentional if you only plan to import this module to supply classes and functions.

If it is not intentional, make sure there is a function call in the program, and make sure the flow of execution reaches it (see <<flow_of_execution>>).
(((flow of execution)))

==== My program hangs

If a program stops and seems to be doing nothing, it is “hanging”. Often that means that it is caught in an infinite loop or infinite recursion.

* If there is a particular loop that you suspect is the problem, add a print statement immediately before the loop that says “entering the loop” and another immediately after that says “exiting the loop”.
+
Run the program. If you get the first message and not the second, you’ve got an infinite loop. Go to <<infinite_loop>> below.
(((infinite loop)))

* Most of the time, an infinite recursion will cause the program to run for a while and then produce a +ERROR: LoadError: StackOverflowError+ error. If that happens, go to <<infinite_recursion>> below.
+
If you are not getting this error but you suspect there is a problem with a recursive method or function, you can still use the techniques in <<infinite_recursion>>.
(((infinite recursion)))

* If neither of those steps works, start testing other loops and other recursive functions and methods.

* If that doesn’t work, then it is possible that you don’t understand the flow of execution in your program. Go to <<flow_of_execution>> below.

[[infinite_loop]]
===== Infinite Loop

If you think you have an infinite loop and you think you know what loop is causing the problem, add a print statement at the end of the loop that prints the values of the variables in the condition and the value of the condition.

For example:

[source,julia]
----
while x > 0 && y < 0
    # do something to x
    # do something to y
    @debug "variables" x y
    @debug "condition" x > 0 && y < 0
end
----

Now when you run the program in debug mode, you will see the value of the variables and the condition for each time through the loop. The last time through the loop, the condition should be +false+. If the loop keeps going, you will be able to see the values of +x+ and +y+, and you might figure out why they are not being updated correctly.

[[infinite_recursion]]
===== Infinite Recursion

Most of the time, infinite recursion causes the program to run for a while and then produce a +ERROR: LoadError: StackOverflowError+ error.
(((StackOverflowError)))

If you suspect that a function is causing an infinite recursion, make sure that there is a base case. There should be some condition that causes the function to return without making a recursive invocation. If not, you need to rethink the algorithm and identify a base case.

If there is a base case but the program doesn’t seem to be reaching it, add a print statement at the beginning of the function that prints the parameters. Now when you run the program, you will see a few lines of output every time the function is invoked, and you will see the parameter values. If the parameters are not moving toward the base case, you will get some ideas about why not.

[[flow_of_execution]]
===== Flow of Execution

If you are not sure how the flow of execution is moving through your program, add print statements to the beginning of each function with a message like “entering function foo”, where foo is the name of the function.

Now when you run the program, it will print a trace of each function as it is invoked.

==== When I run the program I get an exception

If something goes wrong during runtime, Julia prints a message that includes the name of the exception, the line of the program where the problem occurred, and a stacktrace.

The stacktrace identifies the function that is currently running, and then the function that called it, and then the function that called that, and so on. In other words, it traces the sequence of function calls that got you to where you are, including the line number in your file where each call occurred.

The first step is to examine the place in the program where the error occurred and see if you can figure out what happened. These are some of the most common runtime errors:

ArgumentError::
One of the arguments to a function call is not in the expected state.
(((ArgumentError)))

BoundsError::
An indexing operation into an array tried to access an out-of-bounds element.
(((BoundsError)))

DomainError::
The argument to a function or constructor is outside the valid domain.
(((DomainError)))((("error", "Core", "DomainError", see="DomainError")))

DivideError::
Integer division was attempted with a denominator value of 0.
(((DivideError)))((("error", "Core", "DivideError", see="DivideError")))

EOFError::
No more data was available to read from a file or stream.
(((EOFError)))((("error", "Base", "EOFError", see="EOFError")))

InexactError::
Cannot exactly convert to a type.
(((InexactError)))((("error", "Core", "InexactError", see="InexactError")))

KeyError::
An indexing operation into an +AbstractDict+ (+Dict+) or +Set+ like object tried to access or delete a non-existent element.
(((KeyError)))

MethodError::
A method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.
(((MethodError)))

OutOfMemoryError::
An operation allocated too much memory for either the system or the garbage collector to handle properly.
(((OutOfMemoryError)))((("error", "Core", "OutOfMemoryError", see="OutOfMemoryError")))

OverflowError::
The result of an expression is too large for the specified type and will cause a wraparound.
(((OverflowError)))((("error", "Core", "OverflowError", see="OverflowError")))

StackOverflowError::
The function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.
(((StackOverflowError)))

StringIndexError::
An error occurred when trying to access a string at an index that is not valid.
(((StringIndexError)))

SystemError::
A system call failed with an error code.
(((SystemError)))

TypeError::
A type assertion failure, or calling an intrinsic function with an incorrect argument type.
(((TypeError)))

UndefVarError::
A symbol in the current scope is not defined.
(((UndefVarError)))

==== I added so many print statements I get inundated with output

One of the problems with using print statements for debugging is that you can end up buried in output. There are two ways to proceed: simplify the output or simplify the program.

To simplify the output, you can remove or comment out print statements that aren’t helping, or combine them, or format the output so it is easier to understand.

To simplify the program, there are several things you can do. First, scale down the problem the program is working on. For example, if you are searching a list, search a small list. If the program takes input from the user, give it the simplest input that causes the problem.

Second, clean up the program. Remove dead code and reorganize the program to make it as easy to read as possible. For example, if you suspect that the problem is in a deeply nested part of the program, try rewriting that part with simpler structure. If you suspect a large function, try splitting it into smaller functions and testing them separately.
(((dead code)))

Often the process of finding the minimal test case leads you to the bug. If you find that a program works in one situation but not in another, that gives you a clue about what is going on.

Similarly, rewriting a piece of code can help you find subtle bugs. If you make a change that you think shouldn’t affect the program, and it does, that can tip you off.


=== Semantic Errors

In some ways, semantic errors are the hardest to debug, because the interpreter provides no information about what is wrong. Only you know what the program is supposed to do.

The first step is to make a connection between the program text and the behavior you are seeing. You need a hypothesis about what the program is actually doing. One of the things that makes that hard is that computers run so fast.

You will often wish that you could slow the program down to human speed. Inserting a few well-placed print statements is often quicker than setting up a debugger, inserting and removing breakpoints, and “stepping” the program to where the error is occurring.

==== My program doesn’t work

You should ask yourself these questions:

* Is there something the program was supposed to do but which doesn’t seem to be happening? Find the section of the code that performs that function and make sure it is executing when you think it should.

* Is something happening that shouldn’t? Find code in your program that performs that function and see if it is executing when it shouldn’t.

* Is a section of code producing an effect that is not what you expected? Make sure that you understand the code in question, especially if it involves functions or methods in other Julia modules. Read the documentation for the functions you call. Try them out by writing simple test cases and checking the results.

In order to program, you need a mental model of how programs work. If you write a program that doesn’t do what you expect, often the problem is not in the program; it’s in your mental model.
(((mental model)))

The best way to correct your mental model is to break the program into its components (usually the functions and methods) and test each component independently. Once you find the discrepancy between your model and reality, you can solve the problem.

Of course, you should be building and testing components as you develop the program. If you encounter a problem, there should be only a small amount of new code that is not known to be correct.

==== I’ve got a big hairy expression and it doesn’t do what I expect

Writing complex expressions is fine as long as they are readable, but they can be hard to debug. It is often a good idea to break a complex expression into a series of assignments to temporary variables.

For example:

[source,julia]
----
addcard(game.hands[i], popcard(game.hands[findneighbor(game, i)]))
----

This can be rewritten as:

[source,julia]
----
neighbor = findneighbor(game, i)
pickedcard = popcard(game.hands[neighbor])
addcard(game.hands[i], pickedcard)
----

The explicit version is easier to read because the variable names provide additional documentation, and it is easier to debug because you can check the types of the intermediate variables and display their values.

Another problem that can occur with big expressions is that the order of evaluation may not be what you expect. For example, if you are translating the expression latexmath:[\(\frac{x}{2\pi}\)] into Julia, you might write:

[source,julia]
----
y = x / 2 * π
----

That is not correct because multiplication and division have the same precedence and are evaluated from left to right. So this expression computes latexmath:[\(\frac{x\pi}{2}\)].

A good way to debug expressions is to add parentheses to make the order of evaluation explicit:

[source,julia]
----
y = x / (2 * π)
----

Whenever you are not sure of the order of evaluation, use parentheses. Not only will the program be correct (in the sense of doing what you intended), it will also be more readable for other people who haven’t memorized the order of operations.

==== I’ve got a function that doesn’t return what I expect

If you have a return statement with a complex expression, you don’t have a chance to print the result before returning. Again, you can use a temporary variable. For example, instead of:
(((temporary variable)))

[source,julia]
----
return removematches(game.hands[i])
----

you could write:

[source,julia]
----
count = removematches(game.hands[i])
return count
----

Now you have the opportunity to display the value of +count+ before returning.

==== I’m really, really stuck and I need help

First, try getting away from the computer for a few minutes. Working with a computer can cause these symptoms:

* Frustration and rage.

* Superstitious beliefs (“the computer hates me”) and magical thinking (“the program only works when I wear my hat backward”).

* Random walk programming (the attempt to program by writing every possible program and choosing the one that does the right thing).

If you find yourself suffering from any of these symptoms, get up and go for a walk. When you are calm, think about the program. What is it doing? What are some possible causes of that behavior? When was the last time you had a working program, and what did you do next?

Sometimes it just takes time to find a bug. I often find bugs when I am away from the computer and let my mind wander. Some of the best places to find bugs are trains, showers, and in bed, just before you fall asleep.

==== No, I really need help

It happens. Even the best programmers occasionally get stuck. Sometimes you work on a program so long that you can’t see the error. You need a fresh pair of eyes.

Before you bring someone else in, make sure you are prepared. Your program should be as simple as possible, and you should be working on the smallest input that causes the error. You should have print statements in the appropriate places (and the output they produce should be comprehensible). You should understand the problem well enough to describe it concisely.

When you bring someone in to help, be sure to give them the information they need:

* If there is an error message, what is it and what part of the program does it indicate?

* What was the last thing you did before this error occurred? What were the last lines of code that you wrote, or what is the new test case that fails?

* What have you tried so far, and what have you learned?

When you find the bug, take a second to think about what you could have done to find it faster. Next time you see something similar, you will be able to find the bug more quickly.

Remember, the goal is not just to make the program work. The goal is to learn how to make the program work.
