[[chap18]]
== Subtipagem

No capítulo anterior, introduzimos o mecanismo de despacho múltiplo e o polimorfismo. A ausência da especificação do tipo dos argumentos resulta em um método que pode ser chamado com argumentos de qualquer tipo. A especificação de um subconjunto dos tipos permitidos na assinatura de um método é um próximo passo lógico.

Neste capítulo, eu demonstro a subtipagem utilizando tipos que representam as cartas de jogo, os baralhos de cartas e as mãos de pôquer.

Se você não joga pôquer, pode ler sobre isso em https://pt.wikipedia.org/wiki/P%C3%B4quer, mas não precisa pois vou lhe dizer o que se tem que saber para os exercícios.


=== Cartas

Há 52 cartas em um baralho, cada uma pertencendo a um dos quatro naipes e uma das treze cartas de valores diferentes. Os naipes são Espadas (+♠+), Copas (+♥+), Ouro (+♦+) e Paus (+♣+). Os valores são Ás (A), 2, 3, 4, 5, 6, 7, 8, 9, 10, Valete (J), Rainha (Q) e Rei (K). Dependendo do jogo que você está jogando, um ás pode ser maior que o rei ou menor que 2.

Se queremos definir um novo objeto para representar uma carta de baralho, é óbvio quais devem ser os atributos: o valor e o naipe. Mas não é tão óbvio que tipo de atributo deve ser. Uma possibilidade é usar strings contendo palavras como +"Espadas"+ para os naipes e +"Rainha"+ para os valores. Um problema com essa implementação é que não seria fácil comparar as cartas para ver quais possuíam maior valor ou naipe.

Uma alternativa é usar números inteiros para _codificar_ os valores e os naipes. Nesse contexto, "codificar" significa que vamos definir um mapeamento entre números e naipes, ou entre números e valores do baralho. Esse tipo de codificação não é para ser secreto (isso seria "criptografia").
(((codificação)))

Por exemplo, esta tabela mostra a correspondência dos naipes para os números inteiros:

* +♠+  latexmath:[\(\mapsto\)]  4

* +♥+  latexmath:[\(\mapsto\)]  3

* +♦+  latexmath:[\(\mapsto\)]  2

* +♣+  latexmath:[\(\mapsto\)]  1

Este código facilita a comparação das cartas; já que os naipes mais valorizados estão relacionados com números mais altos e podemos comparar os naipes comparando os seus números.

Estou usando o símbolo latexmath:[\(\mapsto\)] para deixar claro que essas correspondências não fazem parte do programa Julia. Eles fazem parte da formulação do programa, e não aparecem explicitamente no código.

A definição para struct +Carta+ é parecida com esta:
(((Carta)))((("tipo", "definido pelo programador", "Carta", see="Carta")))

[source,@julia-setup chap18]
----
struct Carta
    naipe :: Int64
    valor :: Int64
    function Carta(naipe::Int64, valor::Int64)
        @assert(1 ≤ naipe ≤ 4, "naipe não está entre 1 e 4")
        @assert(1 ≤ valor ≤ 13, "valor não está entre 1 e 13")
        new(naipe, valor)
    end
end
----

Para criar uma +Carta+, você chama +Carta+ com o naipe e o valor desejado:

[source,@julia-repl-test chap18]
----
julia> rainha_de_ouro = Carta(2, 12)
Carta(2, 12)
----


=== Variáveis Globais

Para imprimir objetos +Carta+ de uma forma que as pessoas possam ler facilmente, precisamos de um mapeamento dos códigos inteiros até os valores e naipes correspondentes. Uma maneira natural de fazer isso é com arrays de strings:

[source,@julia-setup chap18]
----
const nomes_naipes = ["♣", "♦", "♥", "♠"]
const nomes_valores = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"]
----

As variáveis +nomes_naipes+ e +nomes_valores+ são variáveis globais. A declaração +const+ significa que a variável só pode ser atribuída uma vez. Isso resolve o problema de desempenho das variáveis globais.
(((declaração global)))(((const)))((("palavra-chave", "const", see="const")))

Agora podemos implementar um método +show+ apropriado:
(((show)))

[source,@julia-setup chap18]
----
function Base.show(io::IO, carta::Carta)
    print(io, nomes_valores[carta.valor], nomes_naipes[carta.naipe])
end
----

A expressão +nomes_valores[carta.valor]+ significa “use o campo +valor+ do objeto +carta+ como um índice na matriz +nomes_valores+, e selecione a string apropriada.”

Com os métodos que temos até agora, podemos criar e imprimir as cartas:

[source,@julia-repl-test chap18]
----
julia> Carta(3, 11)
J♥
----


=== Comparando Cartas

Para os tipos embutidos, existem operadores relacionais (+<+, +>+, +==+ etc.) que comparam os valores e determinam quando um é maior que, menor que ou igual ao outro. Para os tipos definidos pelo programador, podemos sobrepor o comportamento dos operadores embutidos ao estabelecer um método chamado +<+.

A ordenação correta das cartas não é óbvia. Por exemplo, qual é melhor, o 3 de Paus ou o 2 de Ouros? Um tem um valor mais alto, mas o outro tem um naipe mais alto. A fim de comparar as cartas, você tem que decidir se o valor ou naipe é mais importante.

A resposta pode depender de qual jogo você está jogando, mas para simplificar, faremos a escolha arbitrária de que naipe é mais importante  para que todas cartas de Espadas são superiores as cartas de Diamantes e assim por diante.

Decidido isso, podemos escrever +<+

[source,@julia-setup chap18]
----
import Base.<

function <(c1::Carta, c2::Carta)
    (c1.naipe, c1.valor) < (c2.naipe, c2.valor)
end
----

===== Exercício 18-1

Escreva um método +<+ para os objetos +MeuTime+ . Você pode usar a comparação de tupla, mas você também pode considerar a comparação de inteiros.


=== Teste da Unidade


_Unit testing_ allows you to verify the correctness of your code by comparing the results of your code to what you expect. This can be useful to be sure that your code still is correct after modifications, and it is also a way to predefine the correct behaviour of your code during development.
(((unit testing)))

Simple unit testing can be performed with the +@test+ macros:
(((Test)))((("module", "Test", see="Test")))(((@test)))((("macro", "Test", "@test", see="@test")))

[source,@julia-repl-test chap18]
----
julia> using Test

julia> @test Card(1, 4) < Card(2, 4)
Test Passed
julia> @test Card(1, 3) < Card(1, 4)
Test Passed
----

+@test+ returns a +"Test Passed"+ if the expression following it is +true+, a +"Test Failed"+ if it is +false+, and an +"Error Result"+ if it could not be evaluated.


=== Decks

Now that we have Cards, the next step is to define Decks. Since a deck is made up of cards, it is natural for each Deck to contain an array of cards as an attribute.

The following is a struct definition for +Deck+. The constructor creates the fields cards and generates the standard set of fifty-two cards:
(((Deck)))((("tipo", "definido pelo programador", "Deck", see="Deck")))

[source,@julia-setup chap18]
----
struct Deck
    cards :: Array{Card, 1}
end

function Deck()
    deck = Deck(Card[])
    for suit in 1:4
        for rank in 1:13
            push!(deck.cards, Card(suit, rank))
        end
    end
    deck
end
----

The easiest way to populate the deck is with a nested loop. The outer loop enumerates the suits from 1 to 4. The inner loop enumerates the ranks from 1 to 13. Each iteration creates a new +Card+ with the current suit and rank, and pushes it to +deck.cards+.

Here is a +show+ method for +Deck+:

[source,@julia-setup chap18]
----
function Base.show(io::IO, deck::Deck)
    for card in deck.cards
        print(io, card, " ")
    end
    println()
end
----

Here’s what the result looks like:

[source,@julia-repl-test chap18]
----
julia> Deck()
A♣ 2♣ 3♣ 4♣ 5♣ 6♣ 7♣ 8♣ 9♣ 10♣ J♣ Q♣ K♣ A♦ 2♦ 3♦ 4♦ 5♦ 6♦ 7♦ 8♦ 9♦ 10♦ J♦ Q♦ K♦ A♥ 2♥ 3♥ 4♥ 5♥ 6♥ 7♥ 8♥ 9♥ 10♥ J♥ Q♥ K♥ A♠ 2♠ 3♠ 4♠ 5♠ 6♠ 7♠ 8♠ 9♠ 10♠ J♠ Q♠ K♠
----


=== Add, Remove, Shuffle and Sort

To deal cards, we would like a function that removes a card from the deck and returns it. The function +pop!+ provides a convenient way to do that:
(((pop!)))

[source,@julia-setup chap18]
----
function Base.pop!(deck::Deck)
    pop!(deck.cards)
end
----

Since +pop!+ removes the last card in the array, we are dealing from the bottom of the deck.

To add a card, we can use the function +push!+:
(((push!)))

[source,@julia-setup chap18]
----
function Base.push!(deck::Deck, card::Card)
    push!(deck.cards, card)
    deck
end
----

A method like this that uses another method without doing much work is sometimes called a _veneer_. The metaphor comes from woodworking, where a veneer is a thin layer of good quality wood glued to the surface of a cheaper piece of wood to improve the appearance.
(((veneer)))

In this case +push!+ is a “thin” method that expresses an array operation in terms appropriate for decks. It improves the appearance, or interface, of the implementation.

As another example, we can write a method named +shuffle!+ using the function +Random.shuffle!+:
(((Random)))((("module", "Random", see="Random")))(((shuffle!)))((("function", "Random", "shuffle!", see="shuffle!")))

[source,@julia-setup chap18]
----
using Random

function Random.shuffle!(deck::Deck)
    shuffle!(deck.cards)
    deck
end
----

===== Exercício 18-2

Write a function named +sort!+ that uses the function +sort!+ to sort the cards in a Deck. +sort!+ uses the +isless+ method we defined to determine the order.
(((sort!)))


=== Abstract Types and Subtyping

We want a type to represent a “hand”, that is, the cards held by one player. A hand is similar to a deck: both are made up of a collection of cards, and both require operations like adding and removing cards.

A hand is also different from a deck; there are operations we want for hands that don’t make sense for a deck. For example, in poker we might compare two hands to see which one wins. In bridge, we might compute a score for a hand in order to make a bid.

So we need a way to group related _concrete types_. In Julia this is done by defining an _abstract type_ that serves as a parent for both +Deck+ and +Hand+. This is called _subtyping_
(((concrete type)))(((abstract type)))(((subtyping)))

Let's call this abstract type +CardSet+:
(((CardSet)))((("tipo", "definido pelo programador", "CardSet", see="CardSet")))

[source,@julia-eval chap18a]
----
struct Card
    suit :: Int64
    rank :: Int64
    function Card(suit::Int64, rank::Int64)
        @assert(1 ≤ suit ≤ 4, "suit is between 1 and 4")
        @assert(1 ≤ rank ≤ 13, "rank is between 1 and 13")
        new(suit, rank)
    end
end;
----

[source,@julia-setup chap18a]
----
abstract type CardSet end
----

A new abstract type is created with the +abstract type+ keyword. An optional “parent” type can be specified by putting after the name +<:+ followed by the name of an already-existing abstract type.
(((abstract type)))((("keyword", "abstract type", see="abstract type")))(((type)))

When no _supertype_ is given, the default supertype is +Any+ – a predefined abstract type that all objects are instances of and all types are _subtypes_ of.
(((supertype)))(((subtype)))

We can now express that +Deck+ is a descendant of +CardSet+:

[source,@julia-setup chap18a]
----
struct Deck <: CardSet
    cards :: Array{Card, 1}
end

function Deck()
    deck = Deck(Card[])
    for suit in 1:4
        for rank in 1:13
            push!(deck.cards, Card(suit, rank))
        end
    end
    deck
end
----

[source,@julia-eval chap18a]
----
using Random

const suit_names = ["♣", "♦", "♥", "♠"];
const rank_names = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];

function Base.show(io::IO, card::Card)
    print(io, rank_names[card.rank], suit_names[card.suit])
end

function Random.shuffle!(deck::Deck)
    shuffle!(deck.cards)
    deck
end
----

The operator +isa+ checks whether an object is of a given type:
(((isa)))((("operator", "Base", "isa", see="isa")))

[source,@julia-repl-test chap18a]
----
julia> deck = Deck();

julia> deck isa CardSet
true
----

A hand is also a kind of +CardSet+:
(((Hand)))((("tipo", "definido pelo programador", "Hand", see="Hand")))

[source,@julia-setup chap18a]
----
struct Hand <: CardSet
    cards :: Array{Card, 1}
    label :: String
end

function Hand(label::String="")
    Hand(Card[], label)
end
----

Instead of populating the hand with 52 new cards, the constructor for +Hand+ initializes +cards+ with an empty array. An optional argument can be passed to the constructor giving a label to the +Hand+.

[source,@julia-repl-test chap18a]
----
julia> hand = Hand("new hand")
Hand(Card[], "new hand")
----


=== Abstract Types and Functions

We can now express the common operations between +Deck+ and +Hand+ as functions having as argument +CardSet+:
(((show)))(((pop!)))(((push!)))

[source,@julia-setup chap18a]
----
function Base.show(io::IO, cs::CardSet)
    for card in cs.cards
        print(io, card, " ")
    end
end

function Base.pop!(cs::CardSet)
    pop!(cs.cards)
end

function Base.push!(cs::CardSet, card::Card)
    push!(cs.cards, card)
    nothing
end
----

We can use +pop!+ and +push!+ to deal a card:

[source,@julia-repl chap18a]
----
deck = Deck()
shuffle!(deck)
card = pop!(deck)
push!(hand, card)
----

A natural next step is to encapsulate this code in a function called +move!+:
(((move!)))((("function", "definido pelo programador", "move!", see="move!")))

[source,@julia-setup chap18a]
----
function move!(cs1::CardSet, cs2::CardSet, n::Int)
    @assert 1 ≤ n ≤ length(cs1.cards)
    for i in 1:n
        card = pop!(cs1)
        push!(cs2, card)
    end
    nothing
end
----

+move!+ takes three arguments, two +Cardset+ objects and the number of cards to deal. It modifies both +Cardset+ objects, and returns +nothing+.

In some games, cards are moved from one hand to another, or from a hand back to the deck. You can use +move!+ for any of these operations: +cs1+ and +cs2+ can be either a +Deck+ or a +Hand+.


=== Type Diagrams

So far we have seen stack diagrams, which show the state of a program, and object diagrams, which show the attributes of an object and their values. These diagrams represent a snapshot in the execution of a program, so they change as the program runs.

They are also highly detailed; for some purposes, too detailed. A _type diagram_ is a more abstract representation of the structure of a program. Instead of showing individual objects, it shows types and the relationships between them.
(((type diagram)))((("diagram", "tipo", see="type diagram")))

There are several kinds of relationship between types:

* Objects of a concrete type might contain references to objects of another type. For example, each Rectangle contains a reference to a Point, and each Deck contains references to an array of Cards. This kind of relationship is called _HAS-A_, as in, “a Rectangle has a Point”.
(((HAS-A)))

* A concrete type can have an abstract type as a supertype. This relationship is called _IS-A_, as in, “a Hand is a kind of a CardSet.”
(((IS-A)))

* One type might depend on another in the sense that objects of one type take objects of the second type as parameters, or use objects of the second type as part of a computation. This kind of relationship is called a _dependency_.
(((dependency)))

[[fig18-1]]
.Type diagram
image::images/fig181.svg[]

The arrow with a hollow triangle head represents an IS-A relationship; in this case it indicates that Hand has as supertype CardSet.

The standard arrow head represents a HAS-A relationship; in this case a Deck has references to Card objects.

The star (+pass:[*]+) near the arrow head is a _multiplicity_; it indicates how many Cards a Deck has. A multiplicity can be a simple number, like +52+, a range, +like 5:7+ or a star, which indicates that a Deck can have any number of Cards.
(((multiplicity)))

There are no dependencies in this diagram. They would normally be shown with a dashed arrow. Or if there are a lot of dependencies, they are sometimes omitted.

A more detailed diagram might show that a Deck actually contains an array of Cards, but built-in types like array and dictionnaries are usually not included in type diagrams.

[[interactive]]
=== Debugging

Subtyping can make debugging difficult because when you call a function with an object as argument, it might be hard to figure out which method will be invoked.

Suppose you are writing a function that works with +Hand+ objects. You would like it to work with all kinds of +Hand+s, like +PokerHand+s, +BridgeHand+s, etc. If you invoke a method like +sort!+, you might get the one defined for an abstract type +Hand+, but if a method +sort!+ with as argument any of the subtypes exists, you’ll get that version instead. This behavior is usually a good thing, but it can be confusing.

[source,@julia-setup chap18a]
----
function Base.sort!(hand::Hand)
    sort!(hand.cards)
end
----

Any time you are unsure about the flow of execution through your program, the simplest solution is to add print statements at the beginning of the relevant methods. If +shuffle!+ prints a message that says something like +Running shuffle! Deck+, then as the program runs it traces the flow of execution.

As better alternative, you can also use the +@which+ macro:
(((InteractiveUtils)))((("module", "InteractiveUtils", see="InteractiveUtils")))(((@which)))((("macro", "InteractiveUtils", "@which", see="@which")))

[source,jlcon]
----
julia> @which sort!(hand)
sort!(hand::Hand) in Main at REPL[5]:1
----

So the +sort!+ method for +hand+ is the one having as argument an object of type +Hand+.

Here’s a design suggestion: when you override a method, the interface of the new method should be the same as the old. It should take the same parameters, return the same type, and obey the same preconditions and postconditions. If you follow this rule, you will find that any function designed to work with an instance of a supertype, like a +CardSet+, will also work with instances of its subtypes +Deck+ and +Hand+.

If you violate this rule, which is called the “Liskov substitution principle”, your code will collapse like (sorry) a house of cards.
(((Liskov substitution principle)))

The function +supertype+ can be used to find the direct supertype of a type.
(((supertype)))((("function", "Base", "supertype", see="supertype")))

[source,@julia-repl-test chap18a]
----
julia> supertype(Deck)
CardSet
----


=== Data Encapsulation

The previous chapters demonstrate a development plan we might call “type-oriented design”. We identified objects we needed—like +Point+, +Rectangle+ and +MyTime+—and defined structs to represent them. In each case there is an obvious correspondence between the object and some entity in the real world (or at least a mathematical world).
(((type-oriented design)))

But sometimes it is less obvious what objects you need and how they should interact. In that case you need a different development plan. In the same way that we discovered function interfaces by encapsulation and generalization, we can discover type interfaces by _data encapsulation_.
(((data encapsulation)))

Markov analysis, from <<markov_analysis>>, provides a good example. If you download my code from https://github.com/JuliaIntro/JuliaIntroBR.jl/blob/master/src/solutions/chap13.jl, you’ll see that it uses two global variables—+suffixes+ and +prefix+—that are read and written from several functions.

[source,@julia-setup]
----
suffixes = Dict()
prefix = []
----

Because these variables are global, we can only run one analysis at a time. If we read two texts, their prefixes and suffixes would be added to the same data structures (which makes for some interesting generated text).

To run multiple analyses, and keep them separate, we can encapsulate the state of each analysis in an object. Here’s what that looks like:
(((Markov)))((("tipo", "definido pelo programador", "Markov", see="Markov")))

[source,@julia-setup chap18b]
----
struct Markov
    order :: Int64
    suffixes :: Dict{Tuple{String,Vararg{String}}, Array{String, 1}}
    prefix :: Array{String, 1}
end

function Markov(order::Int64=2)
    new(order, Dict{Tuple{String,Vararg{String}}, Array{String, 1}}(), Array{String, 1}())
end
----

Next, we transform the functions into methods. For example, here’s +processword+:
(((processword)))((("function", "definido pelo programador", "processword", see="processword")))

[source,@julia-setup chap18b]
----
function processword(markov::Markov, word::String)
    if length(markov.prefix) < markov.order
        push!(markov.prefix, word)
        return
    end
    get!(markov.suffixes, (markov.prefix...,), Array{String, 1}())
    push!(markov.suffixes[(markov.prefix...,)], word)
    popfirst!(markov.prefix)
    push!(markov.prefix, word)
end
----

Transforming a program like this—changing the design without changing the behavior—is another example of refactoring (see <<refactoring>>).
(((refactoring)))(((program development plan)))

This example suggests a development plan for designing types:

* Start by writing functions that read and write global variables (when necessary).

* Once you get the program working, look for associations between global variables and the functions that use them.

* Encapsulate related variables as fields of a struct.

* Transform the associated functions into methods with as argument objects of the new type.

===== Exercício 18-3

Download my Markov code from https://github.com/JuliaIntro/JuliaIntroBR.jl/blob/master/src/solutions/chap13.jl, and follow the steps described above to encapsulate the global variables as attributes of a new struct called +Markov+.


=== Glossary

encode::
To represent one set of values using another set of values by constructing a mapping between them.
(((encode)))

unit testing::
Standardized way to test the correctness of code.
(((unit testing)))

veneer::
A method or function that provides a different interface to another function without doing much computation.
(((veneer)))

subtyping::
The ability to define a hierarchy of related types.
(((subtyping)))

abstract type::
A type that can act as a parent for another type.
(((abstract type)))

concrete type::
A type that can be constructed.
(((concrete type)))

subtype::
A type that has as parent an abstract type.
(((subtype)))

supertype::
An abstract type that is the parent of another type.
(((supertype)))

IS-A relationship::
A relationship between a subtype and its supertype.
(((IS-A relationship)))

HAS-A relationship::
A relationship between two types where instances of one type contain references to instances of the other.
(((HAS-A relationship)))

dependency::
A relationship between two types where instances of one type use instances of the other type, but do not store them as fields.
(((dependency)))

type diagram::
A diagram that shows the types in a program and the relationships between them.
(((type diagram)))

multiplicity::
A notation in a type diagram that shows, for a HAS-A relationship, how many references there are to instances of another class.
(((multiplicity)))

data encapsulation::
A program development plan that involves a prototype using global variables and a final version that makes the global variables into instance fields.
(((data encapsulation)))


=== Exercícios

[[ex18-1]]
===== Exercício 18-4

For the following program, draw a type diagram that shows these types and the relationships among them.

[source,julia]
----
abstract type PingPongParent end

struct Ping <: PingPongParent
    pong :: PingPongParent
end

struct Pong <: PingPongParent
    pings :: Array{Ping, 1}
    function Pong(pings=Array{Ping, 1}())
        new(pings)
    end
end

function addping(pong::Pong, ping::Ping)
    push!(pong.pings, ping)
    nothing
end

pong = Pong()
ping = Ping(pong)
addping(pong, ping)
----

[[ex18-2]]
===== Exercício 18-5

Write a method called +deal!+ that takes three parameters, a +Deck+, the number of hands and the number of cards per hand. It should create the appropriate number of +Hand+ objects, deal the appropriate number of cards per hand, and return an array of +Hand+s.
(((deal!)))((("function", "definido pelo programador", "deal!", see="deal!")))

[[ex18-3]]
===== Exercício 18-6

The following are the possible hands in poker, in increasing order of value and decreasing order of probability:

pair::
two cards with the same rank

two pair::
two pairs of cards with the same rank

three of a kind::
three cards with the same rank

straight::
five cards with ranks in sequence (aces can be high or low, so Ace-2-3-4-5 is a straight and so is 10-Jack-Queen-King-Ace, but Queen-King-Ace-2-3 is not.)

flush::
five cards with the same suit

full house::
three cards with one rank, two cards with another

four of a kind::
four cards with the same rank

straight flush::
five cards in sequence (as defined above) and with the same suit

The goal of this exercise is to estimate the probability of drawing these various hands.

. Add methods named +haspair+, +hastwopair+, etc. that return +true+ or +false+ according to whether or not the hand meets the relevant criteria. Your code should work correctly for “hands” that contain any number of cards (although 5 and 7 are the most common sizes).
(((haspair)))((("function", "definido pelo programador", "haspair", see="haspair")))(((hastwopair)))((("function", "definido pelo programador", "hastwopair", see="hastwopair")))

. Write a method named +classify+ that figures out the highest-value classification for a hand and sets the +label+ field accordingly. For example, a 7-card hand might contain a flush and a pair; it should be labeled “flush”.
(((classify)))((("function", "definido pelo programador", "classify", see="classify")))

. When you are convinced that your classification methods are working, the next step is to estimate the probabilities of the various hands. Write a function that shuffles a deck of cards, divides it into hands, classifies the hands, and counts the number of times various classifications appear.

. Print a table of the classifications and their probabilities. Run your program with larger and larger numbers of hands until the output values converge to a reasonable degree of accuracy. Compare your results to the values at https://en.wikipedia.org/wiki/Hand_rankings.
