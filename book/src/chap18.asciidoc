[[chap18]]
== Subtipagem

No capítulo anterior, introduzimos o mecanismo de despacho múltiplo e o polimorfismo. A ausência da especificação do tipo dos argumentos resulta em um método que pode ser chamado com argumentos de qualquer tipo. A especificação de um subconjunto dos tipos permitidos na assinatura de um método é um próximo passo lógico.

Neste capítulo, eu demonstro a subtipagem utilizando tipos que representam as cartas de jogo, os baralhos de cartas e as mãos de pôquer.

Se você não joga pôquer, pode ler sobre isso em https://pt.wikipedia.org/wiki/P%C3%B4quer, mas não precisa pois vou lhe dizer o que se tem que saber para os exercícios.


=== Cartas

Há 52 cartas em um baralho, cada uma pertencendo a um dos quatro naipes e uma das treze cartas de valores diferentes. Os naipes são Espadas (+♠+), Copas (+♥+), Ouro (+♦+) e Paus (+♣+). Os valores são Ás (A), 2, 3, 4, 5, 6, 7, 8, 9, 10, Valete (J), Rainha (Q) e Rei (K). Dependendo do jogo que você está jogando, um ás pode ser maior que o rei ou menor que 2.

Se queremos definir um novo objeto para representar uma carta de baralho, é óbvio quais devem ser os atributos: o valor e o naipe. Mas não é tão óbvio que tipo de atributo deve ser. Uma possibilidade é usar strings contendo palavras como +"Espadas"+ para os naipes e +"Rainha"+ para os valores. Um problema com essa implementação é que não seria fácil comparar as cartas para ver quais possuíam maior valor ou naipe.

Uma alternativa é usar números inteiros para _codificar_ os valores e os naipes. Nesse contexto, "codificar" significa que vamos definir um mapeamento entre números e naipes, ou entre números e valores do baralho. Esse tipo de codificação não é para ser secreto (isso seria "criptografia").
(((codificação)))

Por exemplo, esta tabela mostra a correspondência dos naipes para os números inteiros:

* +♠+  latexmath:[\(\mapsto\)]  4

* +♥+  latexmath:[\(\mapsto\)]  3

* +♦+  latexmath:[\(\mapsto\)]  2

* +♣+  latexmath:[\(\mapsto\)]  1

Este código facilita a comparação das cartas; já que os naipes mais valorizados estão relacionados com números mais altos e podemos comparar os naipes comparando os seus números.

Estou usando o símbolo latexmath:[\(\mapsto\)] para deixar claro que essas correspondências não fazem parte do programa Julia. Eles fazem parte da formulação do programa, e não aparecem explicitamente no código.

A definição para struct +Carta+ é parecida com esta:
(((Carta)))((("tipo", "definido pelo programador", "Carta", see="Carta")))

[source,@julia-setup chap18]
----
struct Carta
    naipe :: Int64
    valor :: Int64
    function Carta(naipe::Int64, valor::Int64)
        @assert(1 ≤ naipe ≤ 4, "naipe não está entre 1 e 4")
        @assert(1 ≤ valor ≤ 13, "valor não está entre 1 e 13")
        new(naipe, valor)
    end
end
----

Para criar uma +Carta+, você chama +Carta+ com o naipe e o valor desejado:

[source,@julia-repl-test chap18]
----
julia> rainha_de_ouro = Carta(2, 12)
Carta(2, 12)
----


=== Variáveis Globais

Para imprimir objetos +Carta+ de uma forma que as pessoas possam ler facilmente, precisamos de um mapeamento dos códigos inteiros até os valores e naipes correspondentes. Uma maneira natural de fazer isso é com arrays de strings:

[source,@julia-setup chap18]
----
const nomes_naipes = ["♣", "♦", "♥", "♠"]
const nomes_valores = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"]
----

As variáveis +nomes_naipes+ e +nomes_valores+ são variáveis globais. A declaração +const+ significa que a variável só pode ser atribuída uma vez. Isso resolve o problema de desempenho das variáveis globais.
(((declaração global)))(((const)))((("palavra-chave", "const", see="const")))

Agora podemos implementar um método +show+ apropriado:
(((show)))

[source,@julia-setup chap18]
----
function Base.show(io::IO, carta::Carta)
    print(io, nomes_valores[carta.valor], nomes_naipes[carta.naipe])
end
----

A expressão +nomes_valores[carta.valor]+ significa “use o campo +valor+ do objeto +carta+ como um índice na matriz +nomes_valores+, e selecione a string apropriada.”

Com os métodos que temos até agora, podemos criar e imprimir as cartas:

[source,@julia-repl-test chap18]
----
julia> Carta(3, 11)
J♥
----


=== Comparando Cartas

Para os tipos embutidos, existem operadores relacionais (+<+, +>+, +==+ etc.) que comparam os valores e determinam quando um é maior que, menor que ou igual ao outro. Para os tipos definidos pelo programador, podemos sobrepor o comportamento dos operadores embutidos ao estabelecer um método chamado +<+.

A ordenação correta das cartas não é óbvia. Por exemplo, qual é melhor, o 3 de Paus ou o 2 de Ouros? Um tem um valor mais alto, mas o outro tem um naipe mais alto. A fim de comparar as cartas, você tem que decidir se o valor ou naipe é mais importante.

A resposta pode depender de qual jogo você está jogando, mas para simplificar, faremos a escolha arbitrária de que naipe é mais importante  para que todas cartas de Espadas são superiores as cartas de Diamantes e assim por diante.

Decidido isso, podemos escrever +<+

[source,@julia-setup chap18]
----
import Base.<

function <(c1::Carta, c2::Carta)
    (c1.naipe, c1.valor) < (c2.naipe, c2.valor)
end
----

===== Exercício 18-1

Escreva um método +<+ para os objetos +MeuTime+. Você pode usar a comparação de tupla, mas você também pode considerar a comparação de inteiros.


=== Teste da Unidade


_Unit testing_ permite verificar a correção do seu código, comparando os resultados do seu código com o que você espera. Isso pode ser útil para garantir que seu código ainda esteja correto após as modificações, e também é uma maneira de predefinir o comportamento correto do seu código durante o desenvolvimento.
(((teste de unidade)))

Os testes unitários simples podem ser realizados com as macros +@test+:
(((Test)))((("módulo", "Test", see="Test")))(((@test)))((("macro", "Test", "@test", see="@test")))

[source,@julia-repl-test chap18]
----
julia> using Test

julia> @test Carta(1, 4) < Carta(2, 4)
Test Passed
julia> @test Carta(1, 3) < Carta(1, 4)
Test Passed
----

+@test+ retorna +"Test Passed"+ se a expressão seguinte for +true+, +"Test Failed"+ se for +false+, e +"Error Result"+ se não puder ser avaliado.


=== Baralhos

Agora que temos Cartas, o próximo passo é a definição dos baralhos. Como um baralho é composto de cartas, é natural que cada baralho contenha um array de cartas como um atributo.

A seguir, define-se uma struct para +Baralho+. O construtor cria os campos das cartas e gera o conjunto padrão das cinquenta e dois cartas:
(((Deck)))((("tipo", "definido pelo programador", "Deck", see="Deck")))

[source,@julia-setup chap18]
----
struct Baralho
    cartas :: Array{Carta, 1}
end

function Baralho()
    baralho = Baralho(Carta[])
    for naipe in 1:4
        for valor in 1:13
            push!(baralho.cartas, Carta(naipe, valor))
        end
    end
    baralho
end
----

A maneira mais fácil de preencher o barulho é com um laço aninhado. O laço externo enumera os naipes de 1 a 4. O laço interno enumera os valores de 1 a 13. Cada iteração cria uma nova +Carta+ com o naipe e o valor correntes e envia-na para +baralho.cartas+.

Aqui está um método +show+ para +Baralho+:

[source,@julia-setup chap18]
----
function Base.show(io::IO, baralho::Barulho)
    for carta in barulho.cartas
        print(io, carta, " ")
    end
    println()
end
----

Veja como ficou o resultado:

[source,@julia-repl-test chap18]
----
julia> Baralho()
A♣ 2♣ 3♣ 4♣ 5♣ 6♣ 7♣ 8♣ 9♣ 10♣ J♣ Q♣ K♣ A♦ 2♦ 3♦ 4♦ 5♦ 6♦ 7♦ 8♦ 9♦ 10♦ J♦ Q♦ K♦ A♥ 2♥ 3♥ 4♥ 5♥ 6♥ 7♥ 8♥ 9♥ 10♥ J♥ Q♥ K♥ A♠ 2♠ 3♠ 4♠ 5♠ 6♠ 7♠ 8♠ 9♠ 10♠ J♠ Q♠ K♠
----


=== Adicionar, Remover, Baralhar e Ordenar

Para distribuir as cartas, gostaríamos de uma função que remove uma carta do baralho e devolve-a. A função +pop!+ fornece uma maneira apropriada de fazer isso:
(((pop!)))

[source,@julia-setup chap18]
----
function Base.pop!(baralho::Baralho)
    pop!(baralho.cartas)
end
----

Como +pop!+ remove a última carta do baralho, estamos distribuindo a partir do fundo do baralho.

Para adicionar uma carta, podemos usar a função +push!+:
(((push!)))

[source,@julia-setup chap18]
----
function Base.push!(baralho::Baralho, carta::Carta)
    push!(baralho.cartas, carta)
    baralho
end
----

Um método como esse, que usa outro método sem fazer muito trabalho, às vezes é chamado de _folheado_. A metáfora vem do trabalho com madeira, onde um folheado de madeira é uma fina camada de madeira de boa qualidade colada à superfície de um pedaço de madeira mais barato para melhorar a aparência.
(((folheado)))

Neste caso, +push!+ é um método "fino" que expressa uma operação de array relativamente apropriados para baralhos. Ele melhora a aparência, ou interface, da implementação.

Como um outro exemplo, podemos escrever um método chamado +shuffle!+ usando a função +Random.shuffle!+:
(((Random)))((("módulo", "Random", see="Random")))(((shuffle!)))((("função", "Random", "shuffle!", see="shuffle!")))

[source,@julia-setup chap18]
----
using Random

function Random.shuffle!(baralho::Baralho)
    shuffle!(baralho.cartas)
    baralho
end
----

===== Exercício 18-2

Escreva uma função chamada +sort!+ que usa a função +sort!+ para ordenar as cartas em um Baralho. A função +sort!+ usa o método +isless+ na nossa definição para a ordenação.
(((sort!)))


=== Tipos abstratos e Subtipagem

Queremos um tipo que represente uma "mão", ou seja, as cartas que estão nas mãos de um jogador. Uma mão é semelhante a um baralho: ambas são compostas de uma coleção de cartas, e ambas precisam de operações como adicionar e remover cartas.

Uma mão também é diferente de um baralho; existem operações que queremos para as mãos de cartas que não faz sentido para um baralho. Por exemplo, no pôquer, podemos comparar duas mãos para ver qual delas vence. No bridge, podemos calcular uma pontuação para uma mão para fazer um lance.

Portanto, precisamos de uma maneira de agrupar os _tipos concretos_ relacionados. No Julia, isso é feito ao definir um _tipo abstrato_ que serve como o progenitor de +Baralho+ e +Mão+. Isso é chamado _subtipagem_.
(((tipo concreto)))(((tipo abstrato)))(((subtipagem))))

Vamos chamar esse tipo abstrato de +Conjunto_Carta+:
(((Conjunto_Carta)))((("tipo", "definido pelo programador", "Conjunto_Carta", see="Conjunto_Carta")))

[source,@julia-eval chap18a]
----
struct Carta
    naipe :: Int64
    valor :: Int64
    function Carta(naipe::Int64, valor::Int64)
        @assert(1 ≤ naipe ≤ 4, "naipe está entre 1 e 4")
        @assert(1 ≤ valor ≤ 13, "valor está entre 1 e 13")
        new(naipe, valor)
    end
end;
----

[source,@julia-setup chap18a]
----
abstract type Conjunto_Carta end
----

Um novo tipo abstrato é criado com a palavra-chave +abstract type+. Um tipo "progenitor" opcional pode ser especificado colocando +<:+ após o nome seguido do nome de um tipo abstrato já existente.
(((tipo abstrato)))((("palavra-chave", "abstract type", see="abstract type")))(((tipo)))

Quando nenhum _supertipo_ é dado, o supertipe padrão é +Any+ - um tipo abstrato predefinido do qual todos os objetos são instâncias e todos os tipos são _subtipos_.
(((supertipo)))(((subtipo)))

Agora podemos expressar que +Baralho+ é um descendente de +Conjunto_Carta+:

[source,@julia-setup chap18a]
----
struct Baralho <: Conjunto_Carta
    cartas :: Array{Carta, 1}
end

function Baralho()
    baralho = Baralho(Carta[])
    for naipe in 1:4
        for valor in 1:13
            push!(baralho.cartas, Carta(naipe, valor))
        end
    end
    baralho
end
----

[source,@julia-eval chap18a]
----
using Random

const nomes_naipes = ["♣", "♦", "♥", "♠"];
const nomes_valores = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];

function Base.show(io::IO, carta::Carta)
    print(io, nomes_valores[carta.valor], nomes_naipes[carta.naipe])
end

function Random.shuffle!(baralho::Baralho)
    shuffle!(baralho.cartas)
    baralho
end
----

O operador +isa+ verifica se um objeto é de um determinado tipo:
(((isa)))((("operador", "Base", "isa", see="isa")))

[source,@julia-repl-test chap18a]
----
julia> baralho = Baralho();

julia> baralho isa Conjunto_Carta
true
----

Uma mão também é um tipo de +CardSet+:
(((Mão)))((("tipo", "definido pelo programador", "Mão", see="Mão")))

[source,@julia-setup chap18a]
----
struct Mão <: Conjunto_Carta
    carta :: Array{Carta, 1}
    identificação :: String
end

function Mão(identificação::String="")
    Mão(Carta[], identificação)
end
----

Em vez de encher a mão com 52 novas cartas, o construtor de +Mão+ inicializa +cartas+ com um array vazio. Um argumento opcional pode ser passado para o construtor, atribuindo uma identificação para +Mão+.

[source,@julia-repl-test chap18a]
----
julia> mão = Mão("nova mão")
Mão(Carta[], "nova mão")
----


=== Tipos Abstratos e Funções

Agora podemos expressar as operações comuns entre +Baralho+ e +Mão+ como funções tendo como argumento +Conjunto_Carta+:
(((show)))(((pop!)))(((push!)))

[source,@julia-setup chap18a]
----
function Base.show(io::IO, cc::Conjunto_Carta)
    for carta in cc.cartas
        print(io, carta, " ")
    end
end

function Base.pop!(cc::Conjunto_Carta)
    pop!(cc.cartas)
end

function Base.push!(cc::Conjunto_Carta, carta::Carta)
    push!(cc.cartas, carta)
    nothing
end
----

Podemos usar +pop!+ e +push!+ para dar um carta:

[source,@julia-repl chap18a]
----
baralho = Baralho()
shuffle!(baralho)
carta = pop!(baralho)
push!(mão, carta)
----

Um próximo passo natural é encapsular esse código em uma função chamada +move!+:
(((move!)))((("função", "definido pelo programador", "move!", see="move!")))

[source,@julia-setup chap18a]
----
function move!(cc1::Conjunto_Carta, cc2::Conjunto_Carta, n::Int)
    @assert 1 ≤ n ≤ length(cc1.cartas)
    for i in 1:n
        carta = pop!(cc1)
        push!(cc2, carta)
    end
    nothing
end
----

+move!+ recebe três argumentos, dois objetos +Conjunto_Carta+ e o número de cartas a serem distribuídas. Ele modifica os objetos +Conjunto_Carta+ e retorna +nothing+.

Em alguns jogos, as cartas são transferidas de uma mão para outra ou de uma mão para o baralho. Você pode usar +mover!+ para qualquer uma dessas operações, +cc1+ e +cc2+ podem ser ou um +Baralho+ ou uma +Mão+.


=== Diagramas de Tipos

Até agora temos visto diagramas de pilha, que mostram o estado de um programa, e diagramas de objeto, que mostram os atributos de um objeto e os seus valores. Estes diagramas são como um retrato na execução de um programa, portanto eles mudam conforme o programa é executado.

Eles também são muito detalhados e dependendo de alguns propósitos, demasiadamente detalhados. Um _diagrama de tipo_ é uma representação mais abstrata da estrutura de um programa. Ao invés de mostrar objetos individuais, ele mostra os tipos e as relações entre eles.
(((diagrama de tipo)))((("diagrama", "tipo", see="diagrama de tipo")))

Existem vários tipos de relacionamento entre os tipos:

* Objetos de um tipo concreto podem conter referências a objetos de outro tipo. Por exemplo, cada Retângulo contém uma referência a um Ponto, e cada Baralho contém referências a um conjunto de Cartas. Este tipo de relacionamento é chamado de _TEM-UM_, como em “um Retângulo tem um Ponto”.
(((TEM-UM)))

* Um tipo concreto pode ter um tipo abstrato como um supertipo. Esse relacionamento é chamado de _É-UM_, como em “uma Mão é uma espécie de Conjunto_Carta”.
(((É-UM)))

* Um tipo pode depender de outro no sentido de que os objetos de um tipo recebem os objetos do segundo tipo como parâmetros ou usam os objetos do segundo tipo como parte de um cálculo. Esse tipo de relacionamento é denominado _dependência_.
(((dependência)))

[[fig18-1]]
.Diagrama de Tipo
image::images/fig181.svg[]

A flecha com uma ponta de triângulo oco representa um relacionamento É-UM; neste caso, indica que a Mão tem como supertipo o Conjunto_Carta.

A ponta da seta padrão representa um relacionamento TEM-UM e neste caso, um Baralho tem referências aos objetos de Carta.

A estrela (+pass:[*]+) perto da ponta da seta é uma _multiplicidade_ que indica a quantidade de Cartas que um Baralho tem. Uma multiplicidade pode ser um número simples, como +52+, um intervalo, +como 5:7+ ou uma estrela, o que indica que um Baralho pode ter qualquer número de Cartas.
((((multiplicidade)))

Não há dependências neste diagrama. Elas usualmente seriam mostradas com uma seta tracejada. E caso haja muitas dependências, elas são às vezes omitidas.

Um diagrama mais detalhado pode mostrar que um Baralho realmente contém uma array de Cartas, mas tipos internos como array e dicionários geralmente não são inclusos nos diagramas de tipo.

[[interactive]]
=== Debugging

A subtipagem pode dificultar o debugging, porque quando você chama uma função com um objeto como argumento, pode ser difícil descobrir qual método será chamado.

Suponha que você está escrevendo uma função que funciona com os objetos +Mão+. Você gostaria que ela funcionasse com todos os tipos de +Mão+s, como +Mãos de Pôquer+, +Mãos de Bridge+, etc. Se você chamar um método como +sort!+, você pode ter chamado o que definido para um tipo abstrato +Mão+, mas se um método +sort!+ com qualquer um dos subtipos existentes como argumento, você terá essa versão em seu lugar. Este comportamento é normalmente uma coisa boa, mas pode ser confuso.

[source,@julia-setup chap18a]
----
function Base.sort!(mão::Mão)
    sort!(mão.cartas)
end
----

Sempre que você não tiver certeza sobre o fluxo de execução do seu programa, a solução mais simples é adicionar comandos de impressão no início dos métodos relevantes. Se +shuffle!+ imprime uma mensagem que diz algo como +Executando Baralho shuffle!+, à medida que o programa é executado, rastreia-se o fluxo de execução.

Como uma alternativa melhor, você também pode usar a macro +@which+:
(((InteractiveUtils)))((("módulo", "InteractiveUtils", see="InteractiveUtils")))(((@which)))((("macro", "InteractiveUtils", "@which", see="@which")))

[source,jlcon]
----
julia> @which sort!(mão)
sort!(mão::Mão) in Main at REPL[5]:1
----

So the +sort!+ method for +hand+ is the one having as argument an object of type +Hand+.

Portanto, o método + sort! + Para + hand + é aquele que tem como argumento um objeto do tipo + Hand +.

Então o método +sort!+ para +hand+ é aquele que tem como argumento um objeto do tipo +Hand+.

Here’s a design suggestion: when you override a method, the interface of the new method should be the same as the old. It should take the same parameters, return the same type, and obey the same preconditions and postconditions. If you follow this rule, you will find that any function designed to work with an instance of a supertype, like a +CardSet+, will also work with instances of its subtypes +Deck+ and +Hand+.

Aqui está uma sugestão de design: quando você substitui um método, a interface do novo método deve ser a mesma que a do antigo. Ele deve tomar os mesmos parâmetros, retornar o mesmo tipo e obedecer às mesmas condições prévias e pós-condições. Se você seguir esta regra, você verá que qualquer função projetada para trabalhar com uma instância de um supertipo, como um +CardSet+, também funcionará com instâncias de seus subtipos +Deck+ e +Hand+.

Aqui está uma sugestão de design: quando você substitui um método, a interface do novo método deve ser a mesma do antigo. Ele deve usar os mesmos parâmetros, retornar o mesmo tipo e obedecer às mesmas pré-condições e pós-condições. Se você seguir esta regra, descobrirá que qualquer função projetada para funcionar com uma instância de um supertipo, como um + CardSet +, também funcionará com instâncias de seus subtipos + Deck + e + Hand +.

If you violate this rule, which is called the “Liskov substitution principle”, your code will collapse like (sorry) a house of cards.
(((Liskov substitution principle)))

The function +supertype+ can be used to find the direct supertype of a type.
(((supertype)))((("função", "Base", "supertype", see="supertype")))

[source,@julia-repl-test chap18a]
----
julia> supertype(Deck)
CardSet
----


=== Data Encapsulation

The previous chapters demonstrate a development plan we might call “type-oriented design”. We identified objects we needed—like +Point+, +Rectangle+ and +MyTime+—and defined structs to represent them. In each case there is an obvious correspondence between the object and some entity in the real world (or at least a mathematical world).
(((type-oriented design)))

But sometimes it is less obvious what objects you need and how they should interact. In that case you need a different development plan. In the same way that we discovered function interfaces by encapsulation and generalization, we can discover type interfaces by _data encapsulation_.
(((data encapsulation)))

Markov analysis, from <<markov_analysis>>, provides a good example. If you download my code from https://github.com/JuliaIntro/JuliaIntroBR.jl/blob/master/src/solutions/chap13.jl, you’ll see that it uses two global variables—+suffixes+ and +prefix+—that are read and written from several functions.

[source,@julia-setup]
----
suffixes = Dict()
prefix = []
----

Because these variables are global, we can only run one analysis at a time. If we read two texts, their prefixes and suffixes would be added to the same data structures (which makes for some interesting generated text).

To run multiple analyses, and keep them separate, we can encapsulate the state of each analysis in an object. Here’s what that looks like:
(((Markov)))((("tipo", "definido pelo programador", "Markov", see="Markov")))

[source,@julia-setup chap18b]
----
struct Markov
    order :: Int64
    suffixes :: Dict{Tuple{String,Vararg{String}}, Array{String, 1}}
    prefix :: Array{String, 1}
end

function Markov(order::Int64=2)
    new(order, Dict{Tuple{String,Vararg{String}}, Array{String, 1}}(), Array{String, 1}())
end
----

Next, we transform the functions into methods. For example, here’s +processword+:
(((processword)))((("função", "definido pelo programador", "processword", see="processword")))

[source,@julia-setup chap18b]
----
function processword(markov::Markov, word::String)
    if length(markov.prefix) < markov.order
        push!(markov.prefix, word)
        return
    end
    get!(markov.suffixes, (markov.prefix...,), Array{String, 1}())
    push!(markov.suffixes[(markov.prefix...,)], word)
    popfirst!(markov.prefix)
    push!(markov.prefix, word)
end
----

Transforming a program like this—changing the design without changing the behavior—is another example of refactoring (see <<refactoring>>).
(((refactoring)))(((program development plan)))

This example suggests a development plan for designing types:

* Start by writing functions that read and write global variables (when necessary).

* Once you get the program working, look for associations between global variables and the functions that use them.

* Encapsulate related variables as fields of a struct.

* Transform the associated functions into methods with as argument objects of the new type.

===== Exercício 18-3

Download my Markov code from https://github.com/JuliaIntro/JuliaIntroBR.jl/blob/master/src/solutions/chap13.jl, and follow the steps described above to encapsulate the global variables as attributes of a new struct called +Markov+.


=== Glossary

encode::
To represent one set of values using another set of values by constructing a mapping between them.
(((encode)))

unit testing::
Standardized way to test the correctness of code.
(((unit testing)))

veneer::
A method or function that provides a different interface to another function without doing much computation.
(((veneer)))

subtyping::
The ability to define a hierarchy of related types.
(((subtyping)))

abstract type::
A type that can act as a parent for another type.
(((abstract type)))

concrete type::
A type that can be constructed.
(((concrete type)))

subtype::
A type that has as parent an abstract type.
(((subtype)))

supertype::
An abstract type that is the parent of another type.
(((supertype)))

IS-A relationship::
A relationship between a subtype and its supertype.
(((IS-A relationship)))

HAS-A relationship::
A relationship between two types where instances of one type contain references to instances of the other.
(((HAS-A relationship)))

dependency::
A relationship between two types where instances of one type use instances of the other type, but do not store them as fields.
(((dependency)))

type diagram::
A diagram that shows the types in a program and the relationships between them.
(((type diagram)))

multiplicity::
A notation in a type diagram that shows, for a HAS-A relationship, how many references there are to instances of another class.
(((multiplicity)))

data encapsulation::
A program development plan that involves a prototype using global variables and a final version that makes the global variables into instance fields.
(((data encapsulation)))


=== Exercícios

[[ex18-1]]
===== Exercício 18-4

For the following program, draw a type diagram that shows these types and the relationships among them.

[source,julia]
----
abstract type PingPongParent end

struct Ping <: PingPongParent
    pong :: PingPongParent
end

struct Pong <: PingPongParent
    pings :: Array{Ping, 1}
    function Pong(pings=Array{Ping, 1}())
        new(pings)
    end
end

function addping(pong::Pong, ping::Ping)
    push!(pong.pings, ping)
    nothing
end

pong = Pong()
ping = Ping(pong)
addping(pong, ping)
----

[[ex18-2]]
===== Exercício 18-5

Write a method called +deal!+ that takes three parameters, a +Deck+, the number of hands and the number of cards per hand. It should create the appropriate number of +Hand+ objects, deal the appropriate number of cards per hand, and return an array of +Hand+s.
(((deal!)))((("função", "definido pelo programador", "deal!", see="deal!")))

[[ex18-3]]
===== Exercício 18-6

The following are the possible hands in poker, in increasing order of value and decreasing order of probability:

pair::
two cards with the same rank

two pair::
two pairs of cards with the same rank

three of a kind::
three cards with the same rank

straight::
five cards with ranks in sequence (aces can be high or low, so Ace-2-3-4-5 is a straight and so is 10-Jack-Queen-King-Ace, but Queen-King-Ace-2-3 is not.)

flush::
five cards with the same suit

full house::
three cards with one rank, two cards with another

four of a kind::
four cards with the same rank

straight flush::
five cards in sequence (as defined above) and with the same suit

The goal of this exercise is to estimate the probability of drawing these various hands.

. Add methods named +haspair+, +hastwopair+, etc. that return +true+ or +false+ according to whether or not the hand meets the relevant criteria. Your code should work correctly for “hands” that contain any number of cards (although 5 and 7 are the most common sizes).
(((haspair)))((("função", "definido pelo programador", "haspair", see="haspair")))(((hastwopair)))((("função", "definido pelo programador", "hastwopair", see="hastwopair")))

. Write a method named +classify+ that figures out the highest-value classification for a hand and sets the +label+ field accordingly. For example, a 7-card hand might contain a flush and a pair; it should be labeled “flush”.
(((classify)))((("função", "definido pelo programador", "classify", see="classify")))

. When you are convinced that your classification methods are working, the next step is to estimate the probabilities of the various hands. Write a function that shuffles a deck of cards, divides it into hands, classifies the hands, and counts the number of times various classifications appear.

. Print a table of the classifications and their probabilities. Run your program with larger and larger numbers of hands until the output values converge to a reasonable degree of accuracy. Compare your results to the values at https://en.wikipedia.org/wiki/Hand_rankings.
