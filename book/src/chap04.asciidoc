[[chap04]]
== Estudo de Caso: Design de Interface

Este cap√≠tulo apresenta um estudo de caso que demonstra o processo de design de fun√ß√µes que trabalham juntas.

Ele introduz o turtle graphics, um jeito de criar desenhos por meio de um programa. O pacote turtle graphics n√£o est√° incluso na biblioteca padr√£o do Julia, portanto o m√≥dulo JuliaIntroBR tem que ser adicionado na sua configura√ß√£o do Julia.

Os exemplos neste cap√≠tulo podem ser executados em um notebook gr√°fico no JuliaBox, que combina c√≥digo, texto formatado, matem√°tica e multim√≠dia em um √∫nico documento (ver <<juliabox>>).
(((JuliaBox, notebook gr√°fico)))


=== Turtles

Um _m√≥dulo_ √© um arquivo que cont√©m uma cole√ß√£o de fun√ß√µes relacionadas. O Julia fornece alguns m√≥dulos na sua biblioteca padr√£o. Mais funcionalidades podem ser adicionadas a partir de uma crescente cole√ß√£o de _pacotes_ (https://juliaobserver.com).
(((m√≥dulo)))(((pacote)))

Pacotes podem ser instalados no REPL atrav√©s do modo Pkg usando a tecla +]+.
(((pass:[&#93;])))(((JuliaIntroBR)))((("m√≥dulo", "JuliaIntroBR", see="JuliaIntroBR")))

[source,jlcon]
----
(v1.0) pkg> add https://github.com/JuliaIntro/JuliaIntroBR.jl
----

Isso pode demorar um pouco.

Antes de podermos usar as fun√ß√µes de um m√≥dulo, temos que import√°-lo usando a declara√ß√£o +using+:
(((using)))((("palavra-chave", "using", see="using")))(((declara√ß√£o using)))((("declara√ß√£o", "using", see="declara√ß√£o qusing")))

[source,@julia-repl-test]
----
julia> using JuliaIntroBR

julia> üê¢ = Turtle()
Luxor.Turtle(0.0, 0.0, true, 0.0, (0.0, 0.0, 0.0))
----

O m√≥dulo +JuliaIntroBR+ possui uma fun√ß√£o chamada +Turtle+ que cria um objeto +Luxor.Turtle+, que atribu√≠mos a uma vari√°vel chamada +üê¢+ (*+\:turtle: TAB+*).
(((Turtle)))((("tipo", "Luxor", "Turtle", see="Turtle")))

Logo ap√≥s criarmos a tartaruga, podemos chamar uma fun√ß√£o que a move ao redor de um desenho. Por exemplo, para mover a tartaruga para a frente:
(((para a frente)))((("fun√ß√£o", "JuliaIntroBR", "para a frente", see="para a frente")))

[source,julia]
----
@svg begin
    forward(üê¢, 100)
end
----

[[fig04-1]]
.Movendo a tartaruga para a frente
image::images/fig41.svg[]


A palavra-chave +@svg+ executa uma macro que desenha uma imagem SVG. Macros s√£o uma parte importante, mas avan√ßada, do Julia.
(((@svg)))((("macro", "Luxor", "@svg", see="@svg")))(((macro)))(((imagem SVG)))

Os argumentos de +forward+ s√£o a tartaruga e a dist√¢ncia em pixels, portanto o tamanho real do movimento depende do seu monitor.

Outra fun√ß√£o que n√≥s podemos chamar com tartaruga como argumento √© +turn+, para virar. O segundo argumento para +turn+ √© o √¢ngulo em graus.
(((turn)))((("fun√ß√£o", "JuliaIntroBR", "turn", see="turn")))

Al√©m disso, cada tartaruga est√° segurando uma caneta, que pode estar tanto para baixo ou para cima; se a caneta est√° para baixo, a tartaruga deixa uma trilha quando ela se move. <<fig04-1>> mostra a trilha deixada pela tartaruga. As fun√ß√µes +penup+ e +pendown+ significam respectivamente ‚Äúcaneta para cima‚Äù e ‚Äúcaneta para baixo‚Äù.
(((penup)))((("fun√ß√£o", "JuliaIntroBR", "penup", see="penup")))(((pendown)))((("fun√ß√£o", "JuliaIntroBR", "pendown", see="pendown")))

Para desenhar um √¢ngulo reto, modifique a chamada de macro:

[source,julia]
----
üê¢ = Turtle()
@svg begin
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
end
----

===== Exerc√≠cio 4-1

Agora modifique a macro para desenhar um quadrado. N√£o avance at√© que voc√™ fa√ßa isso funcionar!


[[simple_repetition]]
=== Repeti√ß√£o Simples

Existe uma chance de que voc√™ escreveu algo como:
(((repeti√ß√£o)))

[source,julia]
----
üê¢ = Turtle()
@svg begin
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
end
----

N√≥s podemos fazer a mesma coisa de forma mais concisa com uma declara√ß√£o +for+:
(((declara√ß√£o for)))((("declara√ß√£o", "for", see="declara√ß√£o for")))(((for)))((("palavra-chave", "for", see="for")))(((in)))((("palavra-chave", "in", see="in")))

[source,@julia-repl-test]
----
julia> for i in 1:4
          println("Ol√°!")
       end
Ol√°!
Ol√°!
Ol√°!
Ol√°!
----

Esse √© o uso mais simples da declara√ß√£o +for+; n√≥s veremos mais usos mais tarde. Mas isso deve ser o suficiente para que voc√™ possa reescrever o seu programa que desenha um quadrado. N√£o avan√ße at√© que voc√™ o fa√ßa.

Aqui est√° uma declara√ß√£o +for+ que desenha um quadrado:

[source,julia]
----
üê¢ = Turtle()
@svg begin
    for i in 1:4
        forward(üê¢, 100)
        turn(üê¢, -90)
    end
end
----

A sintaxe de uma declara√ß√£o +for+ √© similar a uma defini√ß√£o de fun√ß√£o. Ela possui um cabe√ßalho e um corpo que termina com a palavra-chave +end+. O corpo pode conter qualquer n√∫mero de declara√ß√µes.
(((end)))

Uma declara√ß√£o +for+ tamb√©m √© chamada de _la√ßo_, pois o fluxo de execu√ß√£o percorre o corpo e em seguida retorna at√© o topo em um ciclo. Nesse caso, ela percorre o corpo quatro vezes.
(((la√ßo)))

Essa vers√£o √© na verdade um pouco diferente do c√≥digo que desenha um quadrado visto anteriormente, pois faz mais uma curva depois de desenhar o √∫ltimo lado do quadrado. A curva adicional leva mais tempo, mas simplifica o c√≥digo se fizermos a mesma coisa toda vez que percorre o la√ßo. Essa vers√£o tamb√©m faz a tartaruga retornar para sua posi√ß√£o inicial, de frente √† dire√ß√£o inicial.


=== Exerc√≠cios

A seguir est√£o uma s√©rie de exerc√≠cios utilizando turtles. Elas tem o prop√≥sito de serem divertidas, mas tem um objetivo tamb√©m. Enquanto voc√™ trabalha com elas, pense sobre qual √© o objetivo.

[TIP]
====
A se√ß√£o seguinte cont√©m solu√ß√µes para os exerc√≠cios, ent√£o n√£o olhe at√© voc√™ terminar (ou pelo menos tentar).
====

[[ex04-1]]
===== Exerc√≠cio 4-2

Escreva uma fun√ß√£o chamada +quadrado+ que recebe um par√¢metro chamado +t+, que √© uma tartaruga. Ela deve usar uma tartaruga para desenhar um quadrado.

[[ex04-2]]
===== Exerc√≠cio 4-3

Escreva uma chamada de fun√ß√£o que passa +t+ como um argumento para +quadrado+, e em seguida execute o macro novamente.

[[ex04-3]]
===== Exerc√≠cio 4-4

Adicione outro par√¢metro, chamado +com+, em +quadrado+. Modifique o corpo para que o comprimento dos lados seja +com+, e ent√£o modifique a chamada de fun√ß√£o para receber um segundo argumento. Execute a macro novamente. Teste com uma s√©rie de valores para +com+.

[[ex04-4]]
===== Exerc√≠cio 4-5

Fa√ßa uma c√≥pia de +quadrado+ e mude o nome para +pol√≠gono+. Adicione outro par√¢metro chamado +n+ e modifique o corpo para que ele desenhe um pol√≠gono com latexmath:[\(n\)] lados.

[TIP]
====
Os √¢ngulos externos de um pol√≠gono regular de latexmath:[\(n\)] lados s√£o iguais a latexmath:[\(\frac{360}{n}\)] graus.
====

[[ex04-5]]
===== Exerc√≠cio 4-6

Escreva uma fun√ß√£o chamada +c√≠rculo+ que recebe uma tartaruga +t+, e raio +r+ como par√¢metros e que desenha uma figura pr√≥xima √† um c√≠rculo atrav√©s da chamada de +pol√≠gono+ com um comprimento e n√∫mero de lados apropriados. Teste sua fun√ß√£o com uma s√©rie de valores de +r+.

[TIP]
====
Descubra a circunfer√™ncia do c√≠rculo e garanta que +com * n == circunfer√™ncia+.
====

[[ex04-6]]
===== Exerc√≠cio 4-7

Fa√ßa uma vers√£o mais geral de +c√≠rculo+ chamada +arco+ que recebe um par√¢metro adicional +√¢ngulo+, que determina qual fra√ß√£o de c√≠rculo desenhar. +√¢ngulo+ √© uma medida em graus, ent√£o quando +√¢ngulo = 360+, +arco+ deve desenhar um c√≠rculo completo.


=== Encapsulamento

O primeiro exerc√≠cio pede para que voc√™ coloque o seu c√≥digo de desenhar quadrado em uma defini√ß√£o de fun√ß√£o, e que em seguida voc√™ chame essa fun√ß√£o utilizando tartaruga como par√¢metro. Aqui est√° a solu√ß√£o:
(((quadrado)))((("fun√ß√£o", "definido pelo programador", "quadrado", see="quadrado")))

[source,julia]
----
function quadrado(t)
    for i in 1:4
        forward(t, 100)
        turn(t, -90)
    end
end
üê¢ = Turtle()
@svg begin
    square(üê¢)
end
----

As declara√ß√µes +forward+ e +turn+ s√£o indentadas duas vezes para mostrar que elas est√£o dentro do la√ßo +for+, que est√° dentro da defini√ß√£o da fun√ß√£o.
(((indenta√ß√£o)))

Dentro da fun√ß√£o, +t+ refere-se √† mesma tartaruga +üê¢+, ent√£o +turn(t, -90)+ tem o mesmo efeito que +turn(üê¢+, -90)+. Neste caso, por que n√£o chamar o par√¢metro +üê¢+ ? A ideia √© que +t+ pode ser qualquer tartaruga, n√£o somente +üê¢+, ent√£o voc√™ pode criar uma segunda tartaruga e pass√°-la como argumento para +quadrado+.

[source,julia]
----
üê´ = Turtle()
@svg begin
    square(üê´)
end
----

Envolver um peda√ßo de c√≥digo em uma fun√ß√£o √© chamado de _encapsulamento_. Um dos benef√≠cios do encapsulamento √© que ele anexa um nome ao c√≥digo, que serve como uma forma de documenta√ß√£o. Outra vantagem √© que se voc√™ est√° re-utilizando o c√≥digo, √© mais conciso chamar a fun√ß√£o duas vezes do que copiar e colar o corpo!
(((encapsulamento)))


=== Generaliza√ß√£o

O pr√≥ximo passo √© adicionar +com+ aos par√¢metros de +quadrado+. Aqui est√° a solu√ß√£o:
(((quadrado)))

[source,julia]
----
function quadrado(t, com)
    for i in 1:4
        forward(t, com)
        turn(t, -90)
    end
end
üê¢ = Turtle()
@svg begin
    square(üê¢, 100)
end
----

Adicionar um par√¢metro a uma fun√ß√£o √© chamado de _generaliza√ß√£o_ pois faz com que a fun√ß√£o seja mais abrangente: na vers√£o anterior, o quadrado sempre tem o mesmo tamanho; nesta vers√£o ele pode ter qualquer tamanho.
(((generaliza√ß√£o)))

O pr√≥ximo passo tamb√©m √© uma generaliza√ß√£o. Ao inv√©s de desenhar quadrados, +pol√≠gono+ desenha pol√≠gonos regulares com qualquer n√∫mero de lados. Aqui est√° a solu√ß√£o:
(((pol√≠gono)))((("fun√ß√£o", "definido pelo programador", "pol√≠gono", see="pol√≠gono")))

[source,julia]
----
function pol√≠gono(t, n, com)
    √¢ngulo = 360 / n
    for i in 1:n
        forward(t, com)
        turn(t, -√¢ngulo)
    end
end
üê¢ = Turtle()
@svg begin
    pol√≠gono(üê¢, 7, 70)
end
----

Este exemplo desenha um hept√°gono de lado medindo 70.


=== Design de Interface

O pr√≥ximo passo √© escrever +c√≠rculo+, que recebe um raio +r+ como par√¢metro. Aqui est√° uma solu√ß√£o simples que usa +pol√≠gono+ para desenhar um pol√≠gono de 50 lados:
(((c√≠rculo)))((("fun√ß√£o", "definido pelo programador", "c√≠rculo", see="c√≠rculo")))

[source,julia]
----
function c√≠rculo(t, r)
    circunfer√™ncia = 2 * œÄ * r
    n = 50
    com = circunfer√™ncia / n
    pol√≠gono(t, n, com)
end
----

A primeira linha computa a circunfer√™ncia de um c√≠rculo com raio latexmath:[\(r\)] usando a f√≥rmula latexmath:[\(2 \pi r\)]. +n+ √© o n√∫mero de segmentos de linha usados na nossa aproxima√ß√£o de um c√≠rculo, e +com+ √© o comprimento de cada segmento. Portanto, +pol√≠gono+ desenha um pol√≠gono de 50 lados que se aproxima um c√≠rculo de raio +r+.

Uma limita√ß√£o dessa solu√ß√£o √© que +n+ √© uma constante, o que significa que para c√≠rculos bem grandes, os segmentos de linha s√£o muito longos, e para c√≠rculos pequenos, n√≥s gastamos tempo desenhando segmentos bem pequenos. Uma solu√ß√£o seria generalizar a fun√ß√£o para que ela receba +n+ como par√¢metro. Isso daria ao usu√°rio (qualquer um que chame c√≠rculo) mais controle, mas a interface seria menos limpa.

A _interface_ de uma fun√ß√£o √© um resumo de como ela deve ser usada: quais s√£o os par√¢metros? O que a fun√ß√£o faz? E qual o seu valor de retorno? Uma interface √© ‚Äúlimpa‚Äù se permite √†quele que chamou a fun√ß√£o fazer tudo o que ele quer sem precisar lidar com detalhes desnecess√°rios.
(((interface)))

Neste exemplo, +r+ pertence √† interface pois especifica o c√≠rculo a ser desenhado. +n+ √© menos apropriada pois diz respeito aos detalhes de como o c√≠rculo deve ser renderizado.

Em vez de bagun√ßar a interface, √© melhor escolher um valor apropriado de +n+ dependendo de +circunfer√™ncia+:

[source,julia]
----
function c√≠rculo(t, r)
    circunfer√™ncia = 2 * œÄ * r
    n = trunc(circunfer√™ncia / 3) + 3
    com = circunfer√™ncia / n
    pol√≠gono(t, n, com)
end
----

Agora o n√∫mero de segmentos √© um inteiro ao redor de +circunfer√™ncia/3+, ent√£o o comprimento de cada segmento √© aproximadamente 3, que √© pequeno o suficiente para que os c√≠rculos fiquem bons, mas grande o suficiente para ser eficaz, e aceit√°vel para qualquer tamanho de c√≠rculo.

Adicionar 3 a +n+ garante que o pol√≠gono tenha no m√≠nimo 3 lados.


[[reestrutura√ß√£o]]
=== Reestrutura√ß√£o

Quando escrevemos +c√≠rculo+, pudemos reutilizar +pol√≠gono+ pois um pol√≠gono com v√°rios lados √© uma boa aproxima√ß√£o de um c√≠rculo. Mas +arco+ n√£o √© igualmente cooperativo; n√£o podemos usar +pol√≠gono+ ou +c√≠rculo+ para desenhar um arco.

Uma alternativa √© come√ßar com uma c√≥pia de +pol√≠gono+ e transform√°-la em +arco+. O resultado pode parecer algo como:
(((arco)))((("fun√ß√£o", "definido pelo programador", "arco", see="arco")))

[source,julia]
----
function arco(t, r, √¢ngulo)
    com_arco = 2 * œÄ * r * √¢ngulo / 360
    n = trunc(com_arco / 3) + 1
    tam_passo = com_arco / n
    ang_passo = √¢ngulo / n
    for i in 1:n
        forward(t, tam_passo)
        turn(t, -ang_passo)
    end
end
----

A segunda metade dessa fun√ß√£o parece-se com +pol√≠gono+, mas n√≥s n√£o podemos reusar +pol√≠gono+ sem mudar a interface. N√≥s poder√≠amos generalizar +pol√≠gono+ para receber +√¢ngulo+ como terceiro argumento, mas ent√£o +pol√≠gono+ n√£o seria mais um nome apropriado! Ao inv√©s disso, chamaremos a fun√ß√£o mais geral +polilinha+:
(((polilinha)))((("fun√ß√£o", "definido pelo programador", "polilinha", see="polilinha")))

[source,julia]
----
function polilinha(t, n, com, √¢ngulo)
    for i in 1:n
        forward(t, com)
        turn(t, -√¢ngulo)
    end
end
----

Agora n√≥s podemos reescrever +pol√≠gono+ e +arco+ para usar +polilinha+:
(((pol√≠gono)))(((arco)))

[source,julia]
----
function pol√≠gono(t, n, com)
    √¢ngulo = 360 / n
    polilinha(t, n, com, √¢ngulo)
end

function arco(t, r, √¢ngulo)
    com_arco = 2 * œÄ * r * √¢ngulo / 360
    n = trunc(com_arco / 3) + 1
    com_passo = com_arco / n
    ang_passo = √¢ngulo / n
    polilinha(t, n, com_passo, ang_passo)
end
----

Finalmente, n√≥s podemos reescrever +c√≠rculo+ para usar +arco+:
(((c√≠rculo)))

[source,julia]
----
function c√≠rculo(t, r)
    arco(t, r, 360)
end
----

Este processo de reorganiza√ß√£o de um programa para melhorar interface e facilitar o reuso de c√≥digo √© chamado de _refatora√ß√£o_. Neste caso, n√≥s percebemos que havia c√≥digo similar em +arco+ e +pol√≠gono+, ent√£o n√≥s o ‚Äúfatoramos‚Äù para dentro de +polilinha+.
(((refactoring)))

Se n√≥s tiv√©ssemos planejado com anteced√™ncia, n√≥s poder√≠amos ter escrito +polilinha+ primeiro e evitado a refatora√ß√£o, mas voc√™ frequentemente n√£o sabe o suficiente no come√ßo de um projeto para planejar todas as interfaces. A partir do momento em que voc√™ come√ßa a programar, voc√™ passa a entender o problema melhor. √Äs vezes refatora√ß√£o √© um sinal de que voc√™ aprendeu alguma coisa.


=== Um Plano de Desenvolvimento

Um _plano de desenvolvimento_ √© um processo para escrever programas. O processo que usamos nesse estudo de caso √© ‚Äúencapsulamento e generaliza√ß√£o‚Äù. Os passos desse processo s√£o:
(((plano de desenvolvimento para um programa)))

. Comece escrevendo um pequeno programa sem defini√ß√µes de fun√ß√µes.

. Uma vez que voc√™ fez com que o seu programa funcione, identifique um peda√ßo coerente dele, encapsule-o em uma fun√ß√£o e d√™ a ela um nome.

. Generalize a fun√ß√£o adicionando par√¢metros apropriados.

. Repita os passos 1-3 at√© que voc√™ tenha um conjunto de programas funcionais. Copie e cole o c√≥digo para evitar redigi-los (e redepur√°-los).

. Busque por oportunidades de melhora no programa atrav√©s da refatora√ß√£o. Por exemplo, se voc√™ tem um c√≥digo similar em v√°rios lugares, considere fator√°-lo em uma fun√ß√£o geral apropriada.

Esse processo tem algumas desvantagens-n√≥s veremos as alternativas mais tarde-mas pode ser √∫til se voc√™ n√£o sabe previamente como dividir o programa em fun√ß√µes. Essa abordagem permite que voc√™ planeje conforme voc√™ vai projetando.


=== Docstring

Uma _docstring_ √© uma string que vem antes de uma fun√ß√£o e descreve sua interface (‚Äúdoc‚Äù refere-se a ‚Äúdocumenta√ß√£o‚Äù). Aqui est√° um exemplo:
(((docstring)))(((aspas triplas)))((("pass:[&quot;&quot;&quot;]", see="aspas triplas")))

[source,julia]
----
"""
polilinha(t, n, com, √¢ngulo)

Desenha n segmentos de linha dado o comprimento
e o √¢ngulo (em graus) entre eles.  t √© uma tartaruga.
"""
function polilinha(t, n, com, √¢ngulo)
    for i in 1:n
        forward(t, com)
        turn(t, -√¢ngulo)
    end
end
----

A documenta√ß√£o pode ser acessada no REPL ou em um notebook digitando ? seguido pelo nome de uma fun√ß√£o ou macro, e apertando +ENTER+;
(((ajuda)))((("?", see="ajuda")))

----
help?> polilinha
search:

  polilinha(t, n, com, √¢ngulo)

  Desenha n segmentos de linha dado o comprimento e o √¢ngulo (em graus) entre eles. t √© uma tartaruga.
----

Docstrings s√£o comumente strings envolvidas por tr√™s aspas, tamb√©m conhecidas por strings multi-linha, pois as tr√™s aspas permitem que a string abranja mais de uma linha.

Uma docstring cont√©m a informa√ß√£o essencial que algu√©m precisaria para usar essa fun√ß√£o. Ela explica concisamente o que a fun√ß√£o faz (sem entrar em detalhes de como ela faz). Ela explica que efeito cada par√¢metro tem na execu√ß√£o da fun√ß√£o e qual tipo cada par√¢metro deve ser (se n√£o √© √≥bvio).

[TIP]
====
Escrever esse tipo de documenta√ß√£o √© uma parte importante do design de interface. Uma interface bem projetada deve ser simples de explicar; se voc√™ encontra dificuldade em explicar uma de sua fun√ß√µes, talvez sua interface possa ser melhorada.
====


=== Depurando

Uma interface √© como um contrato entre a fun√ß√£o e quem a chama. Quem chama concorda em fornecer certos par√¢metros e a fun√ß√£o concorda em fazer um certo trabalho.
(((depurando)))

Por exemplo, +polilinha+ requer quatro argumentos: +t+ tem que ser uma tartaruga; +n+ tem que ser um inteiro; +com+ deve ser um n√∫mero positivo; e +√¢ngulo+ tem que ser um n√∫mero, que assume-se ser uma medida em graus.

Esses requerimentos s√£o chamados de _precondi√ß√µes_ pois eles deveriam ser verdadeiros antes que a fun√ß√£o execute. Inversamente, condi√ß√µes no final da fun√ß√£o s√£o chamadas de _p√≥s-condi√ß√µes_. P√≥s-condi√ß√µes incluem o efeito desejado da fun√ß√£o (como desenhar segmentos de linha) e qualquer efeito colateral (como mover a tartaruga ou fazer outra mudan√ßa).
(((precondi√ß√£o)))(((p√≥s-condi√ß√£o)))

precondi√ß√µes s√£o de responsabilidade de quem chama a fun√ß√£o. Se quem chama viola uma precondi√ß√£o (propriamente documentada!) e a fun√ß√£o n√£o funciona adequadamente, o bug est√° em quem chamou, e n√£o na fun√ß√£o.

Se as precondi√ß√µes s√£o satisfeitas e as p√≥s-condi√ß√µes n√£o, ent√£o o bug est√° na fun√ß√£o. Se as suas pr√©- e p√≥s-condi√ß√µes forem claras, elas podem ajudar na hora de depurar.


=== Gloss√°rio

m√≥dulo::
Um arquivo que cont√©m uma cole√ß√£o de fun√ß√µes e outras defini√ß√µes relacionadas.
(((m√≥dulo)))

pacote::
Uma biblioteca externa com funcionalidade adicional.
(((pacote)))

declara√ß√£o using::
Uma declara√ß√£o que l√™ um arquivo m√≥dulo e cria um objeto m√≥dulo.
(((declara√ß√£o using)))

la√ßo::
Uma parte do programa que √© executada repetidamente.
(((la√ßo)))

encapsulamento::
O processo de transformar uma sequ√™ncia de comandos em uma defini√ß√£o de fun√ß√£o.
(((encapsulamento)))

generaliza√ß√£o::
O processo de substituir algo desnecessariamente espec√≠fico (como um n√∫mero) por algo mais adequadamente irrestrito (como uma vari√°vel ou par√¢metro).
(((generaliza√ß√£o)))

interface::
Uma descri√ß√£o de como usar uma fun√ß√£o, incluindo o nome, as descri√ß√µes dos argumentos e o valor de retorno.
(((interface)))

refatora√ß√£o::
O processo de modificar um programa funcional para melhorar a interface da fun√ß√£o e outras qualidades do c√≥digo.
(((refatora√ß√£o)))

plano de desenvolvimento::
Um processo para escrever programas.
(((plano de desenvolvimento)))

docstring::
Uma string que aparece no topo de uma defini√ß√£o de fun√ß√£o para documentar a interface da fun√ß√£o.
(((docstring)))

precondi√ß√£o::
Um requerimento que deve ser satisfeito por quem chama antes da fun√ß√£o iniciar.
(((precondi√ß√£o)))

p√≥s-condi√ß√£o::
Um requerimento que deve ser satisfeito pela fun√ß√£o antes de acabar.
(((p√≥s-condi√ß√£o)))


=== Exerc√≠cios

[[ex04-7]]
===== Exerc√≠cio 4-8

Digite o c√≥digo deste cap√≠tulo em um notebook.

. Desenhe um diagrama de pilha que mostra o fluxo de execu√ß√µes de +c√≠rculo(üê¢, raio)+. Voc√™ pode contar no dedo ou adicionar declara√ß√µes de impress√£o no c√≥digo.

. A vers√£o de +arco+ em <<refatora√ß√£o>> n√£o √© muito precisa dado que a aproxima√ß√£o linear do c√≠rculo est√° sempre fora do verdadeiro c√≠rculo. Como resultado, a tartaruga acaba alguns pixels depois do destino correto. Minha solu√ß√£o mostra uma maneira de reduzir o efeito desse erro. Leia o c√≥digo e veja se faz sentido para voc√™. Se voc√™ desenhar o diagrama, voc√™ poder√° ver como ela funciona.
(((arco)))

[source,julia]
----
"""
arco(t, r, √¢ngulo)

Desenha um arco dado o raio e √¢ngulo:

    t: tartaruga
    r: raio
    √¢ngulo: √¢ngulo feito pelo arco, em graus
"""
function arco(t, r, √¢ngulo)
    com_arco = 2 * œÄ * r * abs(√¢ngulo) / 360
    n = trunc(com_arco / 4) + 3
    com_passo = com_arco / n
    ang_passo = √¢ngulo / n

    # fazendo uma leve curva para a esquerda antes de iniciar
    # reduz o erro causado pela aproxima√ß√£o linear do arco
    turn(t, -ang_passo/2)
    polilinha(t, n, com_passo, ang_passo)
    turn(t, ang_passo/2)
end
----

[[ex04-8]]
===== Exerc√≠cio 4-9

Escreva um conjunto geral de fun√ß√µes apropriadas que podem desenhar flores como em <<fig04-2>>.

[[fig04-2]]
.Flores de Tartaruga
image::images/fig42.svg[]

[[ex04-9]]
===== Exerc√≠cio 4-10

Escreva um conjunto geral de fun√ß√µes apropriadas que podem desenhar formas como as de <<fig04-3>>.

[[fig04-3]]
.Tortas de Tartaruga
image::images/fig43.svg[]

[[ex04-10]]
===== Exerc√≠cio 4-11

As letras do alfabeto podem ser constru√≠das a partir de um n√∫mero moderado de elementos b√°sicos, como linhas verticais, horizontais e algumas curvas. Projete um alfabeto que pode ser desenhado com o menor n√∫mero de elementos b√°sicos e em seguida escreva fun√ß√µes que desenhem letras.

Voc√™ deve escrever uma fun√ß√£o para cada letra, com nomes +desenha_a+, +desenha_b+, etc., e coloque suas fun√ß√µes em um arquivo chamado _letras.jl_.

[[ex04-11]]
===== Exerc√≠cio 4-12

Leia sobre espirais em https://pt.wikipedia.org/wiki/Espiral; em seguida escreva um programa que desenha uma espiral de Arquimedes como em <<fig04-4>>.

[[fig04-4]]
.Espiral de Arquimedes
image::images/fig44.svg[]
