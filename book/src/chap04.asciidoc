[[chap04]]
== Estudo de Caso: Desing de Interface

Este cap√≠tulo apresenta um estudo de caso que demonstra o processo de design de fun√ß√µes que trabalham juntas.

Ele introduz o turtle graphics, um jeito de criar desenhos program√°ticos. O pacote turtle graphics n√£o est√° incluso na biblioteca padr√£o do Julia, portanto o modulo ThinkJulia tem que ser adicionado na sua configura√ß√£o do Julia.

Os exemplos neste cap√≠tulo podem ser executados em um notebook gr√°fico no JuliaBox, que combina c√≥digo, texto formatado, matem√°tica e multim√≠dia em um √∫nico docoumento (ver <<juliabox>>).
(((JuliaBox, notebook gr√°fico)))


=== Turtles

Um _m√≥dulo_ √© um arquivo que cont√©m uma cole√ß√£o de fun√ß√µes relacionadas. O Julia fornece alguns m√≥dulos na sua biblioteca padr√£o. Funcionalidades adicionais podem ser adicionadas a partir de uma crescente cole√ß√£o de _pacotes_ (https://juliaobserver.com).
(((m√≥dulo)))(((pacote)))

Pacotes podem ser instalados no REPL atrav√©s do modo Pkg usando a tecla +]+.
(((pass:[&#93;])))(((ThinkJulia)))((("m√≥dulo", "ThinkJulia", see="ThinkJulia")))

[source,jlcon]
----
(v1.0) pkg> add https://github.com/BenLauwens/ThinkJulia.jl
----

Isso pode demorar um pouco.

Antes de podermos usar as fun√ß√µes em um m√≥dulo, temos que import√°-lo usando a declara√ß√£o +using+:
(((using)))((("palavra-chave", "using", see="using")))(((declara√ß√£o using)))((("declara√ß√£o", "using", see="declara√ß√£o qusing")))

[source,@julia-repl-test]
----
julia> using ThinkJulia

julia> üê¢ = Turtle()
Luxor.Turtle(0.0, 0.0, true, 0.0, (0.0, 0.0, 0.0))
----

O m√≥dulo +ThinkJulia+ m√≥dulo proporciona a fun√ß√£o chamada +Turtle+ que cria um objeto +Luxor.Turtle+, no qual o atribuimos a uma vari√°vel chamada +üê¢+ (*+\:turtle: TAB+*).
(((Turtle)))((("tipo", "Luxor", "Turtle", see="Turtle")))

Logo ap√≥s criarmos a tartaruga, podemos chamar a fun√ß√£o que move-a ao redor de um desenho. Por exemplo, para mover a tartaruga para a frente:
(((para a frente)))((("fun√ß√£o", "ThinkJulia", "para a frente", see="para a frente")))

[source,julia]
----
@svg begin
    forward(üê¢, 100)
end
----

[[fig04-1]]
.Movendo a tartaruga para a frente
image::images/fig41.svg[]


A palavra-chave +@svg+ executa um macro que desenha a imagem SVG. Macros s√£o uma parte importante, mas avan√ßadas, do Julia.
(((@svg)))((("macro", "Luxor", "@svg", see="@svg")))(((macro)))(((imagem SVG)))

Os argumentos de +forward+ s√£o a tartaruga e a dist√¢ncia em pixeis, portanto o tamanho real depende do seu monitor.

Outra fun√ß√£o que n√≥s podemos chamar com tartaruga como argumento √© +turn+, para virar. O segundo argumento para +turn+ √© o √¢ngulo em graus.
(((turn)))((("fun√ß√£o", "ThinkJulia", "turn", see="turn")))

Al√©m disso, cada tartaruga est√° segurando uma caneta, que pode estar tanto para baixo ou para cima; se a caneta est√° para baixo, a tartaruga deixa uma trilha quando ela move-se. <<fig04-1>> mostra a trilha deixada pela tartaruga. As fun√ß√µes +penup+ e +pendown+ significam ‚Äúcaneta acima‚Äù e ‚Äúcaneta abaixo‚Äù.
(((penup)))((("fun√ß√£o", "ThinkJulia", "penup", see="penup")))(((pendown)))((("fun√ß√£o", "ThinkJulia", "pendown", see="pendown")))

Para desenhar um √¢ngulo reto, modifique a chamada de macro:

[source,julia]
----
üê¢ = Turtle()
@svg begin
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
end
----

===== Exerc√≠cio 4-1

Agora modifique o macro para desenhar um quadrado. N√£o v√° at√© que voc√™ fa√ßa-o funcionar!


[[simple_repetition]]
=== Repeti√ß√£o simples

Existe uma chance de que voc√™ escreveu algo como:
(((repeti√ß√£o)))

[source,julia]
----
üê¢ = Turtle()
@svg begin
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
end
----

N√≥s podemos fazer a mesma coisa de forma mais concisa com uma declara√ß√£o +for+:
(((declara√ß√£o for)))((("declara√ß√£o", "for", see="declara√ß√£o for)))(((for)))((("palavra-chave", "for", see="for")))(((in)))((("palavra-chave", "in", see="in")))

[source,@julia-repl-test]
----
julia> for i in 1:4
          println("Ol√°!")
       end
Ol√°!
Ol√°!
Ol√°!
Ol√°!
----

Esse √© o uso mais simples da declara√ß√£o +for+; n√≥s veremos mais usos mais tarde. Mas isso deve ser o suficiente para que voc√™ possa reescrever o seu programa que desenha um quadrado. N√£o v√° at√© que voc√™ fa√ßa-o.

Aqui est√° uma declara√ß√£o +for+ que desenha um quadrado:

[source,julia]
----
üê¢ = Turtle()
@svg begin
    for i in 1:4
        forward(üê¢, 100)
        turn(üê¢, -90)
    end
end
----

A syntaxe de uma declara√ß√£o +for+ √© similar √† uma defini√ß√£o de fun√ß√£o. Ela possui um cabe√ßalho e um corpo que termina com a palavra-chave +end+. O corpo pode conter qualquer n√∫mero de declara√ß√µes.
(((end)))

Uma declara√ß√£o +for+ tamb√©m √© chamada de _loop_, pois o fluxo de execu√ß√£o percorre o corpo e em seguida retorna at√© o topo em um ciclo. Neste caso, ela percorre o corpo quatro vezes.
(((loop)))

Essa vers√£o √© na verdade um pouco diferente do c√≥digo que desenha um quadrado visto anteriormente, pois faz mais uma curva depois de desenhar o √∫ltimo lado do quadrado. A curva adicional leva mais tempo, mas simplifica o c√≥digo se fizermos a mesma coisa toda vez que percorre o loop. Essa vers√£o tamb√©m tem o efeito de retornar a tartaruga para sua posi√ß√£o inicial, de frente √† dire√ß√£o inicial.


=== Exerc√≠cios

A seguir est√£o uma s√©rie de exerc√≠cios utilizando turtles. Elas tem o prop√≥sito de serem divertidas, mas tem um objetivo/ponto tamb√©m. Enquanto voc√™ trabalha com elas, pense sobre qual √© o objetivo/ponto.

[TIP]
====
A sec√ß√£o seguinte cont√©m solu√ß√µes para os exerc√≠cios, ent√£o n√£o olhe at√© que voc√™ termine-os (ou pelo menos tentou).
====

[[ex04-1]]
===== Exerc√≠cio 4-2

Escreva uma fun√ß√£o chamada +quadrado+ que recebe um par√¢metro chamado +t+, que √© uma tartaruga. Ela deve usar uma tartaruga para desenhar um quadrado.

[[ex04-2]]
===== Exerc√≠cio 4-3

Escreva uma chamada de fun√ß√£o que passa +t+ como um argumento para +quadrado+, e em seguida execute o macro novamente.

[[ex04-3]]
===== Exerc√≠cio 4-4

Adicione outro par√¢metro, chamado +com+, em +quadrado+. Modifique o corpo para que o comprimento dos lados seja +com+, e ent√£o modifique a chamada de fun√ß√£o para fornecer um segundo argumento. Execute o macro novamente. Teste com uma s√©rie de valores para +com+.

[[ex04-4]]
===== Exerc√≠cio 4-5

Fa√ßa uma c√≥pia de +quadrado+ e mude o nome para +pol√≠gono+. Adicione outro par√¢metro chamado +n+ e modifique o corpo para que ele desenhe um pol√≠gono com latexmath:[\(n\)] lados.

[TIP]
====
Os √¢ngulos externos de um pol√≠gono regular de latexmath:[\(n\)] lados somam latexmath:[\(\frac{360}{n}\)] graus.
====

[[ex04-5]]
===== Exerc√≠cio 4-6

Escreva uma fun√ß√£o chamada +circulo+ que recebe uma tartaruga< +t+, e raio< +r+, como par√¢metros e que desenha um c√≠rculo aproximado atrav√©s da chamada de +pol√≠gono+ com um comprimento e n√∫mero de lados apropriados. Teste sua fun√ß√£o com uma s√©rie de valores de +r+.

[TIP]
====
Descubra a circumfer√™ncia do c√≠rculo e garanta que +com * n == circumfer√™ncia+.
====

[[ex04-6]]
===== Exerc√≠cio 4-7

Fa√ßa uma vers√£o mais gen√©rica de +circulo+ chamada +arc+ que recebe um par√¢metro adicional +√¢ngulo+, que determina qual fra√ß√£o de c√≠rculo desenhar. +√¢ngulo+ √© uma unidade de graus, ent√£o quando +√¢ngulo = 360+, +arc+ deve desenhar um c√≠rculo completo.


=== Encapsulamento

O primeiro exerc√≠cio pede para que voc√™ coloque o seu c√≥digo de desenhar quadrado em uma defini√ß√£o de fun√ß√£o, e em seguida, chame essa fun√ß√£o utilizando tartaruga como par√¢metro. Aqui est√° a solu√ß√£o:
(((quadrado)))((("fun√ß√£o", "definido pelo programador", "quadrado", see="quadrado")))

[source,julia]
----
function quadrado(t)
    for i in 1:4
        forward(t, 100)
        turn(t, -90)
    end
end
üê¢ = Turtle()
@svg begin
    square(üê¢)
end
----

As declara√ß√µes +forward+ e +turn+ s√£o indentadas duas vezes para mostrar que elas est√£o dentro do loop +for+, que est√° dentro da defini√ß√£o da fun√ß√£o.
(((indenta√ß√£o)))

Dentro da fun√ß√£o, +t+ refere-se √† mesma tartaruga +üê¢+, ent√£o +turn(t, -90)+ tem o mesmo efeito que +turn(üê¢+, -90+. Neste caso, por que n√£o chamar o par√¢metro +üê¢+ ? A id√©ia √© que +t+ pode ser qualquer tartaruga, n√£o somente +üê¢+, ent√£o voc√™ pode criar uma segunda tartaruga e passar como argumento para +quadrado+.

[source,julia]
----
üê´ = Turtle()
@svg begin
    square(üê´)
end
----

Envolver um peda√ßo de c√≥digo em uma fun√ß√£o √© chamado de _encapsulamento_. Um dos benef√≠cios do encapsulamento √© que ele anexa um nome ao c√≥digo, que serve como uma forma de documenta√ß√£o. Outra vantagem √© que se voc√™ est√° re-utilizando c√≥digo, √© mais conciso chamar a fun√ß√£o duas vezes do que copiar e colar o corpo!
(((encapsulamento)))


=== Generaliza√ß√£o

O pr√≥ximo passo √© adicionar +com+ aos par√¢metros de +quadrado+. Aqui est√° a solu√ß√£o:
(((quadrado)))

[source,julia]
----
function quadrado(t, com)
    for i in 1:4
        forward(t, com)
        turn(t, -90)
    end
end
üê¢ = Turtle()
@svg begin
    square(üê¢, 100)
end
----

Adicionar um par√¢metro a uma fun√ß√£o √© chamado de _generaliza√ß√£o_ pois faz com que a fun√ß√£o seja mais gen√©rica: na vers√£o anterior, o quadrado sempre tem o mesmo tamanho; nesta vers√£o ele pode ter qualquer tamanho.
(((generaliza√ß√£o)))

O pr√≥ximo passo tamb√©m √© generaliza√ß√£o. Ao inv√©s de desenhar quadrados, +pol√≠gono+ desenha pol√≠gonos regulares com qualquer n√∫mero de lados. Aqui est√° a solu√ß√£o:
(((pol√≠gono)))((("fun√ß√£o", "definido pelo programador", "pol√≠gono", see="pol√≠gono")))

[source,julia]
----
function pol√≠gono(t, n, com)
    √¢ngulo = 360 / n
    for i in 1:n
        forward(t, com)
        turn(t, -√¢ngulo)
    end
end
üê¢ = Turtle()
@svg begin
    polygon(üê¢, 7, 70)
end
----

Este exemplo desenha um pol√≠gono de 7 lados com comprimento 70.


=== Design de Interface

O pr√≥ximo passo √© escrever +c√≠rculo+, que recebe um raio, +r+, como par√¢metro. Aqui est√° uma solu√ß√£o simples que usa +pol√≠gono+ para desenhar um pol√≠gono de 50 lados:
(((c√≠rculo)))((("fun√ß√£o", "definido pelo programador", "c√≠rculo", see="c√≠rculo")))

[source,julia]
----
function c√≠rculo(t, r)
    circumfer√™ncia = 2 * œÄ * r
    n = 50
    com = circumfer√™ncia / n
    polygon(t, n, com)
end
----

A primeira linha computa a circumfer√™ncia de um c√≠rculo com raio latexmath:[\(r\)] usando a f√≥rmula latexmath:[\(2 \pi r\)]. +n+ √© o n√∫mero de segmentos de linha em nossa aproxima√ß√£o de um c√≠rculo, ent√£o +com+ √© o comprimento de cada segmento. Portanto, +pol√≠gono+ desenha um pol√≠gono de 50 lados que aproxima um c√≠rculo de raio +r+.

Uma limita√ß√£o dessa solu√ß√£o √© que +n+ √© uma constante, o que significa que para c√≠rculos bem grandes, os segmentos de linha s√£o muito longos, e para c√≠rculos pequenos, n√≥s gastamos tempo desenhando segmentos bem pequenos. Uma solu√ß√£o seria generalizar a fun√ß√£o para que ela receba +n+ como par√¢metro. Isso daria ao usu√°rio (qualquer um que chame c√≠rculo) mais controle, mas a interface seria menos limpa.

A _interface_ de uma fun√ß√£o √© um resumo de como ela deve ser usada: quais s√£o os par√¢metros? O que a fun√ß√£o faz? E qual o seu valor de retorno? Uma interface √© ‚Äúlimpa‚Äù se permite ao chamador da fun√ß√£o fazer tudo o que ele quer sem precisar lidar com detalhes desnecess√°rios.
(((interface)))

Neste exemplo, +r+ pertence √† interface pois especifica o c√≠rculo a ser desenhado. +n+ √© menos apropriada pois diz respeito aos detalhes de como o c√≠rculo deve ser renderizado.

Em vez de bagun√ßar a interface, √© melhor escolher um valor apropriado de +n+ dependendo de +circunf√™rencia+:

[source,julia]
----
function c√≠rculo(t, r)
    circunfer√™ncia = 2 * œÄ * r
    n = trunc(circunfer√™ncia / 3) + 3
    com = circunfer√™ncia / n
    polygon(t, n, com)
end
----

Agora o n√∫mero de segmentos √© um inteiro ao redor de +circunfer√™ncia/3+, ent√£o o comprimento de cada segmento √© aproximadamente 3, que √© pequeno o suficiente para que os c√≠rculos fiquem bons, mas grande o suficiente para ser eficaz, e aceit√°vel para qualquer tamanho de c√≠rculo.

Adicionar 3 √† +n+ garante que o pol√≠gono tenha no m√≠nimo 3 lados.


[[reestrutura√ß√£o]]
=== Reestrutura√ß√£o

Quando eu escrevi +c√≠rculo+, eu pude re-utilizar +pol√≠gono+ pois um pol√≠gono com v√°rios lados √© uma boa aproxima√ß√£o de um c√≠rculo. Mas +arc+ n√£o √© igualmente cooperativo; n√£o podemos usar +pol√≠gono+ ou +c√≠rculo+ para desenhar um arco.

Uma alternativa √© come√ßar com uma c√≥pia de +pol√≠gono+ e transform√°-lo em +arc+. O resultado pode parecer algo como:
(((arc)))((("fun√ß√£o", "definido pelo programador", "arc", see="arc")))

[source,julia]
----
function arc(t, r, √¢ngulo)
    com_arc = 2 * œÄ * r * √¢ngulo / 360
    n = trunc(com_arc / 3) + 1
    tam_passo = com_arc / n
    ang_passo = √¢ngulo / n
    for i in 1:n
        forward(t, tam_passo)
        turn(t, -ang_passo)
    end
end
----

A segunda metade dessa fun√ß√£o parece-se com +pol√≠gono+, mas n√≥s n√£o podemos reusar +pol√≠gono+ sem mudar a interface. N√≥s poder√≠amos generalizar +pol√≠gono+ para receber +√¢ngulo+ como terceiro argumento, mas ent√£o +pol√≠gono+ n√£o seria mais um nome apropriado! Ao inv√©z disso, chamaremos a fun√ß√£o mais geral +pol√≠linha+:
(((pol√≠linha)))((("fun√ß√£o", "definido pelo programador", "pol√≠linha", see="pol√≠linha")))

[source,julia]
----
function pol√≠linha(t, n, com, √¢ngulo)
    for i in 1:n
        forward(t, com)
        turn(t, -√¢ngulo)
    end
end
----

Agora n√≥s podemos reescrever +pol√≠gono+ e +arc+ para usar +pol√≠linha+:
(((pol√≠gono)))(((arc)))

[source,julia]
----
function pol√≠gono(t, n, com)
    √¢ngulo = 360 / n
    polyline(t, n, com, √¢ngulo)
end

function arc(t, r, √¢ngulo)
    com_arc = 2 * œÄ * r * √¢ngulo / 360
    n = trunc(com_arc / 3) + 1
    com_passo = com_arc / n
    ang_passo = √¢ngulo / n
    polyline(t, n, com_passo, ang_passo)
end
----

Finalmente, n√≥s podemos reescrever +c√≠rculo+ para usar +arc+:
(((c√≠rculo)))

[source,julia]
----
function c√≠rculo(t, r)
    arc(t, r, 360)
end
----

Este processo-reorganizar um programa para melhorar interface e facilitar reuso de c√≥digo √© chamado de _refatora√ß√£o_. Neste caso, n√≥s percebemos que havia c√≥digo similar em +arc+ e +pol√≠gono+, ent√£o nos ‚Äúfatoramos-o‚Äù para dentro de +pol√≠linha+.
(((refactoring)))

Se n√≥s tivessemos planejado com anteced√™ncia, n√≥s poderiamos ter escrito +pol√≠linha+ primeiro e evitado a refatora√ß√£o, mas voc√™ frequentemente n√£o sabe o suficiente no come√ßo de um projeto para planejar todas as interfaces. A partir do momento em que voc√™ come√ßa a programar, voc√™ passa a entender o problema melhor. As vezes refatora√ß√£o √© um sinal de que voc√™ aprendeu alguma coisa.


=== Um plano de desenvolvimento

Um _plano de desenvolvimento_ √© um processo para escrever programas. O processo que usamos nesse estudo de caso √© ‚Äúencapsulamento e generaliza√ß√£o‚Äù. Os passos desse processo s√£o:
(((plano de desenvolvimento de programa)))

. Comece escrvendo um pequeno programa sem defini√ß√µes de fun√ß√µes.

. Uma vez que voc√™ fez com que o seu programa funcione, identifique um peda√ßo coerente dele, encapsule-o em uma fun√ß√£o e d√™ a ele um nome.

. Generalize a fun√ß√£o adicionando par√¢metros apropriados.

. Repita os passos 1-3 at√© que voc√™ tenha um conjunto de fun√ß√µes que funcionam. Copie e cole c√≥digo para evitar re-digit√°-los (e re-debug√°-los).

. Busque por oportunidades de melhora no programa atrav√©s da refatora√ß√£o. Por exemplo, se voc√™ tem um c√≥digo similar em v√°rios lugares, considere fator√°-lo em um fun√ß√£o geral apropriada.

Esse processo tem algumas desvantagens-n√≥s veremos as alternativas mais tarde-mas pode ser ut√≠l se voc√™ n√£o sabe previamente como dividir o programa em fun√ß√µes. Essa abordagem permite que voc√™ planeje conforme voc√™ vai projetando.


=== Docstring

Um _docstring_ √© uma string que vem antes de uma fun√ß√£o, e explica sua interface (‚Äúdoc‚Äù refere-se a ‚Äúdocumenta√ß√£o‚Äù). Aqui est√° um exemplo:
(((docstring)))(((triple quotes)))((("pass:[&quot;&quot;&quot;]", see="triple quotes")))

[source,julia]
----
"""
pol√≠linha(t, n, com, √¢ngulo)

Desenha n segmentos de linha dado o comprimento
e o √¢ngulo (em graus) entre eles.
t √© uma tartaruga.
"""
function pol√≠linha(t, n, com, √¢ngulo)
    for i in 1:n
        forward(t, com)
        turn(t, -√¢ngulo)
    end
end
----

A documenta√ß√£o pode ser acessada no REPL ou em um notebook digitando ? seguido pelo nome de uma fun√ß√£o ou macro, e apertando +ENTER+;
(((ajuda)))((("?", see="ajuda")))

----
help?> pol√≠linha
search:

  pol√≠linha(t, n, com, √¢ngulo)

  Desenha n segmentos de linha dado o comprimento e o √¢ngulo (em graus) entre eles. t √© uma tartaruga.
----

Docstrings s√£o comumente strings envolvidas por tr√™s aspas, tamb√©m conhecidas por strings multi-linha, pois as tr√™s aspas permitem que a string abranja mais de uma linha.

Uma docstring cont√©m a informa√ß√£o essencial que algu√©m precisaria para usar essa fun√ß√£o. Ela explica concisamente o que a fun√ß√£o faz (sem entrar em detalhes de como ela faz).

Ela explica que efeito cada par√¢metro tem no comportamento da fun√ß√£o e qual tipo cada par√¢metro deve ser (se n√£o √© √≥bvio).

[TIP]
====
Escrever esse tipo de documenta√ß√£o √© uma parte importante do design de interface. Uma interface bem projetada deve ser simples de explicar; se voc√™ encontra dificuldade em explicar uma de sua fun√ß√µes, talvez sua interface possa ser melhorada.
====


=== Debugando

Uma interface √© como um contrato entre a fun√ß√£o e quem a chama. Quem chama concorda em fornecer certos par√¢metros e a fun√ß√£o concorda em fazer certo trabalho.
(((debugando)))

Por exemplo, +pol√≠linha+ requer quatro argumentos: +t+ tem que ser uma tartaruga; +n+ tem que ser um inteiro; +com+ deve ser um n√∫mero positivo; e +√¢ngulo+ tem que ser um n√∫mero, que √© assumido estar em graus.

Esses requerimentos s√£o chamados de _pr√©-condi√ß√µes_ pois eles deveriam ser verdadeiros antes que a fun√ß√£o execute. Inversamente, condi√ß√µes no final da fun√ß√£o s√£o chamadas de _p√≥s-condi√ß√µes_. P√≥s-condi√ß√µes incluem o efeito desejado da fun√ß√£o (como desenhar segmentos de linha) e qualquer efeito colateral (como mover a tartaruga ou fazer outra mudan√ßa).
(((pr√©-condi√ß√£o)))(((p√≥s-condi√ß√£o)))

Pr√©-condi√ß√µes s√£o de responsabilidade de quem chama a fun√ß√£o. Se quem chama viola uma (propriamente documentada!) pr√©-condi√ß√£o e a fun√ß√£o n√£o funciona adequadamente, o bug est√° em quem chamou, e n√£o na fun√ß√£o.

Se as pr√©-condi√ß√µes s√£o satisfeitas e as p√≥s-condi√ß√µes n√£o, o bug est√° na fun√ß√£o. Se as suas pr√©- e p√≥s-condi√ß√µes forem claras, elas podem ajudar na hora de debugar.


=== Gloss√°rio

m√≥dulo::
Um arquivo que cont√©m uma cole√ß√£o de fun√ß√µes relacionadas e outras defini√ß√µes.
(((m√≥dulo)))

pacote::
Uma biblioteca externa com funcionalidade adicional.
(((pacote)))

declara√ß√£o using::
Uma declara√ß√£o que l√™ um arquivo m√≥dulo e cria um objeto m√≥dulo.
(((declara√ß√£o using)))

loop::
Uma parte do programa que executa repeditamente.
(((loop)))

encapsulamento::
O processo de transformar a sequ√™ncia de declara√ß√µes em uma defini√ß√£o de fun√ß√£o.
(((encapsulamento)))

generaliza√ß√£o::
O processo de substituir algo desnecessariamente espec√≠fico (como um n√∫mero) com algo geral adequado (como uma vari√°vel ou par√¢metro).
(((generaliza√ß√£o)))

interface::
Uma descri√ß√£o de como usar uma fun√ß√£o, incluindo o nome e as descri√ß√µes dos argumentos e o valor de retorno.
(((interface)))

refatora√ß√£o::
O processo de modificar um programa funcional para melhorar a interface da fun√ß√£o e outras qualidades do c√≥digo.
(((refatora√ß√£o)))

Plano de desenvolvimento::
Um processo para escrever programas.
(((Plano de desenvolvimento)))

docstring::
Uma string que aparece no topo de uma defini√ß√£o de fun√ß√£o para documentar a interface da fun√ß√£o.
(((docstring)))

pr√©-condi√ß√£o::
Um requerimento que deve ser satisfeito por quem chama antes da fun√ß√£o iniciar.
(((pr√©-condi√ß√£o)))

p√≥s-condi√ß√£o::
Um requerimento que deve ser satisfeito pela fun√ß√£o antes de acabar.
(((p√≥s-condi√ß√£o)))


=== Exerc√≠cios

[[ex04-7]]
===== Exerc√≠cio 4-8

Digite o c√≥digo neste c√°pitulo em um notebook.

. Desenhe um diagrama de pilha que mostra o estado do programa enquanto ele √© executado +c√≠rculo(üê¢, raio)+. Voc√™ pode contar no dedo ou adicionar declara√ß√µes de impress√£o no c√≥digo.

. A vers√£o de +arc+ em <<refatora√ß√£o>> n√£o √© muito precisa dado que a aproxima√ß√£o linear do c√≠rculo est√° sempre fora do verdadeiro c√≠rculo. Como resultado, a tartaruga acaba alguns pix√©is depois do destino correto. Minha solu√ß√£o mostra uma maneira de reduzir o efeito desse erro. Leia o c√≥digo e veja se faz sentido para voc√™. Se voc√™ desenhar o diagrama, √© poss√≠vel que voc√™ veja como funciona.
(((arc)))

[source,julia]
----
"""
arc(t, r, √¢ngulo)

Desenha um arco dado o raio e √¢ngulo:
    t: tartaruga
    r: raio
    √¢ngulo: √¢ngulo feito pelo arco, em graus
"""
function arc(t, r, √¢ngulo)
    com_arc = 2 * œÄ * r * abs(√¢ngulo) / 360
    n = trunc(com_arc / 4) + 3
    com_passo = com_arc / n
    ang_passo = √¢ngulo / n

    # fazendo uma leve curva para a esquerda antes de
    # iniciar reduz o erro causado pela aproxima√ß√£o
    # linear do arco
    turn(t, -ang_passo/2)
    pol√≠linha(t, n, com_passo, ang_passo)
    turn(t, ang_passo/2)
end
----

[[ex04-8]]
===== Exerc√≠cio 4-9

Escreva um conjunto geral de fun√ß√µes apropriadas que podem desenhar flores como em <<fig04-2>>.

[[fig04-2]]
.Flores de Tartaruga
image::images/fig42.svg[]

[[ex04-9]]
===== Exerc√≠cio 4-10

Escreva um conjunto geral de fun√ß√µes apropriadas que podem desenhar formas como as em <<fig04-3>>.

[[fig04-3]]
.Tortas de Tartaruga
image::images/fig43.svg[]

[[ex04-10]]
===== Exerc√≠cio 4-11

As letras do alfabeto podem ser constru√≠das a partir de um n√∫mero moderado de elementos b√°sicos, como linhas verticais e horizontais e algumas curvas. Projete um alfabeto que pode ser desenhado com o m√≠nimo n√∫mero de elementos b√°sicos e em seguida escreva fun√ß√µes que podem desenhar letras.

Voc√™ deve escrever uma fun√ß√£o para cada letra, com nomes +desenha_a+, +desenha_b+, etc. E coloque suas fun√ß√µes em um arquivo chaamdo _letras.jl_.

[[ex04-11]]
===== Exerc√≠cio 4-12

Leia sobre espirais em https://pt.wikipedia.org/wiki/Espiral; em seguida escreva um programa que desenha uma espiral de Arquimedes como em <<fig04-4>>.

[[fig04-4]]
.Espiral de Archimedes
image::images/fig44.svg[]
