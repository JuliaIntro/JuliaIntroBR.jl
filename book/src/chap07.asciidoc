[[chap07]]
== Iteração

Esse capítulo é sobre iteração, que é a habilidade de executar um bloco de argumentos repetidamente. Vimos  um tipo de iteração, usando recursão, em <<recursão>>. Vimos também outro tipo, usando um laço +for+, em <<repetição simples>>. Neste capítulo veremos um outro tipo, que usa uma declração +while+ (_enquanto_ em Português). Mas primeiro eu tenho que dizer um pouco mais sobre atribuição de variável.
(((iteração)))(((recursão)))(((declaração for)))


=== Reatribuição

Você talvez tenha descoberto que é permitido fazer mais de uma atribuição para as mesmas variáveis. Uma nova atribuição faz com que uma variável existente se refira a um novo valor (e pare de se referir ao valor antigo).

[source,@julia-repl-test chap07]
----
julia> x = 5
5
julia> x = 7
7
----

A primeira vez que exibimos +x+, o seu valor é 5; na segunda vez, o seu valor é 7.

[[fig07-1]]
.Diagrama de estado
image::images/fig71.svg[]

<<fig07-1>> mostra como uma _reatribuição_ funciona por meio de um diagrama de estado
(((reatribuição)))(((diagrama de estado)))

Neste ponto, quero abordar um assunto comum de confusão. Como o Julia usa o sinal de igual (+=+) para a atribuição, é tentador interpretar uma afirmação como +a = b+ como uma proposição matemática de igualdade; isto é, a afirmação de que +a+ e +b+ são iguais. Mas essa interpretação está errada.
(((comando de atribuição)))

Primeiro, a igualdade é uma relação simétrica e a atribuição não é. Por exemplo, em matemática, se latexmath:[\(a=7\)] então latexmath:[\(7=a\)]. Mas em Julia, a atribuição +a=7+ é permitida e +7=a+ não.

Também na matemática, uma proposição de igualdade ou é verdadeira ou é falsa para sempre. Se latexmath:[\(a=b)\)] agora, então latexmath:[\(a\)] será sempre igual a latexmath:[\(b\)]. Em Julia, um comando de atribuição pode fazer duas variáveis iguais, mas eles não precisam ficar assim:

[source,@julia-repl-test]
----
julia> a = 5
5
julia> b = a    # a and b are now equal
5
julia> a = 3    # a and b are no longer equal
3
julia> b
5
----

A terceira linha altera o valor de +a+ mas não altera o valor de +b+, portanto eles não são mais iguais.

[WARNING]
====
A reatribuição de variáveis geralmente é útil, mas você deve usá-la com cuidado. Se os valores das variáveis mudarem com frequência, isso poderá dificultar a leitura e o debugging do código.

Não é permitido definir uma função que tenha o mesmo nome de uma variável definida anteriormente.
====


=== Atualizando Variáveis

Um tipo comum de reatribuição é uma atualização, onde o novo valor da variável depende da antiga.
(((atualização)))

[source,@julia-repl-test chap07]
----
julia> x = x + 1
8
----

Isso significa “pegar o valor atual de +x+, adicionar um, e então atualizar +x+ ao novo valor.”

Se você tenta atualizar uma variável que não existe, uma mensagem de erro aparecerá, porque Julia avalia o lado direito antes de atribuir um valor a ++:
(((UndefVarError)))(((Erro de Variável Indefinida)))

[source,@julia-repl-test]
----
julia> y = y + 1
ERROR: UndefVarError: y not defined
----

Antes que você possa atualizar uma variável, você tem que inicializá-la, geralmente com uma atribuição simples:
(((inicialização)))

[source,@julia-repl-test]
----
julia> y = 0
0
julia> y = y + 1
1
----

Atualizar uma variável adicionando 1 é chamado de _incremento_; e subtraindo 1 é chamado de _decremento_.
(((incremento)))(((decremento)))


=== A Declaração +while+

Os computadores são frequentemente usados para automatizar tarefas repetitivas. Repetir tarefas idênticas ou semelhantes sem cometer erros é algo que os computadores fazem bem e as pessoas fazem mal. Em um programa de computador, a repetição também é chamada de _iteração_.
(((iteração)))

Já vimos duas funções, +contador_regressivo+ e +imprima_n+, que iteram usando recursão. Como a iteração é muito comum, Julia dispõe recursos para simplificá-la. Um deles é a declaração +for+ que vimos em <<simple_repetition>>. Voltaremos a este assunto mais tarde.
(((recursão)))(((declaração for)))

A outra é para a _declaração_ +while+. Aqui está a versão do +contagem_regressiva+ que utiliza a declaração +while+:
(((while)))((("keyword", "while", see="while")))(((declaração while)))((("atribuição", "while", see="declaração while")))

[source,@julia-setup]
----
function contagem_regressiva(n)
    while n > 0
        print(n, " ")
        n = n - 1
    end
    println("Vai!")
end
----

Você pode ler quase toda a atribuição +while+ como se estivesse em inglês (ou _Português_). Isso significa que "Enquanto +n+ for maior que 0, exiba o valor de +n+ e diminua +n+. Quando chegar a 0, imprima a palavra Vai!"
(((contagem_regressiva)))

Formalmente, aqui está o fluxo de execução de uma atribuição +while+:
(((fluxo de execução)))

. Determinar se a condição é verdadeira ou falsa.

. Se for falsa, saia da atribuição _while_ e continue a execução para o próximo comando.

. Se a condição for verdadeira, execute os comandos e então volte para o passo 1.

Esse tipo de fluxo é chamado de laço porque o terceiro passo retorna ao topo.
(((laço)))

O corpo do laço deve mudar o valor de uma ou mais variáveis até que a condição eventualmente se torna falsa e o laço é finalizado. Caso contrário, o laço irá se repetir para sempre, que é um _laço infinito_. Uma fonte inesgotável de diversão para os cientistas da computação são as instruções nos frascos de shampoo, “ensaboar, enxaguar, repetir”, que é um laço infinito.
(((laço infinito)))

No caso da +contagem_regressiva+, podemos provar que o laço é finalizado: se +n+ é zero ou negativo, o laço nunca termina. Caso contrário, +n+ vai diminuindo através do laço, e então eventualmente chegará a 0.

Para alguns laços, não é tão fácil de provar. Por exemplo:
(((seq)))((("função", "definido pelo programador", "seq", see="seq")))

[source,@julia-setup]
----
function seq(n)
    while n != 1
        println(n)
        if n % 2 == 0        # n é par
            n = n / 2
        else                 # n é ímpar
            n = n*3 + 1
        end
    end
end
----

A condição para esse laço é +n != 1+, então esse laço irá continuar até que +n+ atinja 1, o que faz a condição ser falsa.

A cada turno do laço, o programa tem como saída o valor +n+ que é verificado se é par ou ímpar. Se for par, +n+ é divisível por 2. Se é ímpar, o valor de +n+ é substituído por +pass:[n*3 + 1]+. Por exemplo, se o argumento da sequência é 3, os valores de +n+ recebidos são 3, 10, 5, 16, 8, 4, 2, 1.

Já que +n+ as vezes cresça e as vezes decresça, não existe uma demonstração óbvia de que +n+ alcançará 1, ou que o programa termine. Para alguns valores particulares de +n+, podemos demonstrar que termina. Por exemplo, se o valor inicial é uma potência de dois, +n+ será sempre par através do laço até que atinja 1. O exemplo anterior finaliza essa sequência, a partir de 16.

A parte difícil é se podemos provar que esse programa finaliza para todos os valores positivos de +n+. Portanto, até agora ninguém foi capaz de provar ou desprovar isso! (consulte https://en.wikipedia.org/wiki/Collatz_conjecture.)
(((Conjectura de Collatz)))

===== Exercício 7-1

Reescreva a função +imprima_n+ de <<Recursão>> usando iteração ao invés de recursão.


=== +break+

Às vezes, você não sabe que é hora de terminar um laço até chegar na metade do corpo. Neste caso você pode utilizar a _declaração break_ para sair do laço.
(((break)))((("palavra-chave", "parada", see="parada")))(((declaração break)))((("atribuição", "parada", see="declaração break")))

Por exemplo, suponha que você quer receber entradas do usuário até que ele digite concluído. Você poderia escrever:
(((readline)))

[source,julia]
----
while true
    print("> ")
    linha = readline()
    if linha == "concluído"
        break
    end
    println(linha)
end
println("Concluído!")
----

A condição deste laço é +true+, o que ocorre sempre, então o laço irá ser executado até chegar na declaração break.

A cada iteração, a solicitação ao usuário ocorre por meio de um sinal de maior (">"). Se o usuário digitar +concluído+, então o comando break finaliza o laço. Caso contrário, o programa mostrará o que o usuário digitar e voltará ao topo do laço. Aqui está uma mostra de execução:

[source]
----
> não está concluído
não está concluído
> concluído
Concluído!
----

Esse jeito de escrever laços é comum porque você pode verificar a condição em qualquer lugar do laço (não apenas no topo) e você pode expressar a condição de parada afirmativamente ("pare quando isso acontecer") tanto quanto negativamente ("continue enquanto isso acontece").


=== +continue+

A declaração break sai do laço. Quando uma _declaração continue_ é encontrado dentro de um laço, salta-se para o início do laço para a próxima iteração, pulando a execução de comandos dentro do corpo do laço para a iteração atual. Por exemplo:
(((continue)))((("palavra-chave", "continue", see="continue")))(((declaração continue)))((("atribuição", "continuar", see="continuar", see="declaração continue")))

[source,@julia]
----
for i in 1:10
    if i % 3 == 0
        continue
    end
    print(i, " ")
end
----

Se +i+ é divisível por 3, a declaração continue para na iteração atual e a próxima iteração é iniciada. Apenas os números no intervalo entre 1 a 10 não divisíveis por 3 são exibidos.

[[raizes_quadradas]]
=== Raízes Quadradas

Laços são geralmente usados em programas que computam resultados numéricos começando com um valor aproximado e é refinado iterativamente.

Por exemplo, um jeito de computar raízes quadradas é através do Método de Newton. Suponha que você quer saber a raíz quadrada de latexmath:[\(a\)]. Se você começar com quase qualquer uma estimativa, latexmath:[\(x\)], pode-se computar uma estimativa melhor com a seguinte fórmula:
(((Método de Newton)))

[latexmath]
++++
\begin{equation}
{y = \frac{1}{2}\left(x + \frac{a}{x}\right)}
\end{equation}
++++
Por exemplo, se latexmath:[\(a\)] é 4 e latexmath:[\(x\)] é 3:

[source,@julia-repl-test chap07]
----
julia> a = 4
4
julia> x = 3
3
julia> y = (x + a/x) / 2
2.1666666666666665
----

O resultado está mais próximo da resposta correta (latexmath:[\(\sqrt 4 = 2\)]). Se repetirmos o processo com a nova estimativa, irá ficar mais próximo ainda:

[source,@julia-repl-test chap07]
----
julia> x = y
2.1666666666666665
julia> y = (x + a/x) / 2
2.0064102564102564
----

Depois de mais algumas atualizações, a estimativa é quase exata:

[source,@julia-repl-test chap07]
----
julia> x = y
2.0064102564102564
julia> y = (x + a/x) / 2
2.0000102400262145
julia> x = y
2.0000102400262145
julia> y = (x + a/x) / 2
2.0000000000262146
----

Em geral, não sabemos antecipadamente quantas etapas são necessárias para obter a resposta certa, mas sabemos quando chegamos lá porque a estimativa para de mudar:

[source,@julia-repl-test chap07]
----
julia> x = y
2.0000000000262146
julia> y = (x + a/x) / 2
2.0
julia> x = y
2.0
julia> y = (x + a/x) / 2
2.0
----

Quando +y == x+, podemos parar. Aqui está um laço que começa com uma estimativa inicial, +x+, e melhora até parar de mudar

[source,julia]
----
while true
    println(x)
    y = (x + a/x) / 2
    if y == x
        break
    end
    x = y
end
----

Esta função funciona bem para a maior parte dos valores de a, mas em geral é perigoso testar igualdade com pontos flutuantes. Pontos flutuantes não são totalmente corretos: a maioria dos números racionais como latexmath:[(\frac{1}{3})], e números irracionais como latexmath:[(\sqrt 2)], não podem ser representados exatamente com um tipo +Float64+.

Em vez de verificar se +x+ e +y+ são exatamente iguais, é mais seguro usar a função interna +abs+ para calcular o valor absoluto, ou magnitude, da diferença entre eles:
(((abs)))

[source,julia]
----
if abs(y-x) < ε
    break
end
----

Onde +ε+ (*+\varepsilon TAB+*) possui um valor como +0.0000001+ que determina o quão suficientemente próximo está.


=== Algoritmos

O Método de Newton é um exemplo de um _algoritmo_: É um processo mecânico para resolver uma categoria de problemas (neste caso, o cálculo de raízes quadradas).
(((algoritmo)))

Para entender o que é um algoritmo, ajudaria começar com algo que não é um algoritmo. Quando você aprendeu a multiplicar unidades, você provavelmente memorizou a tabuada. De fato, você memorizou 100 soluções específicas. Esse tipo de conhecimento não é um algoritmo.

Mas se você fosse "preguiçoso", talvez tivesse aprendido alguns truques. Por exemplo, para encontrar o produto de latexmath:[\(n\)] e 9, você escreve latexmath:[\(n-1\)] no primeiro dígito e latexmath:[\(10-n\)] no segundo dígito. Esse truque é uma solução geral para multiplicar qualquer unidade por 9. Isso é um algoritmo!

Similarmente, as técnicas que você aprendeu para a adição com transporte de unidades, a subtração com empréstimos e a divisão longa são todos algoritmos. Uma das características dos algoritmos é que eles não exigem nenhuma inteligência para serem executados. São processos mecânicos em que cada etapa segue a partir da última, de acordo com um conjunto simples de regras.

A execução de algoritmos é chata, mas elaborá-los é interessante, intelectualmente desafiador e uma parte central da ciência da computação.

Algumas das coisas que as pessoas fazem naturalmente, sem dificuldade ou pensamento consciente, são as mais difíceis de expressar por algoritmos. Compreender a linguagem natural é um bom exemplo. Todos fazemos isso, mas até agora ninguém foi capaz de explicar como fazemos, pelo menos não na forma de um algoritmo.


=== Debugando

Ao começar a escrever programas maiores, você pode passar mais tempo debugando. Mais código significa mais chances de cometer um erro e mais lugares para os erros se esconderem.
(((debugando)))

Uma maneira de reduzir o tempo do debugging é o “debugging por bissecção”. Por exemplo, se houver 100 linhas no seu programa e você verificá-las uma de cada vez, serão necessárias 100 etapas.
(((debugging por bissecção)))

Em vez disso, tente quebrar o problema ao meio. Olhe no meio do programa, ou perto dele, para um valor intermediário que você pode verificar. Adicione um comando print (ou qualquer outra coisa que tenha um propósito de verificação) e execute o programa
(((comando print)))

Se a verificação da região do meio estiver incorreta, deve haver um problema na primeira metade do programa. Se estiver correto, o problema está na segunda metade.

Toda vez que você executa uma verificação como essa, reduz_-se_ pela metade o número de linhas que precisa averiguar. Após seis etapas (que é menor que 100), você reduziria para uma ou duas linhas de código, pelo menos em teoria.

Na prática, nem sempre é claro onde é o "meio do programa e nem sempre é possível verificá-lo. Não faz sentido contar linhas e encontrar o ponto médio exato. Em vez disso, pense nos locais do programa em que pode haver erros e nos locais onde é fácil fazer uma verificação. Em seguida, escolha um local onde você acha que as chances são as mesmas de que o bug seja antes ou depois da verificação.


=== Glossário

reatribuição::
Atribuindo um novo valor a uma variável que já existe.
(((reatribuição)))

atualização::
Uma atribuição em que o novo valor da variável depende do antigo.
(((atualização)))

inicialização::
Uma atribuição que fornece um valor inicial a uma variável que será atualizada.
(((inicialização)))

incremento::
Uma atualização que aumenta o valor de uma variável (geralmente em um).
(((incremento)))

decremento::
Uma atualização que diminui o valor de uma variável.
(((decremento)))

iteração::
Execução repetida de um conjunto de comandos usando uma chamada de função recursiva ou um laço.
(((iteração)))

declaração while::
declração que permite iterações controladas por uma condição.
(((declaração while)))

declaração break::
declração que permite saltar fora de um laço.
(((declaração break)))

declaração continue::
declaração dentro de um laço que salta para o início do laço para a próxima iteração.
(((declaração continue)))

laço infinito::
Um laço no qual a sua condição nunca é satisfeita.
(((laço infinito)))

algoritmo::
Um processo geral para resolver uma categoria de problemas.
(((algoritmo)))


=== Exercícios

[[ex07-1]]
===== Exercício 7-2

Copie o laço de <<square_roots>> e encapsule-o em uma função chamada +minha_raiz+ que use +a+ como parâmetro, e escolha um valor razoável de +x+ e retorne uma estimativa da raiz quadrada de +a+.
(((minha_raiz)))((("função", "definido pelo programador", "minha_raiz", see = "minha_raiz"))))

Para testá-la, escreva uma função chamada +testa_raiz+ que imprime uma tabela como esta:
(((testa_raiz)))((("função", "definido pelo programador", "testa_raiz", see = "testa_raiz"))))

[fonte, @ julia-eval]
----
using ThinkJulia
io = IOBuffer()
testa_raiz(io)
fora = String(take!(io))
println(fora)
----

A primeira coluna é o número +a+; a segunda coluna é a raiz quadrada de +a+ calculado com +minha_raiz+; a terceira coluna é a raiz quadrada calculada por +sqrt+; a quarta coluna é o valor absoluto da diferença entre as duas estimativas.

[[ex07-2]]
===== Exercício 7-3

A função interna +Meta.parse+ pega uma string e a transforma em uma expressão. Essa expressão pode ser avaliada em Julia com a função +Core.eval+. Por exemplo:
(((parse)))((("função","Meta","parse", see="parse"))) (((eval)))((("function", "Core", "eval", see="eval")))

[fonte, @ julia-eval chap07]
----
import Base.eval
----

[fonte, @ julia-repl-test chap07]
----
julia> expr = Meta.parse ("1 + 2 * 3")
: (1 + 2 * 3)
julia> eval (expr)
7
julia> expr = Meta.parse ("sqrt (π)")
: (sqrt (π))
julia> eval (expr)
1.7724538509055159
----

Escreva uma função chamada +avalie_laço+ que solicite iterativamente ao usuário, e então pegue a entrada recebida e a avalie usando +eval+ e depois imprima o resultado. Ele deve continuar até o usuário digitar +concluído+ e retornar o valor da última expressão avaliada.

(((avalie_laço)))((("função", "definido pelo programador", "avalie_laço", see= "avalie_laço")))

[[ex07-3]]
===== Exercício 7-4

O matemático Srinivasa Ramanujan encontrou uma série infinita que pode ser usada para gerar uma aproximação numérica de latexmath:[\(\frac{1}{\pi}\)]:

[latexmath]
++++
\begin{equation}
{\frac{1}{\pi}=\frac{2\sqrt2}{9801}\sum_{k=0}^\infty\frac{(4k)!(1103+26390k)}{(k!)^4 396^{4k}}}
\end{equation}
++++

Escreva uma função chamada +estimativa_pi+ que use essa fórmula para calcular e retornar uma estimativa de π. Ele deve usar um laço while para calcular os termos da soma até que o último termo seja menor que +1e-15+ (que é a notação Julia para latexmath:[(10^{-15}\)]). Você pode verificar o resultado comparando-o com +π+.
(((estimativa_pi)))((("função", "definido pelo programador", "estimativa_pi", see = "estimativa_pi"))))
