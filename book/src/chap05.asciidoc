[[chap05]]
== Condicionais e Recursão

O principal tópico deste capítulo é a atribuição +if+, da qual executa diferentes códigos dependendo do critério do programa. Mas antes eu quero introduzir dois novos operadores: Divisão Inteira e módulo.


=== Divisão Inteira e Módulo

O operador de _Divisão Inteira_, +÷+ (*+\div TAB+*), divide dois números e arredonda pra baixo para um inteiro. Por exemplo, suponha que o tempo de execução de um filme seja de 105 minutos. Você talvez saiba o quanto equivale em horas. A divisão convencional retorna um número em ponto-flutuante:
(((operador Divisão Inteira)))((("operador", "Base", "÷", see="operador Divisão Inteira")))((("÷", see="operador Divisão Inteira")))

[source,@julia-repl-test chap05]
----
julia> minutos = 105
105
julia> minutos / 60
1.75
----

Porém normalmente não escrevemos horas com pontos decimais. Divisão Inteira retorna um número inteiro de horas, arredondando para baixo:

[source,@julia-repl-test chap05]
----
julia> horas = minutos ÷ 60
1
----

Para obter o restante, você pode subtrair uma hora em minutos:

[source,@julia-repl-test chap05]
----
julia> restante = minutos - houras * 60
45
----

Uma alternativa é usar o _operador módulo_, +%+, que divide dois números e retorna o resto.
(((operador módulo)))((("operador", "Base", "%", see="operador módulo")))((("%", see="operador módulo")))

[source,@julia-repl-test chap05]
----
julia> remainder = minutes % 60
45
----

[TIP]
====
O operador módulo é mais útil do que parece. Por exemplo, você pode verificar se um número é divisível por outro — se +x % y+ é zero, então +x+ é divisível por +y+.

Além disso, você pode extrair o dígito ou dígitos mais à direita de um número. Por exemplo, +x % 10+ gera o dígito mais à direita de um inteiro +x+ (na base 10). Da mesma forma +x % 100+ produz os últimos dois dígitos.
====


=== Expressões Booleanas

Uma _expressão booleana_ é uma expressão que é ou verdadeira ou falsa.  Os seguintes exemplos usam o operador +==+, que compara dois operandos e gera +true+ se forem iguais e +false+ footnote:[_True_ e _False_ são comunente utilizadas nas linguagens de programação e são traduzidas, respectivamente como _verdadeiro_ e _falso_]
(((expressão booleana)))(((true)))(((false)))

[source,@julia-repl-test]
----
julia> 5 == 5
true
julia> 5 == 6
false
----

+true+ e +false+ são valores especiais que pertencem ao tipo +Bool+; esses valores não são strings:
(((Bool)))((("tipo", "Base", "Bool", see="Bool")))

[source,@julia-repl-test]
----
julia> typeof(true)
Bool
julia> typeof(false)
Bool
----

O operador +==+ é um operador de relação; os outros são:
(((operador de relação)))(((==)))((("operador", "Base", "==", see="==")))

[source,julia]
----
      x != y               # x não é igual a y
      x ≠ y                # (\ne TAB)
      x > y                # x é maior que y
      x < y                # x é menor que y
      x >= y               # x é maior ou igual a y
      x ≥ y                # (\ge TAB)
      x <= y               # x é menor ou igual a y
      x ≤ y                # (\le TAB)
----

[WARNING]
====
Embora essas operações sejam provavelmente familiares para você, os símbolos Julia são diferentes dos símbolos matemáticos. Um erro comum é usar um único sinal de igual (+=+) em vez de um duplo sinal de igual (+==+). Lembre-se de que +=+ é um operador de atribuição e +==+ é um operador relacional. Não existe +=<+ ou +pass:[=>]+.
(((≠)))((("operador", "Base", "≠", see="≠")))((("!=", see="≠")))((("operador", "Base", "!=", see="≠")))(((>)))((("operador", "Base", ">", see=">")))(((<)))((("operador", "Base", "<", see="<")))(((≥)))((("operador", "Base", "≥", see="≥")))(((">=", see="≥")))((("operador", "Base", ">=", see="≥")))(((≤)))((("operador", "Base", "≤", see="≤")))((("pass:[&lt;=]", see="≤")))((("operador", "Base", "pass:[&lt;=]", see="≤")))
====


=== Operadores Lógicos

Existem três _Operadores Lógicos_: +&&+ (e), +||+ (ou) e +!+ (não). A semântica (significado) destes operadores são similiares aos seus significados em Português. Por exemplo, +x > 0 && x < 10+ é verdadeiro se e somente se +x+ é maior que 0 _e_ menor que +10+.
(((operador lógico)))(((&&)))(((||)))(((!)))

+n % 2 == 0 || n % 3 == 0+ é verdadeiro se _uma ou ambas_ condições são verdadeiras, isto é, se o número é divisível por 2 _ou_ por 3.

Ambos +&&+ e +||+ associam à direita, mas +&&+ tem maior precedência que +||+.

Por fim, o operador +!+ nega uma expressão booleana, então +!(x > y)+ é verdadeira se +x > y+ é falsa, isto é, se +x+ é menor ou igual a +y+.


=== Execução Condicional

Para escrever programas úteis, quase sempre precisamos verificar as condições e alterar o comportamento de acordo com o programa. _Declarações Condicionais_ nos fornece essa habilidade. A forma mais simples é a atribuição _se_ (_if_ em Inglês).
(((atribuição condicional)))(((if)))((("palavra-chave", "se", see="se")))(((atribuição se)))((("atribuição", "se", see="atribuição se")))

[source,julia]
----
if x > 0
    println("x é positivo")
end
----

A expressão booleana depois de +if+ é chamada de _condição_. Se é verdadeira, então a atribuição indentada é executada. Se não, nada acontece. 
(((condição)))

A atribuição _se_ possui a mesma estrutura das definições de funções: Um cabeçalho seguido de um corpo terminado com a palavra-chave _end_. Declarações como essa são chamadas de _declarações compostas_.
(((declarações compostas)))(((end)))

Não há limites para o número de declarações que podem aparecer no corpo. Ocasionalmente, é útil ter um corpo sem declarações (geralmente como detentor de um lugar para o código que você ainda não escreveu).

[source,julia]
----
if x < 0
    # TODO: precisa lidar com valores negativos!
end
----


=== Execuções Alternativas

Uma segunda maneira de usar a atribuição _se_ é a "execução alternativa", da qual há duas possibilidades e a condição determina qual delas deverá ser executada. A sintaxe é a seguinte:
(((execução alternativa)))(((se não)))((("palavra-chave", "se não", see="se não")))

[source,julia]
----
if x % 2 == 0
    println("x é par")
else
    println("x é ímpar")
end
----

Se o resto da divisão de +x+ por 2 é 0, então sabemos que +x+ é par, e o programa irá exibir a mensagem apropriada. Se a condição for falsa, o segundo conjunto de declarações é executado. Desde que a condição seja verdadeira ou falsa, exatamente uma das alternativas irá ser executada. Essas alternativas são chamadas de _ramos_ (_branches_ em inglês), porque são ramos de um fluxo de execução.
(((ramos)))


=== Condicionais Encadeadas

Algumas vezes há mais do que duas possibilidades e precisamos de mais que dois ramos. Uma maneira de expressar um comando como esse é através das _condicionais encadeadas_:
(((condicionais encadeadas)))(((se então)))((("palavra-chave", "se então", see="se então")))

[source,julia]
----
if x < y
    println("x é menor que y")
elseif x > y
    println("x é maior que y")
else
    println("x e y são iguais")
end
----

Novamente, exatamente um dos ramos será executado. Não há limites para o número de declarações +else if+. Se existir uma cláusula +else+, essa deve estar no final, mas não precisa haver uma.

[source,julia]
----
if escolha == "a"
    draw_a()
elseif escolha == "b"
    draw_b()
elseif escolha == "c"
    draw_c()
end
----

Cada condição é checada em ordem. Se a primeira for falsa, a próxima é checada e assim por diante. Se uma delas é verdadeira, o ramo correspondente é executado e a atribuição é encerrada. Se mais de uma condição é verdadeira, apenas o primeiro ramo verdadeiro é executado.


=== Condicionais Aninhadas

Uma condicional também pode ser aninhada com outra. Poderíamos ter escrito no exemplo da seção anterior da seguinte forma:
(((condicionais aninhadas)))

[source,julia]
----
if x == y
    println("x e y são iguais")
else
    if x < y
        println("x é menor que y")
    else
        println("x é maior que y")
    end
end
----

O condicional externo contém dois ramos. O primeiro ramo contém uma atribuição simples. O segundo ramo contém outra atribuição +if+, da qual possui dois ramos inserida nela. Esses dois ramos são declarações simples, embora também possam ter sido declarações condicionais.

Embora a indentação não obrigatória das declarações torne a estrutura aparente, _condicionais aninhadas_ tornam-se difíceis de ler muito rapidamente. É uma boa ideia evitá-los quando puder.
(((indentação)))

Operadores lógicos geralmente fornecem uma maneira de simplificar instruções condicionais aninhadas. Por exemplo, podemos reescrever o seguinte código usando uma única condicional:

[source,julia]
----
if 0 < x
    if x < 10
        println("x é um número positivo de um dígito.")
    end
end
----

A atribuição +print+ executa somente se passarmos pelos dois condicionais, para que possamos obter o mesmo efeito com operador +&&+:

[source,julia]
----
if 0 < x && x < 10
    println("x é um número positivo de um dígito.")
end
----

Para esse tipo de condição, o Julia fornece uma sintaxe mais concisa:

[source,julia]
----
if 0 < x < 10
    println("x é um número positivo de um dígito.")
end
----


[[recursion]]
=== Recursão

É permitido que uma função chame outra; também é permitido uma função chamar si mesmo. Pode não ser óbvio por que isso é uma coisa boa, mas acaba sendo uma das coisas mais mágicas que um programa pode fazer. Por exemplo, observe a seguinte função:
(((contagem regressiva)))((("função", "definido pelo programador", "contagem regressiva", see="contagem")))

[source,@julia-setup chap05]
----
function contagem_regressiva(n)
    if n ≤ 0
        println("Vai!")
    else
        print(n, " ")
        contagem_regressiva(n-1)
    end
end
----

Se +n+ é 0 ou negativo, será exibido a palavra, +"Vai!"+, por outro lado, exibirá +n+ e executará a função chamada +contagem_regressiva+ — ela mesma — passando +n-1+ como argumento.

O que acontece se chamarmos uma função como essa?

[source,@julia-repl-test chap05]
----
julia> contagem_regressiva(3)
3 2 1 Vai!
----

A execução de +contagem_regressiva+ começa com +n = 3+, e desde que +n+ seja maior que 0, terá como saída o valor 3, e depois executa ela mesma...

pass:[&#8193;]A execução de +contagem_regressiva+ começa com +n = 2+, e desde que +n+ seja maior que 0, pass:[<br/>&#8193;&#8193;]terá como saída o valor 2, e depois executa ela mesma ...

pass:[&#8193;&#8193;]A execução de +contagem_regressiva+ começa com +n = 1+, e desde que +n+ seja maior que 0, pass:[<br/>&#8193;&#8193;&#8193;]terá como saída o valor 1, e depois executa ela mesma ...

pass:[&#8193;&#8193;&#8193;]A execução de +contagem_regressiva+ começa com +n = 0+, e desde que +n+ seja maior que pass:[<br/>&#8193;&#8193;&#8193;&#8193;]0, terá como saída uma palavra, +"Vai!"+ e depois retorna.

pass:[&#8193;&#8193;]A contagem regressiva que obteve +n = 1+ retorna.

pass:[&#8193;]A contagem regressiva que obteve +n = 2+ retorna.

A contagem regressiva que obteve +n = 3+ retorna.

E então você voltará para +Main+.

Uma função que chama a si mesma é chamada de _recursiva_; o processo de executar ela é chamada de _recursão_.
(((função recursiva)))(((recursão)))

Um outro exemplo, podemos escrever uma função que imprime uma string latexmath:[\(n\)] vezes.
(((printn)))((("função", "definido pelo programador", "printn", see="printn")))

[source,julia]
----
function imprima_n(s, n)
    if n ≤ 0
        return
    end
    println(s)
    printn(s, n-1)
end
----

Se +n pass:[&lt;]= 0+ a atribuição +return+ sai da função. O fluxo de execução retorna imediatamente para quem a chamou e as linhas restantes da função não são executadas.
(((return)))((("palavra-chave", "return", see="return")))(((declaração de retorno)))((("declaração", "return", see="declaração de retorno")))

O restante da função é similar a +contagem_regressiva+: Exibirá +s+ e chamará a si mesmo para exibir +s+ latexmath:[\(n-1\)] várias vezes. Portanto, o número de linhas de saída é latexmath:[\(1 + (n - 1)\)], o que soma latexmath:[\(n\)].

Para exemplos simples como esse, provavelmente é mais fácil usar um loop +for+. Mas veremos exemplos mais tarde que são difíceis de escrever com um loop +for+ e fáceis de escrever com recursão; portanto, é bom começar cedo.

=== Diagramas de Pilhas para funções recursivas

Em <<stack_diagrams>>, usamos um diagrama de pilha para representar o estado de um programa durante uma chamada de função. O mesmo tipo de diagrama pode ajudar a interpretar uma função recursiva.
(((diagrama de pilha)))

Sempre que uma função é chamada, o Julia cria um quadro para conter as variáveis e parâmetros locais da função. Para uma função recursiva, pode haver mais de um quadro na pilha ao mesmo tempo.
(((quadro)))

[[fig05-1]]
.Diagrama de Pilha
image::images/fig51.svg[]


<<fig05-1>> mostra um diagrama de pilha para +contagem_regressiva+ chamada com +n = 3+.

Como sempre, o topo da pilha é o quadro para +Main+. Ele está vazio porque não criamos nenhuma variável em +Main+ ou nem passamos argumentos para ela.

Os quatro quadros de +contagem_regressiva+ têm valores diferentes para o parâmetro +n+. A parte inferior da pilha, onde +n=0+, é chamada de _caso base_. Ele não faz uma chamada recursiva, portanto não há mais quadros.
(((caso base)))

===== Exercício 5-1

Como exercício, desenhe um diagrama de pilha para +printn+ chamado com +s = "Olá"+ e +n = 2+. Depois, escreva uma função chamada +do_n+ que pega um objeto de função e um número, +n+, como argumento, e que chama a função dada latexmath:[\(n\)] vezes.

=== Recursão Infinita

Se uma recursão nunca atinge o caso base, ele continua fazendo chamadas recursivas para sempre e o programa nunca termina. Isso é conhecido como _recursão infinita_, e geralmente isso não é uma boa ideia. Aqui está um programa pequeno com uma recursão infinita:
(((recursão infinita)))(((recursão)))((("função", "definido pelo programador", "recursão", see="recursão")))

[source,julia]
----
function recursão()
    recursão()
end
----

Na maioria dos ambientes de programação, um programa com recursão infinita realmente não é executado para sempre. O Julia exibe uma mensagem de erro quando a profundidade máxima de recursão é atingida:

[source,jlcon]
----
julia> recursão()
ERROR: StackOverflowError:
Stacktrace:
 [1] recurse() at ./REPL[1]:2 (repeats 80000 times)
----

Esse rastreamento de pilha é um pouco maior do que vimos no capítulo anterior. Quando o erro ocorre, existem 80000 quadros de +recursão+ na pilha!
(((rastreamento de pilha)))(((StackOverflowError)))((("Erro", "Core", "StackOverflowError", see="StackOverflowError")))

Se você encontrar uma recursão infinita por acidente, revise sua função para confirmar se há um caso base que não faz uma chamada recursiva. E se houver um caso base, verifique se você está garantindo para alcançá-lo.


=== Entradas de Teclado

Os programas que escrevemos até agora não aceitam nenhuma entrada do usuário. Eles apenas fazem a mesma coisa todas as vezes.

Julia fornece uma função interna chamada +readline+ que interrompe o programa e aguarda o usuário digitar algo. Quando o usuário pressiona +RETURN+ ou +ENTER+, o programa é retomado e +readline+ retorna o que o usuário digitou como uma sequência de caracteres.
(((readline)))((("function", "Base", "readline", see="readline")))

[source,jlcon]
----
julia> texto = readline()
O que você está esperando?
"O que você está esperando?"
----

Antes de receber informações do usuário, é uma boa ideia imprimir um prompt informando ao usuário o que digitar:
(((prompt)))

[source,jlcon]
----
julia> print("Quem és tu? "); readline()
Quem és tu? Sou Hermanoteu da Pentescopéia, irmão da Micalatéia.
"Sou Hermanoteu da Pentescopéia, irmão da Micalatéia."
----

Um ponto e vírgula +;+ permite colocar multiplas atribuições na mesma linha. No REPL apenas a última atribuição retornará seu valor.
(((;)))

Se você espera que o usuário digite um número inteiro, tente converter o valor de retorno para +Int64+:

[source,jlcon]
----
julia> println("Qual é a velocidade da velocidade do ar de uma andorinha sem carga? "); speed = readline()
Qual é a velocidade da velocidade do ar de uma andorinha sem carga?
42
"42"
julia> parse(Int64, speed)
42
----

Mas se o usuário digitar algo diferente de uma sequência de dígitos, você receberá um erro:
(((analisar)))

[source,jlcon]
----
julia> println("Qual é a velocidade da velocidade do ar de uma andorinha sem carga? "); velocidade = readline()
Qual é a velocidade da velocidade do ar de uma andorinha sem carga?
Como assim, uma andorinha africana ou européia?
"Como assim, uma andorinha africana ou européia?"
julia> parse(Int64, speed)
ERROR: ArgumentError: invalid base 10 digit 'C' in "Como assim, uma andorinha africana ou européia?"
[...]
----

Veremos como lidar com esse tipo de erro posteriormente.
(((Erro de Argumento)))


=== Debugando

Quando ocorre um erro de sintaxe ou de tempo de execução, a mensagem de erro contém muitas informações, mas pode ser avassaladora. As partes mais úteis são geralmente:
(((debugando)))

* Que tipo de erro foi, e

* Onde ocorreu.

Os erros de sintaxe geralmente são fáceis de encontrar, mas existem algumas dicas. Em geral, as mensagens de erro indicam onde o problema foi descoberto, mas o verdadeiro erro pode estar antes no código, às vezes em uma linha anterior.

O mesmo vale para erros de tempo de execução. Suponha que você esteja tentando calcular uma taxa de sinal/ruído em decibéis. A fórmula é

[latexmath]
++++
\begin{equation}
{SNR_{\mathrm{db}} = 10 \log_{10} \frac{P_{\mathrm{sinal}}}{P_{\mathrm{ruido}}}\ .}
\end{equation}
++++

Em Julia, você pode escrever algo como isto:

[source,julia]
----
potência_do_sinal = 9
potência_do_ruido = 10
razão = potência_do_sinal ÷ potência_do_ruido
decibéis = 10 * log10(razão)
print(decibeis)
----

E você obtém:

[source,julia]
----
-Inf
----

Esse não era um resultado que você estava esperando.

Para encontrar o erro, pode ser útil imprimir o valor da razão, que acaba sendo 0. O problema está na linha 3, que usa a Divisão do piso em vez da Divisão do ponto flutuante.

[WARNING]
====
Você deve ler atentamente as mensagens de erro, mas não presuma que tudo o que elas dizem está correto.
====


=== Glossário

Divisão Inteira::
Um operador, denotado +÷+, que divide dois números e arredonda para baixo (em direção ao infinito negativo) para um número inteiro.
(((Divisão Inteira)))

operador módulo::
Um operador, indicado com um sinal de porcentagem (%), que trabalha com números inteiros e retorna o restante quando um número é dividido por outro.
(((operador módulo)))

expressão booleana::
Uma expressão cujo os valores são ou +true+ ou +false+.
(((expressão booleana)))

operador relacional::
Um dos operadores que compara operandos: +==+, +≠+ (+!=+), +>+, +<+, +≥+ (+>=+), e +≤+ (+pass:[&lt;=]+).
(((operador relacional)))

operador lógico::
Um dos operadores que combina expressões booleanas: +&&+ (e), +||+ (ou), e +!+ (não).
(((operador lógico)))

atribuição condicional::
Uma atribuição que controla o fluxo de execução dependendo de alguma condição.
(((atribuição condicional)))

condição::
A expressão boleana em uma atribuição condicional que determina qual ramo executará.
(((condição)))

atribuição composta::
Uma atribuição que consiste em um cabeçalho e um corpo. O corpo é terminado com a palavra-chave +end+.
(((atribuição composta)))

ramos::
Uma das sequências alternativas de atribuições em uma atribuição condicional.
(((ramos)))

atribuição encadeada::
Uma atribuição condicional com uma série de ramos alternativos.
(((atribuição encadeada)))

condicional aninhada::
Uma atribuição condicional que aparece em um dos ramos de outra atribuição condicional.
(((condicional aninhada)))

atribuição de retorno::
Uma atribuição que faz com que uma função pare de executar imediatamente e retorne para quem chamou.
(((atribuição de retorno)))

recursão::
O processo de chamar a função que está sendo executada.
(((recursão)))

caso base::
Uma ramo condicional de uma função recursiva que não faz um chamado recursivo.
(((caso base)))

recursão infinita::
Uma recursão que não tem um caso base, ou nunca atinge ela. Eventualmente, uma recursão infinita causa um erro de tempo de execução.
(((recursão infinita)))


=== Exercícios

[[ex05-1]]
===== Exercício 5-2

A função +tempo+ retorna o tempo médio atual de Greenwich em segundos desde “a época”, que é um tempo arbitrário usado como ponto de referência. Nos sistemas UNIX, a época é 1 de janeiro de 1970.
(((tempo)))((("função", "Base", "hora", see="hora")))

[source,@julia-repl]
----
tempo()
----

Escreva um script que leia a hora atual e a converta para uma hora do dia em horas, minutos e segundos, mais o número de dias desde a época.

[[ex05-2]]
===== Exercício 5-3

O Último Teorema de Fermat diz que não existem inteiros positivos latexmath:[\(a\)], latexmath:[\(b\)], e latexmath:[\(c\)] tais que
(((Último Teorema de Fermat)))

[latexmath]
++++
\begin{equation}
{a^n + b^n = c^n}
\end{equation}
++++

para qualquer valor de latexmath:[\(n\)] maior que 2.

. Escreva uma função chamada +fermat+ que coleta quatro parâmetros — +a+, +b+, +c+ e +n+ — e verifica se o Teorema de Fermat é valido. Se +n+ é maior que 2 e +pass:[a^n + b^n == c^n]+ o programa deve imprimir, "Oloco, Fermat estava errado!" caso contrário o programa deve imprimir, "Não, isso não funciona."
(((fermat)))((("função", "definido pelo programador", "fermat", see="fermat")))

. Escreva uma função que solicite ao usuário que insira valores para +a+, +b+, +c+ e +n+, converta-os em números inteiros e use +fermat+ para verificar se violam o teorema de Fermat.

[[ex05-3]]
===== Exercise 5-4

Se você receber três gravetos, poderá ou não ser capaz de organizá-los em um triângulo. Por exemplo, se um dos gravetos tiver 12 centímetros de comprimento e os outros dois um centímetro, você não conseguirá colocar os gravetos curtos no meio. Para três comprimentos, há um teste simples para verificar se é possível formar um triângulo:

[TIP]
====
Se qualquer um dos três comprimentos for maior que a soma dos outros dois, não será possível formar um triângulo. Caso contrário, você pode. (Se a soma de dois comprimentos for igual ao terceiro, eles formarão o que é chamado de triângulo "degenerado".)
====

. Escreva uma função chamada +triângulo+ que aceite três números inteiros como argumentos e imprima “Sim” ou “Não”, dependendo da possibilidade de formar ou não um triângulo a partir de gravetos com os comprimentos especificados.
(((triângulo)))((("função", "definido pelo programador", "é triângulo", see="é triângulo")))

. Escreva uma função que solicite ao usuário a inserção de três comprimentos de gravetos, os converta em números inteiros e use +triangulo+ para verificar se os gravetos com os comprimentos especificados podem formar um triângulo.

[[ex05-4]]
===== Exercício 5-5

Qual é a saída do seguinte programa? Desenhe um diagrama de pilha que mostre o estado do programa quando ele imprimir o resultado.
(((diagrama de pilha)))(((recursão)))

[source,julia]
----
function recursão(n, s)
    if n == 0
        println(s)
    else
        recursão(n-1, n+s)
    end
end

recursão(3, 0)
----

. O que aconteceria se você chamasse essa função assim: +recursão(-1, 0)+?

. Escreva uma sequência de documentos que explique tudo o que alguém precisa saber para usar essa função (e nada mais).

Os exercícios a seguir usam o módulo +ThinkJulia+, descrito no <<chap04>>:

[[ex05-5]]
===== Exercício 5-6

Leia a função a seguir e veja se você consegue descobrir o que ela faz (veja os exemplos em <<chap04>>). Em seguida, execute-o e veja se você acertou.

[source,julia]
----
function desenhe(t, comprimento, n)
    if n == 0
        return
    end
    angulo = 50
    forward(t, comprimento*n)
    turn(t, -angulo)
    draw(t, comprimento, n-1)
    turn(t, 2*angle)
    draw(t, comprimento, n-1)
    turn(t, -angulo)
    forward(t, -comprimento*n)
end
----

[[ex05-6]]
===== Exercício 5-7

[[fig05-2]]
.A curva de Koch
image::images/fig52.svg[]


A curva de Koch é um fractal que se parece com <<fig05-2>>. Para desenhar uma curva de Koch com comprimento latexmath:[\(x\)], tudo que você precisa fazer é:
(((curva de Koch)))(((fractal)))

. Desenhe uma curva de Koch com comprimento latexmath:[\(\frac{x}{3}\)].

. Gire 60° para esquerda

. Desenhe uma curva de Koch com comprimento latexmath:[\(\frac{x}{3}\)].

. Gire 120° para direita.

. Desenhe uma curva de Koch com comprimento latexmath:[\(\frac{x}{3}\)].

. Gire 60° para esquerda.

. Desenhe uma curva de Koch com comprimento latexmath:[\(\frac{x}{3}\)].

A exceção é se latexmath:[\(x\)] for menor que 3: neste caso, você só desenha uma linha reta de comprimento latexmath:[\(x\)].

. Escreva uma função chamada +koch+ que considere uma tartaruga e um comprimento como parâmetros e que use a tartaruga para desenhar uma curva de Koch com o comprimento especificado.
(((koch)))((("function", "definido pelo programador", "koch", see="koch")))

. Escreva uma função chamada + floco de neve + que desenhe três curvas de Koch para fazer o contorno de um floco de neve.
(((floco de neve)))((("function", "definido pelo programador", "floco de neve", see="floco de neve")))

. A curva de Koch pode ser generalizada de várias maneiras. Veja https://en.wikipedia.org/wiki/Koch_snowflake para exemplos e implemente o seu favorito.
