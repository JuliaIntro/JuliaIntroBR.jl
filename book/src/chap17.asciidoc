[[chap17]]
== Multiple Dispatch

No Julia você tem a habilidade de escrever código que opera em tipos diferentes. Isto é chamado de programação genérica.

Neste capítulo irei discutir o uso de declarações de tipos em Julia, e irei também introduzir métodos que são maneiras de implementar comportamentos diferentes para uma função dependendo dos tipos de seus argumentos. Isto é chamado de despacho múltiplo.


=== Declarações de Tipos

O operador +::+ anexa _anotações de tipo_ à expressões e variáveis:
(((TypeError)))((("error", "Core", "TypeError", see="TypeError")))

[source,@julia-repl-test]
----
julia> (1 + 2) :: Float64
ERROR: TypeError: in typeassert, expected Float64, got Int64
julia> (1 + 2) :: Int64
3
----

Isso ajuda a confirmar que o seu programa funciona do jeito esperado.

O operador +::+ também pode ser acrescentado para o lado esquerdo da atribuição, ou como uma parte de uma declaração.
(((returnfloat)))((("função", "definido pelo programador", "retorna_float", see="retorna_float")))

[source,@julia-repl-test]
----
julia> function retorna_float()
           x::Float64 = 100
           x
       end
retorna_float (generic function with 1 method)
julia> x = retorna_float()
100.0
julia> typeof(x)
Float64
----

A variável +x+ é sempre do tipo +Float64+ e o valor é sempre convertido para um ponto flutuante se necessário.

Uma anotação de tipo também pode ser anexada ao cabeçario de uma definição de função:
(((sinc)))((("função", "definido pelo programador", "sinc", see="sinc")))

[source,@julia-setup]
----
function sinc(x)::Float64
    if x == 0
        return 1
    end
    sin(x)/(x)
end
----

O valor de retorno de +sinc+ é sempre convertido para o tipo +Float64+.

O comportamento padrão em Julia quando tipos são omitidos, é permitir que valores sejam de qualquer tipo (+Any+).
(((Any)))


=== Métodos

Em <<chap16>>, nós definimos uma struct chamada +MeuTempo+ e em <<tempo>>, você escreveu uma função chamada +imprime_tempo+:
(((MeuTempo)))(((imprime_tempo)))

[source,@julia-setup chap17a]
----
using Printf

struct MeuTempo
    hora :: Int64
    minuto :: Int64
    segundo :: Int64
end

function imprime_tempo(tempo)
    @printf("%02d:%02d:%02d", tempo.hora, tempo.minuto, tempo.segundo)
end
----

Como você pode ver, declarações de tipos podem e devem ser adicionadas por razões de performance aos campos na definição da struct.

Para chamar esta função, você deve passar um objeto +MeuTempo+ como argumento:

[source,@julia-repl-test chap17a]
----
julia> início = MeuTempo(9, 45, 0)
MeuTempo(9, 45, 0)
julia> imprime_tempo(início)
09:45:00
----

Para adicionar um _método_ à função +imprime_tempo+ que apenas aceita como argumento um objeto +MeuTempo+, tudo que precisamos fazer é acrescentar +::+ seguido de +MeuTempo+ ao argumento +tempo+ na definição de função:
(((método)))

[source,@julia-setup chap17a]
----
function imprime_tempo(tempo::MeuTempo)
    @printf("%02d:%02d:%02d", tempo.hora, tempo.minuto, tempo.segundo)
end
----

Um método é uma definição de função com uma _assinatura_ específica: +imprime_tempo+ possui um argumento do tipo +MeuTempo+.
(((assinatura)))

Chamar a função +imprime_tempo+ com um objeto +MeuTempo+ produz o mesmo resultado:

[source,@julia-repl-test chap17a]
----
julia> imprime_tempo(início)
09:45:00
----

Nós podemos agora redefinir o primeiro método sem a anotação de tipo +::+, permitindo um argumento de qualquer tipo:

[source,@julia-setup chap17a]
----
function imprime_tempo(tempo)
    println("Eu não sei como imprimir o argumento tempo.")
end
----

Se você chamar a função +imprime_tempo+ com um objeto diferente de +MeuTempo+, agora você recebe:

[source,@julia-repl-test chap17a]
----
julia> imprime_tempo(150)
Eu não sei como imprimir o argumento tempo.
----

===== Exercício 17-1

Reescreva +tempo_para_int+ e +int_para_tempo+ (de <<prototyping_versus_planning>>) para especificar seus argumentos.
(((tempo_para_int)))(((int_para_tempo)))


[source,@julia-eval chap17a]
----
function tempo_para_int(tempo)
    minutos = tempo.hora * 60 + tempo.minuto
    segundos = minutos * 60 + tempo.segundo
end;

function int_para_tempo(segundos)
    (minutos, segundo) = divrem(segundos, 60)
    hora, minuto = divrem(minutos, 60)
    MeuTempo(hora, minuto, segundo)
end;
----

=== Exemplos Adicionais

Aqui está uma versão de +incrementa+ (de <<modifiers>>) reescrita para especificar seus argumentos:
(((incrementar)))

[source,@julia-setup chap17a]
----
function incrementar(tempo::MeuTempo, segundos::Int64)
    segundos += tempo_para_int(tempo)
    int_para_tempo(segundos)
end
----

Note que agora, ela é uma função pura, não um modificador.

Você pode invocar incrementar da seguinte maneira:

[source,@julia-repl-test chap17a]
----
julia> início = MeuTempo(9, 45, 0)
MeuTempo(9, 45, 0)
julia> incrementar(início, 1337)
MeuTempo(10, 7, 17)
----

Se você colocar os argumentos na ordme errada, você recebe um erro:
(((MethodError)))

[source,@julia-repl-test chap17a]
----
julia> incrementar(1337, início)
ERROR: MethodError: no method matching increment(::Int64, ::MeuTempo)
----

A assinatura do método é +incrementar(tempo ::MeuTempo, segundos::Int64)+ e não +incrementar(segundos::Int64, tempo::MeuTempo)+.

Reescrevendo +é_depois+ para agir somente em +MeuTempo+ é fácil:
(((é_depois)))

[source,@julia-setup chap17a]
----
function é_depois(t1::MeuTempo, t2::MeuTempo)
    (t1.hora, t1.minuto, t1.segundo) > (t2.hora, t2.minuto, t2.segundo)
end
----

Aliás, argumentos opcionais são implementados como sintaxe para definições múltiplas de métodos. Por exemplo, esta definição:

[source,@julia-setup]
----
function f(a=1, b=2)
    a + 2b
end
----

traduz para os seguintes três métodos:

[source,@julia-setup]
----
f(a, b) = a + 2b
f(a) = f(a, 2)
f() = f(1, 2)
----

Estas expressões são definições de método válidas em Julia. Esta é uma notação mais enxuta para definir funções/métodos.

[[construtor]]
=== Construtores

Um _construtor_ é uma função especial que é chamada para criar um objeto. Os métodos padrões construtores de +MeuTempo+ tem a seguinte assinatura:
(((construtor)))

[source,julia]
----
MeuTempo(hora, minuto, segundo)
MeuTempo(hora::Int64, minuto::Int64, segundo::Int64)
----

Nós podemos também adicionar nossos próprios métodos _construtores externos_
(((construtor externo)))((("construtor", "externo", see="construtor externo")))

[source,@julia-setup chap17a]
----
function MeuTempo(tempo::MeuTempo)
    MeuTempo(tempo.hora, tempo.minuto, tempo.segundo)
end
----

Esse método é chamado de _construtor cópia_ pois o novo objeto +MeuTempo+ é uma cópia do seu argumento.
(((construtor cópia)))((("construtor", "cópia", see="construtor cópia")))

Para impor invariantes, nós precisamos de métodos _construtores internos_:
(((construtor interno)))((("construtor", "interno", see="construtor interno")))

[source,@julia-setup chap17b]
----
struct MeuTempo
    hora :: Int64
    minuto :: Int64
    segundo :: Int64
    function MeuTempo(hora::Int64=0, minuto::Int64=0, segundo::Int64=0)
        @assert(0 ≤ minuto < 60, "minuto não está entre 0 e 60.")
        @assert(0 ≤ segundo < 60, "segundo não está entre 0 e 60.")
        new(hora, minuto, segundo)
    end
end
----

A struct +MeuTempo+ agora tem 4 métodos construtores internos:

[source,julia]
----
MeuTempo()
MeuTempo(hora::Int64)
MeuTempo(hora::Int64, minuto::Int64)
MeuTempo(hora::Int64, minuto::Int64, segundo::Int64)
----

Um método construtor interno é sempre definido dentro do bloco de uma declaração de tipo e tem acesso à função especial chamada +new+ que cria objetos de um novo tipo declarado.

[WARNING]
====
O construtor padrão não está disponível se qualquer construtor interno estiver definido. Você deve escrever explicitamente todos os construtores internos que você precisa.
====

Um método segundo sem argumento da função local +new+ existe:
(((new)))((("função", "Base", "new", see="new")))

[source,@julia-setup chap17c]
----
mutable struct MeuTempo
    hora :: Int
    minuto :: Int
    segundo :: Int
    function MeuTempo(hora::Int64=0, minuto::Int64=0, segundo::Int64=0)
        @assert(0 ≤ minuto < 60, "minuto está entre 0 e 60.")
        @assert(0 ≤ segundo < 60, "segundo está entre 0 e 60.")
        tempo = new()
        tempo.hora = hora
        tempo.minuto = minuto
        tempo.segundo = segundo
        tempo
    end
end
----

Isso permite a criação de estruturas de dados recorrentes, isto é, uma struct no qual um dos campos também é uma struct. Neste caso a struct precisa ser mutável pois seus campos são modificados após serem instanciados.
(((estruturas de dados recorrentes)))


=== +show+

+show+ é uma função especial que retorna uma representação de string de um objeto. Por exemplo, aqui está um método +show+ para objetos +MeuTempo+:
(((show)))

[source,@julia-setup chap17b]
----
using Printf

function Base.show(io::IO, tempo::MeuTempo)
    @printf(io, "%02d:%02d:%02d", tempo.hora, tempo.minuto, tempo.segundo)
end
----

O prefixo +Base+ é necessário pois nós queremos adicionar um novo método à função +Base.show+.

Quando você imprime um objeto, o Julia invoca a função +show+:

[source,@julia-repl-test chap17b]
----
julia> tempo = MeuTempo(9, 45)
09:45:00
----

Quando eu escreve um novo tipo composto, eu quase sempre começo escrevendo um construtor externo, que facilita a instanciação de objetos, e +show+, que é útil para debugging.

===== Exercício 17-2

Escreva um método construtor externo para a classe +Ponto+ que recebe +x+ e +y+ como parâmetros adicionais e que atribuam a eles seus campos correspondentes.
(((Ponto)))


[source,@julia-eval chap17b]
----
function tempo_para_int(tempo::MeuTempo)
    minutos = tempo.hora * 60 + tempo.minuto
    segundos = minutos * 60 + tempo.segundo
end;

function int_para_tempo(segundos::Int64)
    (minutos, segundo) = divrem(segundos, 60)
    hora, minuto = divrem(minutos, 60)
    MeuTempo(hora, minuto, segundo)
end;

function incrementa(tempo::MeuTempo, segundos::Int64)
    segundos += tempotoint(tempo)
    inttotempo(segundos)
end;
----

=== Operador de Sobrecarga

Ao definir métodos operadores, você pode especificar o comportamento de operadores em tipos definidos pelo programador. Por exemplo, se você define um método chamado +pass:[+]+ com dois argumentos +MeuTempo+, você pdoe usar o operador +pass:[+]+ em objetos +MeuTempo+.

A definição pode se parecer com algo como:

[source,@julia-setup chap17b]
----
import Base.+

function +(t1::MeuTempo, t2::MeuTempo)
    segundos = tempo_para_int(t1) + tempo_para_int(t2)
    int_para_tempo(segundos)
end
----

A declaração import adiciona o operador +pass:[+]+ ao escopo local para que os métodos possam ser adicionados.

E você poderia usá-lo como:


[source,@julia-repl-test chap17b]
----
julia> início = MeuTempo(9, 45)
09:45:00
julia> duração = MeuTempo(1, 35, 0)
01:35:00
julia> início + duração
11:20:00
----

Quando você aplica o operador +pass:[+]+ a objetos +MeuTempo+, o Julia invoca o novo método adicionado. Quando o REPL mostra o resultado, o Julia invoca +show+. Então tem muito acontecendo por trás das cortinas!

Adicionar ao comportamento de um operador para que funcione com tipos definidos pelo programador é chamado de _sobrecarga de operador_.
(((sobrecarga de operador)))


=== Multiple Dispatch

Na secção anterior nós adicionamos dois objetos +MeuTempo+, mas você também pode adicionar um inteiro ao objeto +MeuTempo+:

[source,@julia-setup chap17b]
----
function +(tempo::MeuTempo, segundos::Int64)
    incrementa(tempo, segundos)
end
----

Aqui está um exemplo que usa o operador +pass:[+]+ com um objeto +MeuTempo+ e um inteiro:

[source,@julia-repl-test chap17b]
----
julia> início = MeuTempo(9, 45)
09:45:00
julia> início + 1337
10:07:17
----

Adição é um operador comutativo, então temos que adicionar outro método.

[source,@julia-setup chap17b]
----
function +(segundos::Int64, tempo::MeuTempo)
  tempo + segundos
end
----

E nós obtemos o mesmo resultado:

[source,@julia-repl-test chap17b]
----
julia> 1337 + início
10:07:17
----

A escolha de qual método executar quando a função é aplicada é chamado de _dispatch_. O Julia permite que o processo de dispatch escolha qual método de uma função chamar baseada no número de argumentos dados, e nos tipos de todos os argumentos da função. Usar todos os argumentos de uma função para escolher qual método deve ser invocado é conhecido como _multiple dispatch_.
(((dispatch)))(((multiple dispatch)))

===== Exercício 17-3

Escreva métodos +pass:[+]+ para objetos ponto:

* Se ambos operandos são objetos ponto, o método deve retornar um novo objeto ponto cuja coordenada +x+ é a soma das coordenadas +x+ dos operandos, e da mesma forma para as coordenadas +y+.

* Se o primeiro ou o segundo operando é uma tupla, o método deve somar o primeiro elemento da tupla à coordenada +x+ e o segundo elemento à coordenada +y+, e retornar um novo objeto ponto com o resultado.


=== Programação Genérica

Multiple dispatch é útil quando é necessária, mas (felizmente) ele não é sempre necesário. Muitas vezes você pode evitá-lo escrevendo funções que funcionam corretamente para argumentos com tipos diferentes.

Muitas das funções que nós escrevemos para string também funcionam para outros tipos de sequência. Por exemplo, em <<dictionary_collection_counters>> nós usamos +histograma+ para contar o número de vezes no qual cada letra aparece em uma palavra.
(((histograma)))

[source,@julia-setup chap17]
----
function histograma(s)
    d = Dict()
    for c in s
        if c ∉ keys(d)
            d[c] = 1
        else
            d[c] += 1
        end
    end
    d
end
----

Esta função também funciona para listas, tuplas, e até mesmo dicionários, contanto que para os elementos de +s+ exista uma função hash, então eles podem ser usados como chaves em +d+.

[source,@julia-repl-test chap17]
----
julia> t = ("presunto", "ovo", "presunto", "presunto", "bacon", "presunto")
("presunto", "ovo", "presunto", "presunto", "bacon", "presunto")
julia> histogram(t)
Dict{Any,Any} with 3 entries:
  "bacon"     => 1
  "presunto"  => 4
  "ovo"       => 1
----

Funções que funcionam com vários tipos são chamadas de _polimórficas_. Polimorfismo pode facilitar o reuso de código.
(((polymórfica)))

Por exemplo, a função embutida +sum+, que soma elementos de uma sequência, funciona contanto que os elementos da sequência suportam adição.
(((sum)))

Já que um método +pass:[+]+ é fonrecido para objetos +MeuTempo+, eles funcionam com +sum+:

[source,@julia-repl-test chap17b]
----
julia> t1 = MeuTempo(1, 7, 2)
01:07:02
julia> t2 = MeuTempo(1, 5, 8)
01:05:08
julia> t3 = MeuTempo(1, 5, 0)
01:05:00
julia> sum((t1, t2, t3))
03:17:10
----

Em geral, se todos as operações dentro da função funcionam com um dado tipo, a função funciona com qualquer tipo.

O melhor tipo de Polimorfismo é o tipo não intencional, no qual você descobre que uma função já escrita por você pode ser aplicada a um tipo que você nunca planejou.
(((polimorfismo)))


=== Interface e Implementação

Um dos objetos de despacho múltiplo é facilitar a manutenção de software, o que significa que você pode manter o programa funcionando quando outras partes do sistema mudam, e modificam o programa para cumprir novos requisitos.

Um princípio de design que ajuda a alcançar esse objetivo é manter as interfaces separadas da implementação. Isto significa que métodos que possuem argumentos denotados com um tipo não devem depender de como os campos daquele tipo são representados.
(((interface)))(((implementação)))

Por exemplo, neste capítulo nós desenvolvemos uma struct que representa o tempo do dai. Métodos que possuem argumentos denotados com este tipo incluem +tempo_para_int+, +é_depois+ e +pass:[+]+.

Nós poderíamos implementar estes métodos de muitas maneiras. Os detalhes da implementação dependem de como representamos +MeuTempo+. Neste capítulo, os campos de um objeto +MeuTempo+ são +hora+, +minuto+ e +segundo+.

Como uma alternativa, nós poderiamos substituir estes campos com um único inteiro representando o número de segundos desde a meia-noite. Esta implementação faria com que algumas funções, como +é_depois, sejam mais facéis de escrever, mas faz com que outras funções sejam mais dificéis.

Depois você configurar um novo tipo, você pode descobrir uma implementação melhor. Se outras partes do programas estão usando os eu tipo, pode ser que mudar a interface consuma muito tempo e esteja sujeita a erros.

Mas se você tivesse projetado a interface com cuidado, você pode mudar a implementação sem mudar a interface, o que significa que outras partes do programa não precisam mudar.


=== Debugging

Chamar uma função com os argumentos corretos pode ser difícil quando mais de um método para um função é específicada. O Julia permite examinar as assinaturas dos métodos de uma função.

Para saber quais métodos estão disponíveis para uma dada função, você pode usar a função +methods+:
(((metódos)))(((debugging)))

[source,jlcon]
----
julia> methods(imprime_tempo)
# 2 methods for generic function "imprime_tempo":
[1] imprime_tempo(tempo::MeuTempo) in Main at REPL[3]:2
[2] imprime_tempo(tempo) in Main at REPL[4]:2
----

Neste exemplo, a função +imprime_tempo+ tem 2 métodos: um com argumento +MeuTempo+ e um com argumento +Any+.


=== Glossário

anotação de tipo::
O operador +::+ seguido por um tipo indicando que a expressão ou variável é daquele tipo.
(((anotação de tipo)))

método::
Uma definição de um possível comportamento para uma função.
(((método)))

despacho::
A escolha de qual método executar quando uma função é executada.
(((despacho)))

assinatura::
O número e tipo de argumentos de um método permitindo o despacho à escolher o método mais específico de uma função durante uma chamada de função.
(((assinatura)))

construtor externo::
Um construtor definido fora da definição de tipo para definir métodos de conveniência para criar um objeto.
(((construtor externo)))

construtor interno::
Um construtor definido dentro da definição de tipo para impor invariantes ou para construir objetos que referem-se a si mesmos.
(((construtor interno)))

construtor padrão::
Um construtor interno que está disponível quando nenhum construtor interno definido pelo programador é fornecido.
(((construtor padrão)))

construtor cópia::
Um método construtor externo de um tipo que tem como único argumento um objeto daquele tipo. Ele cria um novo objeto que é uma cópia do seu argumento.
(((construtor cópia)))

sobrecarga de operador::
Adicionar a um comportamento de um operador como +pass:[+]+ para que funcione com um tipo definido pelo programador.
(((sobrecarga de operador)))

despacho múltiplo::
Despacho baseado em todos os argumentos de uma função.
(((despacho múltiplo)))

programação genérica::
Escrever código que pode funcionar com mais de um tipo.
(((programação genérica)))


=== Exercícios

[[ex17-1]]
===== Exercício 17-4

Mude os campos de +MeuTempo+ para que exista apenas um único campo representando os segundos passados desde a meia-noite. Em seguida modifique os métodos definidos neste capítulo para funcionar com a nova implementação.

[[ex17-2]]
===== Exercício 17-5

Escreva uma definição par aum tipo chamado +Canguru+ com um campo chamado +conteúdo_bolso+ de tipo +Array+ e os seguintes métodos:
(((Canguru)))((("tipo", "definido pelo programador", "Canguru", see="Canguru")))

* Um construtor que inicializa +conteúdo_bolso+ para uma lista vazia.

* Um método chamado +coloca_no_bolso+ que recebe um objeto +Canguru+ e um objeto de qualquer tipo e adiciona-o a +conteúdo_bolso+.
(((coloca_no_bolso)))((("função", "definido pelo programador", "coloca_no_bolso", see="coloca_no_bolso")))

* Um método +show+ que retorna uma representação string de um objeto +Canguru+ e o conteúdo do bolso.
(((show)))

Teste seu código criando dois objetos +Canguru+, atribuindo-os a variáveis chamadas +cangu+ e +ru+, e em seguida adicionando +ru+ ao conteúdo do bolso de +cangu+.
