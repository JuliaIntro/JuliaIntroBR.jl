[[chap10]]
== Listas

Este capítulo apresenta um dos tipos internos mais úteis do Julia, listas. Você também aprenderá sobre objetos e o que pode acontecer quando você tiver mais de um nome para o mesmo objeto.


=== Uma Lista é uma Sequência

Como uma string, ua _lista_ é uma sequência de valores. Em uma string, os valores são caracteres; em um vetor, pode ser de qualquer tipo. Os valores de um vetor são chamados de _elementos_ ou por vezes _itens_.
(((lista)))(((element)))(((item)))

Existem diversas maneiras de criar uma nova lista; a mais simples é inserir os elementos entre colchetes (+[ ]+):
(((colchetes)))

[source,julia]
----
[10, 20, 30, 40]
["crunchy frog", "ram bladder", "lark vomit"]
----

O primeiro exemplo é uma lista de quatro inteiros. O segundo é uma lista de três strings. Os elementos de uma lista não precisam ser do mesmo tipo. A seguinte lista contém uma string, um float, um inteiro, e uma outra lista:

[source,julia]
----
["bruxa", 2.0, 5, [10, 20]]
----

Uma lista com outra lista é _aninhada_.
(((aninhado)))

Uma lista que não contém elementos é chamado de lista vazia; você pode criar uma lista vazia com colchetes vazios, +[]+.
(((vetor vazio)))

Como esperado, podemos atribuir valores de listas a variáveis:

[source,@julia-repl-test chap10]
----
julia> vegetais = ["Cenoura", "Brócolis", "Alface"];

julia> números = [42, 123];

julia> vazia = [];

julia> print(vegetais, " ", números, " ", vazio)
["Cenoura", "Brócolis", "Alface"] [42, 123] Any[]
----

A função +typeof+ pode ser usada para encontrar o tipo de lista:
(((typeof)))

[source,@julia-repl-test chap10]
----
julia> typeof(vegetais)
Array{String,1}
julia> typeof(números)
Array{Int64,1}
julia> typeof(vazia)
Array{Any,1}
----

O tipo de lista é especificado entre as chaves e é composto pelo tipo e um número. O número indica a dimensão. A lista +vazia+ contém valores do tipo +Any+., isto é, pode ser designado a valores de todos os tipos.
(((Listas)))((("tipo", "Base", "Vwtor", see="Array")))(((Any)))((("type", "Base", "Any", see="Any")))


=== Listas são mutáveis

A sintaxe para acessar elementos de uma lista é a mesma para acessar caracteres de uma string - colchetes. A expressão dentro dos colchetes especifica o índice. Lembre-se que o índice começa em 1:
(((colchetes)))(((índice)))

[source,@julia-repl-test chap10]
----
julia> vegetais[1]
"Cenoura"
----

Assim como strings, listas são _mutáveis_. Quando os colchetes aparecem no lado esquerdo de uma atribuição, o elemento da lista que está designado é identificado:
(((mutável)))(((declaração de atribuição)))

[source,@julia-repl-test chap10]
----
julia> números[2] = 5
5
julia> print(números)
[42, 5]
----

O segundo elemento de +números+, que costumava ser 1997, agora é 7.

<<fig10-1>> mostra o diagrama de pilha para "vegetais", "números" e "vazio".
(((diagrama de pilha)))

[[fig10-1]]
.Diagrama de pilha
image::images/fig101.svg[]


Vetores são representados por caixas e os elementos dos vetores dentro. +vegetais+ refere-se a uma lista com três elementos indexados +1+, +2+ e +3+. +números+ contém dois elementos; o diagrama mostra que a lista do segundo elemento foi reatribuída de +123+ para +5+. +vazio+ refere-se a uma lista sem elementos.

Os índices das listas funcionam do mesmo jeito que os índices de string (mas sem as ressalvas do UTF-8):

* Qualquer expressão inteira pode ser utilizada como um índice.

* Se você tentar ler ou escrever um elemento que não existe, será exibido +BoundsError+

* A palavra-chave +end+ aponta para o último índice da lista.
(((end)))

O operador +∈+ também funciona em listas:
(((em)))

[source,@julia-repl-test chap10]
----
julia> "Edam" ∈ cheeses
true
julia> "Brie" in cheeses
false
----


=== Atravessando uma Lista

O jeito mais comum de atraversar os elementos de uma lista é através do laço +for+. A sintaxe é a mesma para strings:
(((travessia)))(((atribuição for)))

[source,@julia-setup chap10]
----
for queijo in queijos
    println(queijo)
end
----

Isso funciona bem se você for apenas ler os alementos de uma lista. Mas se você precisa escrever ou atualizar os elementos, você precisa dos índices. Um jeito comum de fazer isso é utilizando a função embutida +eachindex+:
(((eachindex)))((("função", "Base", "eachindex", see="eachindex")))

[source,@julia-setup chap10]
----
for i in eachindex(números)
    números[i] = números[i] * 2
end
----

Esse laço atravessa a lista e atualiza cada elemento. +lenght+ retorna o número de elementos de uma lista. Cada vez no laço +i+ obtém o índice do próximo elemento. A declaração de atribuição no corpo usa +i+ para ler os valores antigos do elemento e desgina ao novo valor:

O laço +for+ sobre uma lista vazia nunca executa o corpo:
(((lista vazia)))

[source,@julia-setup]
----
for x in []
    println("Isso nunca pode acontecer.")
end
----

Embora uma lista possa conter outra lista, a lista aninhada ainda conta como um único elemento. O comprimento dessa lista é quatro:

[source,@julia-setup]
----
["spam", 1, ["Brie", "Roquefort", "Camembert"], [1, 2, 3]]
----


=== Operador de Fatias

O Operador de Fatias também funciona para listas.
(((operador de fatias)))((("operador), "Base", "[:]", see="operador de fatias")))((("[:]", see="operador de fatias")))

[source,@julia-repl-test chap10]
----
julia> t = ['a', 'b', 'c', 'd', 'e', 'f'];

julia> print(t[1:3])
['a', 'b', 'c']
julia> print(t[3:end])
['c', 'd', 'e', 'f']
----

O Operador de Fatia +[:]+, faz uma cópia em toda a lista:
(((cópia)))

[source,@julia-repl-test chap10]
----
julia> print(t[:])
['a', 'b', 'c', 'd', 'e', 'f']
----

Como as listas são mutáveis, geralmente é útil fazer uma cópia antes de executar operações que modificam listas.

O Operador de Fatais no lado esquerdo de uma atribuição pode atualizar múltiplos elementos:

[source,@julia-repl-test chap10]
----
julia> t[2:3] = ['x', 'y'];

julia> print(t)
['a', 'x', 'y', 'd', 'e', 'f']
----


=== Biblioteca de Listas

Julia fornece função que operam com listas. Por exemplo, +push!+ adiciona um novo elemento no final de uma lista:
(((push!)))((("função", "Base", "push!", see="push")))

[source,@julia-repl-test chap10]
----
julia> t = ['a', 'b', 'c'];

julia> push!(t, 'd');

julia> print(t)
['a', 'b', 'c', 'd']
----

+append!+ adiciona elementos da segunda lista ao final da primeira:
(((append!)))((("função", "Base", "append!", see="append!")))

[source,@julia-repl-test chap10]
----
julia> t1 = ['a', 'b', 'c'];

julia> t2 = ['d', 'e'];

julia> append!(t1, t2);

julia> print(t1)
['a', 'b', 'c', 'd', 'e']
----

Esse exemplo deixa +t2+ sem modificação.

+sort!+ organiza os elementos da lista do menor para o maior:
(((sor!)))((("função", "Base", "sort!", see="sort!")))

[source,@julia-repl-test chap10]
----
julia> t = ['d', 'c', 'e', 'b', 'a'];

julia> sort!(t);

julia> print(t)
['a', 'b', 'c', 'd', 'e']
----

+sort_ retorna uma cópia dos elementos da lista em ordem:
(((sort)))((("função", "Base", "sort"m, see="sort")))

[source,@julia-repl-test chap10]
----
julia> t1 = ['d', 'c', 'e', 'b', 'a'];

julia> t2 = sort(t1);

julia> print(t1)
['d', 'c', 'e', 'b', 'a']
julia> print(t2)
['a', 'b', 'c', 'd', 'e']
----

[NOTE]
====
Como uma convenção de estilo em Julia, +! + É anexado a nomes de funções que modificam seus argumentos.
(((!)))
====


=== Mapeamento, Filtro e Redução

Para aumentar todos os números de uma lista, podemos utilizar um laço como o seguinte:

[source,@julia-setup]
----
function adicione_a_todos(t)
    total = 0
    for x in t
        total += x
    end
    total
end
----

+total+ é iniciado em 0. Cada vez que passa pelo laço, +pass:[+=]+ captura um elemento da lista. O operador +pass:[+=]+ fornece um jeito fácil de atuaizar uma variável. Essa _declaração de atribuição aumentada_,
(((declaração de atribuição aumentada)))(((pass:[+=])))((("operador", "Base", "pass:[+=]", see="pass:[+=]")))

[source,julia]
----
total += x
----

é equivalente a

[source,julia]
----
total = total + x
----

Quando o laço é iniciado, +total+ acumula a soma dos elementos; a variável usada dessa maneira é chamada de _acumulador_.
(((acumulador)))

Adicionar elementos de uma lista é uma operação tão comum que o Julia fornece uma função interna, +sum+:
(((soma)))((("função", "Base", "soma", see="soma")))

[source,@julia-repl-test]
----
julia> t = [1, 2, 3, 4];

julia> sum(t)
10
----

Uma operação como essa que combina uma sequência de elementos a um único valor por vezes é chamado de _operação de redução_.
(((operação de redução)))

Muitas vezes, você deseja percorrer uma lista enquanto cria outra. Por exemplo, a função a seguir pega uma lista de strings e retorna uma nova string que contém strings de caracteres maiúsculas:
(((maiúscula)))((("função", "definido pelo programador", "maiúscula")))(((maiúscula)))

[source,@julia-setup]
----
functiontodas_maiúsculas(t)
    res = []
    for s in t
        push!(res, maiúscula(s))
    end
    res
end
----

+res+ é inicializada com uma lista vazia; a cada vez no laço, anexamos o próximo elemento. Então, +res+ é outro tipo de acumulador.

Um operador como +todas_maiúsculas+ é por vezes chamado de _mapa_ pois "mapeia" a função (neste caso +maiuscúla+) em cada um dos elementos em uma sequÊncia.
(((mapa)))

Outro tipo comum de operação é selecionar alguns dos elementos de uma lista e retornar uma sublista. Por exemplo, a seguinte função pega uma lista de strings e retorna uma lista que contém apenas strings maiúsculas:
(((apenas_maiusculas)))((("função", "definido pelo programador", "apenas maiusculas", see="apenas_maiusculas")))

[source,@julia-setup]
----
function apenas_maiusculas(t)
    res = []
    for s in t
        if s == maiúscula(s)
            push!(res, s)
        end
    end
    res
end
----

Um operador como +apenas_maiusculas+ é chamado de _filtro_ pois seleciona alguns dos elementos e filtra em outro.
(((filtro)))

Operações mais comuns de listas podem ser exprressas como uma combinação de mapeamento, filtro e redução.


=== Sintaxe do Ponto

Para cada operador binário como +pass:[^]+, existe uma correspondente em um _operador ponto_ pass:[<code>.^</code>] que é automaticamente definido para atuar +pass:[^]+ elemento-a-elemento nas listas. Por exemplo, pass:[<code>&#91;1, 2, 3&#93; ^ 3</code>] não é definida, mas pass:[<code>&#91;1, 2, 3&#93; .^ 3</code>] é definida computando o resultado elementar pass:[<code>&#91;1^3, 2^3, 3^3&#93;</code>]:
(((operador ponto)))((("operador", "base", ".", see="operador ponto")))(((".", see="operador ponto")))

[source,@julia-repl-test]
----
julia> print([1, 2, 3] .^ 3)
[1, 8, 27]
----

Qualquer função +f+ do Julia pode ter aplicação do resultado elementar de qualquer lista com a _sintaxe do ponto_. Por exemplo, para deiar uma lista de stringas maiúsculas, não precisamos explicitar o laço:
(((sintaxe do ponto)))

[source,@julia-repl-test]
----
julia> t = maiúscula.(["abc", "def", "ghi"]);

julia> print(t)
["ABC", "DEF", "GHI"]
----

Esse é um jeito elegante para criar mapeamentos. A função +todas_maiúsculas+ pode ser implementada de uma única linha:
(((todas_maiúsculas)))

[source,@julia-setup]
----
function todas_maiúsculas(t)
    maiúscula.(t)
end
----


=== Deletando (Inserindo) Elementos

Existem várias maneiras de deletar elementos de uma lista. Se você sabe o índice do elemento que você precisa, você pode usar +splice!+:
(((splice!)))((("função", "Base", "splice!", see="splice!")))

[source,@julia-repl-test]
----
julia> t = ['a', 'b', 'c'];

julia> splice!(t, 2)
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)
julia> print(t)
['a', 'c']
----

+splice!+ modifica a lista e retorna um elemento que foi removido.

+pop!+ deleta e retorna o último elemento:
(((pop!)))((("função", "Base", "pop!", veja="pop!")))

[source,@julia-repl-test]
----
julia> t = ['a', 'b', 'c'];

julia> pop!(t)
'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)
julia> print(t)
['a', 'b']
----

+popfirst!+ deleta e retorna o primeiro elemento:
(((popfirst!)))((("funlão", "Base", "popfirst!", see="popfirst!")))

[source,@julia-repl-test]
----
julia> t = ['a', 'b', 'c'];

julia> popfirst!(t)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
julia> print(t)
['b', 'c']
----

A função +pushfirst!+ e +push!+ insere um elemento no início e respectivamente no fim de uma lista.
(((pushfirst!)))((("função", "Base", "pushfirst", see="pushfirst!")))(((push!)))

Se você não precisa remover valores, você pode usar a função +deleteat!+:
(((deleteat!)))((("função", "Base", "delete!", see="deleteat!")))

[source,@julia-repl-test]
----
julia> t = ['a', 'b', 'c'];

julia> print(deleteat!(t, 2))
['a', 'c']
----

A função +insert!+ insere um elemento em um índice dado:
(((insert!)))((("função", "Base", "insert!", see="insert!")))

[source,@julia-repl-test]
----
julia> t = ['a', 'b', 'c'];

julia> print(insert!(t, 2, 'x'))
['a', 'x', 'b', 'c']
----


=== Listas e Strings

Uma string é uma sequêncuia de caracteres e uma lista é uma sequência de valores, mas uma lista de caracteres não é o mesmo que uma string. Para converter uma string em uma lista de caracteres, voc~e pode usar a função +collect+:
(((collect)))((("function", "Base", "collect", see="collect")))

[source,@julia-repl-test]
----
julia> t = collect("spam");

julia> print(t)
['s', 'p', 'a', 'm']
----

A função +collect+ divide uma sequência ou outra sequêcia em elementos individuais.

Se você quer dividir uma string em palavras, você pode usar a função +split+:
(((split)))((("função", "Base", "split", see="split")))

[source,@julia-repl-test]
----
julia> t = split("Vim lhe trazer este humilde presente");

julia> print(t)
SubString{String}["vim", "lhe", "trazer", "este", "humilde", "presente"]
----

Um _argumento opcional_ chamado _delimitador_ especifica quais caracteres devem ser usados como limites de palavras. Os seguintes exemplos usan um hífen como um delimitador:
(((argumento opcional)))(((delimitador)))

[source,@julia-repl-test]
----
julia> t = split("mayday-mayday-mayday", '-');

julia> print(t)
SubString{String}["mayday", "mayday", "mayday"]
----

+join+ é o inverso de +split+. Ela pega uma lista de strings e concatena os elementos:
(((joing)))((("função", "Base", "join", see="join")))

[source,@julia-repl-test]
----
julia> t = ["Vim", "lhe", "trazer", "este", "humilde", "presente"];

julia> s = join(t, ' ')
"vim lhe trazer este humilde presente"
----

No caso o delimitador é um caracter de espaço. Para concatenar strings sem espaços, você não precisa especificar um delimitador.


=== Objetos e Valores

Um _objeto_ é algo que uma variável pode se refetir. À partir de agora, você pode usar "objeto" e "valor" intercambiavelmente.
(((objeto)))(((variável)))(((valor)))

Se você execusar estas declrações de atribuições:

[source,julia]
----
a = "banana"
b = "banana"
----

Sabemos que ambas +a+ e +b+ referem-se a uma string, mas não sabemos se eles referem à _mesma_ string. Existem dois estados possíveis, mostrados na Figura 10-2.
(((diagrama de estado)))

.Diagrama de estado
image::images/fig102.svg[]


Em um caso, +a+ e +b+ referem-se a dois objetos diferentes que possuem o mesmo valor. No segundo caso, referem-se ao mesmo objeto.

Para verificar se duas variáveis se referem ao mesmo objeto, você pode usar +=+ (*+\equiv TAB+*)  ou o operador +===+.
(((≡)))((("operador", "Base", "≡", see="≡")))((("===", see="≡")))

[source,@julia-repl-test]
----
julia> a = "banana"
"banana"
julia> b = "banana"
"banana"
julia> a ≡ b
true
----

Nesse exemplo, Julia criou apenas um objeto de sequência e ambos +a+ e +b+ se referem a ele. Mas quando você cria duas listas, você obtém dois objetos:

[source,@julia-repl-test]
----
julia> a = [1, 2, 3];

julia> b = [1, 2, 3];

julia> a ≡ b
false
----

Portanto, o diagrama de estado se parece com <<<fig10-3>>.
(((diagrama de estado)))

[[fig10-3]]
.Diagrama de estado
image::images/fig103.svg[]


Nesse case poderíamos dizer que duas listas são _equivalentes_, porque possuem os mesmos elementos, mas não _indênticos_, porque eles não são os mesmos objetos. Se dois objetos são idênticos, eles também são equivalentes, mas se eles são equivalentes, eles não necessariamente são idênticos.
(((equivalentes)))(((idênticos)))

Para sermos mais precisos, um objeto possui um valor. Se você avaliar +[1, 2, 3]+, voc~e obterá uma lista de objetos cujos os valores são uma sequência de inteiros. Se uma outra lista possuir os mesmos elementos, dizemos que eles tem os mesmos valores, mas que não são os mesmos objetos.


=== Alias

Se +a+ refere-se a um objeto e você atribuir +b = a+, então ambas variáveis irão se referir ao mesmo objeto:

[source,@julia-repl-test chap10]
----
julia> a = [1, 2, 3];

julia> b = a;

julia> b ≡ a
true
----

O diagrama de estado se parece com <<<fig10-4>>.

[[fig10-4]]
.Diagrama de estado
image::images/fig104.svg[]


A associação de uma variável com um objeto é chamado de _referência_. Nesse exemplo, existem duas referências ao mesmo objeto.
(((referência)))

Um objeto com mais de uma referência contém mais de um nome, dizemos então que esse objeto é um _alias_.
(((alias)))

Se um objeto alias for mutável, as alterações feitas com um alias afetam o outro:
(((mutável)))

[source,@julia-repl-test chap10]
----
julia> b[1] = 42
42
julia> print(a)
[42, 2, 3]
----

[WARNING]
====
Embora esse comportamento possa ser útil, está propenso a erros. Em geral, é mais seguro evitar alias quando você estiver trabalhando com objetos mutáveis.
====

Para objetos imutáveis, como strings, o alias não é um problema. Neste exemplo:

[source,@julia-setup]
----
a = "banana"
b = "banana"
----

Quase nunca faz diferença se +a+ e +b+ referem-se a mesma string ou não.


=== Argumentos de Listas

Quando você passa uma lista para uma função, a função obtém uma referência para a lista. Se a função modifica a lista, o chamados vê a diferença. Por exemplo, +deletehead!+ remove o primeiro elemento de uma lista:
(((deletehead!)))((("função", "definido pelo programador", "deletehead!", see="deletehead!")))(((popfirst)))

[source,@julia-setup chap10]
----
function deletehead!(t)
    popfirst!(t)
end
----

Segue abaixo como isto é utilizado:

[source,@julia-repl-test chap10]
----
julia> letras = ['a', 'b', 'c'];

julia> deletehead!(letras);

julia> print(letters)
['b', 'c']
----

O parâmetro +t+ e a variável +letras+ são alias para o mesmo objeto. O diagrama de estado se parece com <<fig10-5>>.
(((diagrama de estado)))

[[fig10-5]]
.Diagrama de estado
image::images/fig105.svg[]

Desde que a lista seja compartilhada por dois quadros, eu desenhei entre eles.

Isto é importante para distinguir entre operações que modificam listas e operações que criam novas listas. Por exemplo, +push!+ modifica uma lista mas +vcat+ cria uma nova lista.
(((push!)))(((vcat)))((("função", "Base", "vcat", see="vcat")))

Aqui vai um exemplo usando +push!+:

[source,@julia-repl-test chap10]
----
julia> t1 = [1, 2];

julia> t2 = push!(t1, 3);

julia> print(t1)
[1, 2, 3]
----

+t2+ é um alias de +t1+.

E aqui, um exemplo de +vcat+:

[source,@julia-repl-test chap10]
----
julia> t3 = vcat(t1, [4]);

julia> print(t1)
[1, 2, 3]
julia> print(t3)
[1, 2, 3, 4]
----

O resultado de +vcat+ é uma nova lista, e a lista original permanece inalterada.

Essa diferença é importante quando você escreve funções que devem modificar listas.

Por exemplo, essa função _não_ deleta a cabeça de uma lista:
(((baddeletehead)))((("função", "definido pelo programador", "baddeletehead", see="baddeletehead")))

[source,@julia-setup chap10]
----
function baddeletehead(t)
    t = t[2:end]                # EEERRROU!
end
----

O operador de fatia cria uma nova lista e a atribuição faz com que +t+ se refira a ela, mas isso não afeta o chamador.
(((operador de fatia)))

[source,@julia-repl-test chap10]
----
julia> t4 = baddeletehead(t3);

julia> print(t3)
[1, 2, 3, 4]
julia> print(t4)
[2, 3, 4]
----

No início de +baddeletehead+, +t+ e +t3+ se referem à mesma lista. No final, +t+ se refere a uma nova lista, mas +t3+ continua a se referir à original, uma lista não modificada.

Uma alternativa é escrever uma função que cria e retorna uma nova lista. Por exemplo, +rabo+ retorna todos, exceto o primeiro elemento de uma lista:
(((rabo)))((("função", "definido pelo programador", "rabo", see="rabo")))

[source,@julia-setup chap10]
----
function tail(t)
    t[2:end]
end
----

Essa função deixa a lista original sem modificações. Veja como é usado:

[source,@julia-repl-test chap10]
----
julia> rabo = ['a', 'b', 'c'];

julia> resto = rabo(letras);

julia> print(rest)
['b', 'c']
----


=== Debugando

O uso descuidado de listas (e outros objetos mutáveis) podem levar a longas horas de debug. Veja algumas armadilhas comuns e maneiras de como evitá-las:
(((debugando)))

* A maioria das funções de lista modifica o argumento. É o oposto das funções de sequência, que retornam uma nova sequência e deixam o original em paz.
+
Se você está acostumado a escrever código de string como este:
(((faixa)))(((sort!)))
+
[source,julia]
----
new_word = strip(word)
----
+
É tentador escrever código de lista assim:
+
[source,julia]
----
t2 = sort!(t1)
----
+
Como +sort!+ fetorna a lista original modificada +t1+, +t2+ é um alias de +t1+.
+
[TIP]
====
Antes de usar funções e operadores de lista, você deve ler a documentação com cuidado e testá-los no modo interativo.
====

* Escolha um idioma e fique com ele.
+
Parte do problema com listas é que existem muitas maneiras de fazer as coisas. Por exemplo, para remover um elemento de uma lista, você pode usar +pop!+, +Popfirst!+, +Delete_at+ ou mesmo uma atribuição de fatia. Para adicionar um elemento, você pode usar +push!+, +Pushfirst!+, +Insert!+ Ou +vcat+. Supondo que +t+ é uma lista e +x+ é um elemento da lista, eles estão corretos:
(((push!)))(((pushfirst!)))(((insert!)))(((vcat)))
+
[source,julia]
----
insert!(t, 4, x)
push!(t, x)
append!(t, [x])
----
+
E os seguintes estão errados
+
[source,julia]
----
insert!(t, 4, [x])         # ERROU!
push!(t, [x])              # ERROU!
----

* Faça cópias para evitar alias.
+
Se você precisa usar uma função como +sort!+, que modifica o argumento, voc~e precisa manter a lista original, você pode fazer uma cópia:
(((sort!)))
+
[source,@julia-repl-test chap10]
----
julia> t = [3, 1, 2];

julia> t2 = t[:]; # t2 = cópia(t)

julia> sort!(t2);

julia> print(t)
[3, 1, 2]
julia> print(t2)
[1, 2, 3]
----
+
Nesse exemplo, você também pode usar a função interna +sort+, que retorna uma nova lista classificada e deixa o original em paz:
(((ordenar)))
+
[source,@julia-repl-test chap10]
----
julia> t2 = sort(t);

julia> println(t)
[3, 1, 2]
julia> println(t2)
[1, 2, 3]
----


=== Glossário

lista (_array_)::
Uma sequência de valores.
(((lista)))

elemento::
Um dos valores de uma lista (ou outra sequência), também chama items.
(((elemento)))

lista aninhada::
Uma lista é um elemento de outra lista.
(((lista aninhada)))

acumulador::
Uma variável que é utilizada em um laço para adicionar ou acumular resultados.
(((acumulador)))

atribuição aumentada::
Uma atribuição que atualiza o valor de uma variável utilizando um operador +=+.
(((atribuição aumentada)))

operador ponto::
Um operador binário que é aplicado elemento a elemento de uma lista
(((operador ponto)))

sintaxe do ponto::
Sintaxe utilizada para aplicar uma função resultado elementar a qualquer lista.
(((sintaxe do ponto)))

operador de redução::
Um padrão de processamento que percorre uma sequência e acumula os elementos em um único resultado.
(((operador de redução)))

mapa::
Um padrão de processamento que percorre uma sequência e executa uma operação em cada elemento.
(((mapa)))

filtro::
Um padrão de processamento que percorre uma sequência e seleciona os elementos que atendem a algum critério.
(((filtro)))

objeto::
Algo que uma variável pode se referir. Um objeto tem um tipo e um valor.
(((objeto)))

equivalente::
Contém o mesmo valor.
(((equivalente)))

idêntico::
Sendo o mesmo objeto (o que implica equivalencia).
(((idêntico)))

referência::
Associação entre uma variável e seu valor.
(((referência)))

alias::
Uma circunstância onde duas ou mais variáveis referem-se ao mesmo objeto.
(((alias)))

argumentos opcionais::
Argumentos que não são obrigatórios.
(((argumentos opcionais)))

delimitador::
Um caracter ou ustring utilizada para indicar onde uma string deve ser cortada.
(((delimitador)))


=== Exercícios

[source,@julia-eval chap10]
----
function soma_aninhada(t)
  total = 0
  for nested in t
    total += sum(nested)
  end
  total
end;

function soma_cumulativa(t)
  total = 0
  res = []
  for x in t
    total += x
    push!(res, total)
  end
  res
end;

function interior(t)
  t[2:end-1]
end;

function interior!(t)
  popfirst!(t)
  pop!(t)
  nothing
end;

function eh_ordenada(t)
  t == sort(t)
end;
----

[[ex10-1]]
===== Exercício 10-1

Escreva uma função chamada +soma_aninhada+ que pegue uma lista de listas com números inteiros e adicione os elementos de todas as listas aninhadas. Por exemplo:
(((soma_aninhada)))((("função", "definida pelo programador", "soma_aninhada", see="soma_aninhada")))

[source,@julia-repl-test chap10]
----
julia> t = [[1, 2], [3], [4, 5, 6]];

julia> soma_aninhada(t)
21
----

[[ex10-2]]
===== Exercício 10-2

Escreva uma função chamada +soma_cumulativa+ que pega uma lista de números e retorne a soma cumulativa; isto é, uma nova lista em que o latexmath:[\(i\)]-ésimo elemento é a soma do primeiro elemento latexmath:[\(i\)] da lista original. Por exemplo:
(((soma_cumulativa)))((("função", "definido pelo programador", "soma_cumulativa", see="soma_cumulativa")))

[source,@julia-repl-test chap10]
----
julia> t = [1, 2, 3];

julia> print(soma_cumulativa(t))
Any[1, 3, 6]
----

[[ex10-3]]
===== Exercício 10-3

Escreva uma função chamada +interior+ que pega uma lista e retorna uma nova lista que contém tudo exceto o primeiro e o último elemento. Por exemplo:
(((interior)))((("função", "definido pelo programador", "interior", see="interior")))

[source,@julia-repl-test chap10]
----
julia> t = [1, 2, 3, 4];

julia> print(interior(t))
[2, 3]
----

[[ex10-4]]
===== Exercício 10-4

Escreva uma função chamada +interior!+ Que pegue uma lista, modifique-a removendo o primeiro e o último elementos e retorne +nothing+. Por exemplo:
(((interior!)))((("função", "definido pelo programador", "interior!", see="interior!")))

[source,@julia-repl-test chap10]
----
julia> t = [1, 2, 3, 4];

julia> interior!(t)

julia> print(t)
[2, 3]
----

[[ex10-5]]
===== Exercício 10-5

Escreva uma função chamada +eh_ordenadaa+ que use uma lista como parâmetro e retorne +true+ se a lista for classificada em ordem crescente e +false+ caso contrário. Por exemplo:
(((eh_ordenada)))((("função", "definido pelo programador", "eh_ordenada", see="eh_ordenada")))

[source,@julia-repl-test chap10]
----
julia> eh_ordenada([1, 2, 2])
true
julia> eh_ordenada(['b', 'a'])
false
----

[[ex10-6]]
===== Exercício 10-6

Duas palavras são anagramas se você puder reorganizar as letras de uma para soletrar a outra. Escreva uma função chamada + isanagram + que use duas strings e retorne + true + se forem anagramas.
(((eh_anagrama)))((("função", "definida pelo programador", "eh_anagrama", see="eh_anagrama")))

[[ex10-7]]
===== Exercise 10-7

Escreva uma função chamada +tem_duplas+ que pegue uma lista e retorne +true+ se houver algum elemento que apareça mais de uma vez. Não deve modificar a lista original.
(((tem_duplas)))((("função", "definida pelo programador", "tem_duplas", see="tem_duplas")))

[[ex10-8]]
===== Exercício 10-8

Este exercício refere-se ao chamado Paradoxo de Aniversário, sobre o qual você pode ler em https://en.wikipedia.org/wiki/Birthday_paradox.
(((Paradoxo de Aniversário)))

Se houver 23 alunos em sua turma, quais são as chances de vocês dois terem o mesmo aniversário? Você pode estimar essa probabilidade gerando amostras aleatórias de 23 aniversários e verificando correspondências.
(((aleatório)))((("função", "Base", "aleatório", see="aleatório")))

[TIP]
====
Você pode gerar aniversário aleatório com +rand(1:365)+.
====

[[ex10-9]]
===== Exercício 10-9

Escreva uma função que leia o arquivo +words.txt+ e crie uma lista com um elemento por palavra. Escreva duas versões dessa função, uma usando + push! + E a outra usando o idioma +t=[pass:[t ...], x]+. Qual deles demora mais para ser executado? Por quê?
(((push!)))

[[ex10-10]]
===== Exercício 10-10

Para verificar se uma palavra está na lista de palavras, você pode usar o operador +∈+, mas seria lento porque pesquisará as palavras em ordem.

Como as palavras estão em ordem alfabética, podemos acelerar as coisas com uma pesquisa por bissecção (também conhecida como pesquisa binária), que é semelhante ao que você faz quando procura uma palavra no dicionário. Você começa no meio e verifica se a palavra que você procura vem antes da palavra no meio da lista. Nesse caso, você pesquisa a primeira metade da lista da mesma maneira. Caso contrário, você pesquisará a segunda metade.

De qualquer forma, você reduz pela metade o espaço restante da pesquisa. Se a lista de palavras tiver 113.809 palavras, serão necessárias 17 etapas para encontrar a palavra ou concluir que ela não existe.

Escreva uma função chamada +eh_bissecão+ que usa uma lista classificada e um valor-alvo e retorna +true+ se a palavra estiver na lista e +false+ se não estiver.
(((eh_bissecão)))((("função", "definido pelo programador", "eh_bissecão", see="eh_bissecão")))

[[ex10-11]]
===== Exercício 10-11

Duas palavras são um "par reverso" se cada uma for o inverso da outra. Escreva um programa +par_reverso+ que encontre todos os pares reversos na lista de palavras.
(((par_reverso)))((("função", "definida pelo programador", "par_reverso", see="par_reverso")))

Duas palavras "interligam" se receber letras alternadas de cada uma forma uma nova palavra. Por exemplo, "micro" e "ondas" se interligam para formar "microondas".
(((interligar)))

Crédito: Este exercício é inspirado em um exemplo em http://puzzlers.org.

. Escreva um programa que encontre todos os pares de palavras que se entrelaçam.
+
[GORJETA]
====
Não enumere todos os pares!
====

. Você consegue encontrar alguma palavra intertravada de três vias; isto é, toda terceira letra forma uma palavra, começando na primeira, segunda ou terceira?
