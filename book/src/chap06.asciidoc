[[chap06]]
== Funções produtivas

Muitas das funções de Julia usadas, como as funções matemáticas, produzem valores de retorno. Contudo, as funções que escrevemos são todas nulas: têm um efeito, como imprimir um valor ou mover uma tartaruga, mas retornam +nothing+. Neste capítulo você aprenderá a elaborar funções produtivas.
(((função produtiva)))


=== Valores de retorno

A chamada de uma função gera um valor de retorno, que geralmente atribuímos a uma variável ou utilizamos como parte de uma expressão.

[source,julia]
----
e = exp(1.0)
altura = raio * sin(radianos)
----

As funções escritas até o momento são nulas, que significa que elas não têm valor de retorno; mais precisamente, seu valor de retorno é +nothing+. Neste capítulo, (finalmente) vamos escrever funções produtivas. O primeiro exemplo é +área+, que retorna a área de um círculo dado um raio:
(((nothing)))(((área)))((("função", "definido pelo programador", "área", see="área")))

[source,@julia-setup]
----
function área(raio)
    a = π * raio^2
    return a
end
----

Já vimos a declaração +return+ anteriormente, mas em uma função produtiva a declaração +retorno+ inclui uma expressão. Esta declaração significa: "Retorne imediatamente a partir desta função e leve a expressão seguinte como um valor de retorno". A expressão pode ser arbitrariamente complicada, e então poderíamos ter escrito uma função mais sucinta:
(((declaração de retorno)))

[source,@julia-setup]
----
function área(raio)
    π * raio^2
end
----

O valor retornado por uma função é o valor da última expressão executada, que, por padrão, é a última expressão no corpo da definição da função.

Além disso, _variáveis temporárias_ como +a+ e as intruções explícitas +return+ podem contribuir para a depuração.
(((variável temporária)))

Às vezes, é prático ter diversas instruções +return+, uma em cada ramo de uma condicional:
(((valorAbsoluto)))((("função", "definido pelo programador", "valorAbsoluto", see="valorAbsoluto")))

[source,@julia-setup chap06]
----
function valorAbsoluto(x)
    if x < 0
        return -x
    else
        return x
    end
end
----

Já que estas instruções de retorno estão em uma alternativa condicional, somente uma é executada.
(((alternativa condicional)))

Assim que um comando +return+ é executado, a função termina sem executar qualquer comando posterior. O código que aparece após um comando +return+, ou qualquer outro lugar que o fluxo de execução não alcance, é chamado de _código morto_.
(((fluxo de execução)))(((código morto)))

Em uma função produtiva, recomendamos garantir que todos os caminhos possíveis através do programa chegue em uma declaração de retorno. Por exemplo:

[source,@julia-setup chap06]
----
function valorAbsoluto(x)
    if x < 0
        return -x
    end
    if x > 0
        return x
    end
end
----

Esta função está incorreta porque se +x+ for 0, nenhuma das condições é verdadeira, e a função termina sem chegar a uma instrução +retorno+. Quando o fluxo de execução chegar ao final de uma função, o valor de retorno é +nothing+, que não é o valor absoluto de 0.

[source,@julia-repl-test chap06]
----
julia> show(absvalue(0))
nothing
----

[TIP]
====
Julia tem uma função interna chamada +abs+ que calcula valores absolutos.
(((abs)))((("função", "Base", "abs", see="abs")))
====

===== Exercício 6-1

Escreva uma função +comparar+ que recebe dois valores, +x+ e +y+, e retorna +1+ se +x > y+, +0+ se +x == y+ e +-1+ se +x < y+.


[[incremental_development]]
=== Desenvolvimento incremental

À medida que se escreve funções maiores, talvez aconteça de você passar mais tempo depurando.
(((debugging)))

Ao lidar com programas cada vez mais complexos, tente um processo chamado _desenvolvimento incremental_, que adiciona e testa apenas uma pequena quantidade de código por vez, evitando assim longas sessões de debugging.
(((desenvolvimento incremental)))

Como exemplo, suponha que você queira determinar a distância entre dois pontos, dada pelas coordenadas latexmath:[\(\left(x_1, y_1\right)\)] e latexmath:[\(\left(x_2, y_2\right)\)]. Pelo teorema de Pitágoras, a distância é:
(((teorema de Pitágoras)))

[latexmath]
++++
\begin{equation}
{d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}}
\end{equation}
++++

O primeiro passo é avaliar como deve ser uma função de distância em Julia. Em outras palavras, quais são as entradas (os parâmetros) e qual é a saída (o valor de retorno)?

Neste exemplo, as entradas são dois pontos, que pode ser representado por quatro números. Já o valor de retorno é a distância representada por um valor de ponto flutuante.

Com isso, pode-se esboçar a função:
(((distância))) (((("função", "definido pelo programador", "distância", see="distância"))))

[source,@julia-setup chap06]
----
function distância(x₁, y₁, x₂, y₂)
    0.0
end
----

Obviamente que esta versão da função não computa as distâncias pois ela sempre retorna zero. Mas é sintaticamente correta, e roda, o que significa que você pode testá-la antes de complicá-la. Os números dos subscritos estão disponíveis na codificação de caracteres Unicode (*+\_1 TAB+*, *+\_2 TAB+*, etc.).
(((caracter Unicode)))

Para testar a nova função, chame-a com argumentos do exemplo abaixo:

[source,@julia-repl-test chap06]
----
distância(1, 2, 4, 6)
----

Escolhi estes valores para que a distância horizontal seja 3 e a vertical seja 4; logo, o resultado é 5 porque é a hipotenusa de um triângulo retângulo 3-4-5. Quando testar uma função, é conveniente saber a resposta correta.

Nesse ponto, como já confirmamos que a função está sintaticamente correta então podemos começar a adicionar código ao corpo. Um próximo passo razoável é encontrar as diferenças latexmath:[\(x_2 - x_1\)] e latexmath:[\(y_2 - y_1\)]. A próxima versão armazena esses valores em variáveis temporárias que são mostradas com a macro +@show+.
((("@show")))((("macro", "Base", "@show", see="@show")))

[source,@julia-setup]
----
function distância(x₁, y₁, x₂, y₂)
    dx = x₂ - x₁
    dy = y₂ - y₁
    @show dx dy
    0.0
end
----

Se a função estiver funcionando, ela deve exibir +dx = 3+ e +dy = 4+. Nesse caso, sabemos que a função está obtendo os argumentos certos e executando os primeiros cálculos corretamente. Caso contrário, há apenas poucas linhas para analisar.

Em seguida, somamos os quadrados +dx+ e +dy+:

[source,@julia-setup]
----
function distância(x₁, y₁, x₂, y₂)
    dx = x₂ - x₁
    dy = y₂ - y₁
    d² = dx^2 + dy^2
    @show d²
    0.0
end
----

Você executaria o programa mais uma vez nesse estágio e verificaria a saída (que deveria ser 25). Números sobrescritos também estão disponíveis (*+\^2 TAB+*). Por fim, você pode usar +sqrt+ para calcular e retornar o resultado:
(((sqrt)))

[source,@julia-setup]
----
function distância(x₁, y₁, x₂, y₂)
    dx = x₂ - x₁
    dy = y₂ - y₁
    d² = dx^2 + dy^2
    sqrt(d²)
end
----

Se a função rodar corretamente, pronto. Caso contrário, convém mostrar o valor de +sqrt(d²)+ antes da instrução +return+.

A versão final da função não exibe nada quando é executada, retornando apenas um valor. As instruções de impressão que escrevemos são úteis para o debugging, mas depois que a função estiver funcionando, deve-se removê-las. Um código como esse é chamado _andaime_ porque é útil para criar o programa, mas não faz parte do produto final.
(((andaime)))

Ao iniciar, você deve adicionar apenas uma ou duas linhas de código por vez. À medida que você ganha mais experiência, pode se escrever e debugar pedaços maiores. De qualquer forma, o desenvolvimento incremental pode economizar muito tempo de debugging.

Os principais aspectos do processo são:

. Comece com um programa funcional e faça pequenas alterações incrementais. A qualquer momento, se houver um erro, você deverá ter uma boa idéia de onde está.

. Use variáveis para armazenar valores intermediários de modo que você possa visualizá-los e verificá-los.

. Uma vez que o programa esteja funcionando, você pode querer retirar algumass das instruções andaimes ou consolidar múltiplos comandos em expressões compostas, mas desde que não dificulte a leitura do programa.

===== Exercício 6-2

Use o desenvolvimento incremental para escrever uma função chamada +hipotenusa+ que retorna o comprimento da hipotenusa de um triângulo retângulo, considerando os comprimentos dos outros dois catetos como argumentos. Registre cada estágio do processo de desenvolvimento à medida que avança.


=== Composition

Como já esperado, você pode chamar uma função de dentro da outra. Para exemplificar isto, escreveremos uma função que calcula a área do círculo a partir de dois pontos, o centro do círculo e um ponto no perímetro.
(((composição)))

Suponha que o ponto central é indicado pelas variáveis +xc+ e +yc+, e o ponto de perímetro indicado por +xp+ e +yp+. O primeiro passo é encontrar o raio do círculo, dado pela distância entre estes dois pontos. Para isso, elaboramos a função distância:

[source,julia]
----
raio = distância(xc, yc, xp, yp)
----

O próximo passo é calcular a área de um círculo a partir desse raio, e por isso também escrevemos isso:

[source,julia]
----
resultado = área(raio)
----

Encapsulando esses passos em uma função, temos:
(((área_círculo)))((("função", "definido pelo programador", "área_círculo", see="área_círculo")))

[source,@julia-setup]
----
function área_círculo(xc, yc, xp, yp)
    raio = distância(xc, yc, xp, yp)
    resultado = área(raio)
    return resultado
end
----

As variáveis temporárias +raio+ e +resultado+ são úteis para o desenvolvimento e o debugging, mas depois que o programa estiver funcionando, podemos torná-lo mais conciso fazendo:
(((variável temporária)))

[source,@julia-setup]
----
function área_círculo(xc, yc, xp, yp)
    área(distância(xc, yc, xp, yp))
end
----


[[boolean_functions]]
=== Funções booleanas

As funções podem retornar variáveis booleanas, o que muitas vezes é conveniente para ocultar testes complicados dentro de funções. Por exemplo:
(((função booleana))) (((é_divisível))) ((("função", "definido pelo programador", "é_divisível", consulte = "é_divisível")))

[source,@julia-setup chap06]
----
function é_divisível(x, y)
    if x % y == 0
        return true
    else
        return false
    end
end
----

Frequentemente se atribui nomes de funções booleanas que soam como perguntas de sim/não; neste caso, +é_divisível+ retorna +true+ ou +false+ para saber se +x+ é divisível por +y+.

Here is an example:

[source,@julia-repl-test chap06]
----
julia> isdivisible(6, 4)
false
julia> isdivisible(6, 3)
true
----

The result of the +==+ operator is a boolean, so we can write the function more concisely by returning it directly:
(((==)))

[source,@julia-setup]
----
function isdivisible(x, y)
    x % y == 0
end
----

Boolean functions are often used in conditional statements:
(((conditional statement)))

[source,julia]
----
if isdivisible(x, y)
    println("x is divisible by y")
end
----

It might be tempting to write something like:

[source,julia]
----
if isdivisible(x, y) == true
    println("x is divisible by y")
end
----

But the extra comparison with +true+ is unnecessary.

===== Exercício 6-3

Write a function +isbetween(x, y, z)+ that returns +true+ if +x ≤ y ≤ z+ or +false+ otherwise.


=== More Recursion

We have only covered a small subset of Julia, but you might be interested to know that this subset is a _complete_ programming language, which means that anything that can be computed can be expressed in this language. Any program ever written could be rewritten using only the language features you have learned so far (actually, you would need a few commands to control devices like the mouse, disks, etc., but that’s all).
(((recursion)))(((complete programming language)))((("programming language", "complete", see="complete programming language")))

Proving that claim is a nontrivial exercise first accomplished by Alan Turing, one of the first computer scientists (some would argue that he was a mathematician, but a lot of early computer scientists started as mathematicians). Accordingly, it is known as the Turing Thesis. For a more complete (and accurate) discussion of the Turing Thesis, I recommend Michael Sipser’s book _Introduction to the Theory of Computation_.
(((Turing, Alan)))(((Turing thesis)))

To give you an idea of what you can do with the tools you have learned so far, we’ll evaluate a few recursively defined mathematical functions. A recursive definition is similar to a circular definition, in the sense that the definition contains a reference to the thing being defined. A truly circular definition is not very useful:
(((recursive definition)))(((circular definition)))

vorpal::
An adjective used to describe something that is vorpal.

If you saw that definition in the dictionary, you might be annoyed. On the other hand, if you looked up the definition of the factorial function, denoted with the symbol latexmath:[\(!\)], you might get something like this:
(((factorial function)))

[latexmath]
++++
\begin{equation}
{n! =
\begin{cases}
  1& \textrm{if}\  n = 0 \\
  n (n-1)!& \textrm{if}\  n > 0
\end{cases}}
\end{equation}
++++
This definition says that the factorial of 0 is 1, and the factorial of any other value, latexmath:[\(n\)], is latexmath:[\(n\)] multiplied by the factorial of latexmath:[\(n-1\)].

So latexmath:[\(3!\)] is 3 times latexmath:[\(2!\)], which is 2 times latexmath:[\(1!\)], which is 1 times latexmath:[\(0!\)]. Putting it all together, latexmath:[\(3!\)] equals 3 times 2 times 1 times 1, which is 6.

If you can write a recursive definition of something, you can write a Julia program to evaluate it. The first step is to decide what the parameters should be. In this case it should be clear that factorial takes an integer:
(((fact)))((("função", "definido pelo programador", "fact", see="fact")))

[source,@julia-setup]
----
function fact(n) end
----

If the argument happens to be +0+, all we have to do is return +1+:

[source,@julia-setup]
----
function fact(n)
    if n == 0
        return 1
    end
end
----

Otherwise, and this is the interesting part, we have to make a recursive call to find the factorial of +n-1+ and then multiply it by +n+:

[source,@julia-setup]
----
function fact(n)
    if n == 0
        return 1
    else
        recurse = fact(n-1)
        result = n * recurse
        return result
    end
end
----

The flow of execution for this program is similar to the flow of +countdown+ in <<recursion>>. If we call +fact+ with the value +3+:
(((flow of execution)))

[small]
--
Since +3+ is not +0+, we take the second branch and calculate the factorial of +n-1+ ...

pass:[&#8193;]Since +2+ is not +0+, we take the second branch and calculate the factorial of +n-1+ ...

pass:[&#8193;&#8193;]Since +1+ is not +0+, we take the second branch and calculate the factorial of +n-1+ ...

pass:[&#8193;&#8193;&#8193;]Since +0+ equals +0+, we take the first branch and return +1+ without making any pass:[<br/>&#8193;&#8193;&#8193;&#8193;]more recursive calls.

pass:[&#8193;&#8193;]The return value, +1+, is multiplied by +n+, which is +1+, and the +result+ is returned.

pass:[&#8193;]The return value, +1+, is multiplied by +n+, which is +2+, and the +result+ is returned.

The return value +2+ is multiplied by +n+, which is +3+, and the result, +6+, becomes the return value of the function call that started the whole process.
--

[[fig06-1]]
.Stack diagram
image::images/fig61.svg[]


<<fig06-1>> shows what the stack diagram looks like for this sequence of function calls.
(((stack diagram)))

The return values are shown being passed back up the stack. In each frame, the return value is the value of +result+, which is the product of +n+ and +recurse+.

In the last frame, the local variables +recurse+ and +result+ do not exist, because the branch that creates them does not run.

[TIP]
====
Julia provides the function +factorial+ to calculate the factorial of an integer number.
(((factorial)))((("função", "Base", "factorial", see="factorial")))
====


=== Leap of Faith

Following the flow of execution is one way to read programs, but it can quickly become overwhelming. An alternative is what I call the “leap of faith”. When you come to a function call, instead of following the flow of execution, you _assume_ that the function works correctly and returns the right result.
(((leap of faith)))

In fact, you are already practicing this leap of faith when you use built-in functions. When you call +cos+ or +exp+, you don’t examine the bodies of those functions. You just assume that they work because the people who wrote the built-in functions were good programmers.

The same is true when you call one of your own functions. For example, in <<boolean_functions>>, we wrote a function called +isdivisible+ that determines whether one number is divisible by another. Once we have convinced ourselves that this function is correct—by examining the code and testing—we can use the function without looking at the body again.

The same is true of recursive programs. When you get to the recursive call, instead of following the flow of execution, you should assume that the recursive call works (returns the correct result) and then ask yourself, “Assuming that I can find the factorial of latexmath:[\(n-1\)], can I compute the factorial of latexmath:[\(n\)]?” It is clear that you can, by multiplying by latexmath:[\(n\)].

Of course, it’s a bit strange to assume that the function works correctly when you haven’t finished writing it, but that’s why it’s called a leap of faith!

[[one_more_example]]
=== One More Example

After factorial, the most common example of a recursively defined mathematical function is fibonacci, which has the following definition (see https://en.wikipedia.org/wiki/Fibonacci_number):
(((fibonnaci function)))

[latexmath]
++++
\begin{equation}
{fib(n) =
\begin{cases}
    0& \textrm{if}\  n = 0 \\
    1& \textrm{if}\  n = 1 \\
    fib(n-1) + fib(n-2)& \textrm{if}\  n > 1
\end{cases}}
\end{equation}
++++

Translated into Julia, it looks like this:
(((fib)))((("função", "definido pelo programador", "fib", see="fib")))

[source,@julia-setup chap06]
----
function fib(n)
    if n == 0
        return 0
    elseif n == 1
        return 1
    else
        return fib(n-1) + fib(n-2)
    end
end
----

If you try to follow the flow of execution here, even for fairly small values of +n+, your head explodes. But according to the leap of faith, if you assume that the two recursive calls work correctly, then it is clear that you get the right result by adding them together.


=== Checking Types

What happens if we call +fact+ and give it +1.5+ as an argument?
(((StackOverflowError)))

[source,jlcon]
----
julia> fact(1.5)
ERROR: StackOverflowError:
Stacktrace:
 [1] fact(::Float64) at ./REPL[3]:2
----

It looks like an infinite recursion. How can that be? The function has a base case—when +n == 0+. But if +n+ is not an integer, we can _miss_ the base case and recurse forever.
(((infinite recursion)))

In the first recursive call, the value of +n+ is +0.5+. In the next, it is +-0.5+. From there, it gets smaller (more negative), but it will never be +0+.

We have two choices. We can try to generalize the factorial function to work with floating-point numbers, or we can make +fact+ check the type of its argument. The first option is called the gamma function and it’s a little beyond the scope of this book. So we’ll go for the second.
(((gamma function)))

We can use the built-in operator +isa+ to verify the type of the argument. While we’re at it, we can also make sure the argument is positive:
(((isa)))(((fact)))

[source,@julia-setup chap06]
----
function fact(n)
    if !(n isa Int64)
        error("Factorial is only defined for integers.")
    elseif n < 0
        error("Factorial is not defined for negative integers.")
    elseif n == 0
        return 1
    else
        return n * fact(n-1)
    end
end
----

The first base case handles nonintegers; the second handles negative integers. In both cases, the program prints an error message and returns +nothing+ to indicate that something went wrong:

[source,@julia-repl-test chap06]
----
julia> fact("fred")
ERROR: Factorial is only defined for integers.
julia> fact(-2)
ERROR: Factorial is not defined for negative integers.
----

If we get past both checks, we know that +n+ is positive or zero, so we can prove that the recursion terminates.

This program demonstrates a pattern sometimes called a _guardian_. The first two conditionals act as guardians, protecting the code that follows from values that might cause an error. The guardians make it possible to prove the correctness of the code.
(((guardian)))

In <<catching_exceptions>> we will see a more flexible alternative to printing an error message: raising an exception.

[[deb06]]
=== Debugging

Breaking a large program into smaller functions creates natural checkpoints for debugging. If a function is not working, there are three possibilities to consider:
(((debugging)))

* There is something wrong with the arguments the function is getting; a precondition is violated.
(((precondition)))

* There is something wrong with the function; a postcondition is violated.
(((postcondition)))

* There is something wrong with the return value or the way it is being used.

To rule out the first possibility, you can add a print statement at the beginning of the function and display the values of the parameters (and maybe their types). Or you can write code that checks the preconditions explicitly.

If the parameters look good, add a print statement before each return statement and display the return value. If possible, check the result by hand. Consider calling the function with values that make it easy to check the result (as in <<incremental_development>>).

If the function seems to be working, look at the function call to make sure the return value is being used correctly (or used at all!).

Adding print statements at the beginning and end of a function can help make the flow of execution more visible. For example, here is a version of +fact+ with print statements:
(((fact)))(((flow of execution)))(((print statement)))

[source,@julia-setup chap06]
----
function fact(n)
    space = " " ^ (4 * n)
    println(space, "factorial ", n)
    if n == 0
        println(space, "returning 1")
        return 1
    else
        recurse = fact(n-1)
        result = n * recurse
        println(space, "returning ", result)
        return result
    end
end
----

+space+ is a string of space characters that controls the indentation of the output:

[source,@julia-repl chap06]
----
fact(4)
----

If you are confused about the flow of execution, this kind of output can be helpful. It takes some time to develop effective scaffolding, but a little bit of scaffolding can save a lot of debugging.


=== Glossary

temporary variable::
A variable used to store an intermediate value in a complex calculation.
(((temporary variable)))

dead code::
Part of a program that can never run, often because it appears after a return statement.
(((dead code)))

incremental development::
A program development plan intended to avoid debugging by adding and testing only a small amount of code at a time.
(((incremental development)))(((program development plan)))

scaffolding::
Code that is used during program development but is not part of the final version.
(((scaffolding)))

guardian::
A programming pattern that uses a conditional statement to check for and handle circumstances that might cause an error.
(((guardian)))


=== Exercícios

[[ex06-1]]
===== Exercício 6-4

Draw a stack diagram for the following program. What does the program print?

[source,@julia-setup]
----
function b(z)
    prod = a(z, z)
    println(z, " ", prod)
    prod
end

function a(x, y)
    x = x + 1
    x * y
end

function c(x, y, z)
    total = x + y + z
    square = b(total)^2
    square
end

x = 1
y = x + 1
println(c(x, y+3, x+y))
----

[[ex06-2]]
===== Exercício 6-5

The Ackermann function, latexmath:[\(A(m, n)\)], is defined:
(((Ackermann function)))

[latexmath]
++++
\begin{equation}
{A(m, n) =
\begin{cases}
              n+1& \textrm{if}\ m = 0 \\
        A(m-1, 1)& \textrm{if}\ m > 0\ \textrm{and}\ n = 0 \\
A(m-1, A(m, n-1))& \textrm{if}\ m > 0\ \textrm{and}\ n > 0.
\end{cases}}
\end{equation}
++++
See https://en.wikipedia.org/wiki/Ackermann_function. Write a function named +ack+ that evaluates the Ackermann function. Use your function to evaluate +ack(3, 4)+, which should be 125. What happens for larger values of +m+ and +n+?
(((ack)))((("função", "definido pelo programador", "ack", see="ack")))

[[ex06-3]]
===== Exercício 6-6

A palindrome is a word that is spelled the same backward and forward, like “noon” and “redivider”. Recursively, a word is a palindrome if the first and last letters are the same and the middle is a palindrome.
(((palindrome)))

The following are functions that take a string argument and return the first, last, and middle letters:
(((first)))((("função", "definido pelo programador", "first", see="first")))(((last)))((("função", "definido pelo programador", "last", see="last")))(((middle)))((("função", "definido pelo programador", "middle", see="middle")))

[source,@julia-setup]
----
function first(word)
    first = firstindex(word)
    word[first]
end

function last(word)
    last = lastindex(word)
    word[last]
end

function middle(word)
    first = firstindex(word)
    last = lastindex(word)
    word[nextind(word, first) : prevind(word, last)]
end
----

We’ll see how they work in <<chap08>>

. Test these functions out. What happens if you call middle with a string with two letters? One letter? What about the empty string, which is written +""+ and contains no letters?

. Write a function called +ispalindrome+ that takes a string argument and returns +true+ if it is a palindrome and +false+ otherwise. Remember that you can use the built-in function +length+ to check the length of a string.
(((ispalindrome)))((("função", "definido pelo programador", "ispalindrome", see="ispalindrome")))(((length)))

[[ex06-4]]
===== Exercício 6-7

A number, latexmath:[\(a\)], is a power of latexmath:[\(b\)] if it is divisible by latexmath:[\(b\)] and latexmath:[\(\frac{a}{b}\)] is a power of latexmath:[\(b\)]. Write a function called +ispower+ that takes parameters +a+ and +b+ and returns +true+ if +a+ is a power of +b+.
(((ispower)))((("função", "definido pelo programador", "ispower", see="ispower")))

[TIP]
====
You will have to think about the base case.
====

[[ex06-5]]
===== Exercício 6-8

The greatest common divisor (GCD) of latexmath:[\(a\)] and latexmath:[\(b\)] is the largest number that divides both of them with no remainder.

One way to find the GCD of two numbers is based on the observation that if latexmath:[\(r\)] is the remainder when latexmath:[\(a\)] is divided by latexmath:[\(b\)], then +gcd(a, b) = gcd(b, r)+. As a base case, we can use +gcd(a, 0) = a+.

Write a function called +gcd+ that takes parameters +a+ and +b+ and returns their greatest common divisor.
(((gcd)))((("função", "definido pelo programador", "gcd", see="gcd")))

Credit: This exercise is based on an example from Abelson and Sussman’s _Structure and Interpretation of Computer Programs_.
