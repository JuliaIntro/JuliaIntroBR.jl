[[chap19]]
== Extra: Sintaxe

Uma das nossas metas para este livro √© ensinar o m√≠nimo poss√≠vel de Julia. Quando havia duas formas de fazer algo, escolh√≠amos uma e evit√°vamos mencionar a outra. Ou √†s vezes, prop√∫nhamos a segunda forma como exerc√≠cio.

Agora queremos retornar a algumas coisas boas que ficaram pra tr√°s. O Julia oferece uma variadade de recursos que n√£o s√£o realmente necess√°rios‚Äîvoc√™ pode escrever um bom c√≥digo sem eles‚Äîmas com eles pode-se escrever um c√≥digo mais conciso, leg√≠vel ou eficiente e, √†s vezes, todos os tr√™s.

Neste e no pr√≥ximo cap√≠tulo, iremos discutir coisas dos cap√≠tulos anteriores que deixamos para tr√°s:

* os suplementos de sintaxe
* as fun√ß√µes, os tipos e as macros diretamente dispon√≠veis em +Base+
(((Base)))
* as fun√ß√µes, os tipos e as macros da Biblioteca Padr√£o
(((Biblioteca Padr√£o)))

=== Tuplas Nomeadas

Voc√™ pode nomear os componentes de uma tupla, criando uma tupla nomeada.

[source,@julia-repl-test]
----
julia> x = (a=1, b=1+1)
(a = 1, b = 2)
julia> x.a
1
----

Nas tuplas nomeadas, os campos podem ser acessados pelo nome usando a sintaxe do ponto +(x.a)+.
(((tupla nomeada)))(((sintaxe do ponto)))


=== Fun√ß√µes

Uma fun√ß√£o no Julia pode ser definida por uma sintaxe compacta:

[source,@julia-repl-test]
----
julia> f(x,y) = x + y
f (generic function with 1 method)
----

[[anonymous_functions]]
==== Fun√ß√µes An√¥nimas

Podemos definir uma fun√ß√£o sem especificar um nome:

[source,@julia-repl-test]
----
julia> x -> x^2 + 2x - 1
#1 (generic function with 1 method)
julia> function (x)
           x^2 + 2x - 1
       end
#3 (generic function with 1 method)
----

Estes s√£o os exemplos de _fun√ß√µes an√¥nimas_. E elas geralmente s√£o usadas como argumentos para outras fun√ß√µes:
(((fun√ß√£o an√¥nima)))(((Plots)))((("m√≥dulo", "Plots", see="Plots")))(((plot)))((("fun√ß√£o", "Plots", "plot", see="plot")))

[source,jlcon]
----
julia> using Plots

julia> plot(x -> x^2 + 2x - 1, 0, 10, xlabel="x", ylabel="y")

----

<<fig19-1>> mostra a sa√≠da do comando plot.

[[fig19-1]]
.Plot
image::images/fig191.svg[pdfwidth="10cm"]

==== Argumentos de Palavras-Chave

Argumentos de fun√ß√µes tamb√©m podem ser nomeadas:

[source,@julia-repl-test]
----
julia> function meu_plot(x, y; style="solid", width=1, color="black")
           ###
       end
meu_plot (generic function with 1 method)
julia> meu_plot(0:10, 0:10, style="dotted", color="blue")

----

_Argumentos de palavras-chave_ em uma fun√ß√£o s√£o especificados depois de um ponto e v√≠rgula na assinatura, apesar de poder ser chamado com uma v√≠rgula.
(((;)))(((argumentos de palavra-chave)))

==== Fechamentos

Um _fechamento_ √© uma t√©cnica que permite uma fun√ß√£o capturar uma vari√°vel definida fora do escopo da chamada da fun√ß√£o.

[source,@julia-repl-test]
----
julia> foo(x) = ()->x
foo (generic function with 1 method)

julia> bar = foo(1)
#1 (generic function with 1 method)

julia> bar()
1
----

Nesse exemplo, a fun√ß√£o +foo+ retorna uma fun√ß√£o an√¥nima que possui acesso ao argumento +x+ da fun√ß√£o +foo+. A vari√°vel +bar+ aponta para a fun√ß√£o an√¥nima e retorna o valor do argumento de +foo+.


=== Blocos

Um _bloco_ √© uma forma de agrupar diversos comandos. Um bloco come√ßa com a palavra-chave +begin+ e termina com +end+.
(((begin)))((("palavra-chave", "begin", see="begin")))(((end)))(((bloco)))

No <<chap04>>, a macro +@svg+ foi introduzida:

[source,julia]
----
üê¢ = Turtle()
@svg begin
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
end
----

Neste exemplo, a macro +@svg+ possui um argumento √∫nico, i.e. um bloco que est√° agrupando 3 chamadas de fun√ß√£o.

==== Blocos +let+

Um bloco +let+ √© √∫til para criar novas liga√ß√µes, i.e. locais que podem se referir a valores.

[source,@julia-repl-test]
----
julia> x, y, z = -1, -1, -1;

julia> let x = 1, z
           @show x y z;
       end
x = 1
y = -1
ERROR: UndefVarError: z not defined
julia> @show x y z;
x = -1
y = -1
z = -1
----

Nesse exemplo, a primeira macro +@show+ mostra o +x+ local, a global +y+ e a local indefinida +z+. As vari√°veis globais s√£o intoc√°veis.


==== Blocos +do+

Em <<reading_and_writing>>, tivemos que fechar o arquivo ap√≥s o t√©rmino da escrita. Isso pode ser feito automaticamente usando um _bloco do_:
(((do)))((("palavra-chave", "do", see="do")))

[source,@julia-repl-test chap19]
----
julia> dado = "O meu nome √© Severino, \nn√£o tenho outro de pia.\n"
"O meu nome √© Severino, \nn√£o tenho outro de pia.\n"
julia> open("output.txt", "w") do fout
           write(fout, dado)
       end
48
----

Nesse exemplo, +fout+ √© um fluxo de arquivo usado para a sa√≠da.

Essa funcionalidade √© equivalente a

[source,@julia-repl-test chap19]
----
julia> f = fout -> begin
           write(fout, dado)
       end
#3 (generic function with 1 method)
julia> open(f, "output.txt", "w")
48
----

A fun√ß√£o an√¥nima √© usada como o primeiro argumento da fun√ß√£o +open+:
(((open)))

[source,julia]
----
function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end
----

Um bloco +do+ pode ‚Äúcapturar‚Äù as vari√°veis dos seus escopos anexos. Por exemplo, a vari√°vel +dado+ em +open pass:[...] do+ no exemplo acima √© capturada de outro escopo.


=== Controle de Fluxo

==== Operador Tern√°rio

O _operador tern√°rio_ +?:+ √© uma alternativa para uma declara√ß√£o +if-else+ usada quando voc√™ precisa fazer uma escolha entre valores de express√£o √∫nica.
(((?:)))((("operador", "Base", "?:", see="?:")))((("operador tern√°rio", see="?:")))

[source,@julia-repl-test]
----
julia> a = 150
150
julia> a % 2 == 0 ? println("par") : println("√≠mpar")
par
----

A express√£o antes de +?+ √© uma condi√ß√£o. Se a condi√ß√£o for +true+, a express√£o antes de +:+ √© avaliada, caso contr√°rio, a express√£o depois de +:+ √© avaliada.

==== Avalia√ß√£o de Curto-Circu√≠to

Os operadores +&&+ e +||+ fazem uma _avalia√ß√£o de curto-circuito_: o pr√≥ximo argumento s√≥ √© avaliado quando √© necess√°rio determinar o valor final.
(((&&)))(((||)))(((avalia√ß√£o de curto-circuito)))

Por exemplo, uma rotina recursiva do fatorial pode ser definida da seguinte maneira:
(((fat)))

[source,@julia-setup]
----
function fat(n::Integer)
    n >= 0 || error("n deve ser inteiro n√£o negativo")
    n == 0 && return 1
    n * fat(n-1)
end
----

==== Tarefas (tamb√©m conhecida como Corrotina)

Uma _tarefa_ √© uma estrutura de controle que pode passar pelo controle cooperativamente sem retornar. Em Julia, uma tarefa pode ser implementada como uma fun√ß√£o tendo como o primeiro argumento um objeto de canal (+Channel+). Um canal √© usado para passar valores de uma fun√ß√£o para quem a chamou.

A sequ√™ncia de Fibonnaci pode ser gerada por uma tarefa.
(((tarefa)))(((Channel)))((("tipo", "Base", "Channel", see="Channel")))(((put!)))((("fun√ß√£o", "Base", "put!", see="put!")))

[source,@julia-setup chap19]
----
function fib(c::Channel)
    a = 0
    b = 1
    put!(c, a)
    while true
        put!(c, b)
        (a, b) = (b, a+b)
    end
end
----

+put+ armazena os valores em um objeto de canal e +take!+ l√™ os valores dele:
(((take!)))((("fun√ß√£o", "Base", "take!", see="take!")))

[source,@julia-repl-test chap19]
----
julia> fib_gen = Channel(fib);

julia> take!(fib_gen)
0
julia> take!(fib_gen)
1
julia> take!(fib_gen)
1
julia> take!(fib_gen)
2
julia> take!(fib_gen)
3
----

O construtor +Channel+ cria a tarefa. A fun√ß√£o +fib+ √© suspendida a·πïos cada chamada para +put!+ e retorna depois de +take!+. Por quest√µes de performance, diversos valores da sequ√™ncia s√£o armazenados temporariamente no objeto de canal durante um ciclo de retomada/suspens√£o.

Um objeto de canal tamb√©m pode ser usado como um iterador:

[source,@julia-repl-test chap19]
----
julia> for val in Channel(fib)
           print(val, " ")
           val > 20 && break
       end
0 1 1 2 3 5 8 13 21
----


=== Tipos

==== Tipos Primitivos

Um tipo concreto que consiste em bits simples e antigos √© chamado de _tipo primitivo_. Ao contr√°rio da maioria das linguagens, no Julia voc√™ pode declarar os seus pr√≥prios tipos primitivos. Os tipos primitivos padr√µes s√£o definidos da mesma maneira:
(((tipo primitivo)))((("palavra-chave", "tipo primitivo", see="tipo primitivo")))

[source,julia]
----
primitive type Float64 <: AbstractFloat 64 end
primitive type Bool <: Integer 8 end
primitive type Char <: AbstractChar 32 end
primitive type Int64 <: Signed 64 end
----

O n√∫mero nos comandos especificam quantos bits s√£o necess√°rios.

O exemplo a seguir cria um tipo primitivo +Byte+ e um construtor:
(((Byte)))((("tipo", "definido pelo programador", "Byte", see="Byte")))

[source,@julia-repl-test]
----
julia> primitive type Byte 8 end

julia> Byte(val::UInt8) = reinterpret(Byte, val)
Byte
julia> b = Byte(0x01)
Byte(0x01)
----

A fun√ß√£o +reinterpret+ √© usada para armazenar os bits de um inteiro n√£o assinado com 8 bits (+UInt8+) no byte.
(((reinterpret)))((("fun√ß√£o", "Base", "reinterpret", see="reinterpret")))(((UInt8)))((("tipo", "Base", "UInt8", see="UInt8")))

==== Tipos Param√©tricos

O tipo de sistema do Julia √© _param√©trico_, significando que os tipos podem possuir par√¢metros.

Par√¢metros de tipo s√£o introduzidos depois do nome do tipo, cercado por chaves:
(((chaves)))

[source,@julia-setup chap19]
----
struct Ponto{T<:Real}
    x::T
    y::T
end
----

Isso define um novo tipo param√©trico, +Ponto{T<:Real}+, segurando duas "coordenadas" do tipo +T+, da qual pode ser de qualquer tipo desde que tenha +Real+ como supertipo.

[source,@julia-repl-test chap19]
----
julia> Ponto(0.0, 0.0)
Ponto{Float64}(0.0, 0.0)
----

Al√©m dos tipos compostos, tipos abstratos e tipos primitivos tamb√©m podem ter um par√¢metro de tipo.

[TIP]
====
Ter tipos concretos nos campos da struct √© absolutamente recomendado por motivos de desempenho, portanto essa √© uma boa maneira de tornar +Ponto+ r√°pido e flex√≠vel.
====

==== Uni√£o de Tipo

Uma _uni√£o de tipo_ √© um tipo param√©trico abstrato que pode atuar como qualquer um dos tipos do seu argumento:
(((uni√£o de tipo)))(((Union)))((("tipo", "Base", "Union", see="Union")))

[source,@julia-repl-test]
----
julia> IntOrString = Union{Int64, String}
Union{Int64, String}
julia> 150 :: IntOrString
150
julia> "Julia" :: IntOrString
"Julia"
----

Uma uni√£o de tipo √© na maioria das linguagens de computador uma constru√ß√£o interna para pensar sobre os tipos. O Julia, no entanto, exp√µe esse recurso aos seus usu√°rios porque um c√≥digo eficiente pode ser gerado quando a uni√£o de tipo possui um pequeno n√∫mero de tipos. Esse recurso oferece ao programador do Julia uma tremenda flexibilidade para controlar o despacho.

=== M√©todos

==== M√©todos Param√©tricos

As defini√ß√µes de m√©todo tamb√©m podem ter par√¢metros de tipo que qualificam sua assinatura:
(((assinatura)))

[source,@julia-repl-test chap19]
----
julia> √©_ponto_int(p::Ponto{T}) where {T} = (T === Int64)
√©_ponto_int (generic function with 1 method)
julia> p = Ponto(1, 2)
Ponto{Int64}(1, 2)
julia> √©_ponto_intt(p)
true
----

==== Objetos Semelhantes a Fun√ß√µes

Qualquer objeto arbitr√°rio de Julia pode ser ‚Äúchamado‚Äù. Tais objetos ‚Äúcham√°veis‚Äù √†s vezes s√£o denominados  _funtores_.
(((funtor)))

[source,@julia-setup chap19]
----
struct Polin√¥mio{R}
    coeff::Vector{R}
end

function (p::Polin√¥mio)(x)
    val = p.coeff[end]
    for coeff in p.coeff[end-1:-1:1]
        val = val * x + coeff
    end
    val
end
----

Para calcular o polin√¥mio, basta cham√°-lo:

[source,@julia-repl-test chap19]
----
julia> p = Polin√¥mio([1,10,100])
Polin√¥mio{Int64}([1, 10, 100])
julia> p(3)
931
----

=== Construtores

Tipos param√©tricos podem ser explicitamente ou implicitamente constru√≠dos:

[source,@julia-repl-test chap19]
----
julia> Ponto(1,2)         # implicit T
Ponto{Int64}(1, 2)
julia> Ponto{Int64}(1, 2) # explicit T
Ponto{Int64}(1, 2)
julia> Ponto(1,2.5)       # implicit T
ERROR: MethodError: no method matching Ponto(::Int64, ::Float64)
----

Construtores internos e externos padr√µes s√£o gerados para cada +T+:
(((construtor)))

[source,julia]
----
struct Ponto{T<:Real}
    x::T
    y::T
    Ponto{T}(x,y) where {T<:Real} = new(x,y)
end

Ponto(x::T, y::T) where {T<:Real} = Ponto{T}(x,y);
----

e ambos +x+ e +y+ devem ser do mesmo tipo.

Quando +x+ e +y+ possuem tipos diferentes, o subsequente construtor externo pode ser definido como:

[source,@julia-setup chap19]
----
Ponto(x::Real, y::Real) = Ponto(promote(x,y)...);
----

A fun√ß√£o +promote+ √© detalhada em <<promotion>>.
(((promote)))((("fun√ß√£o", "Base", "promote", see="promote")))

=== Convers√£o e Promo√ß√£o

O Julia tem um sistema para promover argumentos para um tipo comum. Isso n√£o √© feito automaticamente, mas pode ser facilmente realizado.

==== Convers√£o

Um valor pode ser convertido de um tipo para o outro:
(((convers√£o)))(((convert)))((("fun√ß√£o", "Base", "convert", see="convert")))

[source,@julia-repl-test]
----
julia> x = 12
12
julia> typeof(x)
Int64
julia> convert(UInt8, x)
0x0c
julia> typeof(ans)
UInt8
----

Podemos adicionar os nossos pr√≥prios m√©todos +convert+:
[source,@julia-repl-test chap19]
----
julia> Base.convert(::Type{Ponto{T}}, x::Array{T, 1}) where {T<:Real} = Ponto(x...)

julia> convert(Ponto{Int64}, [1, 2])
Ponto{Int64}(1, 2)
----

[[promotion]]
==== Promo√ß√£o

_Promo√ß√£o_ √© a convers√£o de valores dos tipos mistos para um √∫nico tipo comum:
(((promo√ß√£o)))(((promote)))

[source,@julia-repl-test]
----
julia> promote(1, 2.5, 3)
(1.0, 2.5, 3.0)
----

Em geral, os m√©todos para a fun√ß√£o +promote+ n√£o s√£o diretamente definidos, mas a fun√ß√£o auxiliar +promote_rule+ √© usada para especificar as regras da promo√ß√£o:
(((promote_rule)))((("fun√ß√£o", "Base", "promote_rule", see="promote_rule")))

[source,julia]
----
promote_rule(::Type{Float64}, ::Type{Int32}) = Float64
----

=== Metaprograma√ß√£o

O c√≥digo Julia pode ser representado como uma estrutura de dados da pr√≥pria linguagem. Isso permite que um programa transforme e gere o seu pr√≥prio c√≥digo.

==== Express√µes

Todo programa do Julia come√ßa como uma string:

[source,@julia-repl-test chap19]
----
julia> prog = "1 + 2"
"1 + 2"
----

A pr√≥xima etapa √© analisar cada string em um objeto chamado _expression_, representado pelo tipo +Expr+ do Julia:
(((expression)))(((Expr)))((("tipo", "Base", "Expr", see="Expr")))(((parse)))((("fun√ß√£o", "Meta", "parse", see="parse")))

[source,@julia-repl-test chap19]
----
julia> ex = Meta.parse(prog)
:(1 + 2)
julia> typeof(ex)
Expr
julia> dump(ex)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 2
----

A fun√ß√£o +dump+ detalha os objetos expr.
(((dump)))

Express√µes podem ser diretamente constru√≠das prefixando +:+ entre par√™nteses ou usando uma cita√ß√£o em bloco
(((:)))(((quote)))((("palavra-chave", "quote", see="quote")))

[source,@julia-repl-test chap19]
----
julia> ex = quote
           1 + 2
       end;
----

==== +eval+

O Julia pode avaliar um objeto de express√£o usando +eval+:
(((eval)))((("fun√ß√£o", "Core", "eval", see="eval")))

[source,@julia-eval chap19]
----
import Base.eval
----

[source,@julia-repl-test chap19]
----
julia> eval(ex)
3
----

Cada m√≥dulo possui sua pr√≥pria fun√ß√£o +eval+ que avalia as express√µes em seu escopo.

[WARNING]
====
Quando voc√™ est√° usando muitas chamadas para a fun√ß√£o +eval+, geralmente isso significa que algo est√° errado. A fun√ß√£o +eval+ √© considerada do ‚Äúmal‚Äù.
====

==== Macros

Macros podem incluir o c√≥digo gerado em um programa. Uma _macro_ mapeia uma tupla de objetos +Expr+ diretamente para uma express√£o compilada:
(((macro)))

Aqui est√° uma macro simples:
(((@containervari√°vel)))((("macro", "definido pelo programador", "@containervari√°vel", see="@containervari√°vel")))

[source,@julia-setup chap19]
----
macro containervari√°vel(container, elemento)
    return esc(:($(Symbol(container,elemento)) = $container[$elemento]))
end
----

As macros s√£o chamadas ao colocar o prefixo +@+ (sinal de arroba) em seus nomes. A macro chamada +@containervari√°vel letras 1+ √© substitu√≠da por:
(((@)))

[source,julia]
----
:(letras1 = letras[1])
----

+@macroexpand @containervari√°vel letras 1+ retorna essa express√£o que √© extremamente √∫til para a depura√ß√£o.
(((@macroexpand)))((("macro", "Base", "@macroexpand", see="@macroexpand")))

Este exemplo ilustra como uma macro pode acessar o nome dos seus argumentos, algo que uma fun√ß√£o n√£o pode fazer. O comando return precisa ser ‚Äúescapado‚Äù com +esc+, pois precisa ser resolvido no ambiente da chamada da macro.
(((esc)))((("fun√ß√£o", "Base", "esc", see="esc")))

[NOTE]
====
Por que macros?

As macros geram e incluem fragmentos de c√≥digo personalizado durante o tempo de an√°lise, portanto, _antes_ da execu√ß√£o do programa completo.
====

==== Fun√ß√µes Geradas

A macro +@generated+ cria c√≥digo especializado para os m√©todos, dependendo dos tipos dos argumentos:
(((fun√ß√µes geradas)))(((@generated)))((("macro", "Base", "@generated", see="@generated")))

[source,@julia-setup chap19]
----
@generated function quadrado(x)
    println(x)
    :(x * x)
end
----

O corpo retorna uma express√£o entre aspas como uma macro.

Para quem chama, a _fun√ß√£o gerada_ se comporta como uma fun√ß√£o regular:

[source,@julia-repl-test chap19]
----
julia> x = quadrado(2); # nota: a sa√≠da √© da declara√ß√£o println() no corpo
Int64
julia> x              # agora imprimimos x
4
julia> y = quadrado("spam");
String
julia> y
"spamspam"
----

=== Valores Ausentes

_Valores ausentes_ podem ser representados atrav√©s do objeto +missing+, que √© a inst√¢ncia singleton do tipo +Missing+.
(((valores ausentes)))(((missing)))(((Missing)))((("tipo", "Base", "Missing", see="Missing")))

As listas podem conter valores ausentes:

[source,@julia-repl-test chap19]
----
julia> a = [1, missing]
2-element Array{Union{Missing, Int64},1}:
 1
  missing
----

O tipo de elemento dessa lista √© +Union{Missing, T}+, sendo +T+ o tipo de valores n√£o ausentes.

As fun√ß√µes de redu√ß√£o retornam +missing+ quando chamadas nas listas que cont√™m valores ausentes

[source,@julia-repl-test chap19]
----
julia> sum(a)
missing
----

Nessa situa√ß√£o, use a fun√ß√£o +skipmissing+ para ignorar os valores ausentes:
(((skipmissing)))((("fun√ß√£o", "Base", "skipmissing", see="skipmissing")))

[source,@julia-repl-test chap19]
----
julia> sum(skipmissing([1, missing]))
1
----


=== Chamando C√≥digos em C e Fortran

Muitos c√≥digos est√£o escritos em C ou Fortran. Reutilizar o c√≥digo testado geralmente √© melhor do que escrever sua pr√≥pria vers√£o de um algoritmo. Julia pode chamar diretamente as bibliotecas existentes em C ou Fortran usando a sintaxe +ccall+.
(((ccall)))((("fun√ß√£o", "Base", "ccall", see="ccall")))

Em <<databases>>, introduzimos uma interface Julia para a biblioteca GDBM de fun√ß√µes de banco de dados. A biblioteca est√° escrita em C. Para fechar o banco de dados, uma chamada de fun√ß√£o para +close(db)+ teve que ser feita:

[source,julia]
----
Base.close(dbm::DBM) = gdbm_close(dbm.handle)

function gdbm_close(handle::Ptr{Cvoid})
    ccall((:gdbm_close, "libgdbm"), Cvoid, (Ptr{Cvoid},), handle)
end
----

Um objeto dbm possui um campo +handle+ do tipo +Ptr{Cvoid}+. Este campo guarda um ponteiro C que se refere ao banco de dados. Para fechar o banco de dados, a fun√ß√£o C +gdbm_close+ deve ser chamada tendo como √∫nico argumento o ponteiro C apontando para o banco de dados e sem valor de retorno. O Julia faz isso diretamente com a fun√ß√£o +ccall+ tendo como argumentos:
(((Ptr)))((("tipo", "Base", "Ptr", see="Ptr")))

* uma tupla que consiste em um s√≠mbolo que cont√©m o nome da fun√ß√£o que queremos chamar: +:gdbm_close+ e a biblioteca compartilhada especificada como uma string: +"libgdm"+,

* o tipo de retorno: +Cvoid+,

* uma tupla com os tipos de argumentos: +(Ptr{Cvoid},)+ e

* os valores do argumento: +handle+.

O mapeamento completo da biblioteca GDBM pode ser encontrado como um exemplo no reposit√≥rio do JuliaIntroBR.

=== Gloss√°rio

fechamento::
Fun√ß√£o que captura as vari√°veis do seu escopo definido.
(((fechamento)))

bloco let::
Bloco que aloca novas liga√ß√µes de vari√°veis.
(((bloco let)))

fun√ß√£o an√¥nima::
Fun√ß√£o definida sem ter um nome.
(((fun√ß√£o an√¥nima)))

tupla nomeada::
Tupla com componentes nomeados.
(((tupla nomeada)))

argumentos de palavra-chave::
Argumentos identificados pelo nome e n√£o s√≥ pela posi√ß√£o.
(((argumentos de palavra-chave)))

bloco do::
Constru√ß√£o de sintaxe usada para definir e chamar uma fun√ß√£o an√¥nima que se parece com um bloco de c√≥digo normal.
(((bloco do)))

operador tern√°rio::
Operador de fluxo de controle que usa tr√™s operandos para especificar uma condi√ß√£o, uma express√£o a ser executada quando a condi√ß√£o produz +true+ e uma express√£o a ser executada quando a condi√ß√£o produz +false+.
(((operador tern√°rio)))

avalia√ß√£o de curto-circu√≠to::
Avalia√ß√£o de um operador booleano na qual o segundo argumento √© executado ou avaliado apenas se o primeiro argumento n√£o for suficiente para determinar o valor da express√£o.
(((avalia√ß√£o de curto-circu√≠to)))

tarefa (tamb√©m conhecida como Corrotina)::
Recurso de fluxo de controle que permite a suspens√£o e a retomada dos c√°lculos de maneira flex√≠vel.
(((tarefa)))

tipo primitivo::
Tipo concreto cujos dados consistem em bits simples e antigos.
(((tipo primitivo)))

uni√£o de tipo::
Tipo que inclui como objetos todas as inst√¢ncias de qualquer um dos seus par√¢metros de tipo.
(((uni√£o de tipo)))

tipo param√©trico::
Tipo que √© parametrizado.
(((tipo param√©trico)))

funtor::
Objeto com um m√©todo associado, para que ele possa ser chamado.
(((funtor)))

convers√£o::
A convers√£o permite converter um valor de um tipo para outro.
(((convers√£o)))

promo√ß√£o::
Convers√£o de valores de tipos mistos em um √∫nico tipo comum.
(((promo√ß√£o)))

express√£o::
Tipo do Julia que cont√©m uma constru√ß√£o de linguagem.
(((express√£o)))

macro::
Forma de incluir o c√≥digo gerado no final do corpo de um programa.
(((macro)))

fun√ß√µes geradas::
Fun√ß√µes capazes de gerar c√≥digo especializado, dependendo dos tipos dos argumentos.
(((fun√ß√µes geradas)))

valores ausentes::
Inst√¢ncias que representam informa√ß√µes sem valor.
(((valores ausentes)))
