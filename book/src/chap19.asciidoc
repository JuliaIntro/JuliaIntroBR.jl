[[chap19]]
== Extra: Sintaxe

Uma das metas deste livro √© ensinar o m√≠nimo poss√≠vel de Julia. Quando havia duas formas de fazer algo, escolhiamos uma e evitavamos mencionar a outra. Ou √†s vezes, utilizamos a segunda forma como exerc√≠cio.

Agora queremos retornar a algumas coisas boas que ficaram para traz. O Julia oferece uma variadade de recursos que n√£o s√£o realmente necess√°rios ‚Äì voc√™ pode escrever um bom c√≥digo sem eles ‚Äì mas com eles √© poss√≠vel escrever um c√≥digo mais conciso, leg√≠vel ou eficiente e, √†s vezes, todos os tr√™s.

Neste cap√≠tulo e no pr√≥ximo, iremos discutir coisas que deixamos para tr√°s nos cap√≥tulos anteriores:

* suplementos de sintaxe
* fun√ß√µes, tipos e macros diretamente dispon√≠veis em +Base+
(((Base)))
* fun√ß√µes, tipos e macros da Biblioteca Padr√£o
(((Biblioteca Padr√£o)))

=== Tuplas Nomeadas

Podemos nomear os componentes de uma tupla, criando uma tupla nomeada.

[source,@julia-repl-test]
----
julia> x = (a=1, b=1+1)
(a = 1, b = 2)
julia> x.a
1
----

Com tuplas nomeadas, os campos podem ser acessados por nome usando a sintaxe do ponto +(x.a)+.
(((tuplas nomeadas)))(((sintaxe do ponto)))


=== Fun√ß√µes

Uma fun√ß√£o no Julia pode ser definida atrav√©s de uma sintaxe compacta:

[source,@julia-repl-test]
----
julia> f(x,y) = x + y
f (generic function with 1 method)
----

[[anonymous_functions]]
==== Fun√ß√µes An√¥nimas

Podemos definir uma fun√ß√£o sem especificar um nome:

[source,@julia-repl-test]
----
julia> x -> x^2 + 2x - 1
#1 (generic function with 1 method)
julia> function (x)
           x^2 + 2x - 1
       end
#3 (generic function with 1 method)
----

Esses s√£o exemplos de _fun√ß√µes an√¥nimas_. Fun√ß√µes anonimas geralmente s√£o usadas como argumentos para outras fun√ß√µes:
(((fun√ß√µes an√¥nimas)))(((Plots)))((("m√≥dulo", "Plots", see="Plots")))(((plot)))((("fun√ß√£o", "Plots", "plot", see="plot")))

[source,jlcon]
----
julia> using Plots

julia> plot(x -> x^2 + 2x - 1, 0, 10, xlabel="x", ylabel="y")

----

<<fig19-1>> mostra a sa√≠da do comando plot.

[[fig19-1]]
.Plot
image::images/fig191.svg[pdfwidth="10cm"]

==== Argumentos de Palavras-Chave

Argumentos de fun√ß√µes tamb√©m podem ser nomeadas:

[source,@julia-repl-test]
----
julia> function myplot(x, y; style="solid", width=1, color="black")
           ###
       end
myplot (generic function with 1 method)
julia> myplot(0:10, 0:10, style="dotted", color="blue")

----

_Argumentos de palavras-chave_ em uma fun√ß√£o s√£o especificadas depois de um ponto e v√≠rgula na assinatura, mas pode ser chamado com uma v√≠rgula.
(((;)))(((argumentos de palavra-chave)))

=== Fechamentos

Um _fechamento_ √© a t√©cnica que permite uma fun√ß√£o capturar uma vari√°vel definida fora do escopo de chamada de fun√ß√£o.

[source,@julia-repl-test]
----
julia> foo(x) = ()->x
foo (generic function with 1 method)

julia> bar = foo(1)
#1 (generic function with 1 method)

julia> bar()
1
----

Nesse exemplo, a fun√ß√£o +foo+ retorna uma fun√ß√£o an√¥nima que possui acesso ao argumento +x+ da fun√ß√£o +foo+. +bar+ aponta para a fun√ß√£o an√¥nima e retorna o valor do argumento de +foo+.


=== Blocos

Um _bloco_ √© uma forma de agrupar diversos comandos. Um bloco come√ßa com a palavra chave +begin+ e finaliza com +end+.
(((begin)))((("palavra-chave", "begin", see="begin")))(((end)))(((bloco)))

No <<chap04>> a macro +@svg+ foi introduzida:

[source,julia]
----
üê¢ = Turtle()
@svg begin
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
end
----

Neste exemplo, a macro +@svg+ possui um argumento √∫nico, i.e. um bloco agrupando 3 chamadas de fun√ß√µes.

==== Blocos +let+

Um bloco +let+ √© √∫ltil para criar novas liga√ß√µes, i.e. locais que podem se referir a valores.

[source,@julia-repl-test]
----
julia> x, y, z = -1, -1, -1;

julia> let x = 1, z
           @show x y z;
       end
x = 1
y = -1
ERROR: UndefVarError: z not defined
julia> @show x y z;
x = -1
y = -1
z = -1
----

No exemplo, a primeira macro +@show+, mostra o +x+ local, a global +y+ e a local indefinida +z+. As vari√°veis globais s√£o intoc√°veis.


==== Blocos +do+

Em <<reading_and_writing>> tivemos que fechar o arquivo ap√≥s o t√©rmino da grava√ß√£o. Isso pode ser feito automaticamente usando um _bloco do_:
(((do)))((("palavra-chave", "do", see="do")))

[source,@julia-repl-test chap19]
----
julia> dado = "Aqui est√° a ac√°cia,\no emblema de nossa terra.\n"
"Aqui est√° a ac√°cia,\no emblema de nossa terra.\n"
julia> open("output.txt", "w") do fout
           write(fout, dado)
       end
48
----

Nesse exemplo, +fout+ √© um fluxo de arquivo usado para sa√≠da.

Essa funcionalidade √© equivalente a

[source,@julia-repl-test chap19]
----
julia> f = fout -> begin
           write(fout, dado)
       end
#3 (generic function with 1 method)
julia> open(f, "output.txt", "w")
48
----

A fun√ß√£o an√¥nima √© usada como o primeiro argumento da fun√ß√£o +open+:
(((open)))

[source,julia]
----
function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end
----

Um bloco +do+ pode "caputar" vari√°veis de seus escopos anexos. Por exemplo, a vari√°vel +dado+ no exemplo acima de +open pass:[...] do+ √© caputado de outro escopo.


=== Controle de Fluxo

==== Operador Tern√°rio

O _operador tern√°rio_, +?:+, √© uma alternativa para uma declara√ß√£o +if-else+ usada quando voc√™ precisa fazer uma escolha entre valores de express√£o √∫nica.
(((?:)))((("operator", "Base", "?:", see="?:")))((("operador tern√°rio", see="?:")))

[source,@julia-repl-test]
----
julia> a = 150
150
julia> a % 2 == 0 ? println("even") : println("odd")
even
----

A express√£o antes de +?+ √© uma express√£o de condi√ß√£o. Se a condi√ß√£o for +true+, a express√£o antes de +:+ √© avaliada, caso contr√°rio, a express√£o depois de +:+ √© avaliada.

==== Avalia√ß√£o de Curto-Circu√≠to

Os operadores +&&+ e +||+ fazem uma _avalia√ß√£o de curto-circuito_: O pr√≥ximo argumento s√≥ √© avaliado quando √© necess√°rio para determinar o valor final.
(((&&)))(((||)))(((avalia√ß√£o de curto-circuito)))

Por exemplo, uma rotira de fatorial por recurs√£o pode ser definida da seguinte maneira:
(((fat)))

[source,@julia-setup]
----
function fat(n::Integer)
    n >= 0 || error("n deve ser inteiro positivo")
    n == 0 && return 1
    n * fat(n-1)
end
----

==== Tarefas (tamb√©m conhecido Corrotina)

Uma _tarefa_ √© uma estrutura de controle que pode passar pelo controle cooperativo sem retornar. Em Julia, uma tarefa pode ser implementada como uma fun√ß√£o tendo como primeiro argumento um objeto de canal (+Channel+). Um canal √© usado para passar valores de uma fun√ß√£o ao chamador.

A sequ√™ncia de Fibonnaci pode ser gerada usando uma tarefa.
(((tarefa)))(((Canal)))((("tipo", "Base", "Channel", see="Channel")))(((put!)))((("fun√ß√£o", "Base", "put!", see="put!")))

[source,@julia-setup chap19]
----
function fib(c::Channel)
    a = 0
    b = 1
    put!(c, a)
    while true
        put!(c, b)
        (a, b) = (b, a+b)
    end
end
----

+put+ armazena valores em um objeto de canal e +take!+ l√™ valores de:
(((take!)))((("fun√ß√£o", "Base", "take!", see="take!")))

[source,@julia-repl-test chap19]
----
julia> fib_gen = Channel(fib);

julia> take!(fib_gen)
0
julia> take!(fib_gen)
1
julia> take!(fib_gen)
1
julia> take!(fib_gen)
2
julia> take!(fib_gen)
3
----

O construtor +Channel+ cria uma tarefa. A fun√ß√£o +fib+ √© suspendida depois de cada chamada para +put!+ e retorna depois de +take!+. Por quest√µes de performance, muitos valores das sequ√™ncias s√£o armazenadas em buffer no objeto de canal durante um ciclo de retomada/suspens√£o.

Um objeto de canal tamb√©m pode ser usado como um iterador:

[source,@julia-repl-test chap19]
----
julia> for val in Channel(fib)
           print(val, " ")
           val > 20 && break
       end
0 1 1 2 3 5 8 13 21
----


=== Tipos

==== Tipos Primitivos

Um tipo concreto que consiste em bits antigos simples √© chamado de _tipo primitivo_. Ao contr√°rio da maioria das linguagens, com Julia, voc√™ pode declarar seus pr√≥prios tipos primitivos. Os tipos primitivos padr√£o s√£o definidos da mesma maneira:
(((tipo primitivo)))((("palavra-chave", "tipo primitivo", see="tipo primitivo")))

[source,julia]
----
primitive type Float64 <: AbstractFloat 64 end
primitive type Bool <: Integer 8 end
primitive type Char <: AbstractChar 32 end
primitive type Int64 <: Signed 64 end
----

O n√∫mero nos comandos especificam quantos bits s√£o necess√°rios.

O exemplo √† seguir cria um tipo primitivo +Byte+ e um construtor:
(((Byte)))((("tipo", "definido pelo programador", "Byte", see="Byte")))

[source,@julia-repl-test]
----
julia> primitive type Byte 8 end

julia> Byte(val::UInt8) = reinterpret(Byte, val)
Byte
julia> b = Byte(0x01)
Byte(0x01)
----

A fun√ß√£o +reinterpret+ √© usada para armazenar os bits de um inteiro n√£o assinado com 8 bits (+UInt8+) no bit.
(((reinterpret)))((("fun√ß√£o", "Base", "reinterpret", see="reinterpret")))(((UInt8)))((("Tipo", "Base", "UInt8", see="UInt8")))

==== Tipos Param√©tricos

O tipo de sistema do Julia √© _param√©trico_, o que significa que os tipos podem possuir par√¢metros.

Tipos de Par√¢metros s√£o introduzidos depois do nome do tipo, cercado por chaves:
(((chaves)))

[source,@julia-setup chap19]
----
struct Point{T<:Real}
    x::T
    y::T
end
----

Isso define um novo tipo param√©trico, +Point{T<:Real}+, segurando duas "coordenadas" de tipo +T+, da qual pode ser qualquer tipo contendo +Real+ como supertipo.

[source,@julia-repl-test chap19]
----
julia> Point(0.0, 0.0)
Point{Float64}(0.0, 0.0)
----

Al√©m dos tipos compostos, tipos abstratos e tipos primitivos tamb√©m podem ter um par√¢metro de tipo.

[TIP]
====
Ter tipos concretos para campos de estrutura √© absolutamente recomendado por motivos de desempenho, portanto, √© uma boa maneira de tornar o +Point+ r√°pido e flex√≠vel.
====

==== Tipo de Uni√£o

Um _tipo de uni√£o_ √© um tipo param√©trico abstrato que pode atuar como qualquer um dos seus tipos de argumento:
(((tipo de uni√£o)))(((Union)))((("tipo", "Base", "Union", see="Union")))

[source,@julia-repl-test]
----
julia> IntOrString = Union{Int64, String}
Union{Int64, String}
julia> 150 :: IntOrString
150
julia> "Julia" :: IntOrString
"Julia"
----

Uma uni√£o de tipos √© na maioria das linguagens de computador uma constru√ß√£o interna para raciocinar sobre tipos. Julia, no entanto, exp√µe esse recurso a seus usu√°rios porque um c√≥digo eficiente pode ser gerado quando a uni√£o de tipos possui um pequeno n√∫mero de tipos. Esse recurso oferece ao programador Julia uma tremenda flexibilidade para controlar o envio.

=== M√©todos

==== M√©todos Param√©tricos

As defini√ß√µes de m√©todo tamb√©m podem ter par√¢metros de tipo que qualificam sua assinatura:
(((assinatura)))

[source,@julia-repl-test chap19]
----
julia> isintpoint(p::Point{T}) where {T} = (T === Int64)
isintpoint (generic function with 1 method)
julia> p = Point(1, 2)
Point{Int64}(1, 2)
julia> isintpoint(p)
true
----

==== Objetos Semelhantes a Fun√ß√µes

Qualquer objeto arbitr√°rio de Julia pode ser "chamado". Tais objetos "cham√°veis" √†s vezes s√£o chamados de "funtores".
(((funtor)))

[source,@julia-setup chap19]
----
struct Polynomial{R}
    coeff::Vector{R}
end

function (p::Polynomial)(x)
    val = p.coeff[end]
    for coeff in p.coeff[end-1:-1:1]
        val = val * x + coeff
    end
    val
end
----

Para calcular o polin√¥mio, basta cham√°-lo:

[source,@julia-repl-test chap19]
----
julia> p = Polynomial([1,10,100])
Polynomial{Int64}([1, 10, 100])
julia> p(3)
931
----

=== Construtores

Tipos param√©tricos podem ser explicitamente ou implicitamente constru√≠dos:

[source,@julia-repl-test chap19]
----
julia> Point(1,2)         # implicit T
Point{Int64}(1, 2)
julia> Point{Int64}(1, 2) # explicit T
Point{Int64}(1, 2)
julia> Point(1,2.5)       # implicit T
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
----

Construtores internos e externos padr√£o s√£o gerados para cada +T+:
(((construtor)))

[source,julia]
----
struct Point{T<:Real}
    x::T
    y::T
    Point{T}(x,y) where {T<:Real} = new(x,y)
end

Point(x::T, y::T) where {T<:Real} = Point{T}(x,y);
----

e ambos +x+ e +y+ devem ser do mesmo tipo.

Quando +x+ e +y+ possuem tipos diferentes, o seguinte construtor externo pode ser definido:

[source,@julia-setup chap19]
----
Point(x::Real, y::Real) = Point(promote(x,y)...);
----

A fun√ß√£o +promote+ √© detalhada em <<promotion>>.
(((promote)))((("fun√ß√£o", "Base", "promote", see="promote")))

=== Convers√£o e Promo√ß√£o

O Julia tem um sistema para promover argumentos para um tipo comum. Isso n√£o √© feito automaticamente, mas pode ser facilmente estendido.

==== Convers√£o

Um valor pode ser convertido de um tipo para outro:
(((convers√£o)))(((convert)))((("fun√ß√£o", "Base", "convert", see="convert")))

[source,@julia-repl-test]
----
julia> x = 12
12
julia> typeof(x)
Int64
julia> convert(UInt8, x)
0x0c
julia> typeof(ans)
UInt8
----

Podemos adicionar nossos pr√≥prios m√©todos +convert+:
[source,@julia-repl-test chap19]
----
julia> Base.convert(::Type{Point{T}}, x::Array{T, 1}) where {T<:Real} = Point(x...)

julia> convert(Point{Int64}, [1, 2])
Point{Int64}(1, 2)
----

[[promotion]]
==== Promo√ß√£o

_Promo√ß√£o_ √© a convers√£o de valores de tipos mistos para um √∫nico tipo comum:
(((promo√ß√£o)))(((promote)))

[source,@julia-repl-test]
----
julia> promote(1, 2.5, 3)
(1.0, 2.5, 3.0)
----

Os m√©todos para a fun√ß√£o +promote+ normalmente n√£o s√£o definidos diretamente, mas a fun√ß√£o auxiliar +promover_rule+ √© usada para especificar as regras da promo√ß√£o:
(((promote_rule)))((("function", "Base", "promote_rule", see="promote_rule")))

[source,julia]
----
promote_rule(::Type{Float64}, ::Type{Int32}) = Float64
----

=== Meta-programa√ß√£o

O c√≥digo Julia pode ser representado como uma estrutura de dados da pr√≥pria linguagem. Isso permite que um programa transforme e gere seu pr√≥prio c√≥digo.

==== Express√µes

Todo programa do Julia come√ßa como uma string:

[source,@julia-repl-test chap19]
----
julia> prog = "1 + 2"
"1 + 2"
----

A pr√≥xima etapa √© analisar cada string em um objeto chamado _expression_, representado pelo tipo Julia +Expr+:
(((express√£o)))(((Expr)))((("tipo", "Base", "Expr", see="Expr")))(((parse)))((("fun√ß√£o", "Meta", "parse", see="parse")))

[source,@julia-repl-test chap19]
----
julia> ex = Meta.parse(prog)
:(1 + 2)
julia> typeof(ex)
Expr
julia> dump(ex)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 2
----

A fun√ß√£o +dump+ exibe objetos expr com anota√ß√µes.
(((dump)))

Express√µes podem ser constru√≠das diretamente prefixando +:+ entre par√™nteses ou usando um bloco de aspas
(((:)))(((quote)))((("palavra-chave", "quote", see="quote")))

[source,@julia-repl-test chap19]
----
julia> ex = quote
           1 + 2
       end;
----

==== +eval+

O Julia pode avaliar um objeto de express√£o usando +eval+:
(((eval)))((("fun√ß√£o", "Core", "eval", see="eval")))

[source,@julia-eval chap19]
----
import Base.eval
----

[source,@julia-repl-test chap19]
----
julia> eval(ex)
3
----

Cada m√≥dulo possui sua pr√≥pria fun√ß√£o +eval+ que avalia express√µes em seu escopo.

[WARNING]
====
Quando voc√™ est√° usando muitas chamadas para a fun√ß√£o +eval+, geralmente isso significa que algo est√° errado. +eval+ √© considerado "mal".
====

==== Macros

Macros podem incluir c√≥digo gerado em um programa. Um _macro_ mapeia uma tupla de objetos +Expr+ diretamente para uma express√£o compilada:
(((macro)))

Aqui est√° uma simples macro:
(((@containervariavel)))((("macro", "definido pelo programador", "@containervariavel", see="@containervariavel")))

[source,@julia-setup chap19]
----
macro containervariavel(container, elemento)
    return esc(:($(Symbol(container,elemento)) = $container[$elemento]))
end
----

As macros s√£o chamadas com o prefixo +@+ (sinal de arroba). A chamada de macro +@containervariavel letters 1+ √© substitu√≠da por:
(((@)))

[source,julia]
----
:(letters1 = letters[1])
----

+@macroexpand @containervariavel letters 1+ retorna essa express√£o que √© extremamente √∫til para depura√ß√£o.
(((@macroexpand)))((("macro", "Base", "@macroexpand", see="@macroexpand")))

Este exemplo ilustra como uma macro pode acessar o nome de seus argumentos, algo que uma fun√ß√£o n√£o pode fazer. A express√£o de retorno precisa ser "escapada" com +esc+, pois precisa ser resolvida no ambiente de chamada de macro.
(((esc)))((("fun√ß√£o", "Base", "esc", see="esc")))

[NOTE]
====
Por que macros?

As macros geram e incluem fragmentos de c√≥digo personalizado durante o tempo de an√°lise, portanto, _antes_ que o programa completo seja executado.
====

==== Fun√ß√µes Geradas

A macro +@generated+ cria c√≥digo especializado para m√©todos, dependendo dos tipos de argumentos:
(((fun√ß√µes geradas)))(((@generated)))((("macro", "Base", "@generated", see="@generated")))

[source,@julia-setup chap19]
----
@generated function square(x)
    println(x)
    :(x * x)
end
----

O corpo retorna uma express√£o entre aspas como uma macro.

Para o chamador, a fun√ß√£o _generated_ se comporta como uma fun√ß√£o regular:

[source,@julia-repl-test chap19]
----
julia> x = square(2); # note: output √© da declara√ß√£o println() no corpo
Int64
julia> x              # agora imprimimos x
4
julia> y = square("spam");
String
julia> y
"spamspam"
----

=== Valores Ausentes

_Valores ausentes_ podem ser representados atrav√©s do objeto +missing+, que √© a inst√¢ncia singleton do tipo +Missing+.
(((valores ausentes)))(((missing)))(((Missing)))((("tipo", "Base", "Missing", see="Missing")))

As listas podem conter valores ausentes:

[source,@julia-repl-test chap19]
----
julia> a = [1, missing]
2-element Array{Union{Missing, Int64},1}:
 1
  missing
----

O tipo de elemento dessa lista √© +Union{Missing, T}+, com +T+ o tipo de valores n√£o ausentes.

As fun√ß√µes de redu√ß√£o retornam +missing+ quando chamadas em listas que cont√™m valores ausentes

[source,@julia-repl-test chap19]
----
julia> sum(a)
missing
----

Nessa situa√ß√£o, use a fun√ß√£o +skipmissing+ para pular os valores ausentes:
(((skipmissing)))((("fun√ß√£o", "Base", "skipmissing", see="skipmissing")))

[source,@julia-repl-test chap19]
----
julia> sum(skipmissing([1, missing]))
1
----


=== Chamando C√≥digos em C e Fortran

Muitos c√≥digos est√£o escritos em C ou Fortran. Reutilizar o c√≥digo testado geralmente √© melhor do que escrever sua pr√≥pria vers√£o de um algoritmo. Julia pode chamar diretamente as bibliotecas C ou Fortran existentes usando a sintaxe +ccall+.
(((ccall)))((("fun√ß√£o", "Base", "ccall", see="ccall")))

Em <<databases>>, introduzimos uma interface Julia na biblioteca GDBM de fun√ß√µes de banco de dados. A biblioteca est√° escrita em C. Para fechar o banco de dados, uma chamada de fun√ß√£o para +close(db)+ deve ser feita:

[source,julia]
----
Base.close(dbm::DBM) = gdbm_close(dbm.handle)

function gdbm_close(handle::Ptr{Cvoid})
    ccall((:gdbm_close, "libgdbm"), Cvoid, (Ptr{Cvoid},), handle)
end
----

Um objeto dbm possui um campo +handle+ do tipo +Ptr{Cvoid}+. Este campo cont√©m um ponteiro C que se refere ao banco de dados. Para fechar o banco de dados, a fun√ß√£o C +gdbm_close+ deve ser chamada tendo como √∫nico argumento o ponteiro C apontando para o banco de dados e sem valor de retorno. O Julia faz isso diretamente com a fun√ß√£o +ccall+ tendo como argumentos:
(((Ptr)))((("tipo", "Base", "Ptr", see="Ptr")))

* uma trupla que consiste em um s√≠mbolo que cont√©m o nome da fun√ß√£o que queremos chamar: +:gdbm_close+ e a biblioteca compartilhada especificada como uma sequ√™ncia: +"libgdm"+,

* o tipo de retorno: +Cvoid+,

* uma tupla de tipos de argumentos: +(Ptr{Cvoid},)+ e

* os valores do argumento: +handle+.

O mapeamento completo da biblioteca GDBM pode ser encontrada como um exmplo nas fontes do JuliaIntroBR.

=== Gloss√°rio

fechamentos::
Fun√ß√£o que captura vari√°veis de seu escopo definido.
(((fechamento)))

bloqueio let::
Bloqueia a aloca√ß√£o de novas liga√ß√µes de vari√°veis.
(((bloqueio let)))

fun√ß√µes an√¥nimas::
Fun√ß√£o definida sem possuir nome.
(((fun√ß√£o an√¥nima)))

tupla nomeada::
Tupla com componentes nomeados.
(((tupla nomeada)))

argumentos de palavra-chave::
Argumentos identificados pelo nome em vez de apenas pela posi√ß√£o.
(((argumentos de palavra-chave)))

bloco do::
Constru√ß√£o de sintaxe usada para definir e chamar uma fun√ß√£o an√¥nima que se parece com um bloco de c√≥digo normal.
(((bloco do)))

operador tern√°rio::
Operador de fluxo de controle usando tr√™s operandos para especificar uma condi√ß√£o, uma express√£o a ser executada quando a condi√ß√£o render +true+ e uma express√£o a ser executada quando a condi√ß√£o render +false+.
(((operador tern√°rio)))

avalia√ß√£o de curto-circu√≠to::
Avalia√ß√£o de um operador booleano para o qual o segundo argumento √© executado ou avaliado apenas se o primeiro argumento n√£o for suficiente para determinar o valor da express√£o.
(((avalia√ß√£o de curto-circu√≠to)))

tarefa (tamb√©m conhecida como Corrotina)::
Recurso de fluxo de controle que permite que os c√°lculos sejam suspensos e retomados de maneira flex√≠vel.
(((tarefa)))

tipo primitivo::
Tipo de concreto cujos dados consistem em bits antigos simples.
(((tipo primitivo)))

tipo de uni√£o::
Tipo que inclui como objetos todas as inst√¢ncias de qualquer um dos seus par√¢metros de tipo.
(((uni√£o de tipo)))

tipo param√©trico::
Tipo que est√° parametrizado.
(((tipo param√©trico)))

funtor::
Objeto com um m√©todo associado, para que ele possa ser chamado.
(((functor)))

convers√£o::
A convers√£o permite converter um valor de um tipo para outro.
(((convers√£o)))

promo√ß√£o::
Convers√£o valores de tipos mistos em um √∫nico tipo comum.
(((promo√ß√£o)))

express√£o::
Tipo de Julia que cont√©m uma constru√ß√£o de linguagem.
(((express√£o)))

macro::
Forma de incluir o c√≥digo gerado no corpo final de um programa.
(((macro)))

fun√ß√µes geradas::
Fun√ß√µes capazes de gerar c√≥digo especializado, dependendo dos tipos dos argumentos.
(((fun√ß√µes geradas)))

valores ausentes::
Inst√¢ncias que representam pontos de dados sem valor.
(((valores ausentes)))
