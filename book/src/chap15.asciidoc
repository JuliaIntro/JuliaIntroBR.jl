[[chap15]]
== Estruturas e Objetos

A esta altura, você sabe como usar funções para organizar o código e os tipos internos para organizar dados. O próximo passo é aprender a criar seus próprios tipos para organizar o código e os dados. Este é um tópico importante e serão necessários alguns capítulos para tratar do tema.


=== Tipos Compostos

Nós usamos muitos tipos internos do Julia e agora definiremos um novo tipo. Como exemplo, vamos criar um tipo chamado +Ponto+ que representa um ponto no espaço bidimensional.
(((tipo)))(((Ponto)))((("tipo", "definido pelo programador", "Ponto", see="Ponto")))

Na notação matemática, os pontos geralmente são escritos entre parênteses com uma vírgula separando as coordenadas. Por exemplo, latexmath:[\(\left(0,0\right)\)] representa a origem e latexmath:[\(\left(x,y\right)\)] se estiver no 1o. quadrante representa o ponto latexmath:[\(x\)] unidades à direita e latexmath:[\(y\)] unidades acima da origem.

Existem diversas maneiras de representar pontos no Julia:

* Podemos armazenar as coordenadas separadamente em duas variáveis, +x+ e +y+.

* Poderíamos armazenar as coordenadas como elementos de um array ou de uma tupla.

* Poderíamos criar um novo tipo para representar os pontos como objetos.

A criação de um novo tipo é mais complicado que as outras opções, mas possui vantagens que serão mostradas em breve.

Um _tipo composto_ definido pelo programador também é denominado de _estrutura_. A definição +struct+ para um ponto é dada por:
(((tipo composto)))(((struct)))((("palavra-chave", "struct", see="struct")))(((end)))

[source,@julia-setup chap15]
----
struct Ponto
    x
    y
end
----

O cabeçalho indica que a nova struct é chamada de +Ponto+ enquanto o corpo define os _atributos_ ou _campos_ da struct. A struct +Ponto+ possui dois campos: +x+ e +y+.
(((atributo)))((("campo", see="atributo")))

A struct é como se fosse uma fábrica para criar objetos. Para criar um ponto, chama-se +Ponto+ como se fosse uma função tendo como argumentos os valores dos campos. Quando +Ponto+ é usado como uma função, ele é chamado de _construtor_.
(((construtor)))

[source,@julia-repl-test chap15]
----
julia> p = Ponto(3.0, 4.0)
Ponto(3.0, 4.0)
----

O valor de retorno é uma referência a um objeto +Ponto+, que atribuímos a +p+.
(((referência)))

A criação de um novo objeto é chamada _instanciação_, e o objeto é uma _instância_ do tipo.
(((instanciação)))(((instância)))

Quando você imprime uma instância, Julia informa a que tipo pertence e quais os valores dos atributos.

Todo objeto é uma instância de algum tipo; portanto, "objeto" e "instância" são permutáveis. Mas neste capítulo, eu uso "instância" para indicar que estou falando de um tipo definido pelo programador.ador.

Um diagrama de estado que mostra um objeto e seus campos é denominado de _diagrama do objeto_, conforme <<fig15-1>>.
(((diagrama do objeto)))((("diagrama", "objeto", see="diagrama do objeto")))

[[fig15-1]]
.Diagrama do objeto
image::images/fig151.svg[]


=== Structs são Imutáveis

Você pode acessar os valores dos campos usando a notação +.+:
(((.)))((("notação do ponto", see=".")))

[source,@julia-repl-test chap15]
----
julia> x = p.x
3.0
julia> p.y
4.0
----

A expressão +p.x+ significa: "Vá até a referência do objeto +p+ e obtenha o valor de +x+". No exemplo, atribuímos esse valor a uma variável +x+. Não há conflito entre a variável +x+ e o campo +x+.

Você pode usar a notação do ponto como parte de qualquer expressão. Por exemplo:

[source,@julia-repl-test chap15]
----
julia> distância = sqrt(p.x^2 + p.y^2)
5.0
----

Por padrão, as structs são  imutáveis, isto é, após a construção, os campos não podem mudar de valor:
((((imutável)))

[source,@julia-repl-test chap15]
----
julia> p.y = 1.0
ERROR: setfield! immutable struct of type Ponto cannot be changed
----

Isso pode parecer estranho de início, mas tem várias vantagens:

* Pode ser mais eficiente.

* Não é possível violar os invariantes dos construtores do tipo (veja <<constructor>>).

* O código usando objetos imutáveis pode ser mais fácil de ler e entender.


=== Structs Mutáveis

Quando necessário, os tipos compostos mutáveis podem ser declarados com a palavra-chave +mutable struct+. Aqui está a definição de um ponto mutável:
(((tipo composto mutável)))(((struct mutável)))((("palavra-chave", "mutable struct", see="mutable struct")))(((MPonto)))((("tipo", "definido pelo programador", "MPonto", see="MPonto")))

[source,@julia-setup chap15]
----
mutable struct MPonto
    x
    y
end
----

Você pode atribuir valores a uma instância de uma struct mutável usando a notação de ponto:
(((.)))

[source,@julia-repl-test chap15]
----
julia> origem = MPonto(0.0, 0.0)
MPonto(0.0, 0.0)
julia> origem.x = 3.0
3.0
julia> origem.y = 4.0
4.0
----


=== Retângulos

Sometimes it is obvious what the fields of an object should be, but other times you have to make decisions. For example, imagine you are designing a type to represent rectangles. What fields would you use to specify the location and size of a rectangle? You can ignore angle; to keep things simple, assume that the rectangle is either vertical or horizontal.

There are at least two possibilities:

* You could specify one corner of the rectangle (or the center), the width, and the height.

* You could specify two opposing corners.

At this point it is hard to say whether either is better than the other, so we’ll implement the first one, just as an example.
(((Rectangle)))((("type", "definido pelo programador", "Rectangle", see="Rectangle")))

[source,@julia-setup chap15]
----
"""
Represents a rectangle.

fields: width, height, corner.
"""
struct Rectangle
    width
    height
    corner
end
----

The docstring lists the fields: width and height are numbers; corner is a +Point+ object that specifies the lower-left corner.
(((docstring)))

To represent a rectangle, you have to instantiate a +Rectangle+ object:

[source,@julia-repl-test chap15]
----
julia> origin = MPoint(0.0, 0.0)
MPoint(0.0, 0.0)
julia> box = Rectangle(100.0, 200.0, origin)
Rectangle(100.0, 200.0, MPoint(0.0, 0.0))
----

<<fig15-2>> shows the state of this object. An object that is a field of another object is _embedded_. Because the +corner+ attribute refers to a mutable object, the latter is drawn outside the +Rectangle+ object.
(((embedded)))(((object diagram)))

[[fig15-2]]
.Object diagram
image::images/fig152.svg[]


=== Instances as Arguments

You can pass an instance as an argument in the usual way. For example:
(((printpoint)))((("function", "definido pelo programador", "printpoint", see="printpoint")))

[source,@julia-setup chap15]
----
function printpoint(p)
    println("($(p.x), $(p.y))")
end
----

+printpoint+ takes a +Point+ as an argument and displays it in mathematical notation. To invoke it, you can pass +p+ as an argument:

[source,@julia-repl-test chap15]
----
julia> printpoint(blank)
(3.0, 4.0)
----

===== Exercise 15-1

Write a function called +distancebetweenpoints+ that takes two points as arguments and returns the distance between them.
(((distancebetweenpoints)))((("function", "definido pelo programador", "distancebetweenpoints", see="distancebetweenpoints")))

If a mutable struct object is passed to a function as an argument, the function can modify the fields of the object. For example, +movepoint!+ takes a mutable +Point+ object and two numbers, +dx+ and +dy+, and adds the numbers to respectively the +x+ and the +y+ attribute of the +Point+:
(((movepoint!)))((("function", "definido pelo programador", "movepoint!", see="movepoint!")))

[source,@julia-setup chap15]
----
function movepoint!(p, dx, dy)
    p.x += dx
    p.y += dy
    nothing
end
----

Here is an example that demonstrates the effect:

[source,@julia-repl-test chap15]
----
julia> origin = MPoint(0.0, 0.0)
MPoint(0.0, 0.0)
julia> movepoint!(origin, 1.0, 2.0)

julia> origin
MPoint(1.0, 2.0)
----

Inside the function, +p+ is an alias for +origin+, so when the function modifies +p+, +origin+ changes.
(((aliasing)))

Passing an immutable +Point+ object to +movepoint!+ causes an error:

[source,@julia-repl-test chap15]
----
julia> movepoint!(p, 1.0, 2.0)
ERROR: setfield! immutable struct of type Point cannot be changed
----

You can however modify the value of a mutable attribute of an immutable object. For example, +moverectangle!+ has as arguments a +Rectangle+ object and two numbers, +dx+ and +dy+, and uses +movepoint!+ to move the corner of the rectangle:

[source,@julia-setup chap15]
----
function moverectangle!(rect, dx, dy)
  movepoint!(rect.corner, dx, dy)
end
----

Now +p+ in +movepoint!+ is an alias for +rect.corner+, so when +p+ is modified, +rect.corner+ changes also:

[source,@julia-repl-test chap15]
----
julia> box
Rectangle(100.0, 200.0, MPoint(0.0, 0.0))
julia> moverectangle!(box, 1.0, 2.0)

julia> box
Rectangle(100.0, 200.0, MPoint(1.0, 2.0))
----

[WARNING]
====
You cannot reassign a mutable attribute of an immutable object:
(((reassignment)))

[source,@julia-repl-test chap15]
----
julia> box.corner = MPoint(1.0, 2.0)
ERROR: setfield! immutable struct of type Rectangle cannot be changed
----
====

=== Instances as Return Values

Functions can return instances. For example, +findcenter+ takes a +Rectangle+ as an argument and returns a +Point+ that contains the coordinates of the center of the rectangle:
(((findcenter)))((("function", "definido pelo programador", "findcenter", see="findcenter")))

[source,@julia-setup chap15]
----
function findcenter(rect)
    Point(rect.corner.x + rect.width / 2, rect.corner.y + rect.height / 2)
end
----

The expression +rect.corner.x+ means, “Go to the object +rect+ refers to and select the field named +corner+; then go to that object and select the field named +x+.”

Here is an example that passes +box+ as an argument and assigns the resulting +Point+ to +center+:

[source,@julia-repl-test chap15]
----
julia> center = findcenter(box)
Point(51.0, 102.0)
----


=== Copying

Aliasing can make a program difficult to read because changes in one place might have unexpected effects in another place. It is hard to keep track of all the variables that might refer to a given object.
(((aliasing)))

Copying an object is often an alternative to aliasing. Julia provides a function called +deepcopy+ that can duplicate any object:
(((copying)))(((deepcopy)))((("function", "Base", "deepcopy", see="deepcopy")))(((deep copy)))

[source,@julia-repl-test chap15]
----
julia> p1 = MPoint(3.0, 4.0)
MPoint(3.0, 4.0)
julia> p2 = deepcopy(p1)
MPoint(3.0, 4.0)
julia> p1 ≡ p2
false
julia> p1 == p2
false
----

The +≡+ operator indicates that +p1+ and +p2+ are not the same object, which is what we expected. But you might have expected +==+ to yield +true+ because these points contain the same data. In that case, you will be disappointed to learn that for mutable objects, the default behavior of the +==+ operator is the same as the +===+ operator; it checks object identity, not object equivalence. That’s because for mutable composite types, Julia doesn’t know what should be considered equivalent. At least, not yet.
(((==)))(((≡)))

===== Exercise 15-2

Create a +Point+ instance, make a copy of it and check the equivalence and the egality of both. The result can surprise you but it explains why aliasing is a non issue for an immutable object.


=== Debugging

When you start working with objects, you are likely to encounter some new exceptions. If you try to access a field that doesn’t exist, you get:
(((debugging)))

[source,@julia-repl-test chap15]
----
julia> p = Point(3.0, 4.0)
Point(3.0, 4.0)
julia> p.z = 1.0
ERROR: type Point has no field z
----

If you are not sure what type an object is, you can ask:
(((typeof)))

[source,@julia-repl-test chap15]
----
julia> typeof(p)
Point
----

You can also use +isa+ to check whether an object is an instance of a type:
(((isa)))((("operator", "Base", "isa", see="isa")))

[source,@julia-repl-test chap15]
----
julia> p isa Point
true
----

If you are not sure whether an object has a particular attribute, you can use the built-in function +fieldnames+:
(((deepcopy)))((("function", "Base", "deepcopy", see="deepcopy")))

[source,@julia-repl-test chap15]
----
julia> fieldnames(Point)
(:x, :y)
----

or the function +isdefined+:
(((isdefined)))((("function", "Base", "isdefined", see="isdefined")))

[source,@julia-repl-test chap15]
----
julia> isdefined(p, :x)
true
julia> isdefined(p, :z)
false
----

The first argument can be any object; the second argument is a symbol, +:+ followed by the name of the field.
(((:)))(((Symbol)))((("type", "Base", "Symbol", see="Symbol")))

=== Glossary

struct::
A composite type.
(((struct)))

constructor::
A function with the same name as a type that creates instances of the type.
(((constructor)))

instance::
An object that belongs to a type.
(((instance)))

instantiate::
To create a new object.
(((instantiate)))

attribute or field::
One of the named values associated with an object.
(((attribute)))

embedded object::
An object that is stored as a field of another object.
(((embedded object)))

deep copy::
To copy the contents of an object as well as any embedded objects, and any objects embedded in them, and so on; implemented by the +deepcopy+ function.
(((deep copy)))

object diagram::
A diagram that shows objects, their fields, and the values of the fields.
(((object diagram)))


=== Exercises

[[ex15-1]]
===== Exercise 15-3

. Write a definition for a type named +Circle+ with fields +center+ and +radius+, where +center+ is a +Point+ object and +radius+ is a number.
(((Circle)))((("type", "definido pelo programador", "Circle", see="Circle")))

. Instantiate a circle object that represents a circle with its center at latexmath:[\(\left(150, 100\right)\)] and radius 75.

. Write a function named +pointincircle+ that takes a +Circle+ object and a +Point+ object and returns +true+ if the point lies in or on the boundary of the circle.
(((pointincircle)))((("function", "definido pelo programador", "pointincircle", see="pointincircle")))

. Write a function named +rectincircle+ that takes a +Circle+ object and a +Rectangle+ object and returns +true+ if the rectangle lies entirely in or on the boundary of the circle.
(((rectincircle)))((("function", "definido pelo programador", "rectincircle", see="rectincircle")))

. Write a function named +rectcircleoverlap+ that takes a +Circle+ object and a +Rectangle+ object and returns +true+ if any of the corners of the rectangle fall inside the circle. Or as a more challenging version, return +true+ if any part of the rectangle falls inside the circle.
(((rectcircleoverlap)))((("function", "definido pelo programador", "rectcircleoverlap", see="rectcircleoverlap")))

[[ex15-2]]
===== Exercise 15-4

. Write a function called +drawrect+ that takes a turtle object and a +Rectangle+ object and uses the turtle to draw the rectangle. See Chapter 4 for examples using +Turtle+ objects.
(((drawrect)))((("function", "definido pelo programador", "drawrect", see="drawrect")))

. Write a function called +drawcircle+ that takes a +Turtle+ object and a +Circle+ object and draws the circle.
(((drawcircle)))((("function", "definido pelo programador", "drawcircle", see="drawcircle")))
