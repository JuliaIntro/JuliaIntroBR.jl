<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Ben Lauwens e Allen Downey ⋅ Tradução: Abel Soares Siqueira, Gustavo Sarturi, João Okimoto, Kally Chung">
<title>Introdução à programação em Julia</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Introdução à programação em Julia</h1>
<div class="details">
<span id="author" class="author">Ben Lauwens e Allen Downey ⋅ Tradução: Abel Soares Siqueira, Gustavo Sarturi, João Okimoto, Kally Chung</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Índice</div>
<ul class="sectlevel1">
<li><a href="#_licença">Licença</a></li>
<li><a href="#_dedicatória">Dedicatória</a></li>
<li><a href="#_prefácio">Prefácio</a>
<ul class="sectlevel2">
<li><a href="#_por_que_julia">Por que Julia?</a></li>
<li><a href="#_para_quem_é_este_livro">Para Quem é Este Livro?</a></li>
<li><a href="#_convenções_adotadas_neste_livro">Convenções Adotadas Neste Livro</a></li>
<li><a href="#_usando_exemplos_de_código">Usando Exemplos de Código</a></li>
<li><a href="#_agradecimentos">Agradecimentos</a></li>
<li><a href="#_lista_de_contribuidores">Lista de Contribuidores</a></li>
</ul>
</li>
<li><a href="#chap01">1. O Caminho da Programação</a>
<ul class="sectlevel2">
<li><a href="#_o_que_é_um_programa">O que é um Programa?</a></li>
<li><a href="#_executando_o_julia">Executando o Julia</a></li>
<li><a href="#_o_primeiro_programa">O Primeiro Programa</a></li>
<li><a href="#_operações_aritméticas">Operações Aritméticas</a></li>
<li><a href="#_valores_e_tipos">Valores e Tipos</a></li>
<li><a href="#_linguagens_formais_e_naturais">Linguagens Formais e Naturais</a></li>
<li><a href="#_depuração">Depuração</a></li>
<li><a href="#_glossário">Glossário</a></li>
<li><a href="#_exercícios">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap02">2. Variáveis, Expressões e Declarações</a>
<ul class="sectlevel2">
<li><a href="#_declarações_de_atribuição">Declarações de Atribuição</a></li>
<li><a href="#_nomes_de_variáveis">Nomes de variáveis</a></li>
<li><a href="#_expressões_e_declarações">Expressões e Declarações</a></li>
<li><a href="#_modo_script">Modo Script</a></li>
<li><a href="#_precedência_de_operadores">Precedência de Operadores</a></li>
<li><a href="#_operações_com_strings">Operações com Strings</a></li>
<li><a href="#_comentários">Comentários</a></li>
<li><a href="#_depuração_2">Depuração</a></li>
<li><a href="#_glossário_2">Glossário</a></li>
<li><a href="#_exercícios_2">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap03">3. Funções</a>
<ul class="sectlevel2">
<li><a href="#_chamadas_de_funções">Chamadas de funções</a></li>
<li><a href="#_funções_matemáticas">Funções matemáticas</a></li>
<li><a href="#_composição">Composição</a></li>
<li><a href="#_adicionando_novas_funções">Adicionando novas funções</a></li>
<li><a href="#_definições_e_usos">Definições e usos</a></li>
<li><a href="#_fluxo_de_execução">Fluxo de execução</a></li>
<li><a href="#_parâmetros_e_argumentos">Parâmetros e argumentos</a></li>
<li><a href="#_as_variáveis_e_os_parâmetros_são_locais">As variáveis e os parâmetros são locais</a></li>
<li><a href="#stack_diagrams">Diagramas de Pilha</a></li>
<li><a href="#_funções_produtivas_e_funções_nulas">Funções produtivas e funções nulas</a></li>
<li><a href="#_por_que_funções">Por que funções?</a></li>
<li><a href="#_depuração_3">Depuração</a></li>
<li><a href="#_glossário_3">Glossário</a></li>
<li><a href="#_exercícios_3">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap04">4. Estudo de Caso: Design de Interface</a>
<ul class="sectlevel2">
<li><a href="#_turtles">Turtles</a></li>
<li><a href="#simple_repetition">Repetição Simples</a></li>
<li><a href="#_exercícios_4">Exercícios</a></li>
<li><a href="#_encapsulamento">Encapsulamento</a></li>
<li><a href="#_generalização">Generalização</a></li>
<li><a href="#_design_de_interface">Design de Interface</a></li>
<li><a href="#reestruturação">Reestruturação</a></li>
<li><a href="#_um_plano_de_desenvolvimento">Um Plano de Desenvolvimento</a></li>
<li><a href="#_docstring">Docstring</a></li>
<li><a href="#_depuração_4">Depuração</a></li>
<li><a href="#_glossário_4">Glossário</a></li>
<li><a href="#_exercícios_5">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap05">5. Condicionais e Recursão</a>
<ul class="sectlevel2">
<li><a href="#_divisão_inteira_e_módulo">Divisão Inteira e Módulo</a></li>
<li><a href="#_expressões_booleanas">Expressões Booleanas</a></li>
<li><a href="#_operadores_lógicos">Operadores Lógicos</a></li>
<li><a href="#_execução_condicional">Execução Condicional</a></li>
<li><a href="#_execuções_alternativas">Execuções Alternativas</a></li>
<li><a href="#_condicionais_encadeadas">Condicionais Encadeadas</a></li>
<li><a href="#_condicionais_aninhadas">Condicionais Aninhadas</a></li>
<li><a href="#recursion">Recursão</a></li>
<li><a href="#_diagramas_de_pilhas_para_funções_recursivas">Diagramas de Pilhas para Funções Recursivas</a></li>
<li><a href="#_recursão_infinita">Recursão Infinita</a></li>
<li><a href="#_entradas_do_teclado">Entradas do Teclado</a></li>
<li><a href="#_depuração_5">Depuração</a></li>
<li><a href="#_glossário_5">Glossário</a></li>
<li><a href="#_exercícios_6">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap06">6. Funções Produtivas</a>
<ul class="sectlevel2">
<li><a href="#_valores_de_retorno">Valores de Retorno</a></li>
<li><a href="#incremental_development">Desenvolvimento Incremental</a></li>
<li><a href="#_composição_2">Composição</a></li>
<li><a href="#boolean_functions">Funções Booleanas</a></li>
<li><a href="#_mais_recursividade">Mais Recursividade</a></li>
<li><a href="#_salto_de_fé">Salto de Fé</a></li>
<li><a href="#one_more_example">Mais Um Exemplo</a></li>
<li><a href="#_verificação_de_tipos">Verificação de Tipos</a></li>
<li><a href="#deb06">Depuração</a></li>
<li><a href="#_glossário_6">Glossário</a></li>
<li><a href="#_exercícios_7">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap07">7. Iteração</a>
<ul class="sectlevel2">
<li><a href="#_reatribuição">Reatribuição</a></li>
<li><a href="#_atualizando_variáveis">Atualizando Variáveis</a></li>
<li><a href="#_a_declaração_while">A Declaração <code>while</code></a></li>
<li><a href="#_break"><code>break</code></a></li>
<li><a href="#_continue"><code>continue</code></a></li>
<li><a href="#square_roots">Raízes Quadradas</a></li>
<li><a href="#_algoritmos">Algoritmos</a></li>
<li><a href="#_depuração_6">Depuração</a></li>
<li><a href="#_glossário_7">Glossário</a></li>
<li><a href="#_exercícios_8">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap08">8. Strings</a>
<ul class="sectlevel2">
<li><a href="#characters">Caracteres</a></li>
<li><a href="#_uma_string_é_uma_sequência">Uma String é uma Sequência</a></li>
<li><a href="#_length"><code>length</code></a></li>
<li><a href="#_travessia">Travessia</a></li>
<li><a href="#_fatias_de_strings">Fatias de Strings</a></li>
<li><a href="#_string_são_imutáveis">String são Imutáveis</a></li>
<li><a href="#_interpolação_de_strings">Interpolação de Strings</a></li>
<li><a href="#searching">Buscando</a></li>
<li><a href="#looping_and_counting">Realizando Laços e Contando</a></li>
<li><a href="#_a_biblioteca_de_strings">A Biblioteca de Strings</a></li>
<li><a href="#_o_operador">O Operador <code>∈</code></a></li>
<li><a href="#_comparação_de_strings">Comparação de Strings</a></li>
<li><a href="#deb08">Depuração</a></li>
<li><a href="#_glossário_8">Glossário</a></li>
<li><a href="#_exercícios_9">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap09">9. Estudo de Caso: Jogo de Palavras</a>
<ul class="sectlevel2">
<li><a href="#reading_word_lists">Lendo Listas de Palavras</a></li>
<li><a href="#_exercícios_10">Exercícios</a></li>
<li><a href="#search">Busca</a></li>
<li><a href="#_laço_com_índices">Laço com Índices</a></li>
<li><a href="#_depuração_7">Depuração</a></li>
<li><a href="#_glossário_9">Glossário</a></li>
<li><a href="#_exercícios_11">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap10">10. Listas</a>
<ul class="sectlevel2">
<li><a href="#_uma_lista_é_uma_sequência">Uma Lista é uma Sequência</a></li>
<li><a href="#_listas_são_mutáveis">Listas são Mutáveis</a></li>
<li><a href="#_percorrendo_uma_lista">Percorrendo uma Lista</a></li>
<li><a href="#_operador_de_fatias">Operador de Fatias</a></li>
<li><a href="#_biblioteca_de_listas">Biblioteca de Listas</a></li>
<li><a href="#_mapeamento_filtro_e_redução">Mapeamento, Filtro e Redução</a></li>
<li><a href="#_sintaxe_do_ponto">Sintaxe do Ponto</a></li>
<li><a href="#_deletando_inserindo_elementos">Deletando (Inserindo) Elementos</a></li>
<li><a href="#_listas_e_strings">Listas e Strings</a></li>
<li><a href="#_objetos_e_valores">Objetos e Valores</a></li>
<li><a href="#_alias">Alias</a></li>
<li><a href="#_argumentos_de_listas">Argumentos de Listas</a></li>
<li><a href="#_depuração_8">Depuração</a></li>
<li><a href="#_glossário_10">Glossário</a></li>
<li><a href="#_exercícios_12">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap11">11. Dicionários</a>
<ul class="sectlevel2">
<li><a href="#_um_dicionário_é_um_mapeamento">Um Dicionário é um Mapeamento</a></li>
<li><a href="#dictionary_collection_counters">Dicionários como uma Coleção de Contadores</a></li>
<li><a href="#_laços_e_dicionários">Laços e Dicionários</a></li>
<li><a href="#_consulta_inversa">Consulta Inversa</a></li>
<li><a href="#_dicionários_e_listas">Dicionários e Listas</a></li>
<li><a href="#memos">Memos</a></li>
<li><a href="#global_variables">Variáveis Globais</a></li>
<li><a href="#_depuração_9">Depuração</a></li>
<li><a href="#_glossário_11">Glossário</a></li>
<li><a href="#_exercícios_13">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap12">12. Tuplas</a>
<ul class="sectlevel2">
<li><a href="#_tuplas_são_imutáveis">Tuplas são Imutáveis</a></li>
<li><a href="#_atribuição_de_tuplas">Atribuição de Tuplas</a></li>
<li><a href="#_tuplas_como_valores_de_retorno">Tuplas como Valores de Retorno</a></li>
<li><a href="#_tuplas_com_argumentos_de_comprimento_variável">Tuplas com Argumentos de Comprimento Variável</a></li>
<li><a href="#_listas_e_tuplas">Listas e Tuplas</a></li>
<li><a href="#_dicionários_e_tuplas">Dicionários e Tuplas</a></li>
<li><a href="#_sequências_de_sequências">Sequências de Sequências</a></li>
<li><a href="#_depuração_10">Depuração</a></li>
<li><a href="#_glossário_12">Glossário</a></li>
<li><a href="#_exercícios_14">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap13">13. Estudo de Caso: Seleção de Estrutura de Dados</a>
<ul class="sectlevel2">
<li><a href="#_análise_de_frequência_de_palavras">Análise de Frequência de Palavras</a></li>
<li><a href="#_números_aleatórios">Números Aleatórios</a></li>
<li><a href="#_histograma_de_palavra">Histograma de Palavra</a></li>
<li><a href="#_palavras_mais_frequentes">Palavras Mais Frequentes</a></li>
<li><a href="#_parâmetros_opcionais">Parâmetros Opcionais</a></li>
<li><a href="#dictionary_subtraction">Subtração de Dicionário</a></li>
<li><a href="#_palavras_aleatórias">Palavras Aleatórias</a></li>
<li><a href="#markov-analysis">Análise de Markov</a></li>
<li><a href="#_estruturas_de_dados">Estruturas de Dados</a></li>
<li><a href="#_depuração_11">Depuração</a></li>
<li><a href="#_glossário_13">Glossário</a></li>
<li><a href="#_exercícios_15">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap14">14. Arquivos</a>
<ul class="sectlevel2">
<li><a href="#_persistência">Persistência</a></li>
<li><a href="#reading_and_writing">Lendo e Escrevendo</a></li>
<li><a href="#_formatação">Formatação</a></li>
<li><a href="#_nomes_de_arquivos_e_caminhos">Nomes de Arquivos e Caminhos</a></li>
<li><a href="#catching_exceptions">Capturando Exceções</a></li>
<li><a href="#_serialização">Serialização</a></li>
<li><a href="#_objetos_de_comando">Objetos de Comando</a></li>
<li><a href="#_módulos">Módulos</a></li>
<li><a href="#_depuração_12">Depuração</a></li>
<li><a href="#_glossário_14">Glossário</a></li>
<li><a href="#_exercícios_16">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap15">15. Estruturas e Objetos</a>
<ul class="sectlevel2">
<li><a href="#_tipos_compostos">Tipos Compostos</a></li>
<li><a href="#_structs_são_imutáveis">Structs são Imutáveis</a></li>
<li><a href="#_structs_mutáveis">Structs Mutáveis</a></li>
<li><a href="#_retângulos">Retângulos</a></li>
<li><a href="#_instâncias_como_argumentos">Instâncias como Argumentos</a></li>
<li><a href="#_instâncias_como_valores_de_retorno">Instâncias como Valores de Retorno</a></li>
<li><a href="#_copiando_objetos">Copiando Objetos</a></li>
<li><a href="#_depuração_13">Depuração</a></li>
<li><a href="#_glossário_15">Glossário</a></li>
<li><a href="#_exercícios_17">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap16">16. Estruturas e Funções</a>
<ul class="sectlevel2">
<li><a href="#time">Horário</a></li>
<li><a href="#_funções_puras">Funções Puras</a></li>
<li><a href="#modifiers">Modificadores</a></li>
<li><a href="#prototyping_versus_planning">Prototipagem Versus Planejamento</a></li>
<li><a href="#chap16_debugging">Depurando</a></li>
<li><a href="#_glossário_16">Glossário</a></li>
<li><a href="#_exercícios_18">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap17">17. Despacho Múltiplo</a>
<ul class="sectlevel2">
<li><a href="#_declarações_de_tipo">Declarações de Tipo</a></li>
<li><a href="#_métodos">Métodos</a></li>
<li><a href="#_exemplos_adicionais">Exemplos Adicionais</a></li>
<li><a href="#constructor">Construtores</a></li>
<li><a href="#_show"><code>show</code></a></li>
<li><a href="#_sobrecarga_de_operador">Sobrecarga de Operador</a></li>
<li><a href="#_despacho_múltiplo">Despacho Múltiplo</a></li>
<li><a href="#_programação_genérica">Programação Genérica</a></li>
<li><a href="#_interface_e_implementação">Interface e Implementação</a></li>
<li><a href="#_depuração_14">Depuração</a></li>
<li><a href="#_glossário_17">Glossário</a></li>
<li><a href="#_exercícios_19">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap18">18. Subtipagem</a>
<ul class="sectlevel2">
<li><a href="#_cartas">Cartas</a></li>
<li><a href="#_variáveis_globais">Variáveis Globais</a></li>
<li><a href="#_comparando_cartas">Comparando Cartas</a></li>
<li><a href="#_teste_unitário">Teste Unitário```</a></li>
<li><a href="#_baralhos">Baralhos</a></li>
<li><a href="#_adicionar_remover_embaralhar_e_ordenar">Adicionar, Remover, Embaralhar e Ordenar</a></li>
<li><a href="#_tipos_abstratos_e_subtipagem">Tipos Abstratos e Subtipagem</a></li>
<li><a href="#_tipos_abstratos_e_funções">Tipos Abstratos e Funções</a></li>
<li><a href="#_diagramas_de_tipos">Diagramas de Tipos</a></li>
<li><a href="#interactive">Depuração</a></li>
<li><a href="#_encapsulamento_de_dados">Encapsulamento de Dados</a></li>
<li><a href="#_glossário_18">Glossário</a></li>
<li><a href="#_exercícios_20">Exercícios</a></li>
</ul>
</li>
<li><a href="#chap19">19. Extras: Sintaxe</a>
<ul class="sectlevel2">
<li><a href="#_tuplas_nomeadas">Tuplas Nomeadas</a></li>
<li><a href="#_funções">Funções</a></li>
<li><a href="#_blocos">Blocos</a></li>
<li><a href="#_controle_de_fluxo">Controle de Fluxo</a></li>
<li><a href="#_tipos">Tipos</a></li>
<li><a href="#_métodos_2">Métodos</a></li>
<li><a href="#_construtores">Construtores</a></li>
<li><a href="#_conversão_e_promoção">Conversão e Promoção</a></li>
<li><a href="#_metaprogramação">Metaprogramação</a></li>
<li><a href="#_valores_ausentes">Valores Ausentes</a></li>
<li><a href="#_chamando_códigos_em_c_e_fortran">Chamando Códigos em C e Fortran</a></li>
<li><a href="#_glossário_19">Glossário</a></li>
</ul>
</li>
<li><a href="#chap20">20. Extras: Base e a Biblioteca Padrão</a>
<ul class="sectlevel2">
<li><a href="#_mensurando_performance">Mensurando Performance</a></li>
<li><a href="#collections_and_data_structures">Coleções e Estruturas de Dados</a></li>
<li><a href="#_matemática">Matemática</a></li>
<li><a href="#_strings">Strings</a></li>
<li><a href="#_arrays">Arrays</a></li>
<li><a href="#_interfaces">Interfaces</a></li>
<li><a href="#_utilidades_interativas">Utilidades Interativas</a></li>
<li><a href="#_depuração_15">Depuração</a></li>
<li><a href="#_glossário_20">Glossário</a></li>
</ul>
</li>
<li><a href="#chap21">21. Depuração</a>
<ul class="sectlevel2">
<li><a href="#_erros_de_sintaxe">Erros de Sintaxe</a></li>
<li><a href="#_erros_de_tempo_de_execução">Erros de Tempo de Execução</a></li>
<li><a href="#_erros_semânticos">Erros Semânticos</a></li>
</ul>
</li>
<li><a href="#_entrada_unicode">Apêndice A: Entrada Unicode</a></li>
<li><a href="#editores-online">Apêndice B: Editores online</a></li>
<li><a href="#diferencas-ptbr">Apêndice C: Diferenças na tradução</a></li>
<li><a href="#_index">Index</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_licença">Licença</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este livro está disponível sob a licença <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.pt_BR">Creative Commons Atribuição-NãoComercial 3.0 Não Adaptada</a>.
Esta é uma tradução do <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html">ThinkJulia</a>, que tem a mesma licença.
Uma lista das diferenças na tradução deste livro estão disponíveis no <a href="#diferencas-ptbr">Apéndice C</a>.</p>
</div>
<div class="paragraph">
<p>Os autores do ThinkJulia são:</p>
</div>
<div class="paragraph">
<p><strong>Ben Lauwens</strong> é professor de matemática na Rolay Military Academy (RMA Bélgica). Tem um doutorado em engenheria e um mestrado pela KU Leuven e RMA, e um bacharelado pela RMA.</p>
</div>
<div class="paragraph">
<p><strong>Allen Downey</strong> é professor de ciência da computação na Olin College of Engineering. Ele lecionou na Wellesley College, Colby College e U.C. Berkeley. Tem um doutorado em ciência da computação pela U.C. Berkeley e mestrado e bacharelado pelo MIT.</p>
</div>
<div class="paragraph">
<p>Os tradutores para a versão em português são:</p>
</div>
<div class="paragraph">
<p><strong>Abel Soares Siqueira</strong> é professor de matemática na Universidade Federal do Paraná.</p>
</div>
<div class="paragraph">
<p><strong>Gustavo Sarturi</strong> é aluno de graduação em matemática industrial na Universidade Federal do Paraná.</p>
</div>
<div class="paragraph">
<p><strong>João Okimoto</strong> é aluno de graduação em ciência da computação na Universidade Federal do Paraná.</p>
</div>
<div class="paragraph">
<p><strong>Kally Chung</strong>, mestranda em métodos numéricos da engenharia na Universidade Federal do Paraná.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dedicatória">Dedicatória</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Para Emeline, Arnaud e Tibo.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_prefácio">Prefácio</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Em Janeiro de 2018 eu comecei a preparar um curso de programação voltado à estudantes sem experiência de programação. Eu queria usar o Julia, mas descobri que não existia livro com o objetivo de aprender a programar com Julia como a primeira linguagem de programação. Existem tutoriais muito bons que explicam os conceitos chave do Julia, mas nenhum deles dá atenção suficiente a como aprender a pensar como um programador.</p>
</div>
<div class="paragraph">
<p>Eu conhecia o livro <a href="http://shop.oreilly.com/product/0636920045267.do"><em>Think Python</em></a> de Allen Downey, que contém todos os ingredientes chave para aprender a programar corretamente. No entanto, este livro foi baseado na linguagem de programação Python. O meu primeiro rascunho das anotações do curso foi um caldeirão de todos os tipos de trabalhos de referência, mas quanto mais eu trabalhava nele, mais o seu conteúdo começava a se assemelhar aos capítulos de <em>Think Python</em>. Logo após isso, a ideia de desenvolver minhas anotações do curso como uma versão deste livro adaptado ao Julia se concretizou.</p>
</div>
<div class="paragraph">
<p>Todo o material estava disponível em notebooks Jupyter em um repositório no Github. Depois que mandei uma mensagem ao site do Julia Discourse sobre o progresso do meu curso, o feedback foi fantástico. Um livro sobre conceitos básicos de programação com Julia sendo a primeira linguagem de programação era aparentemente um elo perdido no universo Julia. Eu contatei Allen para perguntar se eu poderia começar uma adaptação oficial do <em>Think Python</em> para o Julia, e sua resposta foi imediata: “Vá em frente!” ele me colocou em contato com o seu editor da O&#8217;Reilly Media, e um ano depois, eu estava colocando os toques finais neste livro.</p>
</div>
<div class="paragraph">
<p>Foi  uma jornada e tanto. Em Agosto de 2018 o Julia v1.0 foi lançado, e como todos meus companheiros que programam em Julia, eu tive que fazer uma migração do código. Todos os exemplos nesse livro foram testados durante a conversão dos arquivos fonte para arquivos AsciiDoc compativeís com a O&#8217;Reilly. Tanto o conjunto de ferramentas e o código exemplo teve que ser compatibilizado com o Julia v1.0. Por sorte, não há aulas para dar em Agosto&#8230;&#8203;.</p>
</div>
<div class="paragraph">
<p>Eu espero que você aproveite trabalhar com este livro, e que ele o ajude a aprender a programar e a pensar como um cientista da computação, pelo menos um pouquinho.</p>
</div>
<div class="paragraph byline">
<p>Ben Lauwens</p>
</div>
<div class="sect2">
<h3 id="_por_que_julia">Por que Julia?</h3>
<div class="paragraph">
<p>O Julia  foi originalmente lançada em 2012 por Alan Edelman, Stefan Karpinski, Jeff Bezanson, e Viral Shah. Ela é uma linguagem de programação gratuita e open source.</p>
</div>
<div class="paragraph">
<p>Escolher uma linguagem de programação é sempre subjetivo. Para mim, as seguintes características do Julia são decisivas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>O Julia é desenvolvida como uma linguagem de programação de alta performance.</p>
</li>
<li>
<p>O Julia usa despacho múltiplo, que permite ao programador escolher diferentes padrões de programação adaptados à aplicação.</p>
</li>
<li>
<p>O Julia é uma linguagem dinamicamente tipada que pode ser facilmente usada interativamente.</p>
</li>
<li>
<p>O Julia possui uma boa sintaxe de alto nível que é fácil de aprender.</p>
</li>
<li>
<p>O Julia é uma linguagem de programação de tipo opcional, cujos tipos de dados (definidos pelo usuário) tornam o código mais claro e robusto.</p>
</li>
<li>
<p>O Julia possui uma biblioteca padrão extendida e numerosos pacotes de terceiros que estão disponíveis.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>O Julia é uma linguagem de programação única pois resolve o chamado "problema de duas linguagens". Nenhuma outra linguagem de programação é necessária para escrever código de alta performance. Isso não significa que isso acontece automaticamente. É de responsabilidade do programador otimizar o código que forma um gargalo, mas isso pode ser feito no próprio Julia.</p>
</div>
</div>
<div class="sect2">
<h3 id="_para_quem_é_este_livro">Para Quem é Este Livro?</h3>
<div class="paragraph">
<p>Este livro é para qualquer um que quer aprender a programar. Nenhum conhecimento prévio é requerido.</p>
</div>
<div class="paragraph">
<p>Novos conceitos são introduzidos gradualmente e tópicos mais avançados são descritos em capítulos posteriores.</p>
</div>
<div class="paragraph">
<p><em>Introdução à programação em Julia</em> (<em>Think Julia</em>) pode ser usado para um curso de um semestre em nível de ensino médio ou de universidade.</p>
</div>
</div>
<div class="sect2">
<h3 id="_convenções_adotadas_neste_livro">Convenções Adotadas Neste Livro</h3>
<div class="paragraph">
<p>As  seguintes conveções foram adotadas neste livro:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Itálico</em></dt>
<dd>
<p>indica novos termos, URLs, endereços de email, nomes de arquivo e extensões de arquivo.</p>
</dd>
<dt class="hdlist1"><code>Comprimento constante</code></dt>
<dd>
<p>Usado para listagens de programas, assim como dentro de paragráfos para referir a elementos de programas como variáveis ou nomes de função, banco de dados, tipos de dado, variáveis de ambiente, declarações e palavras-chave.</p>
</dd>
<dt class="hdlist1"><strong><code>Comprimento constante em negrito</code></strong></dt>
<dd>
<p>Indica comandos ou outro texto que deve ser literalmente digitado pelo usuário.</p>
</dd>
<dt class="hdlist1"><em><code>Comprimento constante itálico</code></em></dt>
<dd>
<p>Indica texto que deve ser substituido por valores fornecidos pelo usuário ou por valores determinados pelo contexto.</p>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Este elemento signfica uma dica ou sugestão.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Nota</div>
</td>
<td class="content">
<div class="paragraph">
<p>Este elemento significa uma observação geral.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Atenção</div>
</td>
<td class="content">
<div class="paragraph">
<p>Este elemento indica um aviso ou cuidado.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_usando_exemplos_de_código">Usando Exemplos de Código</h3>
<div class="paragraph">
<p>Todo código usado neste livro está disponível em um repositório Git no Github: <a href="https://github.com/JuliaIntro/JuliaIntroBR.jl" class="bare">https://github.com/JuliaIntro/JuliaIntroBR.jl</a>. Se você não esta familiarizado com o Git, ele é um sistema de controle de versão que permite ao usuário acompanhar os arquivos que fazem parte de um projeto. Um conjunto de arquivos sob controle do Git é chamado de “repositório”. O Github é um serviço de hospedamento que fornece armazenamento para repositórios Git e uma interface web conveniente.</p>
</div>
<div class="paragraph">
<p>Um pacote de conveniência é fornecido que pode ser diretamente adicionado ao Julia. Apenas digite <code>add <a https://github.com/JuliaIntro/JuliaIntroBR.jl">https://github.com/JuliaIntro/JuliaIntroBR.jl</a></code> No REPL em modo Pkg, veja <a href="#turtles">[turtles]</a>.</p>
</div>
<div class="paragraph">
<p>A  maneira mais fácil de executar código em Julia é indo para <a href="https://repl.it" class="bare">https://repl.it</a> e iniciar uma sessão gratuita. Tanto o REPL quanto um editor estão disponíveis. Se você quiser ter o Julia instalado localmente no seu computador, você pode fazer o download do <a href="https://juliacomputing.com/products/juliapro.html">JuliaPro</a> gratuitamente de Julia Computing. Ele consiste de uma versão recente do Julia, um ambiente interativo de desenvolvimento baseado no Atom e um número de pacotes Julia pré-instalados. Se você quiser se aventurar ainda mais, você pode fazer o download do Julia em <a href="https://julialang.org" class="bare">https://julialang.org</a>, instalar o editor que você quiser (ex. Atom ou Visual Studio Code), e ativar plug-ins para integração do Julia. Para uma instalação local, você também pode adicionar o pacote <code>IJulia</code> e executar um notebook Jupyter no seu computador.</p>
</div>
</div>
<div class="sect2">
<h3 id="_agradecimentos">Agradecimentos</h3>
<div class="paragraph">
<p>Eu realmente gostaria de agradecer ao Allen por escrever <em>Think Python</em> e permitir que eu pudesse adaptar o seu livro para o Julia. Seu entusiasmo é contagiante!</p>
</div>
<div class="paragraph">
<p>Eu também gostaria de agradecer aos revisores técnicos para este livro, que fizeram muitas sugestões utéis: Tim Besard, Bart Janssens, e David P. Sanders.</p>
</div>
<div class="paragraph">
<p>Obrigado à Melissa Potter da O&#8217;Reilly Media, que fez deste livro melhor. Você me forçou a fazer as coisas certo e fazer este livro o mais original possível.</p>
</div>
<div class="paragraph">
<p>Obrigado a Matt Hacker da O&#8217;Reilly Media, que me ajudou com o conjunto de ferramentas Atlas e alguns problemas de destacação de sintaxe.</p>
</div>
<div class="paragraph">
<p>Obrigado a todos os estudantes que trabalharam com uma versão inicial deste livro e todos os contribuidores (listados abaixo) que mandaram correções e sugestões.</p>
</div>
</div>
<div class="sect2">
<h3 id="_lista_de_contribuidores">Lista de Contribuidores</h3>
<div class="paragraph">
<p>Se você tem uma sugestão ou correção, porfavor mande um email à <a href="mailto:ben.lauwens@gmail.com">ben.lauwens@gmail.com</a> ou abra um issue em <a href="https://github.com/BenLauwens/ThinkJulia.jl">GitHub</a>. Se eu fizer uma mudança baseada no seu feedback, irei adicioná-lo na lista de contribuidores (a menos que você peça para ser omitido).</p>
</div>
<div class="paragraph">
<p>Me diga com qual versão do livro você esta trabalhando, e qual formato. Se você incluir ao menos parte da frase aonde o erro aparece, isso facilitará a minha busca. Páginas e número de seção também ajudam, mas não são tão facéis de trabalhar. Obrigado!</p>
</div>
<div class="openblock small">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Scott Jones apontou à mudança de nome de <code>Void</code> para <code>Nothing</code>, e isso iniciou a migração para o Julia v1.0.</p>
</li>
<li>
<p>Robin Deits achou alguns erros de digitação em <a href="#chap02">Variáveis, Expressões e Declarações</a>.</p>
</li>
<li>
<p>Mark Schmitz sugeriu ligar a sintaxe de destacação.</p>
</li>
<li>
<p>Zigu Zhao achou alguns bugs em <a href="#chap08">Strings</a>.</p>
</li>
<li>
<p>Oleg Soloviev achou um erro na URL para adicionar o pacote <code>ThinkJulia</code>.</p>
</li>
<li>
<p>Aaron Ang achou alguns problema de renderização e nomeação.</p>
</li>
<li>
<p>Sergey Volkov achou um link quebrado em <a href="#chap07">Iteração</a>.</p>
</li>
<li>
<p>Sean McAllister sugeriu mencionar o excelente pacote <code>BenchmarkTools</code>.</p>
</li>
<li>
<p>Carlos Bolech mandou uma longa lista de correções e sugestões.</p>
</li>
<li>
<p>Krishna Kumar corrigiu o exemplo de Markov em <a href="#chap18">Subtipagem</a>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 pagenumrestart">
<h2 id="chap01">1. O Caminho da Programação</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O objetivo deste livro é ensinar você a pensar como um cientista da computação. Essa maneira de pensar combina algumas das melhores ferramentas da matemática, engenharia e ciências naturais. Como matemáticos, cientistas da computação usam linguagens formais para denotar ideias (especificamente cálculos). Como engenheiros, projetam coisas, montando componentes em sistemas e avaliando ganhos e perdas entre as alternativas. Como cientistas, observam o comportamento de sistemas complexos, formulam hipóteses e testam predições.</p>
</div>
<div class="paragraph">
<p>A habilidade mais importante para um cientista da computação é a resolução de problemas. Resolver problemas significa ter habilidade para formular problemas, pensar em soluções com criatividade, e expressar a solução clara e precisamente. Como se vê, o processo de aprendizagem para programar é uma excelente oportunidade de praticar a habilidade de resolução de problemas. Por essa razão esse capítulo tem como título "O caminho da programação".</p>
</div>
<div class="paragraph">
<p>Por um lado, você estará aprendendo a programar, uma habilidade muito útil por si só. Por outro, você usará a programação como um significado para alcançar um objetivo. Na medida que formos evoluindo, esse fim ficará mais claro.</p>
</div>
<div class="sect2">
<h3 id="_o_que_é_um_programa">O que é um Programa?</h3>
<div class="paragraph">
<p>Um <em>programa</em> é uma sequência de instruções que especifica como deve ser a computação. A computação poderá ser algo matemático, como resolver um sistema de equações ou encontrar as raízes de um polinômio, mas pode ser também uma computação simbólica, como uma busca ou substituição de texto num documento, ou algo gráfico, como o processamento de uma imagem ou reprodução de um vídeo.</p>
</div>
<div class="paragraph">
<p>Os  detalhes são diferentes em diferentes linguagens de programação, mas algumas instruções básicas aparecem em praticamente em todos os idiomas:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Entrada (<em>Input</em>)</dt>
<dd>
<p>Coleta os dados do teclado, de um arquivo, de uma rede ou de algum dispositivo.</p>
</dd>
<dt class="hdlist1">Saída (<em>Output</em>)</dt>
<dd>
<p>Exibe os dados na tela, salva em um documento, envia através da rede, etc.</p>
</dd>
<dt class="hdlist1">Matemáticos</dt>
<dd>
<p>Realiza operações matemática básicas como adição e multiplicação.</p>
</dd>
<dt class="hdlist1">Execução Condicional</dt>
<dd>
<p>Verifica certas condições e executa o código apropriado.</p>
</dd>
<dt class="hdlist1">Repetição</dt>
<dd>
<p>Realiza alguma ação repetidamente, geralmente com alguma variação.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Acredite ou não, isso é tudo que existe. Todo programa que você já usou, por mais complicado que seja, é composto de instruções que são muito similares a essas. Portanto, você pode pensar em programação como o processo de dividir uma tarefa grande e complexa em subtarefas cada vez menores até que as subtarefas sejam simples o suficiente para serem executadas com uma dessas instruções básicas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_executando_o_julia">Executando o Julia</h3>
<div class="paragraph">
<p>Um dos desafios de começar com o Julia é que talvez você precise instalá-lo e softwares relacionados no seu computador. Se você está familiarizado com o seu sistema operacional, e especificamente se você está confortável com a interface das linhas de comando, você não terá problemas em instalar o Julia. Mas, para iniciantes, pode ser assustador aprender sobre administração de sistemas operacionais e programação ao mesmo tempo.</p>
</div>
<div class="paragraph">
<p>Para evitar esse problema, eu recomendo que você comece a executar o Julia em um navegador. Depois, quando se sentir mais confortável com o Julia, eu irei sugerir instalar o Julia em seu computador.</p>
</div>
<div class="paragraph">
<p>No navegador, você pode executar o <a href="https://repl.it">Repl.it</a>. Nenhuma instalação é necessária - Apenas escolha um navegador, faça o <em>log in</em> e comece a programar (veja <a href="#editores-online">Editores online</a>).</p>
</div>
<div class="paragraph">
<p>O <em>REPL</em> do Julia (Read-Eval-Print Loop, que traduzido ao pé da letra, significa Ler, Avaliar e Repetição de impressão) é um programa que lê e executa os códigos do Julia. Você pode começar o REPL abrindo um terminal e escrevendo <strong><code>julia</code></strong> na linha de comando (depois de instalar o Julia). Alternativamente, o Repl.it já abre um terminal junto com o editor. Quando executar, você deverá ver uma saída como essa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.4.2 (2020-05-23)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |

julia&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>As primeiras linhas contém informações sobre o REPL, que deve ser diferente para você. Porém, você deve checar que o número da versão seja pelo menos 1.0.0.</p>
</div>
<div class="paragraph">
<p>A  última linha é um <em>prompt</em> que indica que o REPL está pronto para você inserir o código. Se você digitar uma linha de código e pressionar Enter, o REPL exibirá o seguinte resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 1 + 1
2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Os trechos de códigos podem ser copiados e colados literalmente, incluindo o prompt julia&gt; e qualquer saída.</p>
</div>
<div class="paragraph">
<p>Agora você está pronto para começar. Daqui em diante, irei assumir que você sabe como iniciar o Julia REPL e executar o código.</p>
</div>
</div>
<div class="sect2">
<h3 id="_o_primeiro_programa">O Primeiro Programa</h3>
<div class="paragraph">
<p>Tradicionalmente, o primeiro programa que você escreve em uma nova linguagem de programação é chamado de "Olá, Mundo!" porque tudo que faz é exibir as palavras "Olá, Mundo!". Em Julia, se parece com isso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; println("Olá, Mundo!")
Olá, Mundo!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este é um exemplo de um comando de impressão, embora não imprima nada no papel. Ele exibe o resultado na tela.</p>
</div>
<div class="paragraph">
<p>As aspas no programa marcam o início e o final do texto a ser exibido; eles não aparecem no resultado.</p>
</div>
<div class="paragraph">
<p>Os parênteses indicam que <code>println</code> é uma função. Nós chegaremos em funções no <a href="#Capítulo 3">[Capítulo 3]</a>. </p>
</div>
</div>
<div class="sect2">
<h3 id="_operações_aritméticas">Operações Aritméticas</h3>
<div class="paragraph">
<p>Depois de "Olá, Mundo!" o próximo passo é a aritmética. Julia fornece  <em>operadores</em>, que são símbolos que representam cálculos como adição e multiplicação.</p>
</div>
<div class="paragraph">
<p>Os operadores operators <code>+</code>, <code>-</code>, and <code>*</code> executam adição, subtração e multiplicação, como nos seguintes exemplos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 40 + 2
42
julia&gt; 43 - 1
42
julia&gt; 6 * 7
42</code></pre>
</div>
</div>
<div class="paragraph">
<p>O  operador <code>/</code> executa divisão:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 84 / 2
42.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Talvez você deva estar se perguntando porquê o resultado é 42.0 invés de 42. Eu irei explicar na próxima seção.</p>
</div>
<div class="paragraph">
<p>Finalmente, o operador <code>^</code> executa exponenciação; isto é, eleva um número a uma potência:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 6^2 + 6
42</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_valores_e_tipos">Valores e Tipos</h3>
<div class="paragraph">
<p>Um <em>valor</em>  é uma das coisas mais básicas que um programa trabalha, como uma letra ou um número. Alguns valores que vimos até agora são <code>2</code>, <code>42.0</code>, e <code>"Olá, Mundo!"</code>.</p>
</div>
<div class="paragraph">
<p>Esse valores pertencem a diferentes <em>tipos</em>: 2 é um <em>inteiro</em>, 42.0 é um <em>número de ponto flutuante</em>, e <code>"Olá, Mundo!"</code> é uma <em>string</em>, é chamada assim porque os caracteres que contém são amarrados.</p>
</div>
<div class="paragraph">
<p>Se  você não tem certeza de que tipo é um determinado valor, o REPL pode dizer a você:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; typeof(2)
Int64
julia&gt; typeof(42.0)
Float64
julia&gt; typeof("Hello, World!")
String</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inteiros pertencem ao tipo <code>Int64</code>, strings pertencem a <code>String</code>, e pontos flutuantes pertencem a <code>Float64</code>.</p>
</div>
<div class="paragraph">
<p>E quanto a valores como <code>"2"</code> e <code>"42.0"</code>? Eles parecem números, mas estão entre parênteses como strings. Eles também são strings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; typeof("2")
String
julia&gt; typeof("42.0")
String</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quando você digita um número inteiro grande, você pode ficar tentado a usar vírgulas entre os grupos de dígitos, como em 1,000,000. Isto não é um <em>inteiro</em> permitido em Julia, mas é permitido:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 1,000,000
(1, 0, 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Não era o que esperávamos! Julia analisa <code>1,000,000</code> como uma sequência separada por vírgula de inteiros. Iremos aprender mais sobre este tipo de sequência depois.</p>
</div>
<div class="paragraph">
<p>Contudo,  você pode obter o resultado esperado usando <code>1_000_000</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_linguagens_formais_e_naturais">Linguagens Formais e Naturais</h3>
<div class="paragraph">
<p><em>Linguagens Naturais</em>  são aquelas linguagens que as pessoas falam, como Inglês, Espanhol, Português e o Francês. Elas não são projetadas por pessoas (embora pessoas tentem lhes impor alguma ordem); elas evoluíram naturalmente.</p>
</div>
<div class="paragraph">
<p><em>Linguagens Formais</em>  são linguagens projetadas por pessoas para aplicações específicas. Por exemplo, a notação que os matemáticos utilizam é uma linguagem formal que em particular é boa para denotar a relação entre números e símbolos. Químicos usam uma linguagem formal para representar a estrutura química das moléculas. E mais importante, linguagens de programação são linguagens formais projetadas para expressar cálculos.</p>
</div>
<div class="paragraph">
<p>Linguagens formais tendem a ter regras rígidas de <em>sintaxe</em> que governam a estrutura das declarações. Por exemplo, em matemática a declaração \(3 + 3 = 6\) tem sintaxe correta, mas \(3 += 3 \$ 6\) não. Em química, \(\mathrm{H_2O}\) é uma fórmula sintaticamente correta, mas \(\mathrm{_2Zz}\) não.</p>
</div>
<div class="paragraph">
<p>Regras de sintaxe são fornecidas em dois tipos, pertencentes a <em>símbolos</em> e <em>estruturas</em>. Símbolos são elementos básicos da linguagem, como palavras, números e elementos químicos. Um dos problemas com \(3 += 3 \$ 6\) é que \(\$\) não é um símbolo permitido em matemática (pelo menos até onde eu sei). Da mesma forma, \(\mathrm{_2Zz}\) não é permitido pois não há elemento com abreviação \(\mathrm{Zz}\).</p>
</div>
<div class="paragraph">
<p>O segundo tipo de regra de sintaxe pertence à maneira que símbolos são combinados. A equação \(3 +=3\) não é permitida porque mesmo que \(+\) e \(=\) sejam símbolos permitidos, você não pode ter um logo após o outro. Da mesma forma, em uma fórmula química, o subscrito vem depois do nome do elemento, e não antes.</p>
</div>
<div class="paragraph">
<p>Essa é um@ sentença bem estruturada em portuguê$ com 5ímb0l05 inválidos. Essa frase possui todos os símbolos válidos, mas com estrutura invalida.</p>
</div>
<div class="paragraph">
<p>Quando  você lê uma sentença em Português ou uma declaração numa linguagem formal, você tem que descrever a estrutura (apesar de que em uma linguagem natural você faz isso subconscientemente). Esse processo é chamado de <em>análise</em>.</p>
</div>
<div class="paragraph">
<p>Embora as linguagens formais e naturais tenham muito recursos em comuns — símbolos, estruturas, e sintaxes —  existem algumas diferenças:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Ambiguidade</dt>
<dd>
<p>As linguagens naturais são cheias de ambiguidades, com as quais as pessoas lidam usando pistas contextuais e outras informações. As linguagens formais são projetadas para serem quase ou completamente inequívocas, o que significa que qualquer afirmação tem exatamente um significado, independentemente do contexto.</p>
</dd>
<dt class="hdlist1">Redundância</dt>
<dd>
<p>Para compensar a ambiguidade e reduzir os mal-entendidos, as linguagens naturais empregam muita redundância. Como resultado, elas geralmente são detalhadas. Linguagens formais são menos redundantes e mais concisas.</p>
</dd>
<dt class="hdlist1">Literalidade</dt>
<dd>
<p>As línguas naturais estão cheias de expressões idiomáticas e metáforas. Se eu disser: "Caiu a ficha!", provavelmente não há ficha e nada está caindo (nesse idioma significa que alguém entendeu alguma coisa após um período de confusão). Linguagens formais significam exatamente o que dizem.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Como todos nós crescemos falando linguagens naturais, às vezes é difícil nos adaptarmos às línguas formais. A diferença entre linguagem formal e natural é como a diferença entre poesia e prosa, mas mais ainda:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Poesia</dt>
<dd>
<p>As palavras são usadas tanto pelos sons quanto pelo significado, e o poema inteiro cria um efeito ou resposta emocional. A ambiguidade não é apenas comum, mas muitas vezes deliberada.</p>
</dd>
<dt class="hdlist1">Prosa</dt>
<dd>
<p>O significado literal das palavras é mais importante e a estrutura contribui com mais significado. A prosa é mais passível de análise do que a poesia, mas ainda é ambígua.</p>
</dd>
<dt class="hdlist1">Programas</dt>
<dd>
<p>O significado de um programa de computador é inequívoco e literal e pode ser entendido inteiramente pela análise dos símbolos e da estrutura.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>As linguagens formais são mais densas que as linguagens naturais, por isso leva mais tempo para lê-las. Além disso, a estrutura é importante, portanto nem sempre é melhor ler de cima para baixo, da esquerda para a direita. Em vez disso, você aprenderá a analisar o programa em sua cabeça, identificando os símbolos e interpretando a estrutura. Finalmente, os detalhes são importantes. Pequenos erros de ortografia e pontuação, com os quais você pode se dar bem em idiomas naturais, podem fazer uma grande diferença na linguagem formal. </p>
</div>
</div>
<div class="sect2">
<h3 id="_depuração">Depuração</h3>
<div class="paragraph">
<p>Programadores cometem erros. Por motivos lúdicos, erros de programação são chamados de <em>bugs</em> e o processo de rastreá-lo é chamado de <em>deburação</em>.</p>
</div>
<div class="paragraph">
<p><em>N.T.: Depurar em inglês é Debug, e comumente vemos a utilização de Debug e suas conjunções abrasileiradas. Note que Debugar (verbo) está incluso no dicionário brasileiro, mas Debug, o substantivo correspondente, não está.</em></p>
</div>
<div class="paragraph">
<p>A programação e, especialmente, a depuração, às vezes traz emoções fortes. Se você está lutando com um bug difícil, pode sentir raiva, desânimo ou vergonha.</p>
</div>
<div class="paragraph">
<p>Há evidências de que as pessoas respondem naturalmente aos computadores como se fossem pessoas. Quando eles funcionam bem, pensamos neles como companheiros de equipe e, quando são obstinados ou rudes, respondemos a eles da mesma maneira que respondemos a pessoas rudes e obstinadas.<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</div>
<div class="paragraph">
<p>A preparação para essas reações pode ajudá-lo a lidar com elas. Uma abordagem é pensar no computador como um funcionário com certos pontos fortes, como velocidade e precisão, e pontos fracos particulares, como falta de empatia e incapacidade de entender o cenário geral.</p>
</div>
<div class="paragraph">
<p>Seu trabalho é ser um bom gerente: encontre maneiras de aproveitar os pontos fortes e atenuar os pontos fracos. E encontre maneiras de usar suas emoções para se envolver com o problema, sem deixar que suas reações interfiram na sua capacidade de trabalhar de maneira eficaz.</p>
</div>
<div class="paragraph">
<p>Aprender a depurar pode ser frustrante, mas é uma habilidade valiosa que é útil para muitas atividades além da programação. No final de cada capítulo, há uma seção, como esta, com minhas sugestões para depurar. Espero que eles ajudem!</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossário">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">resolução de problemas</dt>
<dd>
<p>É o  processo de formular o problema, encontrar uma solução e expressar-lo.</p>
</dd>
<dt class="hdlist1">programa</dt>
<dd>
<p>Um  é uma sequência de instruções que especifica um cálculo.</p>
</dd>
<dt class="hdlist1">REPL</dt>
<dd>
<p>Um  programa que repetidamente lê entradas, executa e exibe os resultados.</p>
</dd>
<dt class="hdlist1">prompt</dt>
<dd>
<p>Caratecteres exibido pelo REPL para indicar que está pronto para receber informações do usuário.</p>
</dd>
<dt class="hdlist1">declaração de impressão</dt>
<dd>
<p>Uma  instrução que faz com o que o Julia REPL exiba o valor na tela.</p>
</dd>
<dt class="hdlist1">operador</dt>
<dd>
<p>Um  símbolo que representa um simples cálculo como adição, multiplicação, ou uma concatenação de strings.</p>
</dd>
<dt class="hdlist1">valor</dt>
<dd>
<p>Uma ("valores" das unidades de dados mais básicas, como um número ou string, é o que um programa manipula.</p>
</dd>
<dt class="hdlist1">tipo</dt>
<dd>
<p>Uma  categoria de valores. Os tipos que vimos até agora são números inteiros (<code>Int64</code>), números de ponto flutuante (<code>Float64</code>) e seqüências de caracteres (<code>String</code>).</p>
</dd>
<dt class="hdlist1">inteiros</dt>
<dd>
<p>Um tipo de que representa todos os números.</p>
</dd>
<dt class="hdlist1">ponto-flutuante</dt>
<dd>
<p>Um  tipo que representa números com pontos decimais.</p>
</dd>
<dt class="hdlist1">string</dt>
<dd>
<p>Um  tipo que representa uma sequência de caracteres.</p>
</dd>
<dt class="hdlist1">linguagem natural</dt>
<dd>
<p>Qualquer  uma das linguagens que as pessoas falam que se envolvem naturalmente.</p>
</dd>
<dt class="hdlist1">linguagem formal</dt>
<dd>
<p>Qualquer  uma das linguagens que as pessoas foram desenvolvidas para propósitos específicos, como representar ideias matemáticas ou programas de computador. Todas  as linguagens de programação são formais.</p>
</dd>
<dt class="hdlist1">sintaxe</dt>
<dd>
<p>As  regras que governam a estrutura de um programa.</p>
</dd>
<dt class="hdlist1">símbolo</dt>
<dd>
<p>Um dos elementos mais básicos de uma estrutura de sintaxes de um programa, análogo a uma palavra numa linguagem natural.</p>
</dd>
<dt class="hdlist1">estrutura</dt>
<dd>
<p>A maneira que os símbolos são combinados.</p>
</dd>
<dt class="hdlist1">analisar</dt>
<dd>
<p>Para  examinar um programa e analisar uma estrutra de sintaxe.</p>
</dd>
<dt class="hdlist1">bug</dt>
<dd>
<p>Um  erro de um programa.</p>
</dd>
<dt class="hdlist1">depurar</dt>
<dd>
<p>O  processo de encontrar e corrigir bugs.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios">Exercícios</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>É uma boa ideia ler este livro na frente de um computador para que você possa experimentar os exemplos à medida que avança.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="ex01-1">Exercício 1-1</h5>
<div class="paragraph">
<p>Sempre que você estiver experimentando um novo recurso, tente cometer erros. Por exemplo, no programa "Olá, mundo!", o que acontece se você deixar de fora uma das aspas? E se você deixar de fora ambas? E se você soletrar <code>println</code> errado?</p>
</div>
<div class="paragraph">
<p>Esse tipo de experimento ajuda a lembrar o que você lê; também ajuda quando você está programando, porque você sabe o que significam as mensagens de erro. É melhor cometer erros agora e de propósito, e não mais tarde e acidentalmente.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Em um comando de impressão, o que acontece se você deixar de fora um dos parênteses ou ambos?</p>
</li>
<li>
<p>Se você estiver tentando imprimir uma sequência, o que acontece se você deixar de fora uma das aspas ou ambas?</p>
</li>
<li>
<p>Você pode usar um sinal de menos para fazer um número negativo como <code>-2</code>. O que acontece se você colocar um sinal de mais antes de um número? E a respeito de <code>2++2</code>?</p>
</li>
<li>
<p>Em notação matemática, zeros à esquerda estão corretos, como em <code>02</code>. O que acontece se você tentar isso em Julia?</p>
</li>
<li>
<p>O que acontece se você tem dois valores com nenhum operador entre eles?</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="ex01-2">Exercício 1-2</h5>
<div class="paragraph">
<p>Inicie o Julia REPL e use-o como uma calculadora.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Quantos segundos existem em 42 minutos e 42 segundos?</p>
</li>
<li>
<p>Quantas milhas existem em 10 quilômetros?</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Uma milha equivale a 1,61.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Se você corre uma corrida de 10 quilômetros em 37 minutos e 48 segundos, qual é o seu ritmo médio (tempo por milha em minutos e segundos)? Qual é a sua velocidade média em milhas por hora?</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap02">2. Variáveis, Expressões e Declarações</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Uma das caractereísticas mais poderosas de uma linguagem de programação é a sua habilidade de manipular <em>variáveis</em>. Uma variável é um nome que refere-se a um valor.</p>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="sect2">
<h3 id="_declarações_de_atribuição">Declarações de Atribuição</h3>
<div class="paragraph">
<p>Uma <em>declaração de atribuição</em> cria uma nova variável e da à ela um valor:</p>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; mensagem = "E agora para algo completamente diferente"
"E agora para algo completamente diferente"
julia&gt; n = 17
17
julia&gt; π_val = 3.141592653589793
3.141592653589793</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este exemplo faz três atribuições. A primeira atribui uma string à uma nova variável chamada <code>mensagem</code>; a segunda dá o inteiro <code>17</code> a <code>n</code>; a terceira atribui (aproximadamente) o valor de \(\pi\) a <code>π_val</code> (<strong><code>\pi TAB</code></strong>).</p>
</div>
<div class="paragraph">
<p>Um jeito comum de representar variáveis no papel é escrevendo o nome com uma flecha apontando para o seu valor. Este tipo de figura é denominado de <em>diagrama de estado</em> pois mostra em que estado cada variável encontra-se (imagine isso como sendo o estado de espirito da variável) <a href="#fig02-1">Diagrama de estado</a> mostra o resultado do exemplo anterior.</p>
</div>
<div class="paragraph">
<p></p>
</div>
<div id="fig02-1" class="imageblock">
<div class="content">
<img src="images/fig21.svg" alt="fig21">
</div>
<div class="title">Figura 1. Diagrama de estado</div>
</div>
</div>
<div class="sect2">
<h3 id="_nomes_de_variáveis">Nomes de variáveis</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Programadores geralmente escolhem nomes para suas variáveis que são significativos—eles documentam para o que a variável é usada.</p>
</div>
<div class="paragraph">
<p>Nomes de variáveis podem ser o quão longas você desejar. Eles podem conter quase todos os caracteres Unicode (veja <a href="#caracteres">[caracteres]</a>), mas não podem começar com um número. É permitido usar letras maiúsculas, mas é convencional utilizar somente letras minúsculas para nomes de variáveis.</p>
</div>
<div class="paragraph">
<p>caracteres Unicode podem ser inseridos através do autocompletar do tab de abreviações similares à LaTeX no REPL do Julia.
</p>
</div>
<div class="paragraph">
<p>O caractere sublinhado, <code>_</code>, pode aparecer em um nome. É comumente utilizado em nomes com multiplas palavras, como <code>seu_nome</code> ou <code>velocidade_de_uma_andorinha_sem_carga</code>.
</p>
</div>
<div class="paragraph">
<p>Se um nome inválido for dado a uma variável, recebemos um erro de sintaxe:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 76trombones = "grande desfile"
ERROR: syntax: "76" is not a valid function argument name
julia&gt; mais@ = 1000000
ERROR: syntax: extra token "@" after end of expression
julia&gt; struct = "Zimologia Teórica Avançado"
ERROR: syntax: unexpected "="</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>76trombones</code> é inválido pois começa com um número. <code>mais@</code> é inválido pois contem um caractere inválido, <code>@</code>. Mas o que há de errado com <code>struct</code>?</p>
</div>
<div class="paragraph">
<p>Acontece que <code>struct</code> é uma das palavras chave do Julia. O REPL usa palavras chaves para reconhecer a estrutura do programa, e elas não podem ser usadas como nomes de variáveis.
</p>
</div>
<div class="paragraph">
<p>O Julia possui as seguintes palavras chave:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>abstract type   baremodule   begin    break            catch
const           continue     do       else             elseif
end             export       false    finally          for
function        global       if       import           let
local           macro        module   mutable struct   primitive type
quote           return       true     using            struct
while</pre>
</div>
</div>
<div class="paragraph">
<p>Nós não precisamos memorizar esta lista. Na maior parte dos ambientes desenvolvidos, palavras chave são exibidas em diferentes cores; se nós tentarmos utilizar uma como um nome de variável, saberemos.</p>
</div>
</div>
<div class="sect2">
<h3 id="_expressões_e_declarações">Expressões e Declarações</h3>
<div class="paragraph">
<p>Uma <em>expressão</em> é uma combinação de valores, variáveis e operadores. Um valor por si só é considerado uma expressão, assim como uma variável, então as expressões a seguir são todas válidas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 42
42
julia&gt; n
17
julia&gt; n + 25
42</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quando nós digitamos uma expressão no prompt, o REPL a <em>avalia</em>, o que significa que ele acha o valor da expressão. Neste exemplo, <code>n</code> tem valor 17 e <code>n + 25</code> valor 42.
</p>
</div>
<div class="paragraph">
<p>Uma <em>declaração</em> é uma unidade de código que possui um efeito, como criar uma variável ou exibir um valor.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; n = 17
17
julia&gt; println(n)
17</code></pre>
</div>
</div>
<div class="paragraph">
<p>A primeira linha é uma declaração de atribuição que da valor a <code>n</code>. A segunda linha é uma declaração de impressão que exibe o valor de <code>n</code>.</p>
</div>
<div class="paragraph">
<p>Quando nós digitamos uma declaração, o REPL a <em>executa</em>, o que significa que ele faz o que a declaração diz.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_modo_script">Modo Script</h3>
<div class="paragraph">
<p>Até agora nós rodamos o Julia em <em>modo interativo</em>, o que significa que nós interagimos diretamente com o REPL. O modo interativo é uma boa maneira de começar, mas se nós estamos trabalhando com mais do que poucas linhas de código, ele pode ser inadequado.
</p>
</div>
<div class="paragraph">
<p>A alternativa é salvar o código em um arquivo chamado <em>script</em> e em seguida rodar o Julia em <em>modo script</em> para executar o script. Por convenção, scripts Julia possuem nomes que terminam com <em>.jl</em>.
</p>
</div>
<div class="paragraph">
<p>Se você sabe como criar e rodar um script no seu computador, você está pronto pra utilizar. No entanto eu recomendaria utilizar o Repl.it novamente. Abrir um arquivo de texto, escrever um script e salvá-lo com a extensão <em>.jl</em>. O script pode ser executado em um terminal com o comando <strong><code>julia nome_do_script.jl</code></strong>.
</p>
</div>
<div class="paragraph">
<p>Como o Julia nos fornece ambos os modos, podemos testar pequenos trechos de código no modo interativo antes de colocá-los num script. Mas há diferenças entre o modo interativo e o modo script que podem ser um pouco confusas.</p>
</div>
<div class="paragraph">
<p>Por exemplo,  se nós estamos usando o Julia como uma calculadora, podemos digitar</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; milhas = 26.2
26.2
julia&gt; milhas * 1.61
42.182</code></pre>
</div>
</div>
<div class="paragraph">
<p>A primeira linha atribui um valor à <code>milhas</code> e exibe o seu valor. A segunda linha é uma expressão, então o REPL avalia-a e exibe o resultado. Acontece que uma maratona é aproximadamente 42 quilômetros.</p>
</div>
<div class="paragraph">
<p>Mas se digitarmos o mesmo código num script e rodá-lo, não temos resultado algum. No modo script uma expressão, por si só, não possui nenhum efeito visível. Na verdade o Julia avalia a expressão, mas não exibe o valor a não ser que nós mandemos-o:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">milhas = 26.2
println(milhas * 1.61)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse comportamente pode ser um pouco confuso no início.</p>
</div>
<div class="paragraph">
<p>Um script geralmente contém uma sequência de declarações. Se existe mais de uma declaração, os resultados aparecem um de cada vez conforme as declarações são executadas.</p>
</div>
<div class="paragraph">
<p>Por exemplo, o script</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">println(1)
x = 2
println(x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>produz o resultado</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1
2</pre>
</div>
</div>
<div class="paragraph">
<p>A declaração de atribuição não produz nenhum resultado.</p>
</div>
<div class="sect4">
<h5 id="_exercício_2_1">Exercício 2-1</h5>
<div class="paragraph">
<p>Para verificar o seu entendimento, digite a seguinte sequência de declarações no REPL do Julia e veja o que eles fazem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">5
x = 5
x + 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora coloque o mesmo trecho em um script e rode-o. Qual é o resultado? Modifique o script transformando cada expressão em uma declaração de impressão, e em seguida rode-o novamente.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_precedência_de_operadores">Precedência de Operadores</h3>
<div class="paragraph">
<p>Quando uma expressão contém mais de um operador, a ordem de avaliação depende da <em>precedência de operador</em>. Para operadores matemáticos, Julia segue convenções matemáticas. O acrônimo <em>PEMDAS</em> é uma maneira útil de lembrar as regras:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>P</em>arênteses possuem a maior precedência e podem ser usados para forçar uma expressão a ser avaliada na ordem que nós desejarmos. Já que expressões em parênteses são avaliadas primeiro, <code>2*(3-1)</code> é 4, e <code>(1+1)^(5-2)</code> é 8. Nós também podemos utilizar parênteses para fazer com que uma expressão seja mais fácil de ler, como em <code>(minuto * 100) / 60</code>, mesmo que não altere o resultado.
</p>
</li>
<li>
<p><em>E</em>xponenciação possui a próxima precedência, então <code>1+2^3</code> é 9, e não 27, e <code>2*3^2</code> é 18, não 36.
</p>
</li>
<li>
<p><em>M</em>ultiplicação e <em>D</em>ivisão possuem maior precedência que <em>A</em>dição e <em>S</em>ubtração. Então <code>2*3-1</code> é 5, não 4, e <code>6+4/2</code> é 8, não 5.
</p>
</li>
<li>
<p>Operadores com a mesma precedência são avaliados da esquerda à direita (exceto exponenciação). Então na expressão <code>graus / 2 * π</code>, a divisão acontece primeiro e o resultado é multiplicado por <code>π</code>. Para dividir por \(2\pi\), podemos usar parênteses, escrevendo <code>graus / 2 / π</code> ou <code>graus / 2π</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Não nos esforçamos muito para lembrar a precedência dos operadores. Se nós não consigormos lembrar ao olhar para a expressão, utilizamos parênteses para fazer com que seja óbvio.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_operações_com_strings">Operações com Strings</h3>
<div class="paragraph">
<p>Em geral, não podemos executar operações matemáticas em strings, mesmo se as strings pareçam-se com números, então o que se segue abaixo é inválido.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">"2" - "1"    "ovos" / "fácil"    "terceiro" + "um encanto"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mas existem duas exceções, <code>*</code> e <code>^</code>.
</p>
</div>
<div class="paragraph">
<p>O operador <code>*</code> executa a <em>concatenação de strings</em>, o que signifca que ele junta as strings ligando-as de ponta-a-ponta. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; primeira_str = "tanga"
"tanga"
julia&gt; segunda_str = "mandápio"
"mandápio"
julia&gt; primeira_str * segunda_str
"tangamandápio"</code></pre>
</div>
</div>
<div class="paragraph">
<p>O operador <code>^</code> também funciona em strings; ele executa a repetição. Por exemplo, <code>"Spam"^3</code> é <code>"SpamSpamSpam"</code>. Se um dos valores é uma string, o outro deve ser um inteiro.
</p>
</div>
<div class="paragraph">
<p>Este uso de <code>*</code> e <code>^</code> faz sentido com analogia à multiplicação e exponenciação. Assim como <code>4^3</code> é equivalente a <code>4*4*4</code>, nós esperamos que <code>"Spam"^3</code> seja igual a <code>"Spam"*"Spam"*"Spam"</code>, e é.</p>
</div>
</div>
<div class="sect2">
<h3 id="_comentários">Comentários</h3>
<div class="paragraph">
<p>À medida que os programas ficam maiores e mais complicados, eles ficam mais dificéis de ler. Linguagens formais são densas, e é comum ser difícil olhar para um pedaço de código e descobrir o que está acontecendo, ou por quê.</p>
</div>
<div class="paragraph">
<p>Por esta razão, é uma boa ideia adicionar anotações em nossos programas para explicar em uma linguagem natural o que o programa esta fazendo. Estas anotações são chamadas de <em>comentários</em>, e eles começam com o símbolo <code>#</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia"># calcula a porcentagem da hora que já se passou
porcentagem = (minuto * 100) / 60</code></pre>
</div>
</div>
<div class="paragraph">
<p>Neste caso, o comentário aparece numa linha por si só. Nós também podemos colocar comentários no final da linha:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">porcentagem = (minuto * 100) / 60   # porcentagem de uma hora</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tudo a partir do <code>#</code> até o final da linha é ignorado e não causa efeito algum na execução do programa.</p>
</div>
<div class="paragraph">
<p>Comentários são bastante utéis quando eles documentam caractereísticas não óbvias do código. É razoável assumir que o leitor consegue descobrir <em>o que</em> o código faz; é mais útil explicar o <em>por quê</em>.</p>
</div>
<div class="paragraph">
<p>Esse comentário é redundante com o código e inútil:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">v = 5   # atribui 5 a v</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse comentário contém informação útil que não está no código:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">v = 5   # velocidade em metros/segundo.</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Atenção</div>
</td>
<td class="content">
<div class="paragraph">
<p>Bons nomes de variável podem reduzir a necessidade de comentários, mas nomes longos podem fazer com que expressões complexas sejam dificéis de ler, então há uma compensação.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_depuração_2">Depuração</h3>
<div class="paragraph">
<p>Três tipos de erros podem ocorrer em um programa: erros de sintaxe, erros de execução e erros de semântica. É útil distinguir entre eles a fim de localizá-los mais rapidamente.
</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Erro de sintaxe</dt>
<dd>
<p>“sintaxe” refere-se à estrutura de um programa e as regras sobre esta estrutura. Por exemplo, parênteses precisam vir em pares correspondentes, então <code>(1 + 2)</code> é válido, mas <code>8)</code> é um erro de sintaxe.</p>
<div class="paragraph">
<p>Se existe algum erro de sintaxe em algum lugar do nosso programa, o Julia exibirá uma mensagem de erro e encerrará, e nós não poderemos rodar o programa. Durante as primeiras semanas da sua carreira de programador, você deverá passar bastante tempo localizando erros de sintaxe. Conforme você vai ganhando experiência, você irá cometer menos erros e achá-los mais rapidamente.
</p>
</div>
</dd>
<dt class="hdlist1">Erro de execução</dt>
<dd>
<p>O segundo tipo de erro é o erro de execução, assim denominado pois o erro não aparece até que o programa finalmente esteja rodando. Estes erros também são chamados de <em>exceções</em> pois eles geralmente indicam que algo excepcional (e ruim) aconteceu.</p>
<div class="paragraph">
<p>Erros de execução são raros nos programas simples que você verá nos primeiros capítulos, então pode demorar um pouco até que você encontre um.
</p>
</div>
</dd>
<dt class="hdlist1">Erros de semântica</dt>
<dd>
<p>O terceiro tipo de erro é o de “semântica”, o que significa que ele é relacionado a significado. Se há um erro de semântica no seu programa, ele irá rodar sem gerar nenhuma mensagem de erro, mas não irá fazer a coisa certa. Ele irá fazer outra coisa. Mais especificamente, ele irá fazer o que nós mandamos-o fazer.</p>
<div class="paragraph">
<p>Identificar erros de semântica pode ser complicado, pois requer que nós trabalhemos em sentido contrário ao olhar o resultado do programa e tentar descobrir o que ele está fazendo.
</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_2">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">variável</dt>
<dd>
<p>Um nome que refere-se a um valor.
</p>
</dd>
<dt class="hdlist1">atribuição</dt>
<dd>
<p>Uma declaração que atribui um valor a uma variável.
</p>
</dd>
<dt class="hdlist1">diagrama de estado</dt>
<dd>
<p>Uma representação gráfica de um conjunto de variáveis e os valores que elas referem-se.
</p>
</dd>
<dt class="hdlist1">palavra-chave</dt>
<dd>
<p>Uma palavra reservada que é usada para analisar o programa; você não pode usar palavras-chave como <code>if</code>, <code>function</code>, e <code>while</code> como nomes de variáveis.
</p>
</dd>
<dt class="hdlist1">operando</dt>
<dd>
<p>Um dos valores no qual um operador opera sobre.
</p>
</dd>
<dt class="hdlist1">expressão</dt>
<dd>
<p>Uma combinação de variáveis, operadores, e valores que representam um único resultado.
</p>
</dd>
<dt class="hdlist1">avaliar</dt>
<dd>
<p>Simplificar uma expressão através da execução de operações a fim de produzir um único valor.
</p>
</dd>
<dt class="hdlist1">declaração</dt>
<dd>
<p>Uma seção de código que representa um comando ou ação. Até agora, as declarações que nós vimos são atribuições e declarações de impressão.
</p>
</dd>
<dt class="hdlist1">executar</dt>
<dd>
<p>Rodar uma declaração e fazer o que ela indica.
</p>
</dd>
<dt class="hdlist1">modo interativo</dt>
<dd>
<p>Um modo de usar o REPL do Julia digitando código no prompt.
</p>
</dd>
<dt class="hdlist1">modo script</dt>
<dd>
<p>Um modo de usar o Julia para ler código de um script e executá-lo.
</p>
</dd>
<dt class="hdlist1">script</dt>
<dd>
<p>Um programa guardado em um arquivo.
</p>
</dd>
<dt class="hdlist1">precedência de operador</dt>
<dd>
<p>Regras que governam a ordem na qual as expressões que envolvem múltiplos operadores matemáticos são avaliados.
</p>
</dd>
<dt class="hdlist1">concatenar</dt>
<dd>
<p>Juntar duas strings ponta-a-ponta.
</p>
</dd>
<dt class="hdlist1">comentário</dt>
<dd>
<p>Informação em um programa destinada a outros programadores (ou qualquer um lendo o código fonte) que não tem nenhum efeito na execução do programa.
</p>
</dd>
<dt class="hdlist1">erro de sintaxe</dt>
<dd>
<p>Um erro em um programa que faz com que seja impossível analisar (e consequentemente interpretar).
</p>
</dd>
<dt class="hdlist1">erro de execução ou exceção</dt>
<dd>
<p>Um erro que é detectado enquanto um programa está rodando.
</p>
</dd>
<dt class="hdlist1">semântica</dt>
<dd>
<p>O significado de um programa.
</p>
</dd>
<dt class="hdlist1">erro de semântica</dt>
<dd>
<p>Um erro em um programa que faz com que ele faça algo diferente do que o programador pretendia.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_2">Exercícios</h3>
<div class="sect4">
<h5 id="ex02-1">Exercício 2-2</h5>
<div class="paragraph">
<p>Repetindo o conselho do capítulo anterior, sempre que você aprende novas funcionalidades, você deve experimentá-las no modo interativo e cometer erros de propósito para ver o que acontece de errado.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Nós vimos que <code>n = 42</code> é válido. E <code>42 = n</code> ?</p>
</li>
<li>
<p>E que tal <code>x = y = 1</code>?</p>
</li>
<li>
<p>Em algumas linguagens toda declaração acaba com um ponto e vírgula, <code>;</code>. O que acontece se você colocar um ponto e vírgula no final de uma declaração no Julia?
</p>
</li>
<li>
<p>E se você quiser colocar um ponto no final de uma declaração ?</p>
</li>
<li>
<p>Em notação matemática, você pode multiplicar <code>x</code> e <code>y</code> assim: <code>x y</code>. O que acontece se você tentar isso em Julia? E 5x?</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="ex02-2">Exercício 2-3</h5>
<div class="paragraph">
<p>Pratique usando o REPL do Julia como uma calculadora:
</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>O volume de uma esfera com raio \(r\) é \(\frac{4}{3} \pi r^3\). Qual é o volume de uma esfera de raio 5?</p>
</li>
<li>
<p>Suponha que o preço de cobertura de um livro é R$ 24,95, mas as livrarias possuem desconto de 40%. A entrega custa R$ 3,00 para a primeira cópia e R$ 0,75 para cada cópia adicional. Qual é o preço total do atacado para 60 cópias?</p>
</li>
<li>
<p>Se eu saio de casa às 6:52 da manhã e corro uma milha em um ritmo tranquilo (8min15s por milha), em seguida 3 milhas em ritmo (7min12seg por milha) e 1 milha em um ritmo tranquilo novamente, a que horas eu chego em casa para o café da manhã?</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap03">3. Funções</h2>
<div class="sectionbody">
<div class="paragraph">
<p>No contexto da programação, uma <em>função</em> é uma sequência nomeada de comandos que executa uma tarefa. Ao definir uma função, você especifica o nome e a sequência de comandos. Mais tarde, você pode "chamar" a função pelo nome dado.
</p>
</div>
<div class="sect2">
<h3 id="_chamadas_de_funções">Chamadas de funções</h3>
<div class="paragraph">
<p>Nós já vimos um exemplo de chamada de função:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; println("Olá, Mundo!")
Olá, Mundo!</code></pre>
</div>
</div>
<div class="paragraph">
<p>O nome da função é <code>println</code>. A expressão entre parênteses é o <em>argumento</em> da função.
</p>
</div>
<div class="paragraph">
<p>É comum dizer que uma função "pega" um argumento e "retorna" um resultado que também é chamado de <em>valor de retorno</em>.
</p>
</div>
<div class="paragraph">
<p>Julia fornece funções que convertem valores de um tipo para outro. A função <code>parse</code> recebe uma string e a converte em qualquer tipo de número se puder, ou dá erro caso contrário:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; parse(Int64, "32")
32
julia&gt; parse(Float64, "3.14159")
3.14159
julia&gt; parse(Int64, "Olá")
ERROR: ArgumentError: invalid base 10 digit 'O' in "Olá"</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>trunc</code> pode converter valores de ponto flutuante em valores inteiros, mas não os arredonda; o comando trunca a parte fracionária:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; trunc(Int64, 3.99999)
3
julia&gt; trunc(Int64, -2.3)
-2</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>float</code> converte números inteiros em números de ponto flutuante:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; float(32)
32.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por último, <code>string</code> converte o seu argumento em uma string:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; string(32)
"32"
julia&gt; string(3.14159)
"3.14159"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_funções_matemáticas">Funções matemáticas</h3>
<div class="paragraph">
<p>Em Julia, a maioria das funções matemáticas tradicionais estão diretamente disponíveis:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">razão = potência_sinal / potência_ruído
decibéis = 10 * log10(razão)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este primeiro exemplo usa <code>log10</code> para calcular uma relação sinal-ruído em decibéis (assumindo que <code>potência_sinal</code> e <code>potência_ruído</code> estão definidos). <code>log</code>, que calcula logaritmos naturais, também é dado.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">radianos = 0.7
altura = sin(radianos)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este segundo exemplo calcula o seno de <code>radianos</code>. O nome da variável é uma dica de que <code>sin</code> e de que as outras funções trigonométricas (<code>cos</code>, <code>tan</code>, etc.) recebem argumentos em radianos. Para converter de graus em radianos, divida por 180 e multiplique pelo \(\pi\):
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; graus = 45
45
julia&gt; radianos = graus / 180 * π
0.7853981633974483
julia&gt; sin(radianos)
0.7071067811865475</code></pre>
</div>
</div>
<div class="paragraph">
<p>O valor da variável <code>π</code> é uma aproximação do ponto flutuante de \(\pi\), com precisão de aproximadamente de 16 dígitos.
</p>
</div>
<div class="paragraph">
<p>Se você conhece trigonometria, pode verificar o resultado anterior comparando-o com a raiz quadrada de dois dividido por dois:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; sqrt(2) / 2
0.7071067811865476</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_composição">Composição</h3>
<div class="paragraph">
<p>Até este momento, vimos os elementos de um programa—variáveis, expressões e comandos—isoladamente, sem detalhar em como combiná-las.
</p>
</div>
<div class="paragraph">
<p>Um dos recursos mais úteis das linguagens de programação é a sua capacidade de manipular pequenos blocos de montar e compô-los. Por exemplo, o argumento de uma função pode ser qualquer tipo de expressão, incluindo operadores aritméticos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">x = sin(graus / 360 * 2 * π)</code></pre>
</div>
</div>
<div class="paragraph">
<p>E até mesmo as chamadas de função:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">x = exp(log(x+1))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em quase todos os lugares onde você pode colocar um valor, pode-se colocar uma expressão arbitrária, com uma exceção: o lado esquerdo de uma atribuição tem que ser um nome de variável. Qualquer outra expressão do lado esquerdo resulta em um erro de sintaxe (veremos exceções a esta regra mais tarde).
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; minutos = horas * 60 # correto
120
julia&gt; horas * 60 = minutos # errado!
ERROR: syntax: "60" is not a valid function argument name</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_adicionando_novas_funções">Adicionando novas funções</h3>
<div class="paragraph">
<p>Embora tenhamos usado só as funções que vêm com Julia até agora, também é possível adicionar novas funções. A <em>definição da função</em> especifica o nome de uma nova função e a sequência de comandos que são executados quando a função é chamada. Aqui está um exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprimir_letras()
    println("O cravo brigou com a rosa")
    println("Debaixo de uma sacada.")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>function</code> é uma palavra-chave que indica a definição de função. O nome da função é <code>imprimir_letras</code>. As regras para nomes de funções são as mesmas dos nomes de variáveis: eles podem conter quase todos os caracteres Unicode (veja <a href="#caracteres">[caracteres]</a>), mas o primeiro caracter não pode ser um número. Você não pode usar uma palavra-chave como nome de uma função, e evite ter uma variável e uma função com o mesmo nome.
</p>
</div>
<div class="paragraph">
<p>Os parênteses vazios após o nome da função indicam que esta função não recebe nenhum argumento.
</p>
</div>
<div class="paragraph">
<p>A primeira linha da definição da função é o <em>cabeçalho</em>; o restante é chamado de <em>corpo</em>. Finaliza-se o corpo com a palavra-chave <code>end</code> e pode conter qualquer número de comandos. Para facilitar a leitura, o corpo da função deve estar indentado.
</p>
</div>
<div class="paragraph">
<p>As aspas devem ser "aspas retas" (""), geralmente localizadas abaixo do Esc no teclado. As "aspas encaracoladas" ou "aspas inglesas" (“”), como as que estão nesta frase, não são legais em Julia.
</p>
</div>
<div class="paragraph">
<p>Se você definir uma função no modo interativo, o REPL indentará para informar que a definição não está finalizada:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; function imprimir_letras()
       println("O cravo brigou com a rosa")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para terminar a função, deve-se inserir <code>end</code>.</p>
</div>
<div class="paragraph">
<p>A sintaxe para chamar a nova função é a mesma das funções internas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; imprimir_letras()
O cravo brigou com a rosa
Debaixo de uma sacada.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma vez definida uma função, você pode usá-la dentro de outra função. Por exemplo, para repetir o refrão anterior, poderíamos escrever uma função chamada <code>repetir_letras</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function repetir_letras()
    imprimir_letras()
    imprimir_letras()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>E depois é só chamar <code>repetir_letras</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; repetir_letras()
O cravo brigou com a rosa
Debaixo de uma sacada.
O cravo brigou com a rosa
Debaixo de uma sacada.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mas não é bem assim que a música é.</p>
</div>
</div>
<div class="sect2">
<h3 id="_definições_e_usos">Definições e usos</h3>
<div class="paragraph">
<p>Reunindo os pedaços de código da seção anterior, o programa completo fica assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprimir_letras()
    println("O cravo brigou com a rosa")
    println("Debaixo de uma sacada.")
end

function repetir_letras()
    imprimir_letras()
    imprimir_letras()
end

repetir_letras()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este programa contém duas definições de funções: <code>imprimir_letras</code> e <code>repetir_letras</code>. As definições de funções são executadas exatamente como outros comandos, e o resultado é a criação de objetos do tipo função. Os comandos dentro da função não são executados até que a função seja chamada, e a definição da função não gera saída.</p>
</div>
<div class="paragraph">
<p>Como você pode esperar, deve-se criar uma função antes de poder executá-la. Em outras palavras, a definição da função tem que ser executada antes de chamá-la.</p>
</div>
<div class="sect4">
<h5 id="_exercício_3_1">Exercício 3-1</h5>
<div class="paragraph">
<p>Mova a última linha deste programa para o topo, para que a chamada de função apareça antes das definições. Execute o programa e veja qual mensagem de erro você recebe.</p>
</div>
<div class="paragraph">
<p>Agora mova a chamada de função de volta para a parte inferior e mova a definição de <code>imprimir_letras</code> após a definição de <code>repetir_letras</code>. Ao executar este programa, o que acontece?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fluxo_de_execução">Fluxo de execução</h3>
<div class="paragraph">
<p>Para garantir a definição de uma função antes de sua primeira chamada, é necessário conhecer a ordem dos comandos executados, conhecido como <em>fluxo de execução</em>.
</p>
</div>
<div class="paragraph">
<p>A execução é feita sempre a partir do primeiro comando do programa. Os comandos são executados uma de cada vez, de cima para baixo.</p>
</div>
<div class="paragraph">
<p>As definições das funções não mudam o fluxo de execução do programa, mas lembre-se que os comandos dentro da função são executados somente quando a função é chamada.</p>
</div>
<div class="paragraph">
<p>Quando a função é chamada, é como um desvio no fluxo de execução. Em vez de ir para o comando seguinte, o fluxo salta para o corpo da função, executa os comandos lá e depois volta para continuar de onde parou.</p>
</div>
<div class="paragraph">
<p>Isso parece bastante simples, até você lembrar que uma função pode chamar outra. Enquanto estiver no meio de uma função, o programa pode ter a necessidade de executar os comandos em uma outra função. Logo, ao executar essa nova função, o programa pode precisar executar outra função!</p>
</div>
<div class="paragraph">
<p>Felizmente, Julia é bom em monitorar seus passos, portanto, toda vez que uma função é concluída, o programa retoma de onde parou na função que a chamou. Chegando ao final do programa, ele é encerrado.</p>
</div>
<div class="paragraph">
<p>Em resumo, quando você lê um programa, nem sempre deseja ler de cima para baixo. Às vezes, é mais lógico seguir o fluxo de execução.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parâmetros_e_argumentos">Parâmetros e argumentos</h3>
<div class="paragraph">
<p>Algumas das funções que vimos exigem argumentos. Por exemplo, quando você chama <code>sin</code>, um número é passado como argumento. Algumas funções usam mais de um argumento: <code>parse</code> necessita de dois, um tipo de número e uma string.
</p>
</div>
<div class="paragraph">
<p>Dentro da função, os argumentos são atribuídos a variáveis denominadas <em>parâmetros</em>. Aqui está uma definição para uma função que exige um argumento:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprimir2vezes(bruno)
    println(bruno)
    println(bruno)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta função atribui o argumento a um parâmetro denominado <code>bruno</code>. Quando a função é chamada, imprime-se o valor do parâmetro (qualquer que seja) duas vezes.</p>
</div>
<div class="paragraph">
<p>Esta função funciona com qualquer valor que possa ser impresso.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; imprimir2vezes("Spam")
Spam
Spam
julia&gt; imprimir2vezes(42)
42
42
julia&gt; imprimir2vezes(π)
π
π</code></pre>
</div>
</div>
<div class="paragraph">
<p>As mesmas regras de composição que se aplicam às funções embutidas também se aplicam às funções definidas pelo programador, portanto podemos usar qualquer tipo de expressão como argumento para <code>imprimir2vezes</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; imprimir2vezes("Spam "^4)
Spam Spam Spam Spam
Spam Spam Spam Spam
julia&gt; imprimir2vezes(cos(π))
-1.0
-1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>O argumento é avaliado antes da chamada da função, de modo que nos exemplos as expressões <code>"Spam "^4</code> e <code>cos(π)</code> são avaliadas apenas uma vez.
</p>
</div>
<div class="paragraph">
<p>Também pode-se usar uma variável como argumento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ana = "Uma andorinha sozinha não faz verão."
"Uma andorinha sozinha não faz verão."
julia&gt; imprimir2vezes(ana)
Uma andorinha sozinha não faz verão.
Uma andorinha sozinha não faz verão.</code></pre>
</div>
</div>
<div class="paragraph">
<p>O nome da variável que passamos como argumento (<code>ana</code>) não tem nada a ver com o nome do parâmetro (<code>bruno</code>). Para a função <code>imprimir2vezes</code>, todos os parâmetros são chamados <code>bruno</code>, independentemente do nome da variável que passamos como argumento (neste caso, <code>ana</code>)</p>
</div>
</div>
<div class="sect2">
<h3 id="_as_variáveis_e_os_parâmetros_são_locais">As variáveis e os parâmetros são locais</h3>
<div class="paragraph">
<p>Ao criar uma variável dentro de uma função, ela é <em>local</em>, isto é, ela existe apenas dentro da função. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function concat_imprimir2vezes(parte1, parte2)
    concat = parte1 * parte2
    imprimir2vezes(concat)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta função exige dois argumentos, concatena-os e imprime o resultado duas vezes. A seguir um exemplo que a usa:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; linha1 = "Lava outra, "
"Lava outra, "
julia&gt; linha2 = "lava uma."
"lava uma."
julia&gt; concat_imprimir2vezes(linha1, linha2)
Lava outra, lava uma.
Lava outra, lava uma.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Após o término de <code>concat_imprimir2vezes</code>, a variável <code>concat</code> é destruída. Se tentarmos imprimi-la, aparece uma exceção:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; println(concat)
ERROR: UndefVarError: concat not defined</code></pre>
</div>
</div>
<div class="paragraph">
<p>Os parâmetros também são locais. Por exemplo, fora do <code>imprimir2vezes</code>, não existe o <code>bruno</code>.
</p>
</div>
</div>
<div class="sect2">
<h3 id="stack_diagrams">Diagramas de Pilha</h3>
<div class="paragraph">
<p>Para verificar quais variáveis podem ser usadas e onde, às vezes é prático desenhar um <em>diagrama de pilha</em>. Da mesma maneira dos diagramas de estado, os diagramas de pilha mostram o valor de cada variável, e mostram também a função à qual cada variável pertence.
 </p>
</div>
<div class="paragraph">
<p>Cada função é indicada por um <em>quadro</em>, que é representado por uma caixa com o nome de uma função ao lado e os parâmetros e as variáveis da respectiva função dentro dele. O diagrama de pilha do exemplo anterior é ilustrado em <a href="#fig03-1">Stack diagram</a>.
</p>
</div>
<div id="fig03-1" class="imageblock">
<div class="content">
<img src="images/fig31.svg" alt="fig31">
</div>
<div class="title">Figura 2. Stack diagram</div>
</div>
<div class="paragraph">
<p>Os quadros são dispostos em uma pilha que mostra qual função é chamada por outra, e assim por diante. Neste exemplo, <code>imprimir2vezes</code> foi chamada por <code>concat_imprimir2vezes</code>, e <code>concat_imprimir2vezes</code> foi chamada por <code>Main</code>, que é um nome especial para o quadro superior. Criando uma variável fora de qualquer função, ela pertence a <code>Main</code>.</p>
</div>
<div class="paragraph">
<p>Cada parâmetro recebe o mesmo valor que o seu argumento correspondente. Logo, <code>parte1</code> tem o mesmo valor que <code>linha1</code>, da mesma forma que <code>parte2</code> tem o mesmo valor que <code>linha2</code>, e <code>bruno</code> tem o mesmo valor que <code>concat</code>.</p>
</div>
<div class="paragraph">
<p>Em um caso de erro durante uma chamada de função, Julia imprime o nome da função, o nome da função que a chamou, e o nome da função que chamou por ela, e assim por diante até chegar no <code>Main</code>.
</p>
</div>
<div class="paragraph">
<p>Por exemplo, se você tentar acessar <code>concat</code> de dentro de <code>imprimir2vezes</code>, você recebe um <code>UndefVarError</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ERROR: UndefVarError: concat not defined
Stacktrace:
 [1] imprimir2vezes at ./REPL[1]:2 [inlined]
 [2] concat_imprimir2vezes(::String, ::String) at ./REPL[2]:3</pre>
</div>
</div>
<div class="paragraph">
<p>Esta lista de funções é chamada de <em>rastreamento de pilha</em>, que informa em qual arquivo de programa ocorreu o erro, em qual linha e quais funções estavam sendo executadas no momento. Também indica a linha de código que causou o erro.
</p>
</div>
<div class="paragraph">
<p>A ordem das funções no rastreamento de pilha é a ordem inversa dos quadros no diagrama de pilha. A função atualmente em execução fica no topo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_funções_produtivas_e_funções_nulas">Funções produtivas e funções nulas</h3>
<div class="paragraph">
<p>Algumas das funções que usamos, como as funções matemáticas que retornam resultados; por falta de um nome melhor, chamaremos de <em>funções produtivas</em>. As outras funções, como <code>imprimir2vezes</code>, que executam uma ação sem retornar um valor chamaremos de <em>funções nulas</em>.
 </p>
</div>
<div class="paragraph">
<p>Quando você chama uma função produtiva, quase sempre deseja-se fazer algo com o resultado; por exemplo, atribuí-lo a uma variável ou usá-lo como parte de uma expressão:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">x = cos(radianos)
áurea = (sqrt(5) + 1) / 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ao chamar uma função no modo interativo, Julia exibe o seguinte resultado:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; sqrt(5)
2.23606797749979</code></pre>
</div>
</div>
<div class="paragraph">
<p>Porém em um script, se chamar uma função produtiva por si só, o valor de retorno será perdido para sempre!
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">sqrt(5)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2.23606797749979</pre>
</div>
</div>
<div class="paragraph">
<p>Este script calcula a raiz quadrada de 5, que não é armazenado e nem exibido o resultado, e assim, não é muito útil.</p>
</div>
<div class="paragraph">
<p>As funções nulas podem exibir algo na tela ou ter algum outro efeito, mas não retorna um valor. Se atribuir o resultado a uma variável, obterá um valor especial chamado <code>nothing</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; resultado = imprimir2vezes("Bing")
Bing
Bing
julia&gt; show(resultado)
nothing</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para imprimir o valor <code>nothing</code>, usa-se a função <code>show</code> que é similar a <code>print</code> mas que pode lidar com o valor <code>nothing</code>.
</p>
</div>
<div class="paragraph">
<p>O valor <code>nothing</code> não é o mesmo que a string <code>"nothing"</code>. Pois é um valor especial que tem seu próprio tipo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; typeof(nothing)
Nothing</code></pre>
</div>
</div>
<div class="paragraph">
<p>As funções que temos escrito até o momento são todas nulas. Começaremos a escrever funções produtivas em alguns capítulos.</p>
</div>
</div>
<div class="sect2">
<h3 id="_por_que_funções">Por que funções?</h3>
<div class="paragraph">
<p>Pode não estar claro o motivo de fragmentar um programa em funções, mas existem várias razões:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Criar uma nova função dá a oportunidade de nomear uma série de comandos, o que facilita a leitura e a depuração do programa.</p>
</li>
<li>
<p>As funções podem reduzir o tamanho de um programa, eliminando a repetição do código. Mais tarde, no caso de alguma mudança, é só modificá-lo em um único lugar.</p>
</li>
<li>
<p>Dividir um programa longo em funções permite a depuração das partes, uma de cada vez, e depois reuni-las em um programa mais funcional.</p>
</li>
<li>
<p>Funções bem programadas são frequentemente úteis para muitos outros programas. Depois de escrever e depurar um, você pode reutilizá-la.</p>
</li>
<li>
<p>Em Julia, as funções podem melhorar consideravelmente o desempenho.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_depuração_3">Depuração</h3>
<div class="paragraph">
<p>Uma das habilidades mais significativas que você vai adquirir é a depuração. Ainda que possa ser frustrante, a depuração é uma das partes da programação mais intelectualmente rica, desafiadora e interessante.
</p>
</div>
<div class="paragraph">
<p>De certa forma, a depuração é como um trabalho de detetive. Você é confrontado com pistas e precisa inferir os processos e eventos que levaram aos resultados encontrados.</p>
</div>
<div class="paragraph">
<p>A depuração também é como uma ciência experimental. Uma vez que você tem uma ideia do que está dando errado, modifique seu programa e tente novamente. Se a sua hipótese estiver correta, pode-se prever o resultado da modificação e aproximar-se de um programa funcional. Se a sua hipótese estava errada, inventa-se uma nova. Como Sherlock Holmes apontou,</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Tendo eliminado o impossível, aquilo que resta, ainda que improvável, deve ser a verdade.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; A. Conan Doyle<br>
<cite>O Signo dos Quatro</cite>
</div>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Algumas pessoas consideram que a programação e a depuração são a mesma coisa, já que a programação é o processo de depurar gradualmente um programa até que ele faça o que o programador deseja. A ideia é começar com um programa funcional e fazer pequenas mudanças, depurando-as à medida que avança.</p>
</div>
<div class="paragraph">
<p>Por exemplo, o Linux é um sistema operacional com milhões de linhas de código, mas começou como um programa simples que Linus Torvalds usava para examinar o chip Intel 80386. De acordo com Larry Greenfield, "um dos primeiros projetos de Linus era um programa que alternava entre imprimir "AAAA" e "BBBB". Este mais tarde evoluiu para Linux. ” (<em>The Linux Users' Guide</em> Versão Beta 1).
 </p>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_3">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">função</dt>
<dd>
<p>Uma sequência nomeada de comandos que realiza alguma operação útil. As funções podem ou não nessitar de argumentos e podem ou não gerar um resultado.
</p>
</dd>
<dt class="hdlist1">definição de função</dt>
<dd>
<p>Um comando que cria uma nova função, e com especificação do seu nome, seus parâmetros e dos comandos que ela contém.
</p>
</dd>
<dt class="hdlist1">objeto do tipo função</dt>
<dd>
<p>Um valor criado por uma definição de função. O nome da função é uma variável que se refere a um objeto do tipo função.
</p>
</dd>
<dt class="hdlist1">cabeçalho</dt>
<dd>
<p>A primeira linha de uma definição de função.
</p>
</dd>
<dt class="hdlist1">corpo</dt>
<dd>
<p>A sequência de comandos dentro de uma definição de função.
</p>
</dd>
<dt class="hdlist1">parâmetro</dt>
<dd>
<p>Um nome usado dentro de uma função para se referir ao valor passado como argumento.
</p>
</dd>
<dt class="hdlist1">chamada de função</dt>
<dd>
<p>Um comando que executa uma função. Consiste no nome da função seguido de uma lista de argumentos entre parênteses.
</p>
</dd>
<dt class="hdlist1">argumento</dt>
<dd>
<p>Um valor fornecido a uma função quando a função é chamada. E este valor é atribuído ao parâmetro correspondente na função.
</p>
</dd>
<dt class="hdlist1">variável local</dt>
<dd>
<p>Uma variável definida dentro de uma função. Uma variável local só pode ser utilizada dentro de sua função.
</p>
</dd>
<dt class="hdlist1">valor de retorno</dt>
<dd>
<p>O resultado de uma função. Se uma chamada de função é utilizada como uma expressão, o valor de retorno é o valor da expressão.
</p>
</dd>
<dt class="hdlist1">função produtiva</dt>
<dd>
<p>Uma função que retorna um valor.
</p>
</dd>
<dt class="hdlist1">função nula</dt>
<dd>
<p>Uma função que sempre retorna <code>nothing</code>.
</p>
</dd>
<dt class="hdlist1"><code>nothing</code></dt>
<dd>
<p>Um valor especial devolvido por funções nulas.
</p>
</dd>
<dt class="hdlist1">composição</dt>
<dd>
<p>Usar uma expressão como parte de uma expressão maior ou um comando como parte de um comando maior.
</p>
</dd>
<dt class="hdlist1">fluxo de execução</dt>
<dd>
<p>A ordem da execução dos comandos.
</p>
</dd>
<dt class="hdlist1">diagrama da pilha</dt>
<dd>
<p>Representação gráfica de uma pilha de funções, suas variáveis e os valores a que se referem.
</p>
</dd>
<dt class="hdlist1">quadro</dt>
<dd>
<p>Uma caixa em um diagrama de pilha que representa uma chamada de função, além de conter as variáveis e parâmetros locais da função.
</p>
</dd>
<dt class="hdlist1">rastreamento de pilha</dt>
<dd>
<p>Uma lista das funções que estão sendo executadas, mostrada quando ocorre uma exceção.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_3">Exercícios</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Esses exercícios devem ser realizados usando apenas os comandos e outros recursos aprendidos até o momento.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="ex03-1">Exercício 3-2</h5>
<div class="paragraph">
<p>Escreva uma função denominada <code>alinhar_a_direita</code> que recebe uma string denominada <code>s</code> como parâmetro e imprime a string com espaços suficientes à esquerda de modo que a última letra da string esteja na coluna 70 da exibição.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; alinhar_a_direita("trapalhões")
ERROR: UndefVarError: alinhar_a_direita not defined</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Use concatenação e repetição de string. Além disso, Julia fornece uma função interna chamada <code>length</code> que retorna o comprimento de uma string, portanto o valor de <code>length("trapalhões")</code> é 10.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ex03-2">Exercício 3-3</h5>
<div class="paragraph">
<p>Um objeto do tipo função é um valor que você pode associar a uma variável ou passar como argumento. Por exemplo, <code>fazer2vezes</code> é uma função que pega um objeto do tipo função como argumento e o chama duas vezes:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fazer2vezes(f)
    f()
    f()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Veja um exemplo que usa <code>fazer2vezes</code> para chamar a função <code>imprimir_spam</code> duas vezes.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprimir_spam()
    println("spam")
end

fazer2vezes(imprimir_spam)</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Copie este exemplo em um script e teste-o.</p>
</li>
<li>
<p>Modifique <code>fazer2vezes</code> para que ele receba dois argumentos, um objeto do tipo função e um valor, e chame a função duas vezes, passando o valor como argumento.</p>
</li>
<li>
<p>Copie a definição de <code>imprimir2vezes</code> apresentada no início deste capítulo para o seu script.</p>
</li>
<li>
<p>Use a versão modificada de <code>fazer2vezes</code> para chamar <code>imprimir2vezes</code> duas vezes, e passando <code>"spam"</code> como argumento.</p>
</li>
<li>
<p>Defina uma nova função chamada <code>fazer4vezes</code> que recebe um objeto do tipo função e um valor e chama a função quatro vezes, passando o valor como parâmetro. Esta função deve ter apenas dois comandos no corpo dessa função, e não quatro.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="ex03-3">Exercício 3-4</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escreva uma função <code>imprimir_grade</code> que desenha uma grade da seguinte maneira:
</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; imprimir_grade()
+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +</code></pre>
</div>
</div>
</li>
<li>
<p>Escreva uma função que desenhe uma grade semelhante, com quatro linhas e quatro colunas.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Crédito: este exercício é baseado em um exercício de Oualline, <em>Practical C Programming</em>, Terceira Edição, O´Reilly Media, 1997.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Para mostrar mais de um valor em uma linha, você pode imprimir uma sequência de valores separados por vírgula:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">println("+", "-")</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função <code>print</code> não avança para a linha seguinte:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">print("+ ")
println("-")</code></pre>
</div>
</div>
<div class="paragraph">
<p>A saída desses comandos é <code>"+ -"</code> na mesma linha. A saída do próximo comando é a impressão que começaria na seguinte linha.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap04">4. Estudo de Caso: Design de Interface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo apresenta um estudo de caso que demonstra o processo de design de funções que trabalham juntas.</p>
</div>
<div class="paragraph">
<p>Ele introduz o turtle graphics, um jeito de criar desenhos por meio de um programa. O pacote turtle graphics não está incluso na biblioteca padrão do Julia, portanto o módulo JuliaIntroBR tem que ser adicionado na sua configuração do Julia.</p>
</div>
<div class="sect2">
<h3 id="_turtles">Turtles</h3>
<div class="paragraph">
<p>Um <em>módulo</em> é um arquivo que contém uma coleção de funções relacionadas. O Julia fornece alguns módulos na sua biblioteca padrão. Mais funcionalidades podem ser adicionadas a partir de uma crescente coleção de <em>pacotes</em> (<a href="https://juliaobserver.com" class="bare">https://juliaobserver.com</a>).
</p>
</div>
<div class="paragraph">
<p>Pacotes podem ser instalados no REPL através do modo Pkg usando a tecla <code>]</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">(v1.0) pkg&gt; add https://github.com/JuliaIntro/JuliaIntroBR.jl</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isso pode demorar um pouco.</p>
</div>
<div class="paragraph">
<p>Antes de podermos usar as funções de um módulo, temos que importá-lo usando a declaração <code>using</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; using JuliaIntroBR

julia&gt; 🐢 = Turtle()
Luxor.Turtle(0.0, 0.0, true, 0.0, (0.0, 0.0, 0.0))</code></pre>
</div>
</div>
<div class="paragraph">
<p>O módulo <code>JuliaIntroBR</code> possui uma função chamada <code>Turtle</code> que cria um objeto <code>Luxor.Turtle</code>, que atribuímos a uma variável chamada <code>🐢</code> (<strong><code>\:turtle: TAB</code></strong>).
</p>
</div>
<div class="paragraph">
<p>Logo após criarmos a tartaruga, podemos chamar uma função que a move ao redor de um desenho. Por exemplo, para mover a tartaruga para a frente:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">@svg begin
    forward(🐢, 100)
end</code></pre>
</div>
</div>
<div id="fig04-1" class="imageblock">
<div class="content">
<img src="images/fig41.svg" alt="fig41">
</div>
<div class="title">Figura 3. Movendo a tartaruga para a frente</div>
</div>
<div class="paragraph">
<p>A palavra-chave <code>@svg</code> executa uma macro que desenha uma imagem SVG. Macros são uma parte importante, mas avançada, do Julia.
</p>
</div>
<div class="paragraph">
<p>Os argumentos de <code>forward</code> são a tartaruga e a distância em pixels, portanto o tamanho real do movimento depende do seu monitor.</p>
</div>
<div class="paragraph">
<p>Outra função que nós podemos chamar com tartaruga como argumento é <code>turn</code>, para virar. O segundo argumento para <code>turn</code> é o ângulo em graus.
</p>
</div>
<div class="paragraph">
<p>Além disso, cada tartaruga está segurando uma caneta, que pode estar tanto para baixo ou para cima; se a caneta está para baixo, a tartaruga deixa uma trilha quando ela se move. <a href="#fig04-1">Movendo a tartaruga para a frente</a> mostra a trilha deixada pela tartaruga. As funções <code>penup</code> e <code>pendown</code> significam respectivamente “caneta para cima” e “caneta para baixo”.
</p>
</div>
<div class="paragraph">
<p>Para desenhar um ângulo reto, modifique a chamada de macro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">🐢 = Turtle()
@svg begin
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
end</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_exercício_4_1">Exercício 4-1</h5>
<div class="paragraph">
<p>Agora modifique a macro para desenhar um quadrado. Não avance até que você faça isso funcionar!</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="simple_repetition">Repetição Simples</h3>
<div class="paragraph">
<p>Existe uma chance de que você escreveu algo como:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">🐢 = Turtle()
@svg begin
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nós podemos fazer a mesma coisa de forma mais concisa com uma declaração <code>for</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; for i in 1:4
          println("Olá!")
       end
Olá!
Olá!
Olá!
Olá!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse é o uso mais simples da declaração <code>for</code>; nós veremos mais usos mais tarde. Mas isso deve ser o suficiente para que você possa reescrever o seu programa que desenha um quadrado. Não avançe até que você o faça.</p>
</div>
<div class="paragraph">
<p>Aqui está uma declaração <code>for</code> que desenha um quadrado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">🐢 = Turtle()
@svg begin
    for i in 1:4
        forward(🐢, 100)
        turn(🐢, -90)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A sintaxe de uma declaração <code>for</code> é similar a uma definição de função. Ela possui um cabeçalho e um corpo que termina com a palavra-chave <code>end</code>. O corpo pode conter qualquer número de declarações.
</p>
</div>
<div class="paragraph">
<p>Uma declaração <code>for</code> também é chamada de <em>laço</em>, pois o fluxo de execução percorre o corpo e em seguida retorna até o topo em um ciclo. Nesse caso, ela percorre o corpo quatro vezes.
</p>
</div>
<div class="paragraph">
<p>Essa versão é na verdade um pouco diferente do código que desenha um quadrado visto anteriormente, pois faz mais uma curva depois de desenhar o último lado do quadrado. A curva adicional leva mais tempo, mas simplifica o código se fizermos a mesma coisa toda vez que percorre o laço. Essa versão também faz a tartaruga retornar para sua posição inicial, de frente à direção inicial.</p>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_4">Exercícios</h3>
<div class="paragraph">
<p>A seguir estão uma série de exercícios utilizando turtles. Elas tem o propósito de serem divertidas, mas tem um objetivo também. Enquanto você trabalha com elas, pense sobre qual é o objetivo.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>A seção seguinte contém soluções para os exercícios, então não olhe até você terminar (ou pelo menos tentar).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="ex04-1">Exercício 4-2</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>quadrado</code> que recebe um parâmetro chamado <code>t</code>, que é uma tartaruga. Ela deve usar uma tartaruga para desenhar um quadrado.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex04-2">Exercício 4-3</h5>
<div class="paragraph">
<p>Escreva uma chamada de função que passa <code>t</code> como um argumento para <code>quadrado</code>, e em seguida execute o macro novamente.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex04-3">Exercício 4-4</h5>
<div class="paragraph">
<p>Adicione outro parâmetro, chamado <code>com</code>, em <code>quadrado</code>. Modifique o corpo para que o comprimento dos lados seja <code>com</code>, e então modifique a chamada de função para receber um segundo argumento. Execute a macro novamente. Teste com uma série de valores para <code>com</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex04-4">Exercício 4-5</h5>
<div class="paragraph">
<p>Faça uma cópia de <code>quadrado</code> e mude o nome para <code>polígono</code>. Adicione outro parâmetro chamado <code>n</code> e modifique o corpo para que ele desenhe um polígono com \(n\) lados.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Os ângulos externos de um polígono regular de \(n\) lados são iguais a \(\frac{360}{n}\) graus.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ex04-5">Exercício 4-6</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>círculo</code> que recebe uma tartaruga <code>t</code>, e raio <code>r</code> como parâmetros e que desenha uma figura próxima à um círculo através da chamada de <code>polígono</code> com um comprimento e número de lados apropriados. Teste sua função com uma série de valores de <code>r</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Descubra a circunferência do círculo e garanta que <code>com * n == circunferência</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ex04-6">Exercício 4-7</h5>
<div class="paragraph">
<p>Faça uma versão mais geral de <code>círculo</code> chamada <code>arco</code> que recebe um parâmetro adicional <code>ângulo</code>, que determina qual fração de círculo desenhar. <code>ângulo</code> é uma medida em graus, então quando <code>ângulo = 360</code>, <code>arco</code> deve desenhar um círculo completo.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_encapsulamento">Encapsulamento</h3>
<div class="paragraph">
<p>O primeiro exercício pede para que você coloque o seu código de desenhar quadrado em uma definição de função, e que em seguida você chame essa função utilizando tartaruga como parâmetro. Aqui está a solução:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function quadrado(t)
    for i in 1:4
        forward(t, 100)
        turn(t, -90)
    end
end
🐢 = Turtle()
@svg begin
    square(🐢)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>As declarações <code>forward</code> e <code>turn</code> são indentadas duas vezes para mostrar que elas estão dentro do laço <code>for</code>, que está dentro da definição da função.
</p>
</div>
<div class="paragraph">
<p>Dentro da função, <code>t</code> refere-se à mesma tartaruga <code>🐢</code>, então <code>turn(t, -90)</code> tem o mesmo efeito que <code>turn(🐢</code>, -90)<code>. Neste caso, por que não chamar o parâmetro +🐢</code> ? A ideia é que <code>t</code> pode ser qualquer tartaruga, não somente <code>🐢</code>, então você pode criar uma segunda tartaruga e passá-la como argumento para <code>quadrado</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">🐫 = Turtle()
@svg begin
    square(🐫)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Envolver um pedaço de código em uma função é chamado de <em>encapsulamento</em>. Um dos benefícios do encapsulamento é que ele anexa um nome ao código, que serve como uma forma de documentação. Outra vantagem é que se você está re-utilizando o código, é mais conciso chamar a função duas vezes do que copiar e colar o corpo!
</p>
</div>
</div>
<div class="sect2">
<h3 id="_generalização">Generalização</h3>
<div class="paragraph">
<p>O próximo passo é adicionar <code>com</code> aos parâmetros de <code>quadrado</code>. Aqui está a solução:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function quadrado(t, com)
    for i in 1:4
        forward(t, com)
        turn(t, -90)
    end
end
🐢 = Turtle()
@svg begin
    square(🐢, 100)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adicionar um parâmetro a uma função é chamado de <em>generalização</em> pois faz com que a função seja mais abrangente: na versão anterior, o quadrado sempre tem o mesmo tamanho; nesta versão ele pode ter qualquer tamanho.
</p>
</div>
<div class="paragraph">
<p>O próximo passo também é uma generalização. Ao invés de desenhar quadrados, <code>polígono</code> desenha polígonos regulares com qualquer número de lados. Aqui está a solução:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function polígono(t, n, com)
    ângulo = 360 / n
    for i in 1:n
        forward(t, com)
        turn(t, -ângulo)
    end
end
🐢 = Turtle()
@svg begin
    polígono(🐢, 7, 70)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este exemplo desenha um heptágono de lado medindo 70.</p>
</div>
</div>
<div class="sect2">
<h3 id="_design_de_interface">Design de Interface</h3>
<div class="paragraph">
<p>O próximo passo é escrever <code>círculo</code>, que recebe um raio <code>r</code> como parâmetro. Aqui está uma solução simples que usa <code>polígono</code> para desenhar um polígono de 50 lados:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function círculo(t, r)
    circunferência = 2 * π * r
    n = 50
    com = circunferência / n
    polígono(t, n, com)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A primeira linha computa a circunferência de um círculo com raio \(r\) usando a fórmula \(2 \pi r\). <code>n</code> é o número de segmentos de linha usados na nossa aproximação de um círculo, e <code>com</code> é o comprimento de cada segmento. Portanto, <code>polígono</code> desenha um polígono de 50 lados que se aproxima um círculo de raio <code>r</code>.</p>
</div>
<div class="paragraph">
<p>Uma limitação dessa solução é que <code>n</code> é uma constante, o que significa que para círculos bem grandes, os segmentos de linha são muito longos, e para círculos pequenos, nós gastamos tempo desenhando segmentos bem pequenos. Uma solução seria generalizar a função para que ela receba <code>n</code> como parâmetro. Isso daria ao usuário (qualquer um que chame círculo) mais controle, mas a interface seria menos limpa.</p>
</div>
<div class="paragraph">
<p>A <em>interface</em> de uma função é um resumo de como ela deve ser usada: quais são os parâmetros? O que a função faz? E qual o seu valor de retorno? Uma interface é “limpa” se permite àquele que chamou a função fazer tudo o que ele quer sem precisar lidar com detalhes desnecessários.
</p>
</div>
<div class="paragraph">
<p>Neste exemplo, <code>r</code> pertence à interface pois especifica o círculo a ser desenhado. <code>n</code> é menos apropriada pois diz respeito aos detalhes de como o círculo deve ser renderizado.</p>
</div>
<div class="paragraph">
<p>Em vez de bagunçar a interface, é melhor escolher um valor apropriado de <code>n</code> dependendo de <code>circunferência</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function círculo(t, r)
    circunferência = 2 * π * r
    n = trunc(circunferência / 3) + 3
    com = circunferência / n
    polígono(t, n, com)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora o número de segmentos é um inteiro ao redor de <code>circunferência/3</code>, então o comprimento de cada segmento é aproximadamente 3, que é pequeno o suficiente para que os círculos fiquem bons, mas grande o suficiente para ser eficaz, e aceitável para qualquer tamanho de círculo.</p>
</div>
<div class="paragraph">
<p>Adicionar 3 a <code>n</code> garante que o polígono tenha no mínimo 3 lados.</p>
</div>
</div>
<div class="sect2">
<h3 id="reestruturação">Reestruturação</h3>
<div class="paragraph">
<p>Quando escrevemos <code>círculo</code>, pudemos reutilizar <code>polígono</code> pois um polígono com vários lados é uma boa aproximação de um círculo. Mas <code>arco</code> não é igualmente cooperativo; não podemos usar <code>polígono</code> ou <code>círculo</code> para desenhar um arco.</p>
</div>
<div class="paragraph">
<p>Uma alternativa é começar com uma cópia de <code>polígono</code> e transformá-la em <code>arco</code>. O resultado pode parecer algo como:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function arco(t, r, ângulo)
    com_arco = 2 * π * r * ângulo / 360
    n = trunc(com_arco / 3) + 1
    tam_passo = com_arco / n
    ang_passo = ângulo / n
    for i in 1:n
        forward(t, tam_passo)
        turn(t, -ang_passo)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A segunda metade dessa função parece-se com <code>polígono</code>, mas nós não podemos reusar <code>polígono</code> sem mudar a interface. Nós poderíamos generalizar <code>polígono</code> para receber <code>ângulo</code> como terceiro argumento, mas então <code>polígono</code> não seria mais um nome apropriado! Ao invés disso, chamaremos a função mais geral <code>polilinha</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function polilinha(t, n, com, ângulo)
    for i in 1:n
        forward(t, com)
        turn(t, -ângulo)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora nós podemos reescrever <code>polígono</code> e <code>arco</code> para usar <code>polilinha</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function polígono(t, n, com)
    ângulo = 360 / n
    polilinha(t, n, com, ângulo)
end

function arco(t, r, ângulo)
    com_arco = 2 * π * r * ângulo / 360
    n = trunc(com_arco / 3) + 1
    com_passo = com_arco / n
    ang_passo = ângulo / n
    polilinha(t, n, com_passo, ang_passo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finalmente, nós podemos reescrever <code>círculo</code> para usar <code>arco</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function círculo(t, r)
    arco(t, r, 360)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este processo de reorganização de um programa para melhorar interface e facilitar o reuso de código é chamado de <em>refatoração</em>. Neste caso, nós percebemos que havia código similar em <code>arco</code> e <code>polígono</code>, então nós o “fatoramos” para dentro de <code>polilinha</code>.
</p>
</div>
<div class="paragraph">
<p>Se nós tivéssemos planejado com antecedência, nós poderíamos ter escrito <code>polilinha</code> primeiro e evitado a refatoração, mas você frequentemente não sabe o suficiente no começo de um projeto para planejar todas as interfaces. A partir do momento em que você começa a programar, você passa a entender o problema melhor. Às vezes refatoração é um sinal de que você aprendeu alguma coisa.</p>
</div>
</div>
<div class="sect2">
<h3 id="_um_plano_de_desenvolvimento">Um Plano de Desenvolvimento</h3>
<div class="paragraph">
<p>Um <em>plano de desenvolvimento</em> é um processo para escrever programas. O processo que usamos nesse estudo de caso é “encapsulamento e generalização”. Os passos desse processo são:
</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Comece escrevendo um pequeno programa sem definições de funções.</p>
</li>
<li>
<p>Uma vez que você fez com que o seu programa funcione, identifique um pedaço coerente dele, encapsule-o em uma função e dê a ela um nome.</p>
</li>
<li>
<p>Generalize a função adicionando parâmetros apropriados.</p>
</li>
<li>
<p>Repita os passos 1-3 até que você tenha um conjunto de programas funcionais. Copie e cole o código para evitar redigi-los (e redepurá-los).</p>
</li>
<li>
<p>Busque por oportunidades de melhora no programa através da refatoração. Por exemplo, se você tem um código similar em vários lugares, considere fatorá-lo em uma função geral apropriada.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Esse processo tem algumas desvantagens-nós veremos as alternativas mais tarde-mas pode ser útil se você não sabe previamente como dividir o programa em funções. Essa abordagem permite que você planeje conforme você vai projetando.</p>
</div>
</div>
<div class="sect2">
<h3 id="_docstring">Docstring</h3>
<div class="paragraph">
<p>Uma <em>docstring</em> é uma string que vem antes de uma função e descreve sua interface (“doc” refere-se a “documentação”). Aqui está um exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">"""
polilinha(t, n, com, ângulo)

Desenha n segmentos de linha dado o comprimento
e o ângulo (em graus) entre eles.  t é uma tartaruga.
"""
function polilinha(t, n, com, ângulo)
    for i in 1:n
        forward(t, com)
        turn(t, -ângulo)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A documentação pode ser acessada no REPL ou em um notebook digitando ? seguido pelo nome de uma função ou macro, e apertando <code>ENTER</code>;
</p>
</div>
<div class="listingblock">
<div class="content">
<pre>help?&gt; polilinha
search:

  polilinha(t, n, com, ângulo)

  Desenha n segmentos de linha dado o comprimento e o ângulo (em graus) entre eles. t é uma tartaruga.</pre>
</div>
</div>
<div class="paragraph">
<p>Docstrings são comumente strings envolvidas por três aspas, também conhecidas por strings multi-linha, pois as três aspas permitem que a string abranja mais de uma linha.</p>
</div>
<div class="paragraph">
<p>Uma docstring contém a informação essencial que alguém precisaria para usar essa função. Ela explica concisamente o que a função faz (sem entrar em detalhes de como ela faz). Ela explica que efeito cada parâmetro tem na execução da função e qual tipo cada parâmetro deve ser (se não é óbvio).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Escrever esse tipo de documentação é uma parte importante do design de interface. Uma interface bem projetada deve ser simples de explicar; se você encontra dificuldade em explicar uma de sua funções, talvez sua interface possa ser melhorada.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_depuração_4">Depuração</h3>
<div class="paragraph">
<p>Uma interface é como um contrato entre a função e quem a chama. Quem chama concorda em fornecer certos parâmetros e a função concorda em fazer um certo trabalho.
</p>
</div>
<div class="paragraph">
<p>Por exemplo, <code>polilinha</code> requer quatro argumentos: <code>t</code> tem que ser uma tartaruga; <code>n</code> tem que ser um inteiro; <code>com</code> deve ser um número positivo; e <code>ângulo</code> tem que ser um número, que assume-se ser uma medida em graus.</p>
</div>
<div class="paragraph">
<p>Esses requerimentos são chamados de <em>precondições</em> pois eles deveriam ser verdadeiros antes que a função execute. Inversamente, condições no final da função são chamadas de <em>pós-condições</em>. Pós-condições incluem o efeito desejado da função (como desenhar segmentos de linha) e qualquer efeito colateral (como mover a tartaruga ou fazer outra mudança).
</p>
</div>
<div class="paragraph">
<p>precondições são de responsabilidade de quem chama a função. Se quem chama viola uma precondição (propriamente documentada!) e a função não funciona adequadamente, o bug está em quem chamou, e não na função.</p>
</div>
<div class="paragraph">
<p>Se as precondições são satisfeitas e as pós-condições não, então o bug está na função. Se as suas pré- e pós-condições forem claras, elas podem ajudar na hora de depurar.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_4">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">módulo</dt>
<dd>
<p>Um arquivo que contém uma coleção de funções e outras definições relacionadas.
</p>
</dd>
<dt class="hdlist1">pacote</dt>
<dd>
<p>Uma biblioteca externa com funcionalidade adicional.
</p>
</dd>
<dt class="hdlist1">declaração using</dt>
<dd>
<p>Uma declaração que lê um arquivo módulo e cria um objeto módulo.
</p>
</dd>
<dt class="hdlist1">laço</dt>
<dd>
<p>Uma parte do programa que é executada repetidamente.
</p>
</dd>
<dt class="hdlist1">encapsulamento</dt>
<dd>
<p>O processo de transformar uma sequência de comandos em uma definição de função.
</p>
</dd>
<dt class="hdlist1">generalização</dt>
<dd>
<p>O processo de substituir algo desnecessariamente específico (como um número) por algo mais adequadamente irrestrito (como uma variável ou parâmetro).
</p>
</dd>
<dt class="hdlist1">interface</dt>
<dd>
<p>Uma descrição de como usar uma função, incluindo o nome, as descrições dos argumentos e o valor de retorno.
</p>
</dd>
<dt class="hdlist1">refatoração</dt>
<dd>
<p>O processo de modificar um programa funcional para melhorar a interface da função e outras qualidades do código.
</p>
</dd>
<dt class="hdlist1">plano de desenvolvimento</dt>
<dd>
<p>Um processo para escrever programas.
</p>
</dd>
<dt class="hdlist1">docstring</dt>
<dd>
<p>Uma string que aparece no topo de uma definição de função para documentar a interface da função.
</p>
</dd>
<dt class="hdlist1">precondição</dt>
<dd>
<p>Um requerimento que deve ser satisfeito por quem chama antes da função iniciar.
</p>
</dd>
<dt class="hdlist1">pós-condição</dt>
<dd>
<p>Um requerimento que deve ser satisfeito pela função antes de acabar.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_5">Exercícios</h3>
<div class="sect4">
<h5 id="ex04-7">Exercício 4-8</h5>
<div class="paragraph">
<p>Digite o código deste capítulo em um notebook.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Desenhe um diagrama de pilha que mostra o fluxo de execuções de <code>círculo(🐢, raio)</code>. Você pode contar no dedo ou adicionar declarações de impressão no código.</p>
</li>
<li>
<p>A versão de <code>arco</code> em <a href="#refatoração">[refatoração]</a> não é muito precisa dado que a aproximação linear do círculo está sempre fora do verdadeiro círculo. Como resultado, a tartaruga acaba alguns pixels depois do destino correto. Minha solução mostra uma maneira de reduzir o efeito desse erro. Leia o código e veja se faz sentido para você. Se você desenhar o diagrama, você poderá ver como ela funciona.
</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">"""
arco(t, r, ângulo)

Desenha um arco dado o raio e ângulo:

    t: tartaruga
    r: raio
    ângulo: ângulo feito pelo arco, em graus
"""
function arco(t, r, ângulo)
    com_arco = 2 * π * r * abs(ângulo) / 360
    n = trunc(com_arco / 4) + 3
    com_passo = com_arco / n
    ang_passo = ângulo / n

    # fazendo uma leve curva para a esquerda antes de iniciar
    # reduz o erro causado pela aproximação linear do arco
    turn(t, -ang_passo/2)
    polilinha(t, n, com_passo, ang_passo)
    turn(t, ang_passo/2)
end</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex04-8">Exercício 4-9</h5>
<div class="paragraph">
<p>Escreva um conjunto geral de funções apropriadas que podem desenhar flores como em <a href="#fig04-2">Flores de Tartaruga</a>.</p>
</div>
<div id="fig04-2" class="imageblock">
<div class="content">
<img src="images/fig42.svg" alt="fig42">
</div>
<div class="title">Figura 4. Flores de Tartaruga</div>
</div>
</div>
<div class="sect4">
<h5 id="ex04-9">Exercício 4-10</h5>
<div class="paragraph">
<p>Escreva um conjunto geral de funções apropriadas que podem desenhar formas como as de <a href="#fig04-3">Tortas de Tartaruga</a>.</p>
</div>
<div id="fig04-3" class="imageblock">
<div class="content">
<img src="images/fig43.svg" alt="fig43">
</div>
<div class="title">Figura 5. Tortas de Tartaruga</div>
</div>
</div>
<div class="sect4">
<h5 id="ex04-10">Exercício 4-11</h5>
<div class="paragraph">
<p>As letras do alfabeto podem ser construídas a partir de um número moderado de elementos básicos, como linhas verticais, horizontais e algumas curvas. Projete um alfabeto que pode ser desenhado com o menor número de elementos básicos e em seguida escreva funções que desenhem letras.</p>
</div>
<div class="paragraph">
<p>Você deve escrever uma função para cada letra, com nomes <code>desenha_a</code>, <code>desenha_b</code>, etc., e coloque suas funções em um arquivo chamado <em>letras.jl</em>.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex04-11">Exercício 4-12</h5>
<div class="paragraph">
<p>Leia sobre espirais em <a href="https://pt.wikipedia.org/wiki/Espiral" class="bare">https://pt.wikipedia.org/wiki/Espiral</a>; em seguida escreva um programa que desenha uma espiral de Arquimedes como em <a href="#fig04-4">Espiral de Arquimedes</a>.</p>
</div>
<div id="fig04-4" class="imageblock">
<div class="content">
<img src="images/fig44.svg" alt="fig44">
</div>
<div class="title">Figura 6. Espiral de Arquimedes</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap05">5. Condicionais e Recursão</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O principal tópico deste capítulo é o comando <code>if</code>, que executa diferentes códigos dependendo do estado do programa. Mas antes gostaríamos de introduzir dois novos operadores: divisão inteira e módulo.</p>
</div>
<div class="sect2">
<h3 id="_divisão_inteira_e_módulo">Divisão Inteira e Módulo</h3>
<div class="paragraph">
<p>O operador de <em>divisão inteira</em>, <code>÷</code> (<strong><code>\div TAB</code></strong>), divide dois números e arredonda pra baixo para um inteiro. Por exemplo, suponha que o tempo de duração de um filme seja de 105 minutos. Talvez você queira saber o quanto isso equivale em horas. A divisão convencional retorna um número em ponto-flutuante:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; minutos = 105
105
julia&gt; minutos / 60
1.75</code></pre>
</div>
</div>
<div class="paragraph">
<p>Porém, normalmente não escrevemos horas com pontos decimais. A divisão inteira retorna um número inteiro de horas, arredondando para baixo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; horas = minutos ÷ 60
1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para obter o resto, você pode subtrair uma hora em minutos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; resto = minutos - horas * 60
45</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma alternativa é usar o <em>operador módulo</em>, <code>%</code>, que divide dois números e retorna o resto.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; resto = minutos % 60
45</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>O operador módulo é mais útil do que parece. Por exemplo, você pode verificar se um número é divisível por outro—se <code>x % y</code> é zero, então <code>x</code> é divisível por <code>y</code>.</p>
</div>
<div class="paragraph">
<p>Além disso, você pode extrair o dígito ou dígitos mais à direita de um número. Por exemplo, <code>x % 10</code> gera o dígito mais à direita de um inteiro <code>x</code> (na base 10). Da mesma forma <code>x % 100</code> produz os dois últimos dígitos.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_expressões_booleanas">Expressões Booleanas</h3>
<div class="paragraph">
<p>Uma <em>expressão booleana</em> é uma expressão que é ou verdadeira ou falsa.  Os seguintes exemplos usam o operador <code>==</code>, que compara dois operandos e gera <code>true</code> se forem iguais e <code>false</code>--do inglês, verdadeiro e falso, respectivamente.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 5 == 5
true
julia&gt; 5 == 6
false</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>true</code> e <code>false</code> são valores especiais que pertencem ao tipo <code>Bool</code>; esses valores não são strings:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; typeof(true)
Bool
julia&gt; typeof(false)
Bool</code></pre>
</div>
</div>
<div class="paragraph">
<p>O operador <code>==</code> é um dos operadores de relação; os outros são:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">      x != y               # x não é igual a y
      x ≠ y                # (\ne TAB)
      x &gt; y                # x é maior que y
      x &lt; y                # x é menor que y
      x &gt;= y               # x é maior ou igual a y
      x ≥ y                # (\ge TAB)
      x &lt;= y               # x é menor ou igual a y
      x ≤ y                # (\le TAB)</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Atenção</div>
</td>
<td class="content">
<div class="paragraph">
<p>Embora essas operações provavelmente possam ser familiares à você, os símbolos em Julia são diferentes dos símbolos matemáticos. Um erro comum é usar um único sinal de igual (<code>=</code>) em vez de um duplo sinal de igual (<code>==</code>). Lembre-se de que <code>=</code> é um operador de atribuição e <code>==</code> é um operador relacional. Não existe <code>=&lt;</code> ou <code>=></code>.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_operadores_lógicos">Operadores Lógicos</h3>
<div class="paragraph">
<p>Existem três <em>operadores lógicos</em>: <code>&amp;&amp;</code> (e), <code>||</code> (ou) e <code>!</code> (não). A semântica (significado) destes operadores são similiares aos seus significados em Português. Por exemplo, <code>x &gt; 0 &amp;&amp; x &lt; 10</code> é verdadeiro se e somente se <code>x</code> é maior que 0 <em>e</em> menor que <code>10</code>.
</p>
</div>
<div class="paragraph">
<p><code>n % 2 == 0 || n % 3 == 0</code> é verdadeiro se <em>uma ou ambas</em> condições são verdadeiras, isto é, se o número é divisível por 2 <em>ou</em> por 3.</p>
</div>
<div class="paragraph">
<p>Tanto <code>&amp;&amp;</code> quanto <code>||</code> associam à direita, mas <code>&amp;&amp;</code> tem maior precedência que <code>||</code>.</p>
</div>
<div class="paragraph">
<p>Por fim, o operador <code>!</code> nega uma expressão booleana, então <code>!(x &gt; y)</code> é verdadeira se <code>x &gt; y</code> é falsa, isto é, se <code>x</code> é menor ou igual a <code>y</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_execução_condicional">Execução Condicional</h3>
<div class="paragraph">
<p>Para escrever programas úteis, quase sempre precisamos verificar as condições e alterar o comportamento de acordo com o programa. <em>Comandos condicionais</em> nos fornecem essa habilidade. A forma mais simples é o comando <em>if</em> (da conjunção se em Inglês).
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if x &gt; 0
    println("x é positivo")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A expressão booleana depois de <code>if</code> é chamada de <em>condição</em>. Se é verdadeira, então o comando indentado é executado. Se não, nada acontece.
</p>
</div>
<div class="paragraph">
<p>O comando <em>if</em> possui a mesma estrutura das definições de funções: Um cabeçalho seguido de um corpo terminado com a palavra-chave <em>end</em>. Comandos como esse são chamadas de <em>comandos compostos</em>.
</p>
</div>
<div class="paragraph">
<p>Não há limites para o número de comandos que podem aparecer no corpo. Ocasionalmente, é útil ter um corpo sem comandos (geralmente como detentor de um lugar para o código que você ainda não escreveu).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if x &lt; 0
    # LEMBRETE: precisa lidar com valores negativos!
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_execuções_alternativas">Execuções Alternativas</h3>
<div class="paragraph">
<p>Uma segunda maneira de usar o comando <em>if</em> é através da "execução alternativa", que oferece duas possibilidades e a condição determina qual delas deverá ser executada. A sintaxe é a seguinte:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if x % 2 == 0
    println("x é par")
else
    println("x é ímpar")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se o resto da divisão de <code>x</code> por 2 é 0, então sabemos que <code>x</code> é par, e o programa irá exibir a mensagem apropriada. Se a condição for falsa, o segundo conjunto de comandos será executado. Desde que a condição seja verdadeira ou falsa, exatamente uma das alternativas irá ser executada. Essas alternativas são chamadas de <em>ramos</em> (<em>branches</em> em inglês), porque são ramos de um fluxo de execução.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_condicionais_encadeadas">Condicionais Encadeadas</h3>
<div class="paragraph">
<p>Algumas vezes há mais do que duas possibilidades e precisamos de mais que dois ramos. Uma maneira de expressar um comando como esse é através de <em>condicionais encadeadas</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if x &lt; y
    println("x é menor que y")
elseif x &gt; y
    println("x é maior que y")
else
    println("x e y são iguais")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Novamente, exatamente um dos ramos será executado. Não há limites para o número de comandos <code>elseif</code>. Se existir uma cláusula <code>else</code>, essa deve estar no final, mas não precisa haver uma.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if escolha == "a"
    desenhe_a()
elseif escolha == "b"
    desenhe_b()
elseif escolha == "c"
    desenhe_c()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cada condição é checada em ordem. Se a primeira for falsa, a próxima é checada e assim por diante. Se uma delas é verdadeira, o ramo correspondente é executado e o comando é encerrado. Se mais de uma condição é verdadeira, apenas o primeiro ramo verdadeiro é executado.</p>
</div>
</div>
<div class="sect2">
<h3 id="_condicionais_aninhadas">Condicionais Aninhadas</h3>
<div class="paragraph">
<p>Uma condicional também pode ser aninhada com outra. O exemplo da seção anterior poderia ter sido escrito da seguinte maneira:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if x == y
    println("x e y são iguais")
else
    if x &lt; y
        println("x é menor que y")
    else
        println("x é maior que y")
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O condicional externo contém dois ramos. O primeiro ramo contém um comando simples. O segundo ramo contém outro condicional <code>if</code>, que possui dois ramos inseridos nele. Esses dois ramos são comandos simples, embora também possam ter sido declarações condicionais.</p>
</div>
<div class="paragraph">
<p>Embora a indentação não obrigatória das declarações torne a estrutura aparente, as <em>condicionais aninhadas</em> tornam-se difíceis de ler muito rapidamente. Uma boa ideia é evitá-las quando puder.
</p>
</div>
<div class="paragraph">
<p>Operadores lógicos geralmente produzem uma maneira de simplificar instruções condicionais aninhadas. Por exemplo, podemos reescrever o seguinte código usando uma única condicional:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if 0 &lt; x
    if x &lt; 10
        println("x é um número positivo de um dígito.")
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O comando <code>print</code> executa somente se for verdadeira nas duas condições, para que possamos obter o mesmo efeito com operador <code>&amp;&amp;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if 0 &lt; x &amp;&amp; x &lt; 10
    println("x é um número positivo de um dígito.")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para esse tipo de condição, o Julia fornece uma sintaxe mais concisa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if 0 &lt; x &lt; 10
    println("x é um número positivo de um dígito.")
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="recursion">Recursão</h3>
<div class="paragraph">
<p>É possível fazer com que uma função chame outra; também é possível uma função chamar a si mesma. Pode não parecer óbvio por que isso é uma coisa boa, mas acaba sendo uma das coisas mais mágicas que um programa pode fazer. Por exemplo, observe a seguinte função:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function contagem_regressiva(n)
    if n ≤ 0
        println("Feliz Ano Novo!")
    else
        print(n, " ")
        contagem_regressiva(n-1)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se <code>n</code> é 0 ou negativo, será exibido a frase <code>"Feliz Ano Novo!"</code>. Caso contrário, a função exibe <code>n</code> e chama uma função chamada <code>contagem_regressiva</code>—ela mesma— passando <code>n-1</code> como argumento.</p>
</div>
<div class="paragraph">
<p>O que acontece se chamarmos uma função como essa?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; contagem_regressiva(3)
3 2 1 Feliz Ano Novo!</code></pre>
</div>
</div>
<div class="paragraph">
<p>A execução de <code>contagem_regressiva</code> começa com <code>n = 3</code>, e como <code>n</code> é maior que 0, terá como saída o valor 3, e depois executa a si mesma&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;A execução de <code>contagem_regressiva</code> começa com <code>n = 2</code>, e como <code>n</code> é maior que 0, <br/>&#8193;&#8193;terá como saída o valor 2, e depois executa a si mesma &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;A execução de <code>contagem_regressiva</code> começa com <code>n = 1</code>, e como  <code>n</code> é maior que 0, <br/>&#8193;&#8193;&#8193;terá como saída o valor 1, e depois executa a si mesma &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;&#8193;A execução de <code>contagem_regressiva</code> começa com <code>n = 0</code>, e como <code>n</code> não é maior que <br/>&#8193;&#8193;&#8193;&#8193;0, terá como saída uma frase, <code>"Feliz Ano Novo!"</code> e depois retorna.</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;A contagem regressiva que obteve <code>n = 1</code> retorna.</p>
</div>
<div class="paragraph">
<p>&#8193;A contagem regressiva que obteve <code>n = 2</code> retorna.</p>
</div>
<div class="paragraph">
<p>A contagem regressiva que obteve <code>n = 3</code> retorna.</p>
</div>
<div class="paragraph">
<p>E então você retornará para <code>Main</code>.</p>
</div>
<div class="paragraph">
<p>Uma função que chama a si mesma é dita <em>recursiva</em>; o processo de execução desta função é chamada de <em>recursão</em>.
</p>
</div>
<div class="paragraph">
<p>Um outro exemplo é que podemos escrever uma função que imprime uma string \(n\) vezes.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprima_n(s, n)
    if n ≤ 0
        return
    end
    println(s)
    imprima_n(s, n-1)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se <code>n &lt;= 0</code> o comando <code>return</code> sai da função. O fluxo de execução retorna imediatamente para quem a chamou e as linhas restantes da função não são executadas.
</p>
</div>
<div class="paragraph">
<p>O restante da função é similar a <code>contagem_regressiva</code>: Ela exibirá <code>s</code> e chamará a si mesma para exibir <code>s</code> \(n-1\) várias vezes. Portanto, o número de linhas de saída é \(1 + (n - 1)\), o que soma \(n\).</p>
</div>
<div class="paragraph">
<p>Para exemplos simples como esse, provavelmente é mais fácil usar um laço <code>for</code>. Veremos exemplos em que são difíceis de escrever com um laço <code>for</code> e fáceis de escrever com recursão; portanto, é uma boa ideia começar cedo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_diagramas_de_pilhas_para_funções_recursivas">Diagramas de Pilhas para Funções Recursivas</h3>
<div class="paragraph">
<p>Em <a href="#stack_diagrams">Diagramas de Pilha</a>, usamos um diagrama de pilha para representar o estado de um programa durante uma chamada de função. O mesmo tipo de diagrama pode ajudar a interpretar uma função recursiva.
</p>
</div>
<div class="paragraph">
<p>Sempre que uma função é chamada, o Julia cria um quadro para conter os parâmetros e as variáveis locais da função. Para uma função recursiva, pode haver mais de um quadro na pilha ao mesmo tempo.
</p>
</div>
<div id="fig05-1" class="imageblock">
<div class="content">
<img src="images/fig51.svg" alt="fig51">
</div>
<div class="title">Figura 7. Diagrama de Pilha</div>
</div>
<div class="paragraph">
<p><a href="#fig05-1">Diagrama de Pilha</a> mostra um diagrama de pilha para <code>contagem_regressiva</code> chamada com <code>n = 3</code>.</p>
</div>
<div class="paragraph">
<p>Como sempre, o topo da pilha é o quadro para <code>Main</code>. Ele está vazio porque não criamos nenhuma variável em <code>Main</code> ou nem passamos algum argumento para ela.</p>
</div>
<div class="paragraph">
<p>Os quatro quadros de <code>contagem_regressiva</code> contém valores diferentes para o parâmetro <code>n</code>. A parte inferior da pilha, onde <code>n = 0</code>, é chamada de <em>caso base</em>. Ele não faz uma chamada recursiva, portanto não há mais quadros.
</p>
</div>
<div class="sect4">
<h5 id="_exercício_5_1">Exercício 5-1</h5>
<div class="paragraph">
<p>Como exercício, desenhe um diagrama de pilha para <code>imprima_n</code> chamado com <code>s = "Olá"</code> e <code>n = 2</code>. Depois, escreva uma função chamada <code>faça_n</code> que pega um objeto de função e um número, <code>n</code>, como argumento, e que chama a função dada \(n\) vezes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_recursão_infinita">Recursão Infinita</h3>
<div class="paragraph">
<p>Se uma recursão nunca atinge o caso base, ela continua fazendo chamadas recursivas para sempre e o programa nunca termina. Isso é conhecido como <em>recursão infinita</em>, e geralmente isso não é uma boa ideia. À seguir, um pequeno programa com uma recursão infinita:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function recursão()
    recursão()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Na maioria dos ambientes de programação, um programa com recursão infinita realmente não é executado para sempre. O Julia exibe uma mensagem de erro quando a profundidade máxima de recursão é atingida:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; recursão()
ERROR: StackOverflowError:
Stacktrace:
 [1] recursão() at ./REPL[1]:2 (repeats 80000 times)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse rastreamento de pilha é um pouco maior do que vimos no capítulo anterior. Quando o erro ocorre, existem 80000 quadros de <code>recursão</code> na pilha!
</p>
</div>
<div class="paragraph">
<p>Se você encontrar uma recursão infinita por acidente, revise a sua função para confirmar se há um caso base que não faz uma chamada recursiva. E se houver, verifique que você está garantindo o alcance do caso base.</p>
</div>
</div>
<div class="sect2">
<h3 id="_entradas_do_teclado">Entradas do Teclado</h3>
<div class="paragraph">
<p>Os programas que escrevemos até agora não aceitam nenhuma entrada do usuário. Eles apenas fazem a mesma coisa toda hora.</p>
</div>
<div class="paragraph">
<p>O Julia fornece uma função interna chamada <code>readline</code> que interrompe o programa e aguarda o usuário digitar algo. Quando o usuário pressiona <code>RETURN</code> ou <code>ENTER</code>, o programa é retomado e <code>readline</code> retorna o que o usuário digitou como uma sequência de caracteres.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; texto = readline()
O que você está esperando?
"O que você está esperando?"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Antes de receber informações do usuário, é uma boa ideia imprimir um prompt informando ao usuário o que digitar:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; print("Quem és tu? "); readline()
Quem és tu? Sou Hermanoteu da Pentescopéia, irmão da Micalatéia.
"Sou Hermanoteu da Pentescopéia, irmão da Micalatéia."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um ponto e vírgula <code>;</code> permite colocar múltiplos comandos na mesma linha. No REPL apenas o último comando retornará seu valor.
</p>
</div>
<div class="paragraph">
<p>Se você espera que o usuário digite um número inteiro, tente converter o valor de retorno para <code>Int64</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; println("Qual é a velocidade de voo de uma andorinha sem carga?"); velocidade = readline()
Qual é a velocidade de voo de uma andorinha sem carga?
42
"42"
julia&gt; parse(Int64, velocidade)
42</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mas se o usuário digitar algo diferente de uma sequência de dígitos, você receberá um erro:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; println("Qual é a velocidade de voo de uma andorinha sem carga?"); velocidade = readline()
Qual é a velocidade de voo de uma andorinha sem carga?
Como assim, uma andorinha africana ou européia?
"Como assim, uma andorinha africana ou européia?"
julia&gt; parse(Int64, velocidade)
ERROR: ArgumentError: invalid base 10 digit 'C' in "Como assim, uma andorinha africana ou européia?"
[...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Veremos como lidar com esse tipo de erro posteriormente.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_depuração_5">Depuração</h3>
<div class="paragraph">
<p>Quando um erro de sintaxe ou de tempo de execução ocorrer, a mensagem de erro contém muitas informações, mas ela pode ser avassaladora. As partes mais úteis são geralmente:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Que tipo de erro foi, e</p>
</li>
<li>
<p>Onde ocorreu.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Os erros de sintaxe geralmente são fáceis de encontrar, mas existem algumas ressalvas. Em geral, as mensagens de erro indicam onde o problema foi descoberto, mas o verdadeiro erro pode estar antes no código, às vezes em uma linha anterior.</p>
</div>
<div class="paragraph">
<p>O mesmo vale para erros de tempo de execução. Suponha que você esteja tentando calcular uma taxa de sinal/ruído em decibéis. A fórmula é</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{SNR_{\mathrm{db}} = 10 \log_{10} \frac{P_{\mathrm{sinal}}}{P_{\mathrm{ruido}}}\ .}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>No Julia você pode escrever desta forma:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">potência_do_sinal = 9
potência_do_ruido = 10
razão = potência_do_sinal ÷ potência_do_ruido
decibéis = 10 * log10(razão)
print(decibéis)</code></pre>
</div>
</div>
<div class="paragraph">
<p>E você obtém:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">-Inf</code></pre>
</div>
</div>
<div class="paragraph">
<p>Com certeza não era um resultado que você estava esperando.</p>
</div>
<div class="paragraph">
<p>Para encontrar o erro, pode ser útil imprimir o valor da razão, que acaba sendo 0. O problema está na linha 3, que usa a divisão de piso em vez da divisão do ponto flutuante.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Atenção</div>
</td>
<td class="content">
<div class="paragraph">
<p>Você deve ler atentamente as mensagens de erro, mas não presuma que tudo o que elas dizem está correto.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_5">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">divisão inteira</dt>
<dd>
<p>Um operador, denotado <code>÷</code>, que divide dois números e arredonda para baixo (em direção ao infinito negativo) para um número inteiro.
</p>
</dd>
<dt class="hdlist1">operador módulo</dt>
<dd>
<p>Um operador, indicado com um sinal de porcentagem (%), que trabalha com números inteiros e retorna o restante quando um número é dividido por outro.
</p>
</dd>
<dt class="hdlist1">expressão booleana</dt>
<dd>
<p>Uma expressão cujo os valores são ou <code>true</code> ou <code>false</code>.
</p>
</dd>
<dt class="hdlist1">operador relacional</dt>
<dd>
<p>Um dos operadores que compara operandos: <code>==</code>, <code>≠</code> (<code>!=</code>), <code>&gt;</code>, <code>&lt;</code>, <code>≥</code> (<code>&gt;=</code>), e <code>≤</code> (<code>&lt;=</code>).
</p>
</dd>
<dt class="hdlist1">operador lógico</dt>
<dd>
<p>Um dos operadores que combina expressões booleanas: <code>&amp;&amp;</code> (e), <code>||</code> (ou), e <code>!</code> (não).
</p>
</dd>
<dt class="hdlist1">comando condicional</dt>
<dd>
<p>Um comando que controla o fluxo de execução dependendo de alguma condição.
</p>
</dd>
<dt class="hdlist1">condição</dt>
<dd>
<p>A expressão boleana em um comando condicional que determina qual ramo executará.
</p>
</dd>
<dt class="hdlist1">comando composto</dt>
<dd>
<p>Um comando que consiste em um cabeçalho e um corpo. O corpo é terminado com a palavra-chave <code>end</code>.
</p>
</dd>
<dt class="hdlist1">ramos</dt>
<dd>
<p>Uma das sequências alternativas de comandos em um comando condicional.
</p>
</dd>
<dt class="hdlist1">comando encadeado</dt>
<dd>
<p>Um comando condicional com uma série de ramos alternativos.
</p>
</dd>
<dt class="hdlist1">condicional aninhada</dt>
<dd>
<p>Um comando condicional que aparece em um dos ramos de outro comando condicional.
</p>
</dd>
<dt class="hdlist1">comando de retorno</dt>
<dd>
<p>Um comando que faz com que uma função pare de executar imediatamente e retorne para quem a chamou.
</p>
</dd>
<dt class="hdlist1">recursão</dt>
<dd>
<p>O processo de chamar a função que está sendo executada.
</p>
</dd>
<dt class="hdlist1">caso base</dt>
<dd>
<p>Uma ramo condicional de uma função recursiva que não faz um chamado recursiva.
</p>
</dd>
<dt class="hdlist1">recursão infinita</dt>
<dd>
<p>Uma recursão que não tem um caso base ou que nunca atinge ela. Eventualmente, uma recursão infinita causa um erro de tempo de execução.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_6">Exercícios</h3>
<div class="sect4">
<h5 id="ex05-1">Exercício 5-2</h5>
<div class="paragraph">
<p>A função <code>time</code> retorna o Horário do Meridiano de Greenwich em segundos desde "a época", que é um horário arbitrário usado como ponto de referência. Nos sistemas UNIX, a época é 1 de janeiro de 1970.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; time()
1.595552598838898e9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Escreva um script que leia a hora atual e a converta para uma hora do dia em horas, minutos e segundos, mais o número de dias desde a época.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex05-2">Exercício 5-3</h5>
<div class="paragraph">
<p>O Último Teorema de Fermat diz que não existem inteiros positivos \(a\), \(b\), e \(c\) tais que
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{a^n + b^n = c^n}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>para qualquer valor de \(n\) maior que 2.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escreva uma função chamada <code>fermat</code> que coleta quatro parâmetros — <code>a</code>, <code>b</code>, <code>c</code> e <code>n</code> — e verifica se o Teorema de Fermat é valido. Se <code>n</code> é maior que 2 e <code>a^n + b^n == c^n</code> o programa deve imprimir, "Oloco, Fermat estava errado!" caso contrário o programa deve imprimir, "Não, isso não funciona."
</p>
</li>
<li>
<p>Escreva uma função que solicite ao usuário que insira valores para <code>a</code>, <code>b</code>, <code>c</code> e <code>n</code>, converta-os em números inteiros e use <code>fermat</code> para verificar se eles violam o teorema de Fermat.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="ex05-3">Exercise 5-4</h5>
<div class="paragraph">
<p>Se você receber três gravetos, poderá ou não ser capaz de organizá-los em um triângulo. Por exemplo, se um dos gravetos tiver 12 centímetros de comprimento e os outros dois um centímetro, você não conseguirá formar um triângulo. Para três comprimentos dados, há um teste simples para verificar se é possível formar um triângulo:</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Se qualquer um dos três comprimentos for maior que a soma dos outros dois, não será possível formar um triângulo. Caso contrário, você pode. (Se a soma de dois comprimentos for igual ao terceiro, eles formarão o que é chamado de triângulo "degenerado".)</p>
</div>
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escreva uma função chamada <code>é_triângulo</code> que aceite três números inteiros como argumentos e imprima “Sim” ou “Não”, dependendo da possibilidade de formar ou não um triângulo a partir de gravetos com os comprimentos especificados.
</p>
</li>
<li>
<p>Escreva uma função que solicite ao usuário a inserção de três comprimentos de gravetos, os converta em números inteiros e use <code>é_triângulo</code> para verificar se os gravetos com os comprimentos especificados podem formar um triângulo.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="ex05-4">Exercício 5-5</h5>
<div class="paragraph">
<p>Qual é a saída do seguinte programa? Desenhe um diagrama de pilha que mostre o estado do programa quando ele imprimir o resultado.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function recursão(n, s)
    if n == 0
        println(s)
    else
        recursão(n-1, n+s)
    end
end

recursão(3, 0)</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>O que aconteceria se você chamasse essa função assim: <code>recursão(-1, 0)</code>?</p>
</li>
<li>
<p>Escreva uma docstring que explique tudo o que alguém precisaria saber para usar esta função (e nada mais).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Os exercícios a seguir usam o módulo <code>JuliaIntroBR</code>, descrito no <a href="#chap04">Estudo de Caso: Design de Interface</a>:</p>
</div>
</div>
<div class="sect4">
<h5 id="ex05-5">Exercício 5-6</h5>
<div class="paragraph">
<p>Leia a função a seguir e veja se você consegue descobrir o que ela faz (veja os exemplos em <a href="#chap04">Estudo de Caso: Design de Interface</a>). Em seguida, execute-a e veja se você acertou.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function desenhe(t, comprimento, n)
    if n == 0
        return
    end
    ângulo = 50
    forward(t, comprimento*n)
    turn(t, -ângulo)
    draw(t, comprimento, n-1)
    turn(t, 2*angle)
    draw(t, comprimento, n-1)
    turn(t, -ângulo)
    forward(t, -comprimento*n)
end</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex05-6">Exercício 5-7</h5>
<div id="fig05-2" class="imageblock">
<div class="content">
<img src="images/fig52.svg" alt="fig52">
</div>
<div class="title">Figura 8. Curva de Koch</div>
</div>
<div class="paragraph">
<p>A curva de Koch é um fractal que parece com o da <a href="#fig05-2">Curva de Koch</a>. Para desenhar uma curva de Koch com comprimento \(x\), tudo que você precisa fazer é:
</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Desenhar uma curva de Koch com comprimento \(\frac{x}{3}\).</p>
</li>
<li>
<p>Girar 60° para esquerda</p>
</li>
<li>
<p>Desenhar uma curva de Koch com comprimento \(\frac{x}{3}\).</p>
</li>
<li>
<p>Girar 120° para direita.</p>
</li>
<li>
<p>Desenhar uma curva de Koch com comprimento \(\frac{x}{3}\).</p>
</li>
<li>
<p>Girar 60° para esquerda.</p>
</li>
<li>
<p>Desenhar uma curva de Koch com comprimento \(\frac{x}{3}\).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A exceção é se \(x\) for menor que 3: neste caso, você só desenha uma linha reta de comprimento \(x\).</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escreva uma função chamada <code>koch</code> que receba um turtle e um comprimento como parâmetros e que use o turtle para desenhar uma curva de Koch com o comprimento especificado.
</p>
</li>
<li>
<p>Escreva uma função chamada + floco_de_neve + que desenhe três curvas de Koch para fazer o contorno de um floco de neve.
</p>
</li>
<li>
<p>A curva de Koch pode ser generalizada de várias maneiras. Veja <a href="https://en.wikipedia.org/wiki/Koch_snowflake" class="bare">https://en.wikipedia.org/wiki/Koch_snowflake</a> para exemplos e implemente o seu favorito.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap06">6. Funções Produtivas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Muitas das funções de Julia que usamos, como as funções matemáticas, produzem valores de retorno. Contudo, as funções que escrevemos são todas nulas: têm um efeito, como imprimir um valor ou mover uma tartaruga, mas retornam <code>nothing</code>. Neste capítulo você aprenderá a elaborar funções produtivas.
</p>
</div>
<div class="sect2">
<h3 id="_valores_de_retorno">Valores de Retorno</h3>
<div class="paragraph">
<p>A chamada de uma função gera um valor de retorno, que geralmente atribuímos a uma variável ou utilizamos como parte de uma expressão.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">e = exp(1.0)
altura = raio * sin(radianos)</code></pre>
</div>
</div>
<div class="paragraph">
<p>As funções escritas até o momento são nulas, o que significa que elas não têm valor de retorno; mais precisamente, seu valor de retorno é <code>nothing</code>. Neste capítulo, (finalmente) vamos escrever funções produtivas. O primeiro exemplo é a função <code>área</code>, que retorna a área de um círculo dado um raio:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function área(raio)
    a = π * raio^2
    return a
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Já vimos o comando <code>return</code> anteriormente, mas em uma função produtiva o comando <code>return</code> inclui uma expressão. Este comando significa: "Retorne imediatamente a partir desta função e leve a expressão seguinte como um valor de retorno". Como essa expressão pode ser arbitrariamente complicada, então poderíamos ter escrito uma função mais sucinta:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function área(raio)
    π * raio^2
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O valor retornado por uma função é o valor do último comando executado, que, por padrão, é a última expressão no corpo da definição da função.</p>
</div>
<div class="paragraph">
<p>Além disso, <em>variáveis temporárias</em> como <code>a</code> e as instruções explícitas <code>return</code> podem contribuir para a depuração.
</p>
</div>
<div class="paragraph">
<p>Às vezes, é prático ter diversos comandos <code>return</code>, uma em cada ramo de uma condicional:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function valorAbsoluto(x)
    if x &lt; 0
        return -x
    else
        return x
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>E já que estas instruções de retorno estão em alternativas exclusivas, somente uma é executada.
</p>
</div>
<div class="paragraph">
<p>Assim que um comando <code>return</code> é executado, a função termina sem executar qualquer comando posterior. O código que aparece após um comando <code>return</code>, ou qualquer outro lugar que o fluxo de execução jamais possa alcançar, é chamado de <em>código morto</em>.
</p>
</div>
<div class="paragraph">
<p>Em uma função produtiva, recomendamos garantir que todos os caminhos possíveis através do programa chegue em um comando de retorno. Por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function valorAbsoluto(x)
    if x &lt; 0
        return -x
    end
    if x &gt; 0
        return x
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Essa função está incorreta porque se <code>x</code> for 0, nenhuma das condições é verdadeira, e a função termina sem chegar a um comando <code>return</code>. Quando o fluxo de execução chega ao final de uma função, o valor de retorno é <code>nothing</code>, que não é o valor absoluto de 0.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; show(valorAbsoluto(0))
nothing</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Julia tem uma função interna chamada <code>abs</code> que calcula valores absolutos.
</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_exercício_6_1">Exercício 6-1</h5>
<div class="paragraph">
<p>Escreva uma função <code>comparar</code> que recebe dois valores, <code>x</code> e <code>y</code>, e retorna <code>1</code> se <code>x &gt; y</code>, <code>0</code> se <code>x == y</code> e <code>-1</code> se <code>x &lt; y</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="incremental_development">Desenvolvimento Incremental</h3>
<div class="paragraph">
<p>À medida que se escreve funções maiores, talvez aconteça de você passar mais tempo depurando.
</p>
</div>
<div class="paragraph">
<p>Ao lidar com programas cada vez mais complexos, tente um processo chamado <em>desenvolvimento incremental</em>, que adiciona e testa apenas uma pequena quantidade de código por vez, evitando assim longas sessões de depuração.
</p>
</div>
<div class="paragraph">
<p>Para exemplificar esse processo, suponha que você queira determinar a distância entre dois pontos, dada pelas coordenadas \(\left(x_1, y_1\right)\) e \(\left(x_2, y_2\right)\). Pelo teorema de Pitágoras, a distância é:
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>O primeiro passo é avaliar como deve ser uma função de distância em Julia. Em outras palavras, quais são as entradas (os parâmetros) e qual é a saída (o valor de retorno)?</p>
</div>
<div class="paragraph">
<p>Neste exemplo, as entradas são dois pontos, que pode ser representado por quatro números. Já o valor de retorno é a distância representada por um valor de ponto flutuante.</p>
</div>
<div class="paragraph">
<p>Com isso, pode-se esboçar a função:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function distância(x₁, y₁, x₂, y₂)
    0.0
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviamente que essa versão não determina as distâncias pois ela sempre retorna zero. Mas é sintaticamente correta, e roda, o que significa que você pode testá-la antes de complicá-la. Os números dos subscritos estão disponíveis na codificação de caracteres Unicode (<strong><code>\_1 TAB</code></strong>, <strong><code>\_2 TAB</code></strong>, etc.).
</p>
</div>
<div class="paragraph">
<p>Para testar a nova função, chame-a com argumentos exemplificados a seguir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">distância(1, 2, 4, 6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Escolhemos estes valores para que a distância horizontal seja 3 e a vertical seja 4; logo, o resultado é 5 porque é a hipotenusa de um triângulo retângulo 3-4-5. Quando testar uma função, o aconselhável é já saber a resposta correta.</p>
</div>
<div class="paragraph">
<p>Nesse ponto, como já confirmamos que a função está sintaticamente correta, então podemos começar a adicionar código ao corpo. Um passo subsequente razoável é encontrar as diferenças \(x_2 - x_1\) e \(y_2 - y_1\). A próxima versão da função armazena esses valores em variáveis temporárias que são mostradas com a macro <code>@show</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function distância(x₁, y₁, x₂, y₂)
    dx = x₂ - x₁
    dy = y₂ - y₁
    @show dx dy
    0.0
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se a função estiver funcionando, ela deve exibir <code>dx = 3</code> e <code>dy = 4</code>. Nesse caso, sabemos que a função está obtendo os argumentos certos e executando os primeiros cálculos corretamente. Caso contrário, há apenas poucas linhas para analisar.</p>
</div>
<div class="paragraph">
<p>Em seguida, somamos os quadrados de <code>dx</code> e de <code>dy</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function distância(x₁, y₁, x₂, y₂)
    dx = x₂ - x₁
    dy = y₂ - y₁
    d² = dx^2 + dy^2
    @show d²
    0.0
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Você executaria o programa mais uma vez nesse estágio e verificaria a saída (que deveria ser 25). Números sobrescritos também estão disponíveis (<strong><code>\^2 TAB</code></strong>). Por fim, usa-se <code>sqrt</code> para calcular e retornar o resultado final:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function distância(x₁, y₁, x₂, y₂)
    dx = x₂ - x₁
    dy = y₂ - y₁
    d² = dx^2 + dy^2
    sqrt(d²)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se a função rodar corretamente, pronto. Caso contrário, convém mostrar o valor de <code>sqrt(d²)</code> antes do comando <code>return</code>.</p>
</div>
<div class="paragraph">
<p>A versão final da função não exibe nada quando é executada, retornando apenas um valor. As instruções de impressão que escrevemos são úteis para a depuração, mas depois que a função estiver funcionando, devemos removê-las. Um código como esse é chamado <em>andaime</em> porque é útil para criar o programa, embora não faça parte do produto final.
</p>
</div>
<div class="paragraph">
<p>Ao iniciar, você deve adicionar apenas uma ou duas linhas de código por vez. À medida que você adquire mais experiência, pode se escrever e depurar pedaços maiores. De qualquer forma, o desenvolvimento incremental pode economizar muito tempo de depuração.</p>
</div>
<div class="paragraph">
<p>Os principais aspectos do processo são:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Comece com um programa funcional e faça pequenas alterações incrementais. A qualquer momento, se houver um erro, você deverá ter uma boa ideia de onde ele está.</p>
</li>
<li>
<p>Use variáveis para armazenar valores intermediários de modo que você possa visualizá-los e conferi-los.</p>
</li>
<li>
<p>Uma vez que o programa esteja funcionando, você pode querer retirar algumas das instruções andaimes ou consolidar múltiplos comandos em expressões compostas, desde que não dificulte a leitura do programa.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_exercício_6_2">Exercício 6-2</h5>
<div class="paragraph">
<p>Use o desenvolvimento incremental para escrever uma função chamada <code>hipotenusa</code> que retorna o comprimento da hipotenusa de um triângulo retângulo, a partir dos comprimentos dos outros dois catetos como argumentos. Registre cada estágio do processo de desenvolvimento à medida que avança.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_composição_2">Composição</h3>
<div class="paragraph">
<p>Como já esperado, você pode chamar uma função de dentro da outra. Para exemplificar isso, escreveremos uma função que calcula a área do círculo a partir de dois pontos, o centro do círculo e um ponto no perímetro.
</p>
</div>
<div class="paragraph">
<p>Suponha que o ponto central é indicado pelas variáveis <code>xc</code> e <code>yc</code>, e o ponto de perímetro é indicado por <code>xp</code> e <code>yp</code>. O primeiro passo é encontrar o raio do círculo, dado pela distância entre estes dois pontos. Note que acabamos de escrever a função distância:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">raio = distância(xc, yc, xp, yp)</code></pre>
</div>
</div>
<div class="paragraph">
<p>O próximo passo é calcular a área de um círculo a partir desse raio, e por isso também escrevemos essa função:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">resultado = área(raio)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Encapsulando esses passos em uma função, temos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function área_círculo(xc, yc, xp, yp)
    raio = distância(xc, yc, xp, yp)
    resultado = área(raio)
    return resultado
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>As variáveis temporárias <code>raio</code> e <code>resultado</code> são úteis para o desenvolvimento e a depuração, mas depois que o programa estiver funcionando, podemos torná-lo mais conciso fazendo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function área_círculo(xc, yc, xp, yp)
    área(distância(xc, yc, xp, yp))
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boolean_functions">Funções Booleanas</h3>
<div class="paragraph">
<p>As funções podem retornar valores booleanos, o que muitas vezes é conveniente para ocultar testes complicados dentro de funções. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function é_divisível(x, y)
    if x % y == 0
        return true
    else
        return false
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Frequentemente se atribui nomes de funções booleanas que soam como perguntas de sim/não; neste caso, <code>é_divisível</code> retorna <code>true</code> ou <code>false</code> para saber se <code>x</code> é divisível por <code>y</code>.</p>
</div>
<div class="paragraph">
<p>Eis um exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; é_divisível(6, 4)
false
julia&gt; é_divisível(6, 3)
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>O resultado do operador <code>==</code> é um valor booleano, logo podemos escrever a função de forma mais sucinta por meio de um comando direto:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function é_divisível(x, y)
    x % y == 0
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Funções booleanas são constantemente utilizadas em estruturas condicionais:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if é_divisível(x, y)
    println("x é divisível por y")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Talvez seja tentador escrever algo como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if é_divisível(x, y) == true
    println("x é divisível por y")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>No entanto, a comparação adicional com <code>true</code> é desnecessária.</p>
</div>
<div class="sect4">
<h5 id="_exercício_6_3">Exercício 6-3</h5>
<div class="paragraph">
<p>Escreva uma função <code>está_entre(x, y, z)</code> que retorna <code>true</code> se <code>x ≤ y ≤ z</code> ou <code>false</code> caso contrário.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mais_recursividade">Mais Recursividade</h3>
<div class="paragraph">
<p>Mostramos apenas uma pequena fração de Julia, mas você pode estar interessado em saber que essa fração é uma linguagem de programação <em>completa</em>, significando que qualquer coisa que possa ser calculada pode ser expressa nessa linguagem. Qualquer programa já escrito pode ser reescrito usando apenas os recursos da linguagem que você aprendeu até o momento (na verdade, você precisaria de alguns comandos para controlar dispositivos como mouse, discos, etc., mas isso é tudo).
</p>
</div>
<div class="paragraph">
<p>Essa afirmação é um exercício não trivial provado pela primeira vez por Alan Turing, um dos primeiros cientistas da computação (alguns argumentariam que ele era matemático, mas muitos dos primeiros cientistas da computação começaram como matemáticos). Por isso, esta prova é conhecida como a Tese de Turing. Para uma discussão mais completa (e precisa) da Tese de Turing, recomendo o livro <em>Introdução à teoria da computação</em> de Michael Sipser.
</p>
</div>
<div class="paragraph">
<p>Para ter uma noção do que você pode fazer com as ferramentas que sabe até agora, avaliaremos algumas funções matemáticas definidas recursivamente. Uma definição recursiva é semelhante a uma definição circular, no sentido de que a definição contém uma chamada de si própria. Uma definição totalmente circular não é muito vantajosa:
</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">vorpal</dt>
<dd>
<p>Um adjetivo usado para descrever algo que é vorpal.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Ver essa definição no dicionário pode ser irritante. Por outro lado, se consultar a definição da função fatorial, denotada com o símbolo \(!\), poderá obter algo assim:
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{n! =
\begin{cases}
  1&amp; \textrm{se}\  n = 0 \\
  n (n-1)!&amp; \textrm{se}\  n &gt; 0
\end{cases}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Essa definição diz que o fatorial de 0 é 1, e o fatorial de qualquer outro valor \(n\) é \(n\) multiplicado pelo fatorial de \(n-1\).</p>
</div>
<div class="paragraph">
<p>Então \(3!\) é 3 vezes \(2!\), que é 2 vezes \(1!\), que é 1 vezes \(0!\). Colocando tudo junto, \(3!\) é igual a 3 vezes 2 vezes 1 vezes 1, que dá 6.</p>
</div>
<div class="paragraph">
<p>Se puder escrever uma definição recursiva de algo, pode-se escrever um programa em Julia para testá-la. A primeira etapa é decidir quais devem ser os parâmetros. E nesse caso, é evidente que o fatorial recebe um número inteiro:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fatorial(n) end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se o argumento for <code>0</code>, basta retornar <code>1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fatorial(n)
    if n == 0
        return 1
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Caso contrário, e esta é a parte interessante, temos que fazer uma chamada recursiva para encontrar o fatorial de <code>n-1</code> para depois multiplicá-lo por <code>n</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fatorial(n)
    if n == 0
        return 1
    else
        recursão = fatorial(n-1)
        resultado = n * recursão
        return resultado
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O fluxo de execução deste programa é similar ao fluxo de <code>contagem regressiva</code> em <a href="#recursion">Recursão</a>. Chamando <code>fatorial</code> do valor <code>3</code>:
</p>
</div>
<div class="openblock small">
<div class="content">
<div class="paragraph">
<p>Como <code>3</code> não é <code>0</code>, seguimos para o segundo ramo e calculamos o fatorial de <code>n-1</code> &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;Como <code>2</code> não é <code>0</code>, seguimos para o segundo ramo e calculamos o fatorial de <code>n-1</code> &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;Como <code>1</code> não é <code>0</code>, seguimos para o segundo ramo e calculamos o fatorial de <code>n-1</code> &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;&#8193;Como <code>0</code> é igual a <code>0</code>, seguimos para o primeiro ramo e temos o resultado <code>1</code> sem efetuar <br/>&#8193;&#8193;&#8193;&#8193;mais chamadas recursivas.</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;O valor de retorno (= <code>1</code>) é multiplicado por <code>n</code> (que é <code>1</code>), e o <code>resultado</code> é devolvido.</p>
</div>
<div class="paragraph">
<p>&#8193;O valor de retorno (= <code>1</code>), é multiplicado por <code>n</code> (que é <code>2</code>), e o <code>resultado</code> é devolvido.</p>
</div>
<div class="paragraph">
<p>O valor de retorno (= <code>2</code>) é multiplicado por <code>n</code> (que é <code>3</code>), e o resultado (= <code>6</code>), torna-se o valor de retorno da chamada da função que iniciou todo esse processo.</p>
</div>
</div>
</div>
<div id="fig06-1" class="imageblock">
<div class="content">
<img src="images/fig61.svg" alt="fig61">
</div>
<div class="title">Figura 9. Diagrama de Pilha</div>
</div>
<div class="paragraph">
<p><a href="#fig06-1">Diagrama de Pilha</a> mostra como fica o diagrama de pilha para esta sequência de chamadas de função.
</p>
</div>
<div class="paragraph">
<p>Os valores de retorno são exibidos quando devolvidos de volta para cima da pilha. Em cada quadro, o valor de retorno é o valor de <code>resultado</code>, dado pelo produto de <code>n</code> com <code>recursão</code>.</p>
</div>
<div class="paragraph">
<p>No último quadro, as variáveis locais <code>recursão</code> e <code>resultado</code> não existem porque o ramo que as cria não é executado.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Em Julia, a função <code>factorial</code> calcula o fatorial de um número inteiro.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_salto_de_fé">Salto de Fé</h3>
<div class="paragraph">
<p>Ler programas seguindo o fluxo de execução pode se tornar rapidamente exaustivo. Uma alternativa que eu chamo de "salto de fé" faz a leitura conforme o fluxo de execução e quando se chega a uma chamada de função, <em>assume</em>-se que a função funciona corretamente e devolve o resultado correto.
</p>
</div>
<div class="paragraph">
<p>Na verdade, você já está praticando este salto de fé no uso de funções embutidas. Quando você chama <code>cos</code> ou <code>exp</code>, você não investiga os corpos dessas funções. Você apenas assume que funcionam já que as pessoas que escreveram as funções embutidas eram bons programadores.</p>
</div>
<div class="paragraph">
<p>A mesma prática ocorre quando você chama uma de suas próprias funções. Por exemplo, em <a href="#boolean_functions">Funções Booleanas</a>, escrevemos a função <code>é_divisível</code> que determina se um número é divisível por outro. Depois de nos convencermos de que essa função está correta ao examinar seu código e testar, podemos usá-la sem olhar para o corpo novamente.</p>
</div>
<div class="paragraph">
<p>O mesmo se aplica aos programas recursivos. Ao chegar na chamada recursiva, em vez de acompanhar o fluxo de execução, deve-se assumir que a chamada recursiva funciona (retorna o resultado correto) e depois se perguntar: “Supondo que possa encontrar o fatorial do \(n-1\), posso calcular o fatorial do \(n\)?” Sim, multiplicando por \(n\).</p>
</div>
<div class="paragraph">
<p>É claro que é um pouco estranho assumir que a função funciona corretamente quando ainda não se terminou de escrevê-la, mas é por isso que se chama salto de fé!</p>
</div>
</div>
<div class="sect2">
<h3 id="one_more_example">Mais Um Exemplo</h3>
<div class="paragraph">
<p>Após fatorial, o exemplo mais familiar de uma função matemática definida recursivamente é a sequência de Fibonacci, cuja definição é (consulte <a href="https://pt.wikipedia.org/wiki/Sequência_de_Fibonacci" class="bare">https://pt.wikipedia.org/wiki/Sequência_de_Fibonacci</a>):
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{fib(n) =
\begin{cases}
    0&amp; \textrm{se}\  n = 0 \\
    1&amp; \textrm{se}\  n = 1 \\
    fib(n-1) + fib(n-2)&amp; \textrm{se}\  n &gt; 1
\end{cases}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Traduzindo para Julia, tem-se:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fib(n)
    if n == 0
        return 0
    elseif n == 1
        return 1
    else
        return fib(n-1) + fib(n-2)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se você tentar acompanhar o fluxo de execução aqui, mesmo para valores razoavelmente pequenos de <code>n</code>, sua cabeça vai enlouquecer. No entanto, de acordo com o salto de fé, se presumir que as duas chamadas recursivas funcionam sem erros, fica nítido que o resultado certo é obtido a partir da soma delas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_verificação_de_tipos">Verificação de Tipos</h3>
<div class="paragraph">
<p>O que ocorre se chamarmos <code>fatorial</code> e atribuirmos <code>1.5</code> como argumento?
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fatorial(1.5)
ERROR: StackOverflowError:
Stacktrace:
 [1] fatorial(::Float64) at ./REPL[3]:2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Parece uma recursão infinita. Como pode ser? A função tem um caso base—quando <code>n == 0</code>. Mas se <code>n</code> não for um número inteiro, podemos <em>perder</em> o caso base e ficar recursivo para sempre.
</p>
</div>
<div class="paragraph">
<p>Na primeira chamada recursiva, o valor de <code>n</code> é <code>0.5</code>. No próximo, é <code>-0.5</code>. A partir daí, vai diminuindo e ficando cada vez mais negativo, mas nunca será <code>0</code>.</p>
</div>
<div class="paragraph">
<p>Temos duas escolhas. Podemos tentar generalizar a função fatorial para trabalhar com números de ponto flutuante, ou podemos fazer <code>fatorial</code> verificar o tipo de argumento. Na primeira opção, tem-se a função gama que está um pouco além do escopo deste livro. Logo, vamos adotar a segunda opção.
</p>
</div>
<div class="paragraph">
<p>Podemos usar o operador embutido <code>isa</code> para verificar o tipo do argumento. Ainda falando no assunto, também podemos certificar que o argumento seja positivo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fatorial(n)
    if !(n isa Int64)
        error("Fatorial é definido somente para números inteiros.")
    elseif n &lt; 0
        error("Fatorial não é definido para números inteiros negativos.")
    elseif n == 0
        return 1
    else
        return n * fatorial(n-1)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Enquanto o primeiro caso-base aborda os não-inteiros; o segundo aborda os inteiros negativos. Para esses dois casos, o programa exibe uma mensagem de erro e devolve <code>nothing</code> para indicar que algo deu errado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fatorial("fred")
ERROR: Fatorial é definido somente para números inteiros.
julia&gt; fatorial(-2)
ERROR: Fatorial não é definido para números inteiros negativos.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se passarmos pelas duas verificações, concluímos que <code>n</code> é positivo ou zero, logo, conseguimos provar que a recursão termina.</p>
</div>
<div class="paragraph">
<p>Esse programa demonstra um padrão às vezes de <em>guardião</em>. Os dois primeiros condicionais atuam como guardiões, protegendo o código de valores que podem causar um erro. Além disso, os guardiões tornam possível provar a execução sem erro do código.
</p>
</div>
<div class="paragraph">
<p>Em <a href="#catching_exceptions">Capturando Exceções</a>, veremos uma alternativa mais flexível para mostrar uma mensagem de erro: levantando uma exceção.</p>
</div>
</div>
<div class="sect2">
<h3 id="deb06">Depuração</h3>
<div class="paragraph">
<p>Dividir um programa grande em funções menores cria pontos de verificação naturais para a depuração. Caso uma função não esteja funcionando, há três possibilidades para analisar:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Há algo errado com os argumentos que a função está recebendo; ou seja, uma precondição não foi satisfeita.
</p>
</li>
<li>
<p>Há algo errado com a função; isto é, uma pós-condição não foi satisfeita.
</p>
</li>
<li>
<p>Há algo errado com o valor de retorno ou com a maneira como ele está sendo utilizado.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para descartar a primeira possibilidade de erro, você pode imprimir no início da função os valores dos parâmetros (e possivelmente seus tipos). Ou pode escrever um código que verifique claramente as precondições.</p>
</div>
<div class="paragraph">
<p>Se os parâmetros parecerem bons, imprima o valor de retorno adicionando um comando de impressão antes de cada comando de retorno. Se possível, verifique o resultado à mão. Considere chamar a função com valores que facilitem a conferência do resultado (como em <a href="#incremental_development">Desenvolvimento Incremental</a>).</p>
</div>
<div class="paragraph">
<p>Caso a função pareça estar funcionando, observe a chamada de função para garantir que o valor de retorno esteja sendo usado corretamente (ou se está mesmo sendo usado!).</p>
</div>
<div class="paragraph">
<p>Adicionar comandos de impressão no início e no final de uma função pode facilitar o acompanhamento do fluxo de execução. Por exemplo, aqui está uma versão de <code>fatorial</code> com comandos print:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fatorial(n)
    espaço = " " ^ (4 * n)
    println(espaço, "fatorial ", n)
    if n == 0
        println(espaço, "retornando 1")
        return 1
    else
        recursão = fatorial(n-1)
        resultado = n * recursão
        println(espaço, "retornando ", resultado)
        return resultado
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>espaço</code> é uma string de espaços que atua na indentação da saída:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fatorial(4)
                fatorial 4
            fatorial 3
        fatorial 2
    fatorial 1
fatorial 0
retornando 1
    retornando 1
        retornando 2
            retornando 6
                retornando 24
24</code></pre>
</div>
</div>
<div class="paragraph">
<p>Caso o fluxo de execução não esteja claro, esse tipo de saída de impressões pode ser útil. Leva algum tempo para usar andaimes eficientemente, mas um pouco de andaime pode economizar muita depuração.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_6">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">variável temporária</dt>
<dd>
<p>Uma variável que armazena um valor intermediário em um cálculo difícil.
</p>
</dd>
<dt class="hdlist1">código morto</dt>
<dd>
<p>O pedaço de um programa que nunca será executado, geralmente porque aparece após um comando de retorno.
</p>
</dd>
<dt class="hdlist1">desenvolvimento incremental</dt>
<dd>
<p>Um plano de desenvolvimento de programa que tem o objetivo de evitar a depuração, adicionando e testando apenas uma pequena quantidade de código de cada vez.
</p>
</dd>
<dt class="hdlist1">andaime</dt>
<dd>
<p>O código usado no decorrer do desenvolvimento do programa, porém não faz parte da versão final.
</p>
</dd>
<dt class="hdlist1">guardião</dt>
<dd>
<p>Um padrão de programação que usa a estrutura condicional para conferir e tratar de circunstâncias que possam levar a erros.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_7">Exercícios</h3>
<div class="sect4">
<h5 id="ex06-1">Exercício 6-4</h5>
<div class="paragraph">
<p>Desenhe o diagrama de pilha correspondente ao seguinte programa. O que o programa imprime?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function b(z)
    produto = a(z, z)
    println(z, " ", produto)
    produto
end

function a(x, y)
    x = x + 1
    x * y
end

function c(x, y, z)
    total = x + y + z
    quadrado = b(total)^2
    quadrado
end

x = 1
y = x + 1
println(c(x, y+3, x+y))</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex06-2">Exercício 6-5</h5>
<div class="paragraph">
<p>Veja a função de Ackermann, \(A(m, n)\), definida como:
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{A(m, n) =
\begin{cases}
              n+1&amp; \textrm{se}\ m = 0 \\
        A(m-1, 1)&amp; \textrm{se}\ m &gt; 0\ \textrm{e}\ n = 0 \\
A(m-1, A(m, n-1))&amp; \textrm{se}\ m &gt; 0\ \textrm{e}\ n &gt; 0.
\end{cases}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Consulte <a href="https://pt.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_de_Ackermann" class="bare">https://pt.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_de_Ackermann</a>. Escreva uma função chamada <code>ack</code> que calcula a função de Ackermann. Use sua função para avaliar <code>ack(3, 4)</code>, que é 125. O que ocorre quando aumentam os valores de <code>m</code> e <code>n</code>?
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex06-3">Exercício 6-6</h5>
<div class="paragraph">
<p>Palíndromo é uma palavra que se soletra igualmente nos dois sentidos, como "arara" e "reviver". Definindo recursivamente, uma palavra é um palíndromo se a primeira e a última letras forem as mesmas e se o meio também for um palíndromo.
</p>
</div>
<div class="paragraph">
<p>As funções seguintes recebem uma string como argumento e retornam respectivamente a primeira, a última letra e as letras do meio:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function primeira(palavra)
    primeira = firstindex(palavra)
    palavra[primeira]
end

function última(palavra)
    última = lastindex(palavra)
    palavra[última]
end

function meio(palavra)
    primeira = firstindex(palavra)
    última = lastindex(palavra)
    palavra[nextind(palavra, primeira) : prevind(palavra, última)]
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Veremos como eles funcionam no <a href="#chap08">Strings</a>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Teste estas funções. O que acontece se você chamar meio para uma string de duas letras? E de uma letra? E no caso da string vazia, que é escrita <code>""</code> e não tem nenhuma letra?</p>
</li>
<li>
<p>Escreva uma função chamada <code>é_palíndromo</code> que recebe um argumento string e retorna <code>true</code> se for um palíndromo e <code>false</code> caso contrário. Lembre-se de que você pode usar a função interna <code>length</code> para verificar o comprimento de uma string.
</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="ex06-4">Exercício 6-7</h5>
<div class="paragraph">
<p>Um número, \(a\), é dito uma potência de \(b\) se for divisível por \(b\) e \(\frac{a}{b}\) for potência de \(b\). Escreva uma função chamada <code>é_potência</code> que dados os parâmetros <code>a</code> e <code>b</code> devolve <code>true</code> se <code>a</code> for uma potência de <code>b</code>.
</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Você terá que considerar o caso base.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ex06-5">Exercício 6-8</h5>
<div class="paragraph">
<p>O máximo divisor comum (MDC) de \(a\) e \(b\) é o maior número que divide os dois sem sobrar resto.</p>
</div>
<div class="paragraph">
<p>Uma maneira de encontrar o MDC de dois números é baseada na observação de que se \(r\) é o resto da divisão de \(a\) por \(b\), então <code>mcd(a, b) = mcd(b, r)</code>. Para o caso base, considere que <code>mdc(a, 0) = a</code>.</p>
</div>
<div class="paragraph">
<p>Escreva a função <code>mdc</code> que recebe os parâmetros <code>a</code> e <code>b</code> e retorna o máximo divisor comum.
</p>
</div>
<div class="paragraph">
<p>Crédito: Este exercício é baseado em um exemplo do livro <em>Structure and Interpretation of Computer Programs</em> de Abelson e Sussman.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap07">7. Iteração</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Esse capítulo é sobre iteração, que é a habilidade de executar um bloco de argumentos repetidamente. Vimos um tipo de iteração usando recursão em <a href="#recursion">Recursão</a>. Vimos também outro tipo, usando um laço <code>for</code> em <a href="#simple_repetition">Repetição Simples</a>. Neste capítulo, veremos um outro tipo, que usa uma declaração <code>while</code> (<em>enquanto</em> em Português). Mas antes temos que falar um pouco mais sobre atribuição de variável.
</p>
</div>
<div class="sect2">
<h3 id="_reatribuição">Reatribuição</h3>
<div class="paragraph">
<p>Como você deve ter descoberto, é permitido fazer mais de uma atribuição para as mesmas variáveis. Uma nova atribuição faz com que uma variável existente se refira a um novo valor (e pare de se referir ao valor antigo).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = 5
5
julia&gt; x = 7
7</code></pre>
</div>
</div>
<div class="paragraph">
<p>A primeira vez que exibimos <code>x</code>, o seu valor é 5; na segunda vez, o seu valor é 7.</p>
</div>
<div id="fig07-1" class="imageblock">
<div class="content">
<img src="images/fig71.svg" alt="fig71">
</div>
<div class="title">Figura 10. Diagrama de estado</div>
</div>
<div class="paragraph">
<p><a href="#fig07-1">Diagrama de estado</a> mostra como uma <em>reatribuição</em> funciona por meio de um diagrama de estado.
</p>
</div>
<div class="paragraph">
<p>Neste ponto, queremos abordar um assunto comum de confusão. Como o Julia usa o sinal de igual (<code>=</code>) para a atribuição, é tentador interpretar uma afirmação como <code>a = b</code> como uma proposição matemática de igualdade; isto é, a afirmação de que <code>a</code> e <code>b</code> são iguais. Mas essa interpretação está errada.
</p>
</div>
<div class="paragraph">
<p>Primeiro que a igualdade é uma relação simétrica e a atribuição não é. Por exemplo, em matemática, se \(a=7\) então \(7=a\). Mas em Julia, a atribuição <code>a=7</code> é permitida e <code>7=a</code> não.</p>
</div>
<div class="paragraph">
<p>Também na matemática, uma proposição de igualdade ou é verdadeira ou é falsa para sempre. Se \(a=b\) agora, então \(a\) será sempre igual a \(b\). Em Julia, uma atribuição pode fazer duas variáveis iguais, mas elas não precisam ficar assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = 5
5
julia&gt; b = a    # a e b são iguais
5
julia&gt; a = 3    # a e b não são mais iguais
3
julia&gt; b
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>A terceira linha altera o valor de <code>a</code> mas não altera o valor de <code>b</code>, portanto eles não são mais iguais.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Atenção</div>
</td>
<td class="content">
<div class="paragraph">
<p>A reatribuição de variáveis geralmente é útil, mas você deve usá-la com cuidado. Se os valores das variáveis mudarem com frequência, isso pode dificultar a leitura e a depuração do código.</p>
</div>
<div class="paragraph">
<p>Não é permitido definir uma função que tenha o mesmo nome de uma variável definida anteriormente.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_atualizando_variáveis">Atualizando Variáveis</h3>
<div class="paragraph">
<p>Um tipo comum de reatribuição é uma atualização, onde o novo valor da variável depende do antigo.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = x + 1
8</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isso significa “pegue o valor atual de <code>x</code>, adicione um, e então atualize <code>x</code> ao novo valor.”</p>
</div>
<div class="paragraph">
<p>Se você tenta atualizar uma variável que não existe, uma mensagem de erro aparecerá, porque o Julia avalia o lado direito antes de atribuir um valor a <code>x</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; y = y + 1
ERROR: UndefVarError: y not defined</code></pre>
</div>
</div>
<div class="paragraph">
<p>Antes que você possa atualizar uma variável, deve-se inicializá-la geralmente com uma atribuição simples:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; y = 0
0
julia&gt; y = y + 1
1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Atualizar uma variável adicionando 1 é chamado de <em>incremento</em>; e subtraindo 1 é chamado de <em>decremento</em>.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_declaração_while">A Declaração <code>while</code></h3>
<div class="paragraph">
<p>Os computadores são frequentemente usados para automatizar tarefas repetitivas. Repetir tarefas idênticas ou semelhantes sem cometer erros é algo que os computadores fazem bem, ao contrário das pessoas. Em um programa de computador, a repetição também é chamada de <em>iteração</em>.
</p>
</div>
<div class="paragraph">
<p>Já vimos duas funções, <code>contador_regressivo</code> e <code>imprima_n</code>, que iteram usando recursão. Como a iteração é muito comum, Julia dispõe de recursos para simplificá-la. Um deles é a declaração <code>for</code> que vimos em <a href="#simple_repetition">Repetição Simples</a>. Voltaremos a este assunto mais tarde.
</p>
</div>
<div class="paragraph">
<p>A outra é a <em>declaração</em> <code>while</code>. Aqui está a versão de <code>contagem_regressiva</code> que utiliza a declaração <code>while</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function contagem_regressiva(n)
    while n &gt; 0
        print(n, " ")
        n = n - 1
    end
    println("Decolar!")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Você pode ler a declaração <code>while</code> quase como se estivesse em Português, traduzindo <em>while</em> por <em>enquanto</em>. Ela significa “Enquanto <code>n</code> for maior que 0, exiba o valor de <code>n</code> e depois diminua <code>n</code>. Quando chegar a 0, imprima a palavra Decolar!”
</p>
</div>
<div class="paragraph">
<p>Formalmente, segue abaixo o fluxo de execução de uma declaração <code>while</code>:
</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Determinar se a condição é verdadeira ou falsa.</p>
</li>
<li>
<p>Se for falsa, saia da declaração <em>while</em> e continue a execução para o próximo comando.</p>
</li>
<li>
<p>Se a condição for verdadeira, execute os comandos do corpo e então volte para o passo 1.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Esse tipo de fluxo é chamado de laço porque o terceiro passo retorna ao topo.
</p>
</div>
<div class="paragraph">
<p>O corpo do laço deve mudar o valor de uma ou mais variáveis até que eventualmente a condição se torna falsa e o laço é finalizado. Caso contrário, o laço irá se repetir para sempre, ou seja, um <em>laço infinito</em>. Uma fonte inesgotável de diversão para os cientistas da computação são as instruções nos frascos de shampoo, “ensaboe, enxague, repita”, pois é um laço infinito.
</p>
</div>
<div class="paragraph">
<p>No caso da função <code>contagem_regressiva</code>, podemos provar que o laço é finalizado: se <code>n</code> é zero ou negativo, o laço nunca termina. Caso contrário, <code>n</code> vai diminuindo durante o laço e então eventualmente chegará a 0.</p>
</div>
<div class="paragraph">
<p>Para alguns laços, não é tão fácil de provar. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function seq(n)
    while n != 1
        println(n)
        if n % 2 == 0        # n é par
            n = n / 2
        else                 # n é ímpar
            n = n*3 + 1
        end
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A condição para esse laço é <code>n != 1</code>, então esse laço irá continuar até que <code>n</code> seja 1, o que faz a condição ser falsa.</p>
</div>
<div class="paragraph">
<p>A cada passada do laço, o programa tem como saída o valor <code>n</code> que é verificado se é par ou ímpar. Se é par, <code>n</code> é dividido por 2. Se é ímpar, o valor de <code>n</code> é substituído por <code>n*3 + 1</code>. Por exemplo, se o argumento da sequência é 3, os valores de <code>n</code> recebidos são 3, 10, 5, 16, 8, 4, 2, 1.</p>
</div>
<div class="paragraph">
<p>Já que <code>n</code> às vezes cresce e às vezes decresce, não existe uma demonstração óbvia de que <code>n</code> resultará em 1 ou que o programa termine. Para alguns valores particulares de <code>n</code>, podemos demonstrar que termina. Por exemplo, se o valor inicial é uma potência de dois, <code>n</code> será sempre par durante o laço até que chega em 1. O exemplo anterior finaliza essa sequência, a partir de 16.</p>
</div>
<div class="paragraph">
<p>A parte difícil é provar que esse programa finaliza para todos os valores positivos de <code>n</code>. Até agora ninguém foi capaz de provar ou desprovar isso! (Consulte <a href="https://pt.wikipedia.org/wiki/Conjectura_de_Collatz." class="bare">https://pt.wikipedia.org/wiki/Conjectura_de_Collatz.</a>)
</p>
</div>
<div class="sect4">
<h5 id="_exercício_7_1">Exercício 7-1</h5>
<div class="paragraph">
<p>Reescreva a função <code>imprima_n</code> de <a href="#recursion">Recursão</a> usando iteração ao invés de recursão.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_break"><code>break</code></h3>
<div class="paragraph">
<p>Às vezes, você não sabe que é hora de terminar um laço até chegar na metade do corpo. Neste caso você pode utilizar a <em>declaração break</em> para sair do laço.
</p>
</div>
<div class="paragraph">
<p>Por exemplo, suponha que você queira receber entradas do usuário até que ele digite concluído. Poderia-se escrever:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">while true
    print("&gt; ")
    linha = readline()
    if linha == "concluído"
        break
    end
    println(linha)
end
println("Concluído!")</code></pre>
</div>
</div>
<div class="paragraph">
<p>A condição deste laço é <code>true</code>, que é sempre verdade, então o laço será executado até chegar na declaração break.</p>
</div>
<div class="paragraph">
<p>A cada iteração, a solicitação ao usuário ocorre por meio de um sinal de maior ("&gt;"). Se o usuário digitar <code>concluído</code>, então a declaração break finaliza o laço. Caso contrário, o programa mostrará o que o usuário digitar e voltará ao topo do laço. Aqui está um exemplo de execução:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&gt; não está concluído
não está concluído
&gt; concluído
Concluído!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Essa maneira de escrever laços é comum porque você pode verificar a condição em qualquer lugar do laço (não apenas no topo) e você pode expressar a condição de parada afirmativamente ("pare quando isso acontecer") ao invés de negativamente ("continue enquanto isso acontece").</p>
</div>
</div>
<div class="sect2">
<h3 id="_continue"><code>continue</code></h3>
<div class="paragraph">
<p>A declaração break sai do laço. Quando uma <em>declaração continue</em> é encontrado dentro de um laço, salta-se para o início do laço da próxima iteração, pulando a execução de comandos dentro do corpo do laço da iteração atual. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for i in 1:10
    if i % 3 == 0
        continue
    end
    print(i, " ")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1 2 4 5 7 8 10</pre>
</div>
</div>
<div class="paragraph">
<p>Se <code>i</code> é divisível por 3, a declaração continue para na iteração atual e a próxima iteração é iniciada. Apenas os números no intervalo entre 1 a 10 não divisíveis por 3 são exibidos.</p>
</div>
</div>
<div class="sect2">
<h3 id="square_roots">Raízes Quadradas</h3>
<div class="paragraph">
<p>Laços são frequentemente usados em programas que calculam resultados numéricos começando com um valor aproximado e aprimorando-o iterativamente.</p>
</div>
<div class="paragraph">
<p>Por exemplo, uma maneira de calcular raízes quadradas é através do método de Newton. Suponha que você queira saber a raiz quadrada de \(a\). Se você começar com uma estimativa qualquer, \(x\), pode-se calcular uma estimativa melhor com a seguinte fórmula:
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{y = \frac{1}{2}\left(x + \frac{a}{x}\right)}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Por exemplo, se \(a\) é 4 e \(x\) é 3:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = 4
4
julia&gt; x = 3
3
julia&gt; y = (x + a/x) / 2
2.1666666666666665</code></pre>
</div>
</div>
<div class="paragraph">
<p>O resultado está mais próximo da resposta correta (\(\sqrt 4 = 2\)). Se repetirmos o processo com a nova estimativa, ficará mais próximo ainda:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = y
2.1666666666666665
julia&gt; y = (x + a/x) / 2
2.0064102564102564</code></pre>
</div>
</div>
<div class="paragraph">
<p>Depois de mais algumas atualizações, a estimativa é quase exata:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = y
2.0064102564102564
julia&gt; y = (x + a/x) / 2
2.0000102400262145
julia&gt; x = y
2.0000102400262145
julia&gt; y = (x + a/x) / 2
2.0000000000262146</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em geral, não sabemos antecipadamente quantos passos são necessários para obter a resposta certa, mas sabemos quando chegamos lá porque a estimativa para de mudar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = y
2.0000000000262146
julia&gt; y = (x + a/x) / 2
2.0
julia&gt; x = y
2.0
julia&gt; y = (x + a/x) / 2
2.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quando <code>y == x</code>, podemos parar. Aqui está um laço que começa com uma estimativa inicial <code>x</code>, e melhora até parar de mudar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">while true
    println(x)
    y = (x + a/x) / 2
    if y == x
        break
    end
    x = y
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Essa função funciona bem para a maior parte dos valores de a, mas em geral é perigoso testar igualdade com pontos flutuantes. Pontos flutuantes não são totalmente exatos: a maioria dos números racionais, como \(\frac{1}{3}\), e números irracionais, como \(\sqrt 2\), não podem ser representados exatamente com um tipo <code>Float64</code>.</p>
</div>
<div class="paragraph">
<p>Em vez de verificar se <code>x</code> e <code>y</code> são exatamente iguais, é mais seguro usar a função interna <code>abs</code> para calcular o valor absoluto, ou magnitude, da diferença entre eles:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if abs(y-x) &lt; ε
    break
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Onde <code>ε</code> (<strong><code>\varepsilon TAB</code></strong>) possui um valor como <code>0.0000001</code> que determina o quão suficientemente próximo está.</p>
</div>
</div>
<div class="sect2">
<h3 id="_algoritmos">Algoritmos</h3>
<div class="paragraph">
<p>O método de Newton é um exemplo de um <em>algoritmo</em>: um processo mecânico para resolver uma categoria de problemas (nesse caso, o cálculo de raízes quadradas).
</p>
</div>
<div class="paragraph">
<p>Para entender o que é um algoritmo, talvez seja interessante começar com algo que não é um algoritmo. Quando você aprendeu a multiplicar unidades, você provavelmente memorizou a tabuada. De fato, você memorizou 100 soluções específicas. Esse tipo de conhecimento não é um algoritmo.</p>
</div>
<div class="paragraph">
<p>Mas se você fosse “preguiçoso”, talvez tivesse aprendido alguns truques. Por exemplo, para encontrar o produto de \(n\) e 9, você pode escrever \(n-1\) no primeiro dígito e \(10-n\) no segundo dígito. Esse truque é uma solução geral para multiplicar qualquer unidade por 9. Isso é um algoritmo!</p>
</div>
<div class="paragraph">
<p>Similarmente, as técnicas que você aprendeu para a adição com transporte de unidades, a subtração com empréstimos e a divisão longa são todos algoritmos. Uma das características dos algoritmos é que eles não exigem nenhuma inteligência para serem executados. São processos mecânicos em que cada passo segue a partir do último, de acordo com um conjunto simples de regras.</p>
</div>
<div class="paragraph">
<p>Apesar da execução de algoritmos ser chata, a construção é interessante, intelectualmente desafiadora e uma parte central da ciência da computação.</p>
</div>
<div class="paragraph">
<p>Algumas das coisas que as pessoas fazem naturalmente, sem dificuldade ou conscientemente pensado, são as mais difíceis de expressar por algoritmos. Compreender a linguagem natural é um bom exemplo. Todos nós fazemos isso, mas até agora ninguém foi capaz de explicar <em>como</em> fazemos, pelo menos não na forma de um algoritmo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_depuração_6">Depuração</h3>
<div class="paragraph">
<p>Ao começar a escrever programas maiores, você pode passar mais tempo com a depuração. Mais código significa mais chances de cometer um erro e mais lugares para os erros se esconderem.
</p>
</div>
<div class="paragraph">
<p>Uma maneira de reduzir o tempo da depuração é a “depuração por bissecção”. Por exemplo, se houver 100 linhas no seu programa e você verificá-las uma de cada vez, serão necessárias 100 etapas.
</p>
</div>
<div class="paragraph">
<p>Em vez disso, tente quebrar o problema ao meio. Olhe no meio do programa, ou por perto, para um valor intermediário que você pode verificar. Adicione uma declaração print (ou qualquer outra coisa que tenha um propósito de verificação) e execute o programa.
</p>
</div>
<div class="paragraph">
<p>Se a verificação da região do meio estiver incorreta, deve haver um problema na primeira metade do programa. Se estiver correta, o problema está na segunda metade.</p>
</div>
<div class="paragraph">
<p>Toda vez que você executa uma verificação como essa, reduz-se pela metade o número de linhas que se precisa averiguar. Após seis etapas (que é menor que 100), você reduziria para uma ou duas linhas de código, pelo menos em teoria.</p>
</div>
<div class="paragraph">
<p>Na prática, nem sempre é claro onde é o "meio do programa" e nem sempre é possível verificá-lo. Não faz sentido contar linhas e encontrar o ponto médio exato. Em vez disso, pense nos locais do programa em que pode haver erros e nos locais onde é fácil fazer uma verificação. Em seguida, escolha um local onde você acha que as chances são as mesmas de que o erro seja antes ou depois da verificação.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_7">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">reatribuição</dt>
<dd>
<p>Atribuindo um novo valor a uma variável que já existe.
</p>
</dd>
<dt class="hdlist1">atualização</dt>
<dd>
<p>Uma atribuição em que o novo valor da variável depende do antigo.
</p>
</dd>
<dt class="hdlist1">inicialização</dt>
<dd>
<p>Uma atribuição que fornece um valor inicial a uma variável que será atualizada.
</p>
</dd>
<dt class="hdlist1">incremento</dt>
<dd>
<p>Uma atualização que aumenta o valor de uma variável (frequentemente em um).
</p>
</dd>
<dt class="hdlist1">decremento</dt>
<dd>
<p>Uma atualização que diminui o valor de uma variável.
</p>
</dd>
<dt class="hdlist1">iteração</dt>
<dd>
<p>Execução repetida de um conjunto de comandos usando uma chamada de função recursiva ou um laço.
</p>
</dd>
<dt class="hdlist1">declaração while</dt>
<dd>
<p>Comando que permite iterações controladas por uma condição.
</p>
</dd>
<dt class="hdlist1">declaração break</dt>
<dd>
<p>Comando que permite saltar fora de um laço.
</p>
</dd>
<dt class="hdlist1">declaração continue</dt>
<dd>
<p>Comando dentro de um laço que salta para o início do laço da próxima iteração.
</p>
</dd>
<dt class="hdlist1">laço infinito</dt>
<dd>
<p>Um laço no qual a sua condição de parada nunca é satisfeita.
</p>
</dd>
<dt class="hdlist1">algoritmo</dt>
<dd>
<p>Um processo geral para resolver uma categoria de problemas.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_8">Exercícios</h3>
<div class="sect4">
<h5 id="ex07-1">Exercício 7-2</h5>
<div class="paragraph">
<p>Copie o laço de <a href="#square_roots">Raízes Quadradas</a> e encapsule-o em uma função chamada <code>minha_raiz</code> que usa a variável <code>a</code> como um parâmetro e escolha um valor razoável de <code>x</code> que retorne uma estimativa da raiz quadrada de <code>a</code>.
</p>
</div>
<div class="paragraph">
<p>Para testá-la, escreva uma função chamada <code>avalia_raiz_quadrada</code> que imprime uma tabela como esta:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a   mysqrt             sqrt               diff
-   ------             ----               ----
1.0 1.0                1.0                0.0
2.0 1.414213562373095  1.4142135623730951 2.220446049250313e-16
3.0 1.7320508075688772 1.7320508075688772 0.0
4.0 2.0                2.0                0.0
5.0 2.23606797749979   2.23606797749979   0.0
6.0 2.449489742783178  2.449489742783178  0.0
7.0 2.6457513110645907 2.6457513110645907 0.0
8.0 2.82842712474619   2.8284271247461903 4.440892098500626e-16
9.0 3.0                3.0                0.0</pre>
</div>
</div>
<div class="paragraph">
<p>A primeira coluna é um número, <code>a</code>; a segunda coluna é a raiz quadrada de <code>a</code> calculada com <code>minha_raiz</code>; a terceira coluna é a raiz quadrada calculada por <code>sqrt</code>; a quarta coluna é o valor absoluto da diferença entre as duas estimativas.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex07-2">Exercício 7-3</h5>
<div class="paragraph">
<p>A função interna <code>Meta.parse</code> recebe uma string e transforma-a em uma expressão. Essa expressão pode ser avaliada em Julia com a função <code>Core.eval</code>. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; expr = Meta.parse("1+2*3")
:(1 + 2 * 3)
julia&gt; eval(expr)
7
julia&gt; expr = Meta.parse("sqrt(π)")
:(sqrt(π))
julia&gt; eval(expr)
1.7724538509055159</code></pre>
</div>
</div>
<div class="paragraph">
<p>Escreva uma função chamada <code>avalie_laço</code> que solicite iterativamente ao usuário, pegue a entrada recebida e avalie-a usando <code>eval</code> e depois imprime o resultado. A função deve continuar até o usuário digitar <code>concluído</code> e depois retornar o valor da última expressão avaliada.</p>
</div>
<div class="paragraph">
<p></p>
</div>
</div>
<div class="sect4">
<h5 id="ex07-3">Exercício 7-4</h5>
<div class="paragraph">
<p>O matemático Srinivasa Ramanujan encontrou uma série infinita que pode ser usada para gerar uma aproximação numérica de \(\frac{1}{\pi}\):</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{\frac{1}{\pi}=\frac{2\sqrt2}{9801}\sum_{k=0}^\infty\frac{(4k)!(1103+26390k)}{(k!)^4 396^{4k}}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Escreva uma função chamada <code>estima_pi</code> que use essa fórmula para calcular e retornar uma estimativa de π. Ela deve usar um laço while para calcular os termos da soma até que o último termo seja menor que <code>1e-15</code> (que é a notação do Julia para \(10^{-15}\)). Você pode verificar o resultado comparando-o com <code>π</code>.
</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap08">8. Strings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Strings não são como inteiros, pontos flutuante e tipos booleanos. Uma string é uma <em>sequência</em>, o que significa que ela está em uma coleção ordenada de outros valores. Neste capítulo você verá como acessar os caracteres que compõem uma string e irá aprender sobre algumas funções auxiliares de strings fornecidas pelo Julia.
</p>
</div>
<div class="sect2">
<h3 id="characters">Caracteres</h3>
<div class="paragraph">
<p>Falantes da língua portuguesa estão familiarizados com caracteres como as letras do alfabeto (A, B, C, &#8230;&#8203;), numerais e a pontuação comum. Esses caracteres são padronizados e mapeados para valores inteiros entre 0 e 127 pelo <em>padrão ASCII</em> (American Standard Code for Information ou "Código Padrão Americano de Intercâmbio de Informações")
</p>
</div>
<div class="paragraph">
<p>Existem, é claro, muitos outros caracteres usados em línguas diferentes do Português, incluindo variantes dos caracteres ASCII com acentos e outras modificações, scripts relacionados como o Cirílico e o Grego e scripts completamente não relacionados ao ASCII e ao Português, incluindo Árabe, Chinês, Hebreu, Hindi, Japonês e Koreano.</p>
</div>
<div class="paragraph">
<p>O <em>padrão Unicode</em> lida com as complexidades do que exatamente é um caractere e é geralmente aceitado como o padrão definitivo que resolve esse problema. Ele fornece um número único para todo caractere em uma escala mundial.
</p>
</div>
<div class="paragraph">
<p>Um valor <code>Char</code> representa um único caractere e está cercado por aspas simples:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)
julia&gt; '🍌'
'🍌': Unicode U+1F34C (category So: Symbol, other)
julia&gt; typeof('x')
Char</code></pre>
</div>
</div>
<div class="paragraph">
<p>Até mesmo emojis fazem parte do padrão Unicode. (<strong><code>\:banana: TAB</code></strong>)
</p>
</div>
</div>
<div class="sect2">
<h3 id="_uma_string_é_uma_sequência">Uma String é uma Sequência</h3>
<div class="paragraph">
<p>Uma string é uma sequência de caracteres. Você pode acessar os caracteres um de cada vez com o operador colchetes:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fruta = "banana"
"banana"
julia&gt; letra = fruta[1]
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
<div class="paragraph">
<p>O segundo comando seleciona o primeiro caractere de <code>fruta</code> e o atribui para <code>letra</code>.</p>
</div>
<div class="paragraph">
<p>A expressão em colchetes é chamada de <em>índice</em>. O índice indica qual caractere da sequência você deseja (por isso o nome).
</p>
</div>
<div class="paragraph">
<p>Toda indexação no Julia começa em 1, o primeiro elemento de qualquer objeto inteiramente indexado é encontrado no índice 1 e o último no índice <code>end</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fruta[end]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Você pode usar como índice uma expressão que contém variáveis e operadores:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; i = 1
1
julia&gt; fruta[i+1]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
julia&gt; fruta[end-1]
'n': ASCII/Unicode U+006E (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mas o valor do índice precisa ser um inteiro. Caso contrário você recebe:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; letra = fruta[1.5]
ERROR: MethodError: no method matching getindex(::String, ::Float64)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_length"><code>length</code></h3>
<div class="paragraph">
<p><code>length</code> é uma função interna que retorna o número de caracteres em uma string:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; frutas = "🍌 🍎 🍐"
"🍌 🍎 🍐"
julia&gt; tamanho = length(frutas)
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para obter a última letra da string, você pode ficar tentado a fazer algo como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; last = frutas[tamanho]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mas você pode não conseguir o que espera.</p>
</div>
<div class="paragraph">
<p>Strings são codificadas usando a <em>codificação UTF-8</em>. UTF-8 é uma codificação de largura variável, o que significa que nem todos os caracteres estão codificados com o mesmo número de bytes.
</p>
</div>
<div class="paragraph">
<p>A função <code>sizeof</code> retorna o número de bytes em uma string:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; sizeof("🍌")
4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como um emoji é codificado em 4 bytes e a indexação de strings é baseado em bytes, o quinto elemento de <code>frutas</code> é um <code>ESPAÇO</code>.
</p>
</div>
<div class="paragraph">
<p>Isso significa também que nem todo índice de bytes em uma string UTF-8 é necessariamente um índice válido para um caractere. Se você indexar em uma string com um índice de bytes inválido, será gerado um erro:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; frutas[2]
ERROR: StringIndexError("🍌 🍎 🍐", 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>No caso de <code>frutas</code>, o caractere <code>🍌</code> é um caractere de quatro bytes, então os índices 2, 3 e 4 são inválidos e o índice do próximo caractere é 5; esse próximo índice válido pode ser calculado por <code>nextind(frutas, 1)</code> e o índice depois dele por <code>nextind(frutas, 5)</code> e assim por diante.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_travessia">Travessia</h3>
<div class="paragraph">
<p>Muitos problemas computacionais envolvem o processamento de uma string, um caractere de cada vez. Geralmente eles começam no início, selecionando cada caractere por vez, fazendo algo com ele, e continuando até o final. Esse padrão de processamento é denominado de <em>travessia</em>. Um jeito de escrever uma travessia é com um laço <code>while</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">índice = firstindex(frutas)
while índice &lt;= sizeof(frutas)
    letra = frutas[índice]
    println(letra)
    global índice = nextind(frutas, índice)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse laço faz a travessia da string e exibe cada letra em uma linha por si só. A condição do laço é <code>index &lt;= sizeof(fruta)</code>, então quando o índice é maior que o número de bytes em uma string, a condição é <code>false</code>, e o corpo do laço não executa.</p>
</div>
<div class="paragraph">
<p>A função <code>firstindex</code> retorna o primeiro índice de bytes válido. A palavra-chave <code>global</code> antes de <code>índice</code> indica que nós queremos reatribuir a variável <code>índice</code> definida em <code>Main</code> (ver <a href="#global_variables">Variáveis Globais</a>).
</p>
</div>
<div class="sect4">
<h5 id="_exercício_8_1">Exercício 8-1</h5>
<div class="paragraph">
<p>Escreva uma função que recebe uma string como argumento e exibe as letras ao contrário, uma por linha.</p>
</div>
<div class="paragraph">
<p>Outra maneira de escrever uma travessia é com o laço <code>for</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for letra in frutas
    println(letra)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cada vez que o laço é percorrido, o próximo caractere na string é atribuido para a variável <code>letra</code>. O laço continua até que não haja mais caracteres sobrando.</p>
</div>
<div class="paragraph">
<p>O próximo exemplo mostra como usar concatenação (multiplicação de strings) e um laço <code>for</code> para gerar séries abecedárias (isto é, em ordem alfabética). No livro de Robert McCloskey, <em>Make way for Ducklings</em> (Abram caminho para os Patinhos), os nomes dos patinhos são Jack, Kack, Lack, Mack, Nack, Ouack, Pack, e Quack. Esse laço gera os nomes em ordem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">prefixos = "JKLMNOPQ"
sufixo = "ack"

for letra in prefixos
    println(letra * sufixo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack</pre>
</div>
</div>
<div class="paragraph">
<p>É claro, isso não está completamente correto pois “Ouack” e “Quack” estão incorretos.</p>
</div>
</div>
<div class="sect4">
<h5 id="_exercício_8_2">Exercício 8-2</h5>
<div class="paragraph">
<p>Modifique o programa para consertar este erro.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fatias_de_strings">Fatias de Strings</h3>
<div class="paragraph">
<p>Um segmento de uma string é chamado de <em>fatia</em>. Selecionar uma fatia é similar a selecionar um caractere:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; str = "Chapolin Colorado";

julia&gt; str[1:8]
"Chapolin"</code></pre>
</div>
</div>
<div class="paragraph">
<p>O operador <code>[n:m]</code> retorna a parte da string do <code>n</code>-ésimo byte até o <code>m</code>-ésimo byte. Então o mesmo cuidado é necessário como para a indexação simples.
</p>
</div>
<div class="paragraph">
<p>A palavra-chave <code>end</code> pode ser usada para indicar o último byte da string:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; str[10:end]
"Colorado"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se o primeiro índice é maior que o segundo, o resultado é uma <em>string vazia</em>, representada por aspas duplas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; str[8:7]
""</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma string vazia não contém nenhum caractere e possui tamanho 0, mas fora isso, é igual a qualquer outra string.</p>
</div>
<div class="sect4">
<h5 id="_exercício_8_3">Exercício 8-3</h5>
<div class="paragraph">
<p>Continuando este exemplo, o que você acha que <code>str[:]</code> significa? Experiemente e veja.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_string_são_imutáveis">String são Imutáveis</h3>
<div class="paragraph">
<p>É tentador usar o operador <code>[]</code> no lado esquerdo da atribuição, com a intenção de mudar um caractere de uma string. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; cumprimento = "Olá, Mundo!"
"Olá, Mundo!"
julia&gt; cumprimento[1] = 'E'
ERROR: MethodError: no method matching setindex!(::String, ::Char, ::Int64)</code></pre>
</div>
</div>
<div class="paragraph">
<p>O motivo deste erro é de que strings são <em>imutáveis</em>, o que significa que você não pode mudar uma string existente. O melhor que você pode fazer é criar uma nova string que é uma variação da original:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; cumprimento = "E" * cumprimento[2:end]
"Elá, Mundo!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse exemplo concatena uma nova primeira letra em uma fatia de cumprimento. Ele não tem efeito algum na string original.</p>
</div>
</div>
<div class="sect2">
<h3 id="_interpolação_de_strings">Interpolação de Strings</h3>
<div class="paragraph">
<p>Construir strings usando concatenação pode vir a ser um incômodo. Para reduzir a necessidade dessas chamadas verbosas para <code>string</code> ou multiplicações repetidas, o Julia permite <em>interpolação de strings</em> usando <code>$</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; cumprimento = "Olá"
"Olá"
julia&gt; quem = "Mundo"
"Mundo"
julia&gt; "$cumprimento, $(quem)!"
"Olá, Mundo!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isso é mais legível e conveniente do que concatenação de strings: <code>cumprimento * ", " * quem * "!"</code></p>
</div>
<div class="paragraph">
<p>O valor da menor expressão inteira após o <code>$</code> é tomado como o valor que deve ser interpolado na sequência. Assim, você pode interpolar qualquer expressão em uma string usando parênteses:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; "1 + 2 = $(1 + 2)"
"1 + 2 = 3"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="searching">Buscando</h3>
<div class="paragraph">
<p>O que a função a seguir faz?
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function buscar(palavra, letra)
    índice = firstindex(palavra)
    while índice &lt;= sizeof(palavra)
        if palavra[índice] == letra
            return índice
        end
        índice = nextind(palavra, índice)
    end
    -1
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>De certo modo, buscar é o inverso do operador <code>[]</code>. Ao invés de pegar um índice e extrair o caractere correspondente, ela recebe o caractere e busca o índice aonde este caractere aparece. Se o caractere não é encontrado, a função retorna -1.</p>
</div>
<div class="paragraph">
<p>Esse é o primeiro exemplo que nós vimos de uma declaração return dentro de um laço. Se <code>palavra[índice] == letra</code>, a função sai do laço e retorna imediatamente.</p>
</div>
<div class="paragraph">
<p>Se o caractere não aparece na string, o programa sai do laço normalmente e retorna -1.</p>
</div>
<div class="paragraph">
<p>Percorrer uma sequência e retornar o objeto que estamos procurando quando achamos-o é um padrão de computação chamado de <em>busca</em>.
</p>
</div>
<div class="sect4">
<h5 id="_exercício_8_4">Exercício 8-4</h5>
<div class="paragraph">
<p>Modifique <code>busca</code> para que ela tenha um terceiro parâmetro, o índice em <code>palavra</code> aonde ela deve começar a procurar.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="looping_and_counting">Realizando Laços e Contando</h3>
<div class="paragraph">
<p>O seguinte programa conta o número de vezes que a letra <code>a</code> aparece em uma string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">palavra = "banana"
contador = 0
for letra in palavra
    if letra == 'a'
        global contador = contador + 1
    end
end
println(contador)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse programa demonstra outro padrão de programação chamado <em>contador</em>. A variável <code>contador</code> é inicializada com 0 e incrementada toda vez que um <code>a</code> é encontrado. Quando a função sai do laço, <code>contador</code> contém o resultado-o número total de <code>a</code>’s.
</p>
</div>
<div class="sect4">
<h5 id="_exercício_8_5">Exercício 8-5</h5>
<div class="paragraph">
<p>Encapsule esse código em uma função chamada <code>conte</code> e a generealize para que ela aceite a string e a letra como argumentos.</p>
</div>
<div class="paragraph">
<p>Depois reescreva a função de modo que ao invés de percorrer a string, ela usa a versão com três parâmetros de <code>busca</code> da seção anterior.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_a_biblioteca_de_strings">A Biblioteca de Strings</h3>
<div class="paragraph">
<p>O Julia fornece funções que executam uma variedade de operações utéis com strings. Por exemplo, a função <code>uppercase</code> recebe uma string e retorna uma nova string com todas suas letras maiúsculas.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; uppercase("Olá, Mundo!")
"OLÁ, MUNDO!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Acontece que, existe uma função chamada <code>findfirst</code> que é bastante similar a função <code>busca</code> que nós escrevemos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; findfirst("a", "banana")
2:2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Na verdade, a função <code>findfirst</code> é mais geral que a nossa função; ela pode achar substrings, não apenas caracteres:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; findfirst("na", "banana")
3:4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por padrão, <code>findfirst</code> começa no início da string, mas a função <code>findnext</code> recebe um terceiro argumento, o <code>índice</code> onde ela deve começar:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; findnext("na", "banana", 4)
5:6</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_o_operador">O Operador <code>∈</code></h3>
<div class="paragraph">
<p>O operador <code>∈</code> (<strong><code>\in TAB</code></strong>) é um operador booleano que recebe um caractere e uma string e retorna <code>true</code> se o caractere aparece na string:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 'a' ∈ "banana"    # 'a' em "banana"
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por exemplo, a seguinte função imprime todas as letras da palavra1 que também aparecem na palavra2:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function em_ambos(palavra1, palavra2)
    for letra in palavra1
        if letra ∈ palavra2
            print(letra, " ")
        end
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Com variáveis de nomes bem escolhidos, o Julia às vezes lê como Inglês. Você poderia ler este laço da seguinte forma: “para (cada) letra na (primeira) palavra, se (a) letra é um elemento da (segunda) palavra, imprima (a) letra”</p>
</div>
<div class="paragraph">
<p>Isso é o que você recebe se você compara <code>"maçãs"</code> e <code>"laranjas"</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; em_ambos("maçãs", "laranjas")
a s</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_comparação_de_strings">Comparação de Strings</h3>
<div class="paragraph">
<p>O operador relacional funciona em strings. Para ver se duas strings são iguais:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">palavra = "Abacaxi"
if palavra == "banana"
    println("Tudo certo, bananas.")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Outras operações relacionais são utéis para colocar palavras em ordem alfabética:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if palavra &lt; "banana"
    println("Sua palavra, $palavra, vem antes de banana.")
elseif palavra &gt; "banana"
    println("Sua palavra, $palavra, vem depois de banana.")
else
    println("Tudo certo, bananas.")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O Julia não trata letras maiúsculas e minúsculas do mesmo jeito que as pessoas lidam. Todas as letras maiúsculas vem antes de todas as letras minúsculas, então:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Sua palavra, Abacaxi, vem antes de banana.</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Uma maneira comum de resolver este problema é convertendo strings para um formato padrão, como todas minúsculas, antes de efetuar a comparação.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="deb08">Depuração</h3>
<div class="paragraph">
<p>Quando você usa índices para percorrer os valores em uma sequência, é difícil de obter o começo e o fim da travessia direito. Aqui está uma função que deveria comparar duas palavras e retornar <code>true</code> se uma das palavras é o inverso da outra, mas ela contém dois erros:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function é_inversa(palavra1, palavra2)
    if length(palavra1) != length(palavra2)
        return false
    end
    i = firstindex(palavra1)
    j = lastindex(palavra2)
    while j &gt;= 0
        j = prevind(palavra2, j)
        if palavra1[i] != palavra2[j]
            return false
        end
        i = nextind(palavra1, i)
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A primeira declaração <code>if</code> verifica se as palavras são do mesmo tamanho. Se não, nós podemos retornar <code>false</code> imediatamente. Caso contrário, para o resto da função, nós podemos assumir que as palavras são do mesmo tamanho. Isso é um exemplo do padrão guardião.</p>
</div>
<div class="paragraph">
<p><code>i</code> e <code>j</code> são índices: <code>i</code> percorre a <code>palavra1</code> de frente para trás, enquanto <code>j</code> percorre a <code>palavra2</code> de trás para frente. Se nós acharmos duas letras que não são iguais, nós podemos retornar <code>false</code> imediatamente. Se nós passarmos pelo laço inteiro e todas as letras forem iguais, nós retornamos <code>true</code>.</p>
</div>
<div class="paragraph">
<p>A função <code>lastindex</code> retorna o último índice de bytes válido de uma string e <code>prevind</code> o último índice válido de um caractere.</p>
</div>
<div class="paragraph">
<p>Se nós testarmos essa função com as palavras "pare" e "erap", nós esperamos que o valor de retorno seja <code>true</code>, mas nós obtemos <code>false</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; é_inversa("pare", "erap")
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para depurar esse tipo de erro, o primeiro passo é imprimir os valores dos índices:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">    while j &gt;= 0
        j = prevind(palavra2, j)
        @show i j
        if palavra1[i] != palavra2[j]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora quando executamos novamente o programa, obtemos mais informações:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; é_inversa("pare", "erap")
i = 1
j = 3
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Na primeira iteração do laço, o valor de <code>j</code> é 3, que tem que ser 4. Isso pode ser consertado movendo <code>j = prevind(palavra2, j)</code> para o final do laço <code>while</code>.</p>
</div>
<div class="paragraph">
<p>Se consertamos este erro e executarmos novamente o programa, obtemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; é_inversa("pare", "erap")
i = 1
j = 4
i = 2
j = 3
i = 3
j = 2
i = 4
j = 1
i = 5
j = 0
ERROR: BoundsError: attempt to access String
  at index [5]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Desta vez um <code>BoundsError</code> foi gerado. O valor de <code>i</code> é 5, que está fora do alcance para a string <code>"erap"</code>.
</p>
</div>
<div class="sect4">
<h5 id="_exercício_8_6">Exercício 8-6</h5>
<div class="paragraph">
<p>Execute o programa em papel, mudando os valores de <code>i</code> e <code>j</code> durante cada iteração. Encontre e conserte o segundo erro nesta função.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_8">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">sequência</dt>
<dd>
<p>Uma coleção ordenada de valores no qual cada valor é identificado por um índice inteiro.
</p>
</dd>
<dt class="hdlist1">padrão ASCII</dt>
<dd>
<p>Um padrão de codificação de caracteres para comunicação eletrônica que especifica 128 caracteres.
</p>
</dd>
<dt class="hdlist1">padrão Unicode</dt>
<dd>
<p>Um padrão da indústria da computação para a codificação consistente, representação, e tratamento de texto expressado na maioria dos sistemas de escrita do mundo.
</p>
</dd>
<dt class="hdlist1">índice</dt>
<dd>
<p>Um valor inteiro usado para selecionar um item em uma sequência, como um caractere em uma string. Em Julia índices começam em 1.
</p>
</dd>
<dt class="hdlist1">codificação UTF-8</dt>
<dd>
<p>Uma codificação de comprimento variável de caractere capaz de codificar todas as 1112064 pontos de código usando um a quatro bytes de 8-bit.
</p>
</dd>
<dt class="hdlist1">travessia</dt>
<dd>
<p>Iterar sobre os items de uma sequência, realizando operações similares em cada um deles.
</p>
</dd>
<dt class="hdlist1">fatia</dt>
<dd>
<p>Uma parte de uma string especificado por um alcance de índices.
</p>
</dd>
<dt class="hdlist1">string vazia</dt>
<dd>
<p>Uma string sem caracteres e comprimento 0, representada por aspas duplas.
</p>
</dd>
<dt class="hdlist1">imutável</dt>
<dd>
<p>A propriedade de uma sequência no qual seus items não podem ser mudados.
</p>
</dd>
<dt class="hdlist1">interpolação de strings</dt>
<dd>
<p>O processo de avaliar uma string que contém um ou mais espaços reservados, produzindo um resultado no qual os espaços reservados são substituidos por seus valores correspondentes.
</p>
</dd>
<dt class="hdlist1">busca</dt>
<dd>
<p>Um padrão de travessia que para quando acha o que está procurando.
</p>
</dd>
<dt class="hdlist1">contador</dt>
<dd>
<p>Uma variável usada para contar algo, geralmente inicializada para zero e em seguida incrementada.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_9">Exercícios</h3>
<div class="sect4">
<h5 id="ex08-1">Exercício 8-7</h5>
<div class="paragraph">
<p>Leia a documentação das funções de string em <a href="https://docs.julialang.org/en/v1/manual/strings/" class="bare">https://docs.julialang.org/en/v1/manual/strings/</a>. Você talvez queira experimentar algumas delas para garantir que você entende como elas funcionam. <code>strip</code> e <code>replace</code> são particulamente utéis.</p>
</div>
<div class="paragraph">
<p>A documentação usa uma sintaxe que pode ser confusa. Por exemplo, em <code>search(string::AbstractString, chars::Chars, [start::Integer])</code>, os colchetes indicam argumentos opcionais. Então <code>string</code> e <code>chars</code> são obrigatórios, mas <code>start</code> é opcional.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex08-2">Exercício 8-8</h5>
<div class="paragraph">
<p>Existe uma função embutida chamada <code>count</code> que é similar à função em <a href="#looping_and_counting">Realizando Laços e Contando</a>. Leia a documentação desta função e a use para contar o número de <code>a</code>’s em "banana".
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex08-3">Exercício 8-9</h5>
<div class="paragraph">
<p>Uma fatia de string pode receber um terceiro índice. O primeiro especifica o começo, o terceiro o fim e o segundo o “tamanho do passo”; isto é, o número de espaços entre caracteres sucessivos. Um tamanho de passo de 2 significa que andamos de dois em dois; 3 significa de três em três e etc.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fruta = "banana"
"banana"
julia&gt; fruta[1:2:6]
"bnn"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um tamanho de passo -1 percorre a palavra ao contrário, então a fatia <code>[end:-1:1]</code> gera uma string reversa.</p>
</div>
<div class="paragraph">
<p>Use esse idioma para escrever uma versão de uma linha de <code>é_palíndromo</code> do <a href="#ex06-3">Exercício 6-6</a>.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex08-4">Exercício 8-10</h5>
<div class="paragraph">
<p>As seguintes função são todas <em>planejadas</em> para checar se a string contém alguma letra minúscula, mas pelo menos algumas delas estão erradas. Para cada função, descreva o que a função faz de fato (assumindo que o parâmetro é uma string).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function qualquer_minúscula1(s)
    for c in s
        if islowercase(c)
            return true
        else
            return false
        end
    end
end

function qualquer_minúscula2(s)
    for c in s
        if islowercase('c')
            return "true"
        else
            return "false"
        end
    end
end

function qualquer_minúscula3(s)
    for c in s
        flag = islowercase(c)
    end
    flag
end

function qualquer_minúscula4(s)
    flag = false
    for c in s
        flag = flag || islowercase(c)
    end
    flag
end

function qualquer_minúscula5(s)
    for c in s
        if !islowercase(c)
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex08-5">Exercício 8-11</h5>
<div class="paragraph">
<p>Uma cifra de César é uma forma fraca de criptografia que envolve “rotacionar” cada letra por um número fixo de lugares. Rotacionar uma letra significa deslocar ela através do alfabeto, retornando ao começo se necessário, então <code>’A’</code> rotacionada por 3 é <code>’D’</code> e <code>’Z’</code> rotacionada por 1 é <code>’A’</code>.
</p>
</div>
<div class="paragraph">
<p>Para rotacionar uma palavra, rotacione cada letra pelo mesmo valor. Por exemplo <code>"ovo"</code> rotacionado por 16 é <code>"ele"</code> e <code>"teve"</code> rotacionado por 22 é <code>"para"</code>. No filme <em>2001: Odisseia no espaço, o computador de bordo</em> é chamado de HAL, que é IBM rotacionado por -1.</p>
</div>
<div class="paragraph">
<p>Escreva uma função chamada <code>rotacionapalavra</code> que recebe uma string e um inteiro como parâmetros, e retorna uma nova string que contém as letras da string original rotacionada pela inteiro fornecido.
</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Você pode querer usar as funções embutidas <code>Int</code>, que converte um caractere para um código numérico, e <code>Char</code>, que converte códigos numéricos para caracteres. Letras do alfabeto são codificadas em ordem alfabética, então por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; Int('c') - Int('a')
2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por que <code><em>c</em></code> é a terceira letra do alfabeto. Mas tome cuidado: os códigos numéricos para letras maiúsculas são diferentes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; Char(Int('A') + 32)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Piadas potencialmente ofensivas na internet são algumas vezes codificadas em ROT13, que é uma cifra de César com rotação 13. Se você não é facilmente ofendido, encontre e codifique algumas delas.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap09">9. Estudo de Caso: Jogo de Palavras</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo apresenta o segundo estudo de caso, que envolve solucionar um quebra-cabeças onde devemos encontrar palavras com certas propriedades. Por exemplo, encontraremos os palíndromos mais longos em Inglês e as palavras cujas letras aparecem em ordem alfabética. Além disso, apresentaremos outro plano de desenvolvimento de programa: redução até um problema previamente resolvido.</p>
</div>
<div class="sect2">
<h3 id="reading_word_lists">Lendo Listas de Palavras</h3>
<div class="paragraph">
<p>Para os exercícios deste capítulo, será necessária uma lista de palavras em inglês. Existem muitas listas de palavras disponíveis na internet, e a mais adequada para o nosso propósito é uma das listas de palavras coletadas e disponibilizadas em domínio público por Grady Ward como parte do projeto léxico da Moby (consulte <a href="https://wikipedia.org/wiki/Moby_Project" class="bare">https://wikipedia.org/wiki/Moby_Project</a>). É uma lista com 113.809 palavras cruzadas oficiais; isto é, termos considerados válidos em palavras cruzadas e outros jogos com palavras. Na coleção de Moby, o nome do arquivo é <em>113809of.fic</em> e você pode fazer o download de uma cópia, com o nome mais simples <em>palavras.txt</em>, em <a href="https://github.com/JuliaIntro/JuliaIntroBR.jl/blob/master/data/palavras.txt" class="bare">https://github.com/JuliaIntro/JuliaIntroBR.jl/blob/master/data/palavras.txt</a>.
</p>
</div>
<div class="paragraph">
<p>Este arquivo está em texto não formatado e portanto, pode ser aberto com um editor de texto, inclusive também pode ser lido em Julia. A função interna <code>open</code> precisa receber o nome do arquivo como parâmetro e retorna um <em>fluxo (stream) de arquivo</em> usado para a leitura do arquivo.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; arquivo_entrada = open("palavras.txt")
IOStream(&lt;file palavras.txt&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>arquivo_entrada</code> é um fluxo de arquivo usado para a entrada de dados e quando não for mais necessário, deve ser fechado com <code>close(arquivo_entrada)</code>.</p>
</div>
<div class="paragraph">
<p>O Julia fornece várias funções para leitura, como a <code>readline</code>, que lê os caracteres do arquivo até chegar a um comando de <code>nova linha</code> e retorna o resultado como uma string:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; readline(arquivo_entrada)
"aa"</code></pre>
</div>
</div>
<div class="paragraph">
<p>A primeira palavra em Inglês nesta lista especial é "aa", que é uma espécie de lava.</p>
</div>
<div class="paragraph">
<p>O fluxo de arquivo monitora sua localização no arquivo; portanto, se chamarmos novamente o comando readline, recebemos a próxima palavra:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; readline(arquivo_entrada)
"aah"</code></pre>
</div>
</div>
<div class="paragraph">
<p>O termo subsequente em inglês é "aah", que é uma palavra perfeitamente legítima, então pare de me olhar desse jeito.</p>
</div>
<div class="paragraph">
<p>Você também pode usar um objeto de arquivo em um laço <code>for</code>. Este programa lê <code>palavras.txt</code> e imprime cada palavra, uma por linha:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for linha in eachline("palavras.txt")
    println(linha)
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_10">Exercícios</h3>
<div class="sect4">
<h5 id="ex09-1">Exercício 9-1</h5>
<div class="paragraph">
<p>Escreva um programa que leia <code>palavras.txt</code> e imprima somente as palavras com mais de 20 caracteres (sem contar os espaços em branco).</p>
</div>
</div>
<div class="sect4">
<h5 id="ex09-2">Exercício 9-2</h5>
<div class="paragraph">
<p>Em 1939, Ernest Vincent Wright publicou um romance de 50.000 palavras chamado Gadsby que não contém a letra <code><em>e</em></code>. Como <code><em>e</em></code> é a letra mais usada em inglês, escrever um romance assim não é fácil.
</p>
</div>
<div class="paragraph">
<p>De fato, é difícil elaborar um único pensamento sem conter essa letra mais usada. É lento no início, mas com cautela e horas de treinamento, você pode gradualmente aprimorar essa habilidade até ficar mais fácil. Em Inglês, este parágrafo não contém a letra e.</p>
</div>
<div class="paragraph">
<p>Tudo bem, vou parar agora.</p>
</div>
<div class="paragraph">
<p>Escreva uma função chamada <code>sem_e</code> que informa <code>true</code> se a palavra especificada não contém a letra <code><em>e</em></code>.
</p>
</div>
<div class="paragraph">
<p>Altere o programa que você acabou de escrever para que ele imprima apenas as palavras que não possuem <code><em>e</em></code> e informe a porcentagem de palavras na lista que não possuem <code><em>e</em></code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex09-3">Exercício 9-3</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>evita</code> que recebe uma palavra e uma string de letras proibidas e devolve <code>true</code> se a palavra não contém nenhuma das letras proibidas.
</p>
</div>
<div class="paragraph">
<p>Modifique o seu programa para receber uma string de letras proibidas digitada pelo usuário e imprimir o número de palavras que não contêm nenhuma dessas letras. Você consegue encontrar uma combinação de 5 letras proibidas que exclua a menor quantidade de palavras?</p>
</div>
</div>
<div class="sect4">
<h5 id="ex09-4">Exercício 9-4</h5>
<div class="paragraph">
<p>Escreva uma função denominada <code>usa_somente</code> que recebe uma palavra e uma string de letras e devolve <code>true</code> se a palavra contém apenas as letras da string. Você pode fazer uma frase usando apenas as letras <code>acefhlo</code>? Uma diferente de "Hoe alfafa?"
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex09-5">Exercício 9-5</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>usa_todas</code> que recebe uma palavra e uma string de letras obrigatórias, e devolve <code>true</code> se a palavra usar todas as letras obrigatórias ao menos uma vez. Quantas palavras existem que usam todas as vogais <code>aeiou</code>? E que tal <code>aeiouy</code>?
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex09-6">Exercício 9-6</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>é_abecedário</code> que retorna <code>true</code> se as letras em uma palavra aparecem em ordem alfabética (letras repetidas não são um problema). Quantas palavras em ordem alfabética existem?
</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search">Busca</h3>
<div class="paragraph">
<p>Todos os exercícios da seção anterior têm algo em comum; eles podem ser resolvidos por meio de um padrão de busca. O exemplo mais simples é:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function sem_e(palavra)
    for letra in palavra
        if letra == 'e'
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O laço <code>for</code> percorre os caracteres das palavras. Se encontrarmos a letra <code><em>e</em></code>, podemos retornar imediatamente <code>false</code>; caso contrário, temos que avançar para a próxima letra. Se sairmos do laço do modo convencional, isso significa que não encontramos um <code><em>e</em></code>, por isso retornamos <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Você poderia escrever esta função de forma mais sucinta usando o operador <code>∉</code> (<strong><code>\notin TAB</code></strong>), mas comecei com essa versão porque ela mostra a lógica do padrão de busca.
</p>
</div>
<div class="paragraph">
<p><code>evita</code> é uma versão mais geral do <code>sem_e</code>, apesar de ter a mesma estrutura:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function evita(palavra, proibido)
    for letra in palavra
        if letra ∈ proibido
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Devolvemos <code>false</code> assim que encontrarmos uma letra proibida e se chegarmos ao final do laço, retornamos <code>true</code>.</p>
</div>
<div class="paragraph">
<p><code>usa_somente</code> é parecido, exceto que o sentido da condição se inverte:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function usa_somente(palavra, válido)
    for letra in palavra
        if letra ∉ válido
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ao invés de uma lista de letras proibidas, temos uma série de letras válidas. Se encontrarmos uma letra em <code>palavra</code> que não seja <code>válida</code>, então podemos retornar <code>false</code>.</p>
</div>
<div class="paragraph">
<p><code>usa_todas</code> é similar, exceto que invertemos a posição da palavra e a sequência de letras:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function usa_todas(palavra, obrigatória)
    for letra in obrigatória
        if letra ∉ palavra
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em vez de percorrer as letras nas palavras, o laço percorre as letras obrigatórias. Se alguma das letras obrigatórias não aparecer na palavra, então retornamos <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Se você estivesse realmente pensando como um cientista da computação, você teria identificado que <code>usa_todas</code> era um caso de um problema previamente solucionado e teria escrito:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function usa_todas(palavra, obrigatórias)
    usa_somente(obrigatória, palavra)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este é um exemplo de um plano de desenvolvimento para um programa chamado <em>redução para um problema previamente resolvido</em>, no qual você reconhece o problema em que está trabalhando como uma instância de um problema resolvido e aplica uma solução existente.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_laço_com_índices">Laço com Índices</h3>
<div class="paragraph">
<p>Escrevi as funções da seção anterior com laços <code>for</code> porque só precisava dos caracteres nas strings, sem precisar operar com os índices.</p>
</div>
<div class="paragraph">
<p>Em <code>é_abecedário</code>, temos que comparar letras adjacentes, o que é um pouco trabalhoso com um laço <code>for</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function é_abecedário(palavra)
    i = firstindex(palavra)
    anterior = palavra[i]
    j = nextind(palavra, i)
    for c in palavra[j:end]
        if c &lt; anterior
            return false
        end
        anterior = c
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma alternativa é usar a recursão:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function é_abecedário(palavra)
    if length(palavra) &lt;= 1
        return true
    end
    i = firstindex(palavra)
    j = nextind(palavra, i)
    if palavra[i] &gt; palavra[j]
        return false
    end
    é_abecedário(palavra[j:end])
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma outra opção é usar um laço <code>while</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function é_abecedário(palavra)
    i = firstindex(palavra)
    j = nextind(palavra, 1)
    while j &lt;= sizeof(palavra)
        if palavra[j] &lt; palavra[i]
            return false
        end
        i = j
        j = nextind(palavra, i)
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O laço começa em <code>i=1</code> e <code>j=nextind(palavra, 1)</code> e termina quando <code>j&gt;sizeof(palavra)</code>. A cada iteração no laço, ele compara o <code>i</code>-ésimo caractere (que você pode pensar como sendo o caractere atual) com o <code>j</code>-ésimo caractere (que você pode pensar como o próximo).</p>
</div>
<div class="paragraph">
<p>Se a posição do próximo caractere é alfabeticamente antecedente à posição do caractere atual, descobrimos uma quebra na tendência alfabética e retornamos <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Ao chegarmos ao final do laço sem uma falha, então a palavra passa no teste. Para se convencer de que o laço termina corretamente, considere a palavra <code>"acenos"</code> como um exemplo.</p>
</div>
<div class="paragraph">
<p>Aqui está uma versão de <code>é_palíndromo</code> que usa dois índices; um está no início e sobe, e o outro está no final e desce.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function é_palíndromo(palavra)
    i = firstindex(palavra)
    j = lastindex(palavra)
    while i&lt;j
        if palavra[i] != palavra[j]
            return false
        end
        i = nextind(palavra, i)
        j = prevind(palavra, j)
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ou podemos fazer a redução para um problema resolvido anteriormente e escrever:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function é_palíndromo(palavra)
    é_inversa(palavra, palavra)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>usando <code>é_inversa</code> de <a href="#deb08">Depuração</a>.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_depuração_7">Depuração</h3>
<div class="paragraph">
<p>Testar programas é difícil. As funções neste capítulo são relativamente fáceis de testar já que você pode verificar os resultados manualmente. Mesmo assim, é difícil ou impossível escolher um conjunto de palavras para testar todos os erros possíveis.
</p>
</div>
<div class="paragraph">
<p>Selecionando <code>sem_e</code> como exemplo, há dois casos óbvios a serem avaliados: palavras com <code><em>e</em></code> devem retornar <code>false</code> e palavras sem <code><em>e</em></code> devem retornar <code>true</code>. Não vai ser difícil encontrar um exemplo de cada.</p>
</div>
<div class="paragraph">
<p>Dentro de cada caso, existem subcasos menos óbvios. Entre as palavras que possuem um "e", você deve testar as palavras com "e" no início, no final e em algum lugar no meio. Devem-se testar palavras longas, curtas e muito curtas, como a string vazia. A string vazia é um exemplo de um <em>caso especial</em>, que é um dos casos não óbvios onde geralmente os erros se ocultam.
</p>
</div>
<div class="paragraph">
<p>Além dos casos de teste gerados, você também pode testar seu programa com uma lista de palavras como <code>palavras.txt</code>. Ao avaliar a saída, podem-se detectar erros, mas tenha cuidado: você pode encontrar um tipo de erro (palavras que não devem ser incluídas, mas são) e não o outro tipo (palavras que devem ser incluídas, mas não são).</p>
</div>
<div class="paragraph">
<p>Em geral, o teste pode te ajudar a encontrar bugs, embora não seja fácil gerar um bom conjunto de casos de teste e, mesmo que você consiga, não é possível ter certeza de que seu programa está correto. De acordo com um lendário cientista da computação:
</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Testar programas pode ser usado para mostrar a presença de bugs, mas nunca para mostrar a ausência deles!</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Edsger W. Dijkstra
</div>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_9">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">fluxo de arquivo</dt>
<dd>
<p>Um valor que representa um arquivo aberto.
</p>
</dd>
<dt class="hdlist1">redução a um problema previamente resolvido</dt>
<dd>
<p>Uma maneira de resolver um problema, tratando-o como um caso de um problema resolvido anteriormente.
</p>
</dd>
<dt class="hdlist1">caso especial</dt>
<dd>
<p>Um caso de teste que é atípico ou que não é óbvio (e com menor chance de ser abordado corretamente).
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_11">Exercícios</h3>
<div class="sect4">
<h5 id="ex09-7">Exercício 9-7</h5>
<div class="paragraph">
<p>Esta pergunta é baseada em um quebra-cabeças que foi transmitido no programa de rádio chamado <em>Car Talk</em> (<a href="https://www.cartalk.com/puzzler/browse" class="bare">https://www.cartalk.com/puzzler/browse</a>):
</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Diga-me uma palavra com três letras duplas consecutivas. Darei a você algumas palavras que quase se qualificam, mas não são. Por exemplo, a palavra committee (comitê em inglês), c-o-m-m-i-t-t-e-e. Seria ótimo, exceto pelo <em>i</em> que está infiltrado na palavra. Ou Mississippi: M-i-s-s-i-s-s-i-p-p-i. Se você pudesse tirar aqueles i&#8217;s, funcionaria. Mas há uma palavra que possui três pares consecutivos de letras e, pelo que sei, essa pode ser a única palavra. Claro que há provavelmente mais 500, mas só consigo pensar em uma. Qual é a palavra?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Escreva um programa para encontrar essa palavra em Inglês.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex09-8">Exercício 9-8</h5>
<div class="paragraph">
<p>Aqui está outro desafio de <em>Car Talk</em> (<a href="https://www.cartalk.com/puzzler/browse" class="bare">https://www.cartalk.com/puzzler/browse</a>):</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Eu estava dirigindo na estrada outro dia e notei meu odômetro. Conforme a maioria dos odômetros, seis dígitos são mostrados, em milhas inteiras. Por exemplo, se meu carro tivesse percorrido 300.000 milhas, então eu veria 3-0-0-0-0-0.</p>
</div>
<div class="paragraph">
<p>Agora, o que vi naquele dia foi muito interessante. Percebi que os últimos quatro dígitos eram palíndromos; ou seja, eles são lidos tanto para a frente como para trás. Por exemplo, 5-4-4-5 é um palíndromo, então meu odômetro poderia ter lido 3-1-5-4-4-5.</p>
</div>
<div class="paragraph">
<p>Uma milha depois, os últimos 5 números se tornaram um palíndromo. Por exemplo, poderia ter lido 3-6-5-4-5-6. Uma milha depois disso, os 4 dos 6 números do meio formaram um palíndromo. E você está pronto para isso? Uma milha depois, todos os 6 se tornaram um palíndromo!</p>
</div>
<div class="paragraph">
<p>A pergunta é, qual o número que estava no odômetro quando olhei pela primeira vez?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Escreva um programa em Julia que teste todos os números de seis dígitos e mostre qualquer número que atenda esses requisitos.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex09-9">Exercício 9-9</h5>
<div class="paragraph">
<p>Eis um outro desafio <em>Car Talk</em> que você pode resolver com uma busca (<a href="https://www.cartalk.com/puzzler/browse" class="bare">https://www.cartalk.com/puzzler/browse</a>):</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Recentemente, visitei minha mãe e percebemos que os dois dígitos que compõem minha idade quando trocados resultavam em sua idade. Por exemplo, se ela tem 73 anos, tenho 37 anos. Imaginávamos com que frequência isso acontecia ao longo dos anos, mas acabamos mudamos de assunto e nunca chegamos a uma resposta.</p>
</div>
<div class="paragraph">
<p>Quando cheguei em casa, descobri que os dígitos de nossas idades foram trocados seis vezes até agora. Também descobri que, se tivermos sorte, isso acontecerá novamente em alguns anos, e se tivermos muita sorte, isso acontecerá mais uma vez depois disso. Ou seja, isso teria acontecido oito vezes. Então a pergunta é: qual a minha idade agora?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Escreva um programa em Julia que procure as soluções deste desafio.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>A função <code>lpad</code> pode ser útil para você.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap10">10. Listas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo apresenta um dos tipos internos mais úteis do Julia, as listas. Você também aprenderá sobre objetos e o que pode acontecer quando se tem mais de um nome para o mesmo objeto.</p>
</div>
<div class="sect2">
<h3 id="_uma_lista_é_uma_sequência">Uma Lista é uma Sequência</h3>
<div class="paragraph">
<p>Assim como uma string, uma <em>lista</em> é uma sequência de valores. Em uma string, os valores são caracteres; em uma lista, eles podem ser de qualquer tipo. Os valores de uma lista são chamados de <em>elementos</em> ou por vezes <em>itens</em>.
</p>
</div>
<div class="paragraph">
<p>Existem diversas maneiras de criar uma nova lista; a mais simples é inserir os elementos entre colchetes (<code>[ ]</code>), da seguinte forma:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">[10, 20, 30, 40]
["sapo", "coelho", "aranha"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>O primeiro exemplo é uma lista de quatro inteiros. O segundo é uma lista de três strings. Os elementos de uma lista não precisam ser do mesmo tipo. A seguinte lista contém uma string, um float, um inteiro e uma outra lista:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">["bruxa", 2.0, 5, [10, 20]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma lista dentro de outra lista é dita <em>aninhada</em>.
</p>
</div>
<div class="paragraph">
<p>Uma lista que não contém elementos é chamada de lista vazia; você pode criar uma lista vazia com colchetes vazios, <code>[]</code>.
</p>
</div>
<div class="paragraph">
<p>Como esperado, podemos atribuir valores de listas a variáveis:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; vegetais = ["Cenoura", "Brócolis", "Alface"];

julia&gt; números = [42, 123];

julia&gt; vazia = [];

julia&gt; print(vegetais, " ", números, " ", vazia)
["Cenoura", "Brócolis", "Alface"] [42, 123] Any[]</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função <code>typeof</code> pode ser usada para encontrar o tipo de lista:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; typeof(vegetais)
Array{String,1}
julia&gt; typeof(números)
Array{Int64,1}
julia&gt; typeof(vazia)
Array{Any,1}</code></pre>
</div>
</div>
<div class="paragraph">
<p>O tipo de lista é especificado entre as chaves e é composto por um tipo e um número. O número indica as dimensões. A lista <code>vazia</code> contém valores do tipo <code>Any</code>., isto é, ela pode conter valores de todos os tipos.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_listas_são_mutáveis">Listas são Mutáveis</h3>
<div class="paragraph">
<p>A sintaxe para acessar elementos de uma lista é a mesma para acessar caracteres de uma string com o operador colchetes. A expressão dentro dos colchetes especifica o índice. Lembre-se que o índice começa em 1:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; vegetais[1]
"Cenoura"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ao contrário de strings, listas são <em>mutáveis</em>. Quando os colchetes aparecem no lado esquerdo de uma atribuição, eles identificam o elemento da lista que será atribuido:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; números[2] = 5
5
julia&gt; print(números)
[42, 5]</code></pre>
</div>
</div>
<div class="paragraph">
<p>O segundo elemento de <code>números</code>, que costumava ser 123, agora é 5.</p>
</div>
<div class="paragraph">
<p><a href="#fig10-1">Diagrama de estado</a> mostra o diagrama de estado para <code>vegetais</code>, <code>números</code> e <code>vazia</code>.
</p>
</div>
<div id="fig10-1" class="imageblock">
<div class="content">
<img src="images/fig101.svg" alt="fig101">
</div>
<div class="title">Figura 11. Diagrama de estado</div>
</div>
<div class="paragraph">
<p>Uma lista é representada por uma caixa e pelos elementos da lista dentro dela. <code>vegetais</code> refere-se a uma lista com três elementos indexados <code>1</code>, <code>2</code> e <code>3</code>. <code>números</code> contém dois elementos; o diagrama mostra que o valor do segundo elemento foi reatribuído de <code>123</code> para <code>7</code>. <code>vazia</code> refere-se a uma lista sem elementos.</p>
</div>
<div class="paragraph">
<p>Os índices das listas funcionam do mesmo jeito que os índices de strings (mas sem as ressalvas do UTF-8):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Qualquer expressão inteira pode ser utilizada como um índice.</p>
</li>
<li>
<p>Se você tentar ler ou escrever um elemento que não existe, um <code>BoundsError</code> (erro de limites) será gerado.</p>
</li>
<li>
<p>A palavra-chave <code>end</code> aponta para o último índice da lista.
</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>O operador <code>∈</code> também funciona em listas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; "Cenoura" ∈ vegetais
true
julia&gt; "Beterraba" in vegetais
false</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_percorrendo_uma_lista">Percorrendo uma Lista</h3>
<div class="paragraph">
<p>A maneira mais comum de percorrer os elementos de uma lista é através de um laço <code>for</code>. A sintaxe é a mesma para strings:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for vegetal in vegetais
    println(vegetal)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isso funciona bem se você precisa apenas ler os elementos de uma lista. Mas se você deseja escrever ou atualizar os elementos, você precisa dos índices. Um jeito comum de fazer isto é utilizando a função interna <code>eachindex</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for i in eachindex(números)
    números[i] = números[i] * 2
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse laço percorre a lista e atualiza cada elemento. <code>length</code> retorna o número de elementos de uma lista. Toda vez que o laço é percorrido, <code>i</code> obtém o índice do próximo elemento. O comando de atribuição no corpo usa <code>i</code> para ler o valor antigo do elemento e atribuir ao novo valor:</p>
</div>
<div class="paragraph">
<p>Utilizar o laço <code>for</code> sobre uma lista vazia nunca executa o corpo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for x in []
    println("Isso nunca acontecerá.")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Embora uma lista possa conter outra lista, a lista aninhada ainda conta como um único elemento. O comprimento dessa lista é quatro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">["spam", 1, ["João", "Pedro", "Gabriel"], [1, 2, 3]]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_operador_de_fatias">Operador de Fatias</h3>
<div class="paragraph">
<p>O operador de fatias também funciona para listas.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'b', 'c', 'd', 'e', 'f'];

julia&gt; print(t[1:3])
['a', 'b', 'c']
julia&gt; print(t[3:end])
['c', 'd', 'e', 'f']</code></pre>
</div>
</div>
<div class="paragraph">
<p>O operador de fatia <code>[:]</code>, faz uma cópia de toda a lista:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; print(t[:])
['a', 'b', 'c', 'd', 'e', 'f']</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como as listas são mutáveis, geralmente é útil fazer uma cópia antes de executar operações que modificam listas.</p>
</div>
<div class="paragraph">
<p>O operador de fatias no lado esquerdo de uma atribuição pode atualizar múltiplos elementos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t[2:3] = ['x', 'y'];

julia&gt; print(t)
['a', 'x', 'y', 'd', 'e', 'f']</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_biblioteca_de_listas">Biblioteca de Listas</h3>
<div class="paragraph">
<p>O Julia fornece funções que operam com listas. Por exemplo, <code>push!</code> adiciona um novo elemento ao final de uma lista:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; push!(t, 'd');

julia&gt; print(t)
['a', 'b', 'c', 'd']</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>append!</code> adiciona os elementos da segunda lista ao final da primeira:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t1 = ['a', 'b', 'c'];

julia&gt; t2 = ['d', 'e'];

julia&gt; append!(t1, t2);

julia&gt; print(t1)
['a', 'b', 'c', 'd', 'e']</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse exemplo deixa <code>t2</code> sem modificações.</p>
</div>
<div class="paragraph">
<p><code>sort!</code> organiza os elementos da lista do menor para o maior:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['d', 'c', 'e', 'b', 'a'];

julia&gt; sort!(t);

julia&gt; print(t)
['a', 'b', 'c', 'd', 'e']</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>sort</code> retorna uma cópia dos elementos da lista em ordem:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t1 = ['d', 'c', 'e', 'b', 'a'];

julia&gt; t2 = sort(t1);

julia&gt; print(t1)
['d', 'c', 'e', 'b', 'a']
julia&gt; print(t2)
['a', 'b', 'c', 'd', 'e']</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Nota</div>
</td>
<td class="content">
<div class="paragraph">
<p>Por convenção, no Julia <code>!</code> é anexado a nomes de funções que modificam seus argumentos.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_mapeamento_filtro_e_redução">Mapeamento, Filtro e Redução</h3>
<div class="paragraph">
<p>Para somar todos os números de uma lista, podemos utilizar um laço da seguinte forma:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function soma_todos(t)
    total = 0
    for x in t
        total += x
    end
    total
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>total</code> é iniciado em 0. Toda vez que o laço é percorrido, <code>+=</code> captura um elemento da lista. O operador <code>+=</code> fornece um jeito fácil de atualizar uma variável. Esse <em>comando de atribuição aumentada</em>,
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">total += x</code></pre>
</div>
</div>
<div class="paragraph">
<p>é equivalente a</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">total = total + x</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quando o laço é iniciado, <code>total</code> acumula a soma dos elementos; uma variável usada dessa maneira é chamada de <em>acumuladora</em>.
</p>
</div>
<div class="paragraph">
<p>Adicionar elementos de uma lista é uma operação tão comum que o Julia fornece uma função interna, <code>sum</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [1, 2, 3, 4];

julia&gt; sum(t)
10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma operação como essa que combina uma sequência de elementos a um único valor por vezes é chamada de <em>operação de redução</em>.
</p>
</div>
<div class="paragraph">
<p>Muitas vezes, você deseja percorrer uma lista enquanto cria outra. Por exemplo, a função à seguir recebe uma lista de strings e retorna uma nova lista que contém as strings com todos os seus caracteres maiúsculos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function todas_maiúsculas(t)
    res = []
    for s in t
        push!(res, uppercase(s))
    end
    res
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>res</code> é inicializada com uma lista vazia; toda vez que laço é percorrido, anexamos o próximo elemento. Então, <code>res</code> é outro tipo de acumulador.</p>
</div>
<div class="paragraph">
<p>Uma operação como <code>todas_maiúsculas</code> é por vezes chamado de <em>mapa</em> pois “mapeia” uma função (neste caso <code>uppercase</code>) a cada um dos elementos em uma sequência.
</p>
</div>
<div class="paragraph">
<p>Outro tipo comum de operação é selecionar alguns dos elementos de uma lista e retornar uma sublista. Por exemplo, a seguinte função recebe uma lista de strings e retorna uma lista que contém apenas as strings com letras maiúsculas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function apenas_maiúsculas(t)
    res = []
    for s in t
        if s == uppercase(s)
            push!(res, s)
        end
    end
    res
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma operação como <code>apenas_maiúsculas</code> é chamada de <em>filtro</em> pois seleciona alguns dos elementos e filtra outros.
</p>
</div>
<div class="paragraph">
<p>Operações mais comuns de listas podem ser expressas como uma combinação de mapeamento, filtro e redução.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sintaxe_do_ponto">Sintaxe do Ponto</h3>
<div class="paragraph">
<p>Para cada operador binário como <code>^</code>, existe um <em>operador ponto</em> <code>.^</code> correspondente que é automaticamente definido para efetuar <code>^</code> elemento-a-elemento em listas. Por exemplo, <code>&#91;1, 2, 3&#93; ^ 3</code> não é definido, mas <code>&#91;1, 2, 3&#93; .^ 3</code> é definido como calcular elemento a elemento o resultado <code>&#91;1^3, 2^3, 3^3&#93;</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; print([1, 2, 3] .^ 3)
[1, 8, 27]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Qualquer função <code>f</code> do Julia pode ser aplicada elemento a elemento à qualquer lista com a <em>sintaxe do ponto</em>. Por exemplo, para deixar uma lista de strings com todas as strings em letra maiúscula, não precisamos explicitar o laço:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = uppercase.(["abc", "def", "ghi"]);

julia&gt; print(t)
["ABC", "DEF", "GHI"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse é um jeito elegante de criar mapeamentos. A função <code>todas_maiúsculas</code> pode ser implementada em uma única linha:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function todas_maiúsculas(t)
    uppercase.(t)
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_deletando_inserindo_elementos">Deletando (Inserindo) Elementos</h3>
<div class="paragraph">
<p>Existem várias maneiras de deletar elementos de uma lista. Se você sabe o índice do elemento que você precisa, você pode usar <code>splice!</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; splice!(t, 2)
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)
julia&gt; print(t)
['a', 'c']</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>splice!</code> modifica a lista e retorna o elemento que foi removido.</p>
</div>
<div class="paragraph">
<p><code>pop!</code> deleta e retorna o último elemento:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; pop!(t)
'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)
julia&gt; print(t)
['a', 'b']</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>popfirst!</code> deleta e retorna o primeiro elemento:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; popfirst!(t)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
julia&gt; print(t)
['b', 'c']</code></pre>
</div>
</div>
<div class="paragraph">
<p>As funções <code>pushfirst!</code> e <code>push!</code> inserem, respectivamente, um elemento no início e no fim de uma lista.
</p>
</div>
<div class="paragraph">
<p>Se você não precisa do valor removido, você pode usar a função <code>deleteat!</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; print(deleteat!(t, 2))
['a', 'c']</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função <code>insert!</code> insere um elemento em um índice dado:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; print(insert!(t, 2, 'x'))
['a', 'x', 'b', 'c']</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_listas_e_strings">Listas e Strings</h3>
<div class="paragraph">
<p>Uma string é uma sequência de caracteres e uma lista é uma sequência de valores, mas uma lista de caracteres não é o mesmo que uma string. Para converter uma string em uma lista de caracteres, você pode usar a função <code>collect</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = collect("spam");

julia&gt; print(t)
['s', 'p', 'a', 'm']</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função <code>collect</code> divide uma sequência ou outra sequêcia em elementos individuais.</p>
</div>
<div class="paragraph">
<p>Se você quer dividir uma string em palavras, você pode usar a função <code>split</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = split("vim lhe trazer este humilde presente");

julia&gt; print(t)
SubString{String}["vim", "lhe", "trazer", "este", "humilde", "presente"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um <em>argumento opcional</em> chamado <em>delimitador</em> especifica quais caracteres devem ser usados como limites de palavras. Os seguintes exemplos usam um hífen como um delimitador:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = split("mayday-mayday-mayday", '-');

julia&gt; print(t)
SubString{String}["mayday", "mayday", "mayday"]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>join</code> é o inverso de <code>split</code>. Ela recebe uma lista de strings e concatena os elementos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ["vim", "lhe", "trazer", "este", "humilde", "presente"];

julia&gt; s = join(t, ' ')
"vim lhe trazer este humilde presente"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Neste caso o delimitador é um caractere de espaço. Para concatenar strings sem espaços, você não precisa especificar um delimitador.</p>
</div>
</div>
<div class="sect2">
<h3 id="_objetos_e_valores">Objetos e Valores</h3>
<div class="paragraph">
<p>Um <em>objeto</em> é algo que uma variável pode se referir a. Até agora, você poderia usar “objeto” e “valor” sem distinção.
</p>
</div>
<div class="paragraph">
<p>Se você executar estes comandos de atribuições:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">a = "banana"
b = "banana"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sabemos que ambas <code>a</code> e <code>b</code> referem-se a uma string, mas não sabemos se eles referem à <em>mesma</em> string. Existem dois estados possíveis, mostrados na Figura 10-2.
</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/fig102.svg" alt="fig102">
</div>
<div class="title">Figura 12. Diagrama de estado</div>
</div>
<div class="paragraph">
<p>Em um caso, <code>a</code> e <code>b</code> referem-se a dois objetos diferentes que possuem o mesmo valor. No segundo caso, elas referem-se ao mesmo objeto.</p>
</div>
<div class="paragraph">
<p>Para verificar se duas variáveis referem-se ao mesmo objeto, você pode usar o operador <code>≡</code> (<strong><code>\equiv TAB</code></strong>) ou <code>===</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = "banana"
"banana"
julia&gt; b = "banana"
"banana"
julia&gt; a ≡ b
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nesse exemplo, o Julia apenas criou um objeto string, e ambos <code>a</code> e <code>b</code> referem-se a ele. Mas quando você cria duas listas, você obtém dois objetos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = [1, 2, 3];

julia&gt; b = [1, 2, 3];

julia&gt; a ≡ b
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Portanto, o diagrama de estado se parece com <a href="#fig10-3">Diagrama de estado</a>.
</p>
</div>
<div id="fig10-3" class="imageblock">
<div class="content">
<img src="images/fig103.svg" alt="fig103">
</div>
<div class="title">Figura 13. Diagrama de estado</div>
</div>
<div class="paragraph">
<p>Nesse caso poderíamos dizer que as duas listas são <em>equivalentes</em>, porque possuem os mesmos elementos, mas não <em>idênticos</em>, porque elas não são o mesmo objeto. Se dois objetos são idênticos, eles também são equivalentes, mas se eles são equivalentes, eles não necessariamente são idênticos.
</p>
</div>
<div class="paragraph">
<p>Para sermos mais precisos, um objeto possui um valor. Se você avaliar <code>[1, 2, 3]</code>, você obterá um objeto lista cujo o valor é uma sequência de inteiros. Se uma outra lista possuir os mesmos elementos, dizemos que eles tem os mesmos valores, mas que não são o mesmo objeto.</p>
</div>
</div>
<div class="sect2">
<h3 id="_alias">Alias</h3>
<div class="paragraph">
<p>Se <code>a</code> refere-se a um objeto e você atribuir <code>b = a</code>, então ambas variáveis irão se referir ao mesmo objeto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = [1, 2, 3];

julia&gt; b = a;

julia&gt; b ≡ a
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>O diagrama de estado se parece com <a href="#fig10-4">Diagrama de estado</a>.</p>
</div>
<div id="fig10-4" class="imageblock">
<div class="content">
<img src="images/fig104.svg" alt="fig104">
</div>
<div class="title">Figura 14. Diagrama de estado</div>
</div>
<div class="paragraph">
<p>A associação de uma variável com um objeto é chamado de <em>referência</em>. Nesse exemplo, existem duas referências ao mesmo objeto.
</p>
</div>
<div class="paragraph">
<p>Um objeto com mais de uma referência contém mais de um nome, dizemos então que esse objeto é um <em>alias</em>.
</p>
</div>
<div class="paragraph">
<p>Se um objeto alias for mutável, as alterações feitas com um alias afetam o outro:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; b[1] = 42
42
julia&gt; print(a)
[42, 2, 3]</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Atenção</div>
</td>
<td class="content">
<div class="paragraph">
<p>Embora esse comportamento possa ser útil, está propenso a erros. Em geral, é mais seguro evitar alias quando você estiver trabalhando com objetos mutáveis.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Para objetos imutáveis, como strings, o alias não é um problema. Neste exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">a = "banana"
b = "banana"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quase nunca faz diferença se <code>a</code> e <code>b</code> referem-se a mesma string ou não.</p>
</div>
</div>
<div class="sect2">
<h3 id="_argumentos_de_listas">Argumentos de Listas</h3>
<div class="paragraph">
<p>Quando você passa uma lista para uma função, a função recebe uma referência para a lista. Se a função modifica a lista, quem chama nota a diferença. Por exemplo, <code>deleta_cabeça!</code> remove o primeiro elemento de uma lista:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function deleta_cabeça!(t)
    popfirst!(t)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Segue abaixo como isto é utilizado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; letras = ['a', 'b', 'c'];

julia&gt; deleta_cabeça!(letras);

julia&gt; print(letras)
['b', 'c']</code></pre>
</div>
</div>
<div class="paragraph">
<p>O parâmetro <code>t</code> e a variável <code>letras</code> são alias para o mesmo objeto. O diagrama de estado se parece com a <a href="#fig10-5">Diagrama de estado</a>.
</p>
</div>
<div id="fig10-5" class="imageblock">
<div class="content">
<img src="images/fig105.svg" alt="fig105">
</div>
<div class="title">Figura 15. Diagrama de estado</div>
</div>
<div class="paragraph">
<p>Já que a lista é compartilhada por dois quadros, eu a desenhei entre eles.</p>
</div>
<div class="paragraph">
<p>É importante distinguir operações que modificam listas de operações que criam novas listas. Por exemplo, <code>push!</code> modifica uma lista, mas <code>vcat</code> cria uma nova lista.
</p>
</div>
<div class="paragraph">
<p>Aqui vai um exemplo usando <code>push!</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t1 = [1, 2];

julia&gt; t2 = push!(t1, 3);

julia&gt; print(t1)
[1, 2, 3]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>t2</code> é um alias de <code>t1</code>.</p>
</div>
<div class="paragraph">
<p>E aqui, um exemplo de <code>vcat</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t3 = vcat(t1, [4]);

julia&gt; print(t1)
[1, 2, 3]
julia&gt; print(t3)
[1, 2, 3, 4]</code></pre>
</div>
</div>
<div class="paragraph">
<p>O resultado de <code>vcat</code> é uma nova lista e a lista original permanece inalterada.</p>
</div>
<div class="paragraph">
<p>Essa diferença é importante quando você escreve funções que devem modificar listas.</p>
</div>
<div class="paragraph">
<p>Por exemplo, essa função <em>não</em> deleta a cabeça de uma lista:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function não_deleta_cabeça(t)
    t = t[2:end]                # ERRADO!
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O operador de fatia cria uma nova lista e a atribuição faz com que <code>t</code> se refira a ela, mas isso não afeta quem a chama.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t4 = não_deleta_cabeça(t3);

julia&gt; print(t3)
[1, 2, 3, 4]
julia&gt; print(t4)
[2, 3, 4]</code></pre>
</div>
</div>
<div class="paragraph">
<p>No início de <code>não_deleta_cabeça</code>, <code>t</code> e <code>t3</code> referem-se à mesma lista. No final, <code>t</code> refere-se a uma nova lista, mas <code>t3</code> continua a referir-se à lista original, que não foi modificada.</p>
</div>
<div class="paragraph">
<p>Uma alternativa é escrever uma função que cria e retorna uma nova lista. Por exemplo, <code>calda</code> retorna todos, exceto o primeiro elemento de uma lista:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function calda(t)
    t[2:end]
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Essa função deixa a lista original sem modificações. Veja como ela é usada:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; letras = ['a', 'b', 'c'];

julia&gt; resto = calda(letras);

julia&gt; print(resto)
['b', 'c']</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_depuração_8">Depuração</h3>
<div class="paragraph">
<p>O uso descuidado de listas (e outros objetos mutáveis) pode levar longas horas para depurar. Veja algumas armadilhas comuns e maneiras de como evitá-las:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A maioria das funções de lista modifica o argumento. É o oposto das funções de strings, que retornam uma nova string e deixam a original em paz.</p>
<div class="paragraph">
<p>Se você está acostumado a escrever código de string como:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">nova_palavra = strip(palavra)</code></pre>
</div>
</div>
<div class="paragraph">
<p>É tentador escrever código de lista assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">t2 = sort!(t1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como <code>sort!</code> retorna a lista original modificada <code>t1</code>, <code>t2</code> é um alias de <code>t1</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Antes de usar funções e operadores de lista, você deve ler a documentação com cuidado e testá-los no modo interativo.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Escolha um idioma e fique com ele.</p>
<div class="paragraph">
<p>Parte do problema com listas é que existem muitas maneiras de fazer as coisas. Por exemplo, para remover um elemento de uma lista, você pode usar <code>pop!</code>, <code>popfirst!</code>, <code>delete_at</code> ou até mesmo uma atribuição de fatia. Para adicionar um elemento, você pode usar <code>push!</code>, <code>pushfirst!</code>, <code>insert!</code> Ou <code>vcat</code>. Supondo que <code>t</code> é uma lista e <code>x</code> é um elemento da lista, os seguintes estão corretos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">insert!(t, 4, x)
push!(t, x)
append!(t, [x])</code></pre>
</div>
</div>
<div class="paragraph">
<p>E os seguintes estão errados</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">insert!(t, 4, [x])         # ERRADO!
push!(t, [x])              # ERRADO!</code></pre>
</div>
</div>
</li>
<li>
<p>Faça cópias para evitar alias.</p>
<div class="paragraph">
<p>Se você quer usar uma função como <code>sort!</code> que modifica o argumento, mas você precisa manter a lista original, você pode fazer uma cópia:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [3, 1, 2];

julia&gt; t2 = t[:]; # t2 = copy(t)

julia&gt; sort!(t2);

julia&gt; print(t)
[3, 1, 2]
julia&gt; print(t2)
[1, 2, 3]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nesse exemplo, você também pode usar a função interna <code>sort</code>, que retorna uma nova lista ordenada e deixa a original em paz:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t2 = sort(t);

julia&gt; println(t)
[3, 1, 2]
julia&gt; println(t2)
[1, 2, 3]</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_10">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">lista (<em>array</em>)</dt>
<dd>
<p>Uma sequência de valores.
</p>
</dd>
<dt class="hdlist1">elemento</dt>
<dd>
<p>Um dos valores de uma lista (ou outra sequência), também chamado de itens.
</p>
</dd>
<dt class="hdlist1">lista aninhada</dt>
<dd>
<p>Uma lista que é um elemento de uma outra lista.
</p>
</dd>
<dt class="hdlist1">acumulador</dt>
<dd>
<p>Uma variável que é utilizada em um laço para adicionar ou acumular resultados.
</p>
</dd>
<dt class="hdlist1">atribuição aumentada</dt>
<dd>
<p>Uma atribuição que atualiza o valor de uma variável utilizando um operador como <code>=</code>.
</p>
</dd>
<dt class="hdlist1">operador ponto</dt>
<dd>
<p>Um operador binário que é aplicado elemento a elemento de uma lista
</p>
</dd>
<dt class="hdlist1">sintaxe do ponto</dt>
<dd>
<p>Sintaxe utilizada para aplicar uma função elemento a elemento a qualquer lista.
</p>
</dd>
<dt class="hdlist1">operador de redução</dt>
<dd>
<p>Um padrão de processamento que percorre uma sequência e acumula os elementos em um único resultado.
</p>
</dd>
<dt class="hdlist1">mapa</dt>
<dd>
<p>Um padrão de processamento que percorre uma sequência e executa uma operação em cada elemento.
</p>
</dd>
<dt class="hdlist1">filtro</dt>
<dd>
<p>Um padrão de processamento que percorre uma sequência e seleciona os elementos que atendem a algum critério.
</p>
</dd>
<dt class="hdlist1">objeto</dt>
<dd>
<p>Algo que uma variável pode se referir. Um objeto tem um tipo e um valor.
</p>
</dd>
<dt class="hdlist1">equivalente</dt>
<dd>
<p>Contém o mesmo valor.
</p>
</dd>
<dt class="hdlist1">idêntico</dt>
<dd>
<p>Ser o mesmo objeto (o que implica equivalência).
</p>
</dd>
<dt class="hdlist1">referência</dt>
<dd>
<p>Associação entre uma variável e seu valor.
</p>
</dd>
<dt class="hdlist1">alias</dt>
<dd>
<p>Uma circunstância no qual duas ou mais variáveis referem-se ao mesmo objeto.
</p>
</dd>
<dt class="hdlist1">argumentos opcionais</dt>
<dd>
<p>Argumentos que não são obrigatórios.
</p>
</dd>
<dt class="hdlist1">delimitador</dt>
<dd>
<p>Um caractere ou string utilizada para indicar onde uma string deve ser cortada.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_12">Exercícios</h3>
<div class="sect4">
<h5 id="ex10-1">Exercício 10-1</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>soma_aninhada</code> que recebe uma lista de listas de números inteiros e some os elementos de todas as listas aninhadas. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [[1, 2], [3], [4, 5, 6]];

julia&gt; soma_aninhada(t)
21</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex10-2">Exercício 10-2</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>soma_cumulativa</code> que recebe uma lista de números e retorne a soma cumulativa; isto é, uma nova lista em que o \(i\)-ésimo elemento é a soma do primeiro elemento \(i\) da lista original. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [1, 2, 3];

julia&gt; print(soma_cumulativa(t))
Any[1, 3, 6]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex10-3">Exercício 10-3</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>interior</code> que recebe uma lista e retorna uma nova lista que não contém o primeiro e o último elemento. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [1, 2, 3, 4];

julia&gt; print(interior(t))
[2, 3]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex10-4">Exercício 10-4</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>interior!</code> que recebe uma lista, modifique-a removendo o primeiro e o último elemento e retorne <code>nothing</code>. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [1, 2, 3, 4];

julia&gt; interior!(t)

julia&gt; print(t)
[2, 3]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex10-5">Exercício 10-5</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>é_ordenada</code> que use uma lista como parâmetro e retorne <code>true</code> se a lista estiver ordenada em ordem crescente e <code>false</code> caso contrário. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; é_ordenada([1, 2, 2])
true
julia&gt; é_ordenada(['b', 'a'])
false</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex10-6">Exercício 10-6</h5>
<div class="paragraph">
<p>Duas palavras são anagramas se você puder reorganizar as letras de uma para formar a outra. Escreva uma função chamada <code>é_anagrama</code> que recebe duas strings e retorne <code>true</code> se elas forem anagramas.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex10-7">Exercise 10-7</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>tem_duplicatas</code> que recebe uma lista e retorne <code>true</code> se houver algum elemento que apareça mais de uma vez. Ela não deve modificar a lista original.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex10-8">Exercício 10-8</h5>
<div class="paragraph">
<p>Este exercício refere-se ao chamado Paradoxo de Aniversário, sobre o qual você pode ler em <a href="https://pt.wikipedia.org/wiki/Paradoxo_do_anivers%C3%A1rio" class="bare">https://pt.wikipedia.org/wiki/Paradoxo_do_anivers%C3%A1rio</a>.
</p>
</div>
<div class="paragraph">
<p>Se houver 23 alunos em sua turma, quais são as chances de vocês dois terem o mesmo aniversário? Você pode estimar essa probabilidade gerando amostras aleatórias de 23 aniversários e verificando correspondências.
</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Você pode gerar aniversários aleatórios com <code>rand(1:365)</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ex10-9">Exercício 10-9</h5>
<div class="paragraph">
<p>Escreva uma função que leia o arquivo <code>words.txt</code> e crie uma lista com um elemento por palavra. Escreva duas versões dessa função, uma usando <code>push!</code> e a outra usando o idioma <code>t=[t ..., x]</code>. Qual delas demora mais para ser executada? Por quê?
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex10-10">Exercício 10-10</h5>
<div class="paragraph">
<p>Para verificar se uma palavra está na lista de palavras, você poderia usar o operador <code>∈</code>, mas isto seria lento porque as palavras seriam pesquisadas em ordem.</p>
</div>
<div class="paragraph">
<p>Como as palavras estão em ordem alfabética, podemos acelerar as coisas com uma busca por bissecção (também conhecida como busca binária), que é semelhante ao que você faz quando procura uma palavra no dicionário. Você começa no meio e verifica se a palavra que você procura vem antes da palavra no meio da lista. Nesse caso, você pesquisa a primeira metade da lista da mesma maneira. Caso contrário, você pesquisará a segunda metade.</p>
</div>
<div class="paragraph">
<p>De qualquer forma, você reduz pela metade o espaço restante da busca. Se a lista de palavras possuir 113.809 palavras, serão necessárias 17 etapas para encontrar a palavra ou concluir que ela não está na lista.</p>
</div>
<div class="paragraph">
<p>Escreva uma função chamada <code>em_bisseção</code> que usa uma lista ordenada e um valor-alvo e retorna <code>true</code> se a palavra estiver na lista e <code>false</code> se não estiver.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex10-11">Exercício 10-11</h5>
<div class="paragraph">
<p>Duas palavras são um “par reverso” se uma for o inverso da outra. Escreva um programa <code>par_reverso</code> que encontre todos os pares reversos na lista de palavras.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex10-12">Exercício 10-12</h5>
<div class="paragraph">
<p>Duas palavras “interligam” se receber letras alternadas de cada uma forma uma nova palavra. Por exemplo, “shoe” e “cold” se interligam para formar “schooled”.
</p>
</div>
<div class="paragraph">
<p>Crédito: Este exercício é inspirado em um exemplo em <a href="http://puzzlers.org" class="bare">http://puzzlers.org</a>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escreva um programa que encontre todos os pares de palavras que se interligam.</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Não enumere todos os pares!</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Você consegue encontrar alguma palavra interligada/entrelaçada de três vias; isto é, toda terceira letra forma uma palavra, começando na primeira, segunda ou terceira?</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap11">11. Dicionários</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo apresenta outra estrutura de dados embutida chamada dicionário.</p>
</div>
<div class="sect2">
<h3 id="_um_dicionário_é_um_mapeamento">Um Dicionário é um Mapeamento</h3>
<div class="paragraph">
<p>Um <em>dicionário</em> é como uma lista, mas mais geral. Em uma lista, os índices devem ser inteiros e em um dicionário, eles podem ser de (quase) qualquer tipo.
</p>
</div>
<div class="paragraph">
<p>Um dicionário contém uma coleção de índices, que são chamados de <em>chaves</em>, e uma coleção de valores. Cada chave é associada a um único valor. A associação de uma chave e um valor é chamada de <em>par chave-valor</em> ou, às vezes, de item.
</p>
</div>
<div class="paragraph">
<p>Na linguagem matemática, um dicionário representa um <em>mapeamento</em> das chaves para os valores, então você também pode dizer que cada chave “é mapeada” para um valor. Como um exemplo, iremos construir um dicionário que mapeia palavras em Português para palavras em Espanhol, com as chaves e os valores todos strings.
</p>
</div>
<div class="paragraph">
<p>A função <code>Dict</code> cria um novo dicionário sem items. Como <code>Dict</code> é um nome de uma função embutida, devemos evitar usar ele como um nome de variável.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; pt_para_esp = Dict()
Dict{Any,Any} with 0 entries</code></pre>
</div>
</div>
<div class="paragraph">
<p>O tipo do dicionário é cercado por chaves: as chaves são do tipo <code>Any</code> e os valores também são do tipo <code>Any</code>.
</p>
</div>
<div class="paragraph">
<p>O dicionário está vazio. Para adicionar items no dicionário, podemos usar os colchetes:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; pt_para_esp["um"] = "uno";</code></pre>
</div>
</div>
<div class="paragraph">
<p>Essa linha cria um item que mapeia a chave "um" para o valor "uno". Se imprimirmos o dicionário novamente, nós vemos o par chave-valor com a flecha <code>=&gt;</code> entre a chave e o valor:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; pt_para_esp
Dict{Any,Any} with 1 entry:
  "um" =&gt; "uno"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Essa formatação de saída também é uma formatação de entrada. Por exemplo, você pode criar um novo dicionário com três itens:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; pt_para_esp = Dict("um" =&gt; "uno", "dois" =&gt; "dos", "três" =&gt; "tres")
Dict{String,String} with 3 entries:
  "dois" =&gt; "dos"
  "três" =&gt; "tres"
  "um"   =&gt; "uno"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Todas as chaves e os valores iniciais são strings, então um <code>Dict{String,String}</code> é criado.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Atenção</div>
</td>
<td class="content">
<div class="paragraph">
<p>A ordem do par chave-valor pode não ser a mesma. Se você digitar o mesmo exemplo no seu computador, pode obter um resultado diferente. Em geral, a ordem dos itens em um dicionário é imprevisível.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Mas isso não é um problema pois os elementos de um dicionário nunca são indexados com índices inteiros. Ao invés disso, nós usamos as chaves para consultar os valores correspondentes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; pt_para_esp["dois"]
"dos"</code></pre>
</div>
</div>
<div class="paragraph">
<p>A chave "dois" sempre é mapeada para o valor "dos", então a ordem dos itens não importa.</p>
</div>
<div class="paragraph">
<p>Se a chave não está no dicionário, nós recebemos uma exceção:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; pt_para_esp["quatro"]
ERROR: KeyError: key "quatro" not found</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função <code>length</code> funciona nos dicionários e retorna o número de pares chave-valor:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; length(pt_para_esp)
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função <code>keys</code> retorna uma lista com as chaves do dicionário:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ks = keys(pt_para_esp);

julia&gt; print(ks)
["dois", "três", "um"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora você pode usar o operador <code>∈</code> para verificar se algo aparece como uma <em>chave</em> no dicionário:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; "um" ∈ ks
true
julia&gt; "uno" ∈ ks
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para verificar se algo aparece como um valor em um dicionário, você pode usar a função <code>values</code> que retorna uma coleção de valores, e em seguida usar o operador <code>∈</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; vs = values(pt_para_esp);

julia&gt; "uno" ∈ vs
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>O operador <code>∈</code> utiliza algoritmos diferentes para as listas e dicionários. Para as listas, ele busca os elementos da lista em ordem, como em <a href="#searching">Buscando</a>. À medida que a lista fica maior, o tempo de busca cresce diretamente proporcional.</p>
</div>
<div class="paragraph">
<p>Para os dicionários, o Julia usa um algoritmo chamado <em>tabela hash</em> (ou tabela de dispersão ou tabela de espalhamento) que possui uma propriedade excepcional: o operador <code>∈</code> leva aproximadamente o mesmo tempo independente da quantidade de itens do dicionário.
</p>
</div>
</div>
<div class="sect2">
<h3 id="dictionary_collection_counters">Dicionários como uma Coleção de Contadores</h3>
<div class="paragraph">
<p>Suponha que é dado a você uma string e você gostaria de contar quantas vezes cada letra aparece. Existem muitas maneiras de fazer isso:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Você poderia criar 26 variáveis, um para cada letra do alfabeto. Em seguida você poderia percorrer a string, e para cada caractere, incrementar o contador correspondente, provavelmente usando um condicional encadeado.</p>
</li>
<li>
<p>Você poderia criar uma lista com 26 elementos. Em seguida pode-se converter cada caractere para um número (usando a função embutida <code>Int</code>), usar o número como um índice para a lista, e incrementar o contador adequado.</p>
</li>
<li>
<p>Você poderia criar um dicionário com os caracteres como as chaves e os contadores como seus valores correspondentes. A primeira vez que você vê um caractere, adicionaria um item no dicionário. Após isso, você só incrementaria o valor de um item existente.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cada uma dessas opções efetua o mesmo cálculo, mas cada uma delas implementa este cálculo de formas diferentes.</p>
</div>
<div class="paragraph">
<p>Uma <em>implementação</em> é uma maneira de efetuar um cálculo e algumas implementações são melhores que outras. Por exemplo, uma vantagem da implementação do dicionário é que nós não temos que saber antecipadamente quais letras aparecem na string, e sim criar espaço só para as letras que aparecem.
</p>
</div>
<div class="paragraph">
<p>O código pode parecer com algo como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function histograma(s)
    d = Dict()
    for c in s
        if c ∉ keys(d)
            d[c] = 1
        else
            d[c] += 1
        end
    end
    d
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O nome da função é <code>histograma</code>, que é um termo estátistico para uma coleção de contadores (ou frequências).
</p>
</div>
<div class="paragraph">
<p>A primeira linha da função cria um dicionário vazio. O laço <code>for</code> percorre a string. Toda vez que o laço é percorrido, se o caractere <code>c</code> não está no dicionário, nós criamos um novo item com a chave <code>c</code> e o valor inicial <code>1</code> (já que nós vimos esta letra uma vez). Se <code>c</code> já está no dicionário, nós incrementamos <code>d[c]</code>.</p>
</div>
<div class="paragraph">
<p>Funciona da seguinte forma:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; h = histograma("brontossauro")
Dict{Any,Any} with 8 entries:
  'n' =&gt; 1
  's' =&gt; 2
  'a' =&gt; 1
  'r' =&gt; 2
  't' =&gt; 1
  'o' =&gt; 3
  'u' =&gt; 1
  'b' =&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>O histograma indica que as letras <code><em>a</em></code> e <code><em>b</em></code> aparecem uma vez; <code><em>o</em></code> aparece três, e assim em diante.</p>
</div>
<div class="paragraph">
<p>Dicionários possuem uma função chamada <code>get</code> que recebe uma chave e um valor padrão. Se a chave aparece no dicionário, <code>get</code> retorna o valor correspondente; caso contrário ela retorna o valor padrão. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; h = histograma("a")
Dict{Any,Any} with 1 entry:
  'a' =&gt; 1
julia&gt; get(h, 'a', 0)
1
julia&gt; get(h, 'b', 0)
0</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_exercício_11_1">Exercício 11-1</h5>
<div class="paragraph">
<p>Use <code>get</code> para escrever <code>histograma</code> de uma maneira mais concisa. Você deve ser capaz de eliminar a declaração <code>if</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_laços_e_dicionários">Laços e Dicionários</h3>
<div class="paragraph">
<p>Você pode percorrer as chaves de um dicionário em uma declaração <code>for</code>. Por exemplo, <code>imprime_hist</code> exibe cada chave e o seu valor correspondente:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprime_hist(h)
    for c in keys(h)
        println(c, " ", h[c])
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aqui está o resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; h = histograma("papagaio");

julia&gt; imprime_hist(h)
g 1
a 3
i 1
p 2
o 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Novamente as chaves não estão em nenhuma ordem específica. Para percorrer as chaves em ordem, você pode combinar <code>sort</code> e <code>collect</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; for c in sort(collect(keys(h)))
           println(c, " ", h[c])
       end
a 3
g 1
i 1
o 1
p 2</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_consulta_inversa">Consulta Inversa</h3>
<div class="paragraph">
<p>Dado um dicionário <code>d</code> e uma chave <code>k</code>, é fácil achar o valor correspondente <code>v = d[k]</code>. Esta operação é chamada de <em>consulta</em>.
</p>
</div>
<div class="paragraph">
<p>Mas e se você tem <code>v</code> e quer achar <code>k</code>? Você tem dois problemas: primeiro, pode haver mais de uma chave que mapeia para o valor <code>v</code>. Dependendo do que é pedido, você poderia escolher um, ou teria que criar uma lista que contém todos eles. Segundo, não há uma sintaxe simples que faz uma <em>consulta inversa</em>; você tem que procurar.
</p>
</div>
<div class="paragraph">
<p>Aqui está uma função que recebe um valor e retorna a primeira chave que mapeia a este valor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function consulta_inversa(d, v)
    for k in keys(d)
        if d[k] == v
            return k
        end
    end
    error("Erro de Consulta")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta função é mais um exemplo do padrão de busca, mas usa uma função que ainda não vimos, <code>error</code>. A função <code>error</code> é usada para gerar um <code>ErrorException</code> que interrompe o fluxo normal de controle. Neste caso ela tem a mensagem <code>"Erro de Consulta"</code>, indicando que a chave não existe.
</p>
</div>
<div class="paragraph">
<p>Se nós chegarmos no final do laço, isso significa que <code>v</code> não aparece no dicionário como um valor, então geramos uma exceção.</p>
</div>
<div class="paragraph">
<p>Aqui está um exemplo de uma consulta inversa bem-sucedida:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; h = histograma("papagaio");

julia&gt; chave = consulta_inversa(h, 2)
'p': ASCII/Unicode U+0070 (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
<div class="paragraph">
<p>E uma malsucedida:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; chave = consulta_inversa(h, 4)
ERROR: Erro de Consulta</code></pre>
</div>
</div>
<div class="paragraph">
<p>O resultado de uma exceção gerada é o mesmo quando o Julia gera um: ele exibe o stacktrace e uma mensagem de erro.</p>
</div>
<div class="paragraph">
<p>Julia fornece uma maneira otimizada de fazer uma consulta inversa: <code>findall(isequal(3), h)</code>.
</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Atenção</div>
</td>
<td class="content">
<div class="paragraph">
<p>Uma consulta inversa é muito mais demorada que uma consulta normal; se você tiver que executá-la várias vezes, ou se o dicionário ficar muito grande, o desempenho do seu programa diminuirá.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_dicionários_e_listas">Dicionários e Listas</h3>
<div class="paragraph">
<p>Listas podem aparecer como valores em um dicionário. Por exemplo, se você receber um dicionário que mapeia letras às frequências, você pode querer invertê-lo; isto é, criar um dicionário que mapeia frequências até as letras. Já que várias letras podem ter a mesma frequência, cada valor em um dicionário invertido deve ser uma lista de letras.</p>
</div>
<div class="paragraph">
<p>Aqui está uma função que inverte um dicionário:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function inverte_dict(d)
    inverso = Dict()
    for chave in keys(d)
        valor = d[chave]
        if valor ∉ keys(inverso)
            inverso[valor] = [chave]
        else
            push!(inverso[valor], chave)
        end
    end
    inverso
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cada vez que o laço é percorrido, <code>chave</code> recebe uma chave de <code>d</code> e <code>valor</code> recebe o valor correspondente. Se <code>valor</code> não está em <code>inverso</code>, isto significa que não a vimos ainda, então criamos um novo item e inicializamos com um <em>singleton</em> (uma lista que contém um único elemento). Caso contrário esse valor já foi visto, e então acrescentamos a chave correspondente à lista.
</p>
</div>
<div class="paragraph">
<p>Aqui está um exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; hist = histograma("papagaio");

julia&gt; inverso = inverte_dict(hist)
Dict{Any,Any} with 3 entries:
  2 =&gt; ['p']
  3 =&gt; ['a']
  1 =&gt; ['g', 'i', 'o']</code></pre>
</div>
</div>
<div id="fig11-1" class="imageblock">
<div class="content">
<img src="images/fig111.svg" alt="fig111">
</div>
<div class="title">Figura 16. Diagrama de Estado</div>
</div>
<div class="paragraph">
<p><a href="#fig11-1">Diagrama de Estado</a> é um diagrama de estado mostrando <code>hist</code> e <code>inverso</code>. Um dicionário é representado como uma caixa com os pares chave-valor dentro. Para os valores que são inteiros, pontos flutuantes ou strings, eu os desenho dentro da caixa, já para as listas normalmente desenho fora da caixa, só para simplificar o diagrama.
</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Nota</div>
</td>
<td class="content">
<div class="paragraph">
<p>Mencionamos anteriormente que um dicionário é implementado usando uma tabela hash e isso significa que as chaves devem ser <em>hashable</em>, isto é, de um tipo que permite que uma função hash atuem sobre elas.
</p>
</div>
<div class="paragraph">
<p>Uma <em>hash</em> é uma função que recebe um valor (de qualquer tipo) e retorna um inteiro. Dicionários usam estes inteiros, chamados de valores hash, para guardar e consultar pares chave-valor.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="memos">Memos</h3>
<div class="paragraph">
<p>Se você já brincou com a função <code>fibonacci</code> de <a href="#one_more_exemple">[one_more_exemple]</a>, pode ter percebido que quanto maior o argumento que você fornece, mais tempo a função leva para executar. Além disso, o tempo de execução cresce rapidamente.
</p>
</div>
<div class="paragraph">
<p>Para entender o porquê, considere <a href="#fig11-2">Grafo de chamada</a>, que mostra um <em>grafo de chamada</em> para <code>fibonacci</code> com <code>n = 4</code>:
</p>
</div>
<div id="fig11-2" class="imageblock">
<div class="content">
<img src="images/fig112.svg" alt="fig112">
</div>
<div class="title">Figura 17. Grafo de chamada</div>
</div>
<div class="paragraph">
<p>Um grafo de chamada mostra um conjunto de quadros da função, com linhas conectando cada quadro aos quadros que a função chama. No topo do grafo, <code>fibonacci</code> com <code>n = 4</code> chama <code>fibonacci</code> com <code>n = 3</code> e <code>n = 2</code>. Por sua vez, <code>fibonacci</code> com <code>n = 3</code> chama <code>fibonacci</code> com <code>n = 2</code> e <code>n = 1</code>. E assim em diante.</p>
</div>
<div class="paragraph">
<p>Conte quantas vezes <code>fibonacci(0)</code> e <code>fibonacci(1)</code> são chamadas. Está é uma solução ineficiente do problema, e fica pior à medida que o argumento aumenta.</p>
</div>
<div class="paragraph">
<p>Uma solução é acompanhar os valores já calculados armazenando-os em um dicionário. Um valor previamente calculado que é armazenado para uso posterior é chamado de <em>memo</em>. Aqui está uma versão “memoizada” de fibonacci:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">conhecidos = Dict(0=&gt;0, 1=&gt;1)

function fibonacci(n)
    if n ∈ keys(conhecidos)
        return conhecidos[n]
    end
    res = fibonacci(n-1) + fibonacci(n-2)
    conhecidos[n] = res
    res
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>conhecidos</code> é um dicionáro que guarda os números de Fibonacci que já sabemos. Ele começa com dois itens: <code>0</code> mapeia para <code>0</code> e <code>1</code> mapeia para <code>1</code>.</p>
</div>
<div class="paragraph">
<p>Toda vez que <code>fibonacci</code> é chamada, ela checa <code>conhecidos</code>. Se o resultado já está lá, ela retorna imediatamente. Por outro lado ela tem que computar um novo valor, adicionar ele ao dicionário, e retorná-lo.</p>
</div>
<div class="paragraph">
<p>Se você executar esta versão de <code>fibonacci</code> e comparar com a original, você verá que a atual é muito mais rápida.</p>
</div>
</div>
<div class="sect2">
<h3 id="global_variables">Variáveis Globais</h3>
<div class="paragraph">
<p>No exemplo anterior, conhecidos é criado fora da função, então ela pertence ao quadro especial chamado <code>Main</code>. Variáveis em <code>Main</code> são às vezes chamadas de <em>globais</em> pois podem ser acessadas de qualquer função. Diferente de variáveis locais, que desaparecem quando a função acaba, variáveis globais persistem de uma chamada de função para a próxima.
</p>
</div>
<div class="paragraph">
<p>É comum usar variáveis globais para <em>flags</em>; isto é, variáveis booleanas que indicam (“sinalizam”) se uma condição é verdadeira. Por exemplo, alguns programas usam uma flag chamada <code>verbose</code> para controlar o nível de detalhamento na saída:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">verbose = true

function exemplo1()
    if verbose
        println("Executando exemplo1")
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se você tentar reatribuir uma variável global, poderá se surpreender. O exemplo a seguir deve acompanhar se a função foi chamada:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">foi_chamada = false

function exemplo2()
    foi_chamada = true         # ERRADO
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mas se você executar a função, você verá que o valor de <code>foi_chamada</code> não muda. O problema é que <code>exemplo2</code> cria uma nova variável local denominada <code>foi_chamada</code>. A variável local é removida quando a função termina, e não tem nenhum efeito sobre a variável global.</p>
</div>
<div class="paragraph">
<p>Para reatribuir uma variável global dentro de uma função, você deve <em>declarar</em> a variável global antes de usá-la:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">foi_chamada = false

function exemplo2()
    global foi_chamada
    foi_chamada = true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <em>declaração global</em> indica ao interpretador algo como “Nesta função, quando eu digo <code>foi_chamada</code>, eu quero dizer a variável global; não crie uma local.”
</p>
</div>
<div class="paragraph">
<p>Aqui está um exemplo que tenta atualizar uma variável global:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">conta = 0

function exemplo3()
    conta = conta + 1          # ERRADO
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ao executar a função, você recebe:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; exemplo3()
ERROR: UndefVarError: conta not defined</code></pre>
</div>
</div>
<div class="paragraph">
<p>O Julia assume que <code>conta</code> é local, partindo da suposição de que você está lendo a função antes de escrevê-la. A solução, novamente, é declarar <code>conta</code> como global.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">conta = 0

function exemplo3()
    global conta
    conta += 1
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se uma variável global se refere a um valor mutável, você pode modificar o valor sem declarar a variável global:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">conhecido = Dict(0=&gt;0, 1=&gt;1)

function exemplo4()
    conhecido[2] = 1
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Então você pode adicionar, remover e substituir os elementos de uma lista global ou dicionário, mas se você quiser reatribuir a variável, você deve declará-la como global:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">conhecido = Dict(0=&gt;0, 1=&gt;1)

function exemplo5()
    global conhecido
    conhecido = Dict()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por razões de performance, deve-se declarar uma variável global como constante. Você já não pode reatribuir a variável mas caso ela faça referência a um valor mutável, pode-se modificar o valor.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">const conhecido = Dict(0=&gt;0, 1=&gt;1)

function exemplo4()
    conhecido[2] = 1
end</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Atenção</div>
</td>
<td class="content">
<div class="paragraph">
<p>Variáveis globais podem ser utéis, mas se tem muitas delas, e você modifica-as frequentemente, elas podem ser a causa dos programas serem dificéis de depurar e terem mau desempenho.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_depuração_9">Depuração</h3>
<div class="paragraph">
<p>Na medida em que você trabalha com conjuntos de dados maiores, pode ser que seja difícil depurar imprimindo e checando a saída na mão. Aqui estão algumas sugestões para depurar conjuntos de dados maiores:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Diminua a entrada:</p>
<div class="paragraph">
<p>Se possível, reduza o tamanho do conjunto de dados. Por exemplo, se o programa lê um arquivo de texto, comece com apenas as 10 primeiras linhas, ou com o menor exemplo que dá erro. Você não deve editar os arquivos em si, mas modificar o programa para que ele leia somente as primeiras \(n\) linhas.
</p>
</div>
<div class="paragraph">
<p>Se existe um erro, você pode reduzir de \(n\) para o menor valor que dá erro, e em seguida incrementá-lo gradualmente à medida que você encontra e corrige os erros.</p>
</div>
</li>
<li>
<p>Verifique os resumos e os tipos:</p>
<div class="paragraph">
<p>Ao invés de imprimir e checar o conjunto de dados inteiro, considere imprimir os resumos dos dados: por exemplo, o número de itens em um dicionário ou o total de uma lista de números.
</p>
</div>
<div class="paragraph">
<p>Uma causa comum de erros de execução é um valor que não é do tipo correto. Para a depuração desse tipo de erro, geralmente é suficiente imprimir o tipo de um valor.</p>
</div>
</li>
<li>
<p>Escreva auto-verificações:</p>
<div class="paragraph">
<p>Algumas vezes você pode escrever código para checar os erros automaticamente. Por exemplo, se você está calculando a média de uma lista de números, você poderia checar que o resultado não está acima do maior elemento da lista ou abaixo do menor elemento. Isso é chamado de “verificação de sanidade”.
</p>
</div>
<div class="paragraph">
<p>Outro tipo de verificação compara o resultado de dois cálculos diferentes para verificar se eles são consistentes. Isso é chamado de “verificação de consistência”.
</p>
</div>
</li>
<li>
<p>Formate a saída:</p>
<div class="paragraph">
<p>Resultados de depuração formatados podem facilitar a detecção de erros, como visto em um exemplo em <a href="#deb06">Depuração</a>.
</p>
</div>
<div class="paragraph">
<p>E mais uma vez, o tempo que você usa construindo andaimes pode reduzir o tempo gasto na depuração.
</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_11">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">mapeamento</dt>
<dd>
<p>Uma relação na qual cada elemento de um conjunto corresponde a um elemento de outro conjunto.
</p>
</dd>
<dt class="hdlist1">dicionário</dt>
<dd>
<p>Um mapeamento de chaves para os seus valores correspondentes.
</p>
</dd>
<dt class="hdlist1">par chave-valor</dt>
<dd>
<p>A representação de um mapeamento de uma chave para um valor.
</p>
</dd>
<dt class="hdlist1">item</dt>
<dd>
<p>Em um dicionário, é outro nome para o par chave-valor.
</p>
</dd>
<dt class="hdlist1">chave</dt>
<dd>
<p>Um objeto que aparece em um dicionário como a primeira parte de um par chave-valor.
</p>
</dd>
<dt class="hdlist1">valor</dt>
<dd>
<p>Um objeto que aparece em um dicionário como a segunda parte de um par chave-valor. Isso é mais específico que o nosso uso prévio da palavra “valor”.
</p>
</dd>
<dt class="hdlist1">implementação</dt>
<dd>
<p>Uma maneira de efetuar os cálculos.
</p>
</dd>
<dt class="hdlist1">tabela hash</dt>
<dd>
<p>O algoritmo usado para implementar os dicionários em Julia.
</p>
</dd>
<dt class="hdlist1">função hash</dt>
<dd>
<p>Uma função usado por uma tabela hash para computar a localização de uma chave.
</p>
</dd>
<dt class="hdlist1">hashable</dt>
<dd>
<p>Um tipo que tem uma função hash.
</p>
</dd>
<dt class="hdlist1">consulta</dt>
<dd>
<p>Uma operação em um dicionário que recebe uma chave e encontra o valor correspondente.
</p>
</dd>
<dt class="hdlist1">consulta inversa</dt>
<dd>
<p>Uma operação em um dicionário que recebe um valor e encontra uma ou mais chaves mapeadas para ele.
</p>
</dd>
<dt class="hdlist1">singleton</dt>
<dd>
<p>Uma lista (ou outra sequência) com um único elemento.
</p>
</dd>
<dt class="hdlist1">grafo de chamada</dt>
<dd>
<p>Um diagrama que mostra todo quadro criado durante a execução de um programa, com uma flecha que vai de quem chama para quem é chamado.
</p>
</dd>
<dt class="hdlist1">memo</dt>
<dd>
<p>Um valor já computado e guardado para evitar cálculos futuros desnecessários.
</p>
</dd>
<dt class="hdlist1">variável global</dt>
<dd>
<p>Uma variável definida fora da função. Variáveis globais podem ser acessadas de qualquer função.
</p>
</dd>
<dt class="hdlist1">declaração global</dt>
<dd>
<p>Uma declaração para tornar um nome de variável como global.
</p>
</dd>
<dt class="hdlist1">flag</dt>
<dd>
<p>Uma variável booleana usada para indicar se uma condição é verdadeira.
</p>
</dd>
<dt class="hdlist1">declaração</dt>
<dd>
<p>Uma declaração como <code>global</code> que informa ao interpretador algo sobre a variável.
</p>
</dd>
<dt class="hdlist1">variável global constante</dt>
<dd>
<p>Uma variável global que não pode ser reatribuída.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_13">Exercícios</h3>
<div class="sect4">
<h5 id="ex11-1">Exercício 11-2</h5>
<div class="paragraph">
<p>Escreva uma função que leia as palavras em <em>palavras.txt</em> e guarde-as como chaves em um dicionário. Não importa quais sejam os valores. Em seguida, você pode usar o operador <code>∈</code> como uma maneira rápida de verificar se uma string está ou não no dicionário.
</p>
</div>
<div class="paragraph">
<p>Se o exercício <a href="#ex10-10">Exercício 10-10</a> foi feito, você pode comparar a velocidade desta implementação com o operador <code>∈</code> em listas e na busca em bissecção.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex11-2">Exercício 11-3</h5>
<div class="paragraph">
<p>Leia a documentação da função de dicionário <code>get!</code> e use-a para escrever uma versão mais concisa de <code>inverte_dict</code>.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex11-3">Exercício 11-4</h5>
<div class="paragraph">
<p>Memoize a função de Ackermann de <a href="#ex06-2">Exercício 6-5</a> e verifique se a memoização possibilita a avaliação da função com argumentos maiores.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex11-4">Exercício 11-5</h5>
<div class="paragraph">
<p>Se <a href="#ex10-7">Exercise 10-7</a> foi feito, então já possui uma função chamada <code>tem_duplas</code> que recebe uma lista como parâmetro e retorna <code>true</code> se há qualquer objeto que aparece mais de uma vez na lista.
</p>
</div>
<div class="paragraph">
<p>Use um dicionário para escrever uma versão mais rápida e simplificada de <code>tem_duplas</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex11-5">Exercício 11-6</h5>
<div class="paragraph">
<p>Duas palavras são “pares rotacionados” se você pode rotacionar um deles e obter o outro (ver <code>rotaciona_palavra</code> em <a href="#ex08-5">Exercício 8-11</a>).
</p>
</div>
<div class="paragraph">
<p>Escreva um programa que lê uma lista e encontra todos os pares rotacionados.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex11-6">Exercício 11-7</h5>
<div class="paragraph">
<p>Aqui está outro quebra cabeça de Car Talk (<a href="https://www.cartalk.com/puzzler/browse" class="bare">https://www.cartalk.com/puzzler/browse</a>):
</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Essa foi enviada por um sujeito chamado Dan O’Leary. Ele encontrou recentemente uma palavra em inglês comum de uma sílaba e cinco letras, que possui a seguinte propriedade peculiar. Quando você remove a primeira letra, as letras restantes formam um homófono da palavra original, isto é, uma palavra que soa exatamente igual. Troque a primeira letra, isto é, coloque-a novamente e remova a segunda letra, e o resultado é outro homófono da palavra original. E a pergunta é, qual é a palavra?</p>
</div>
<div class="paragraph">
<p>Agora irei dar um exemplo que não funciona. Vamos olhar para uma palavra de cinco letras, ‘wrack.’ W-R-A-C-K, como na expressão ‘wrack with pain.’ Se eu remover a primeira letra, tenho uma palavra de quatro letras, ’R-A-C-K.’ Como em, ‘Holy cow, did you see the rack on that buck! It must have been a nine-pointer!’ É um homófono perfeito. Se você colocar o ‘w’ novamente, e remover o ‘r’, você fica com a palavra ‘wack,’ que é uma palavra real, só não é um homófona das outras duas palavras.</p>
</div>
<div class="paragraph">
<p>Mas há pelo menos uma palavra, que Dan e nós conhecemos, que irá produzir dois homófonos se você remover tanto as duas primeiras letras para criar duas novas palavras de quatro letras. A pergunta é, qual é a palavra?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Você pode usar o dicionário de <a href="#ex11-1">Exercício 11-2</a> para verificar se uma string está na lista de palavras.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Para verificar se duas palavras em inglês são homófonas, você pode usar o Dicionário CMU de Pronunciação. E também pode baixá-lo em  <a href="http://www.speech.cs.cmu.edu/cgi-bin/cmudict" class="bare">http://www.speech.cs.cmu.edu/cgi-bin/cmudict</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Escreva um programa que lista todas as palavras que resolvem o quebra cabeça.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap12">12. Tuplas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo apresenta mais um tipo interno, a tupla, e mostra como as listas, os dicionários e as tuplas trabalham juntos. Também apresento um recurso útil para as listas de argumentos de tamanho variável, operadores de agrupamento e de separação.</p>
</div>
<div class="sect2">
<h3 id="_tuplas_são_imutáveis">Tuplas são Imutáveis</h3>
<div class="paragraph">
<p>Uma tupla é uma sequência de valores. Estes valores podem ser de qualquer tipo e são indexados por números inteiros; logo, neste aspecto, as tuplas são muito similares às listas. A diferença importante é que as tuplas são imutáveis e que cada elemento pode ter seu próprio tipo.
</p>
</div>
<div class="paragraph">
<p>Sintaticamente, uma tupla é uma lista de valores separados por vírgula:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = 'a', 'b', 'c', 'd', 'e'
('a', 'b', 'c', 'd', 'e')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Apesar de não ser necessário, é comum colocar tuplas entre parênteses:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ('a', 'b', 'c', 'd', 'e')
('a', 'b', 'c', 'd', 'e')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para criar uma tupla com um único elemento, tem que inserir uma vírgula no final:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t1 = ('a',)
('a',)
julia&gt; typeof(t1)
Tuple{Char}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Atenção</div>
</td>
<td class="content">
<div class="paragraph">
<p>Um único valor entre parênteses sem vírgula não é uma tupla:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t2 = ('a')
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
julia&gt; typeof(t2)
Char</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Outra maneira de criar uma tupla é por meio da função interna <code>tuple</code>. Sem nenhum argumento, uma tupla vazia é criada:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; tuple()
()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se vários argumentos são fornecidos, o resultado é uma tupla com os argumentos dados:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t3 = tuple(1, 'a', pi)
(1, 'a', π)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Já que <code>tuple</code> é o nome de uma função interna, deve-se evitar usá-lo como o nome de variável.</p>
</div>
<div class="paragraph">
<p>A maioria dos operadores da lista também funciona com as tuplas. O operador colchete indexa um elemento:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ('a', 'b', 'c', 'd', 'e');

julia&gt; t[1]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
<div class="paragraph">
<p>E o operador de fatia seleciona uma faixa de elementos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t[2:4]
('b', 'c', 'd')</code></pre>
</div>
</div>
<div class="paragraph">
<p>E caso você tente modificar um dos elementos da tupla, uma mensagem de erro aparecerá:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t[1] = 'A'
ERROR: MethodError: no method matching setindex!(::NTuple{5,Char}, ::Char, ::Int64)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Já que as tuplas são imutáveis, você não pode modificar os elementos.</p>
</div>
<div class="paragraph">
<p>Os operadores relacionais trabalham com tuplas e outras sequências; em Julia, começa-se comparando o primeiro elemento de cada sequência. Se forem iguais, passa-se para os elementos seguintes, e assim por diante, até encontrar elementos que diferem. Após isso, os elementos seguintes são desconsiderados (ainda que sejam realmente grandes).
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; (0, 1, 2) &lt; (0, 3, 4)
true
julia&gt; (0, 1, 2000000) &lt; (0, 3, 4)
true</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_atribuição_de_tuplas">Atribuição de Tuplas</h3>
<div class="paragraph">
<p>Muitas vezes, deseja-se permutar os valores de duas variáveis. Nas atribuições convencionais, você tem que usar uma variável temporária. Por exemplo, para permutar as variáveis a e b:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">temp = a
a = b
b = temp</code></pre>
</div>
</div>
<div class="paragraph">
<p>Essa solução é trabalhosa; já a atribuição da tupla é mais elegante:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">a, b = b, a</code></pre>
</div>
</div>
<div class="paragraph">
<p>O lado esquerdo é uma tupla de variáveis; o lado direito é uma tupla de expressões. Cada valor é atribuído à sua correspondente variável. Todas as expressões no lado direito são avaliadas antes de qualquer uma das atribuições.</p>
</div>
<div class="paragraph">
<p>O número de variáveis do lado esquerdo não deve ser maior do que o número de valores do lado direito:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; (a, b) = (1, 2, 3)
(1, 2, 3)
julia&gt; a, b, c = 1, 2
ERROR: BoundsError: attempt to access (1, 2)
  at index [3]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Geralmente, o lado direito pode ser qualquer tipo de sequência (string, lista ou tupla). Por exemplo, ao dividir um endereço de e-mail em um nome de usuário e um domínio, poderia-se escrever:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; email = "julio.cesar@roma"
"julio.cesar@roma"
julia&gt; nome_usuário, domínio = split(email, '@');</code></pre>
</div>
</div>
<div class="paragraph">
<p>O valor de retorno de <code>split</code> é uma lista com dois elementos; o primeiro elemento é atribuído a <code>nome_usuário</code> e o segundo a <code>domínio</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; nome_usuário
"julio.cesar"
julia&gt; domínio
"roma"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tuplas_como_valores_de_retorno">Tuplas como Valores de Retorno</h3>
<div class="paragraph">
<p>A princípio, uma função pode retornar apenas um valor, mas se o valor for uma tupla, é como se devolvesse vários valores. Por exemplo, se você deseja dividir dois números inteiros e calcular o quociente e o restante, é ineficiente calcular <code>x ÷ y</code> e depois <code>x % y</code>. É melhor fazer os dois cálculos ao mesmo tempo.
 </p>
</div>
<div class="paragraph">
<p>A função embutida <code>divrem</code> recebe dois argumentos e retorna uma tupla de dois valores: o quociente e o restante, respectivamente. O resultado pode ser armazenado como uma tupla:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = divrem(7, 3)
(2, 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ou use a atribuição de tupla para armazenar os elementos separadamente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; q, r = divrem(7, 3);

julia&gt; @show q r;
q = 2
r = 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eis um exemplo de uma função que retorna uma tupla:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function minmax(t)
    minimum(t), maximum(t)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>As funções internas <code>maximum</code> e <code>minimum</code> encontram o maior e o menor elemento de uma sequência. <code>minmax</code> calcula os dois e retorna-os por meio de uma tupla. Já a função interna <code>extrema</code> é mais eficiente.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_tuplas_com_argumentos_de_comprimento_variável">Tuplas com Argumentos de Comprimento Variável</h3>
<div class="paragraph">
<p>As funções podem receber um número variável de argumentos. Um nome de parâmetro que termina com <code>...</code> <em>agrupa</em> argumentos em uma tupla. Por exemplo, <code>printall</code> pega qualquer número de argumentos e os imprime:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function printall(args...)
    println(args)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O parâmetro de agrupamento pode ter qualquer nome que você goste, mas <code>args</code> é padronizado. Veja como funciona a função:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; printall(1, 2.0, '3')
(1, 2.0, '3')</code></pre>
</div>
</div>
<div class="paragraph">
<p>O complemento do agrupamento é a <em>separação</em>. Se você tem uma seqüência de valores e quiser passá-la para uma função com diversos argumentos, pode-se usar o operador <code>...</code>. No exemplo seguinte, <code>divrem</code> recebe exatamente dois argumentos e não funciona com uma tupla:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = (7, 3);

julia&gt; divrem(t)
ERROR: MethodError: no method matching divrem(::Tuple{Int64,Int64})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mas se você separar a tupla, o comando funcionará:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; divrem(t...)
(2, 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Muitas das funções embutidas usam tuplas com argumentos de comprimento variável. Por exemplo, <code>max</code> e <code>min</code> podem receber qualquer número de argumentos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; max(1, 2, 3)
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mas <code>sum</code>, não:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; sum(1, 2, 3)
ERROR: MethodError: no method matching sum(::Int64, ::Int64, ::Int64)</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_exercício_12_1">Exercício 12-1</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>soma_tudo</code> que recebe qualquer número de argumentos e devolve o resultado da soma deles.
</p>
</div>
<div class="paragraph">
<p>No mundo de Julia, agrupar é chamado de "slurp" e separar de "splat".</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_listas_e_tuplas">Listas e Tuplas</h3>
<div class="paragraph">
<p><code>zip</code> é uma função interna que recebe duas ou mais sequências e retorna uma coleção de tuplas em que cada tupla contém um elemento de cada sequência. O nome da função refere-se a um zíper, que une e intercala duas faixas de dentes.
</p>
</div>
<div class="paragraph">
<p>Este exemplo intercala uma string com uma lista:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; s = "abc";

julia&gt; t = [1, 2, 3];

julia&gt; zip(s, t)
Base.Iterators.Zip{Tuple{String,Array{Int64,1}}}(("abc", [1, 2, 3]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>O resultado é um <em>objeto zip</em> que sabe como iterar através dos pares. O uso mais comum de <code>zip</code> ocorre em um laço <code>for</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; for par in zip(s, t)
           println(par)
       end
('a', 1)
('b', 2)
('c', 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>O objeto zip é um tipo de <em>iterador</em>, um objeto usado para percorrer uma sequência. De uma certa forma, os iteradores são similares às listas, e o que difere das listas é que não se pode usar um índice para selecionar um elemento a partir de um iterador.
</p>
</div>
<div class="paragraph">
<p>Se você quiser usar operadores e funções de listas, pode-se usar um objeto zip para gerar uma lista:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; collect(zip(s, t))
3-element Array{Tuple{Char,Int64},1}:
 ('a', 1)
 ('b', 2)
 ('c', 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>O resultado é uma lista de tuplas; e neste exemplo, cada tupla contém um caractere da string e o elemento correspondente da lista.</p>
</div>
<div class="paragraph">
<p>Se as sequências não tiverem o mesmo comprimento, o resultado terá o comprimento da menor sequência.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; collect(zip("Anna", "Rui"))
3-element Array{Tuple{Char,Char},1}:
 ('A', 'R')
 ('n', 'u')
 ('n', 'i')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Você pode usar a atribuição de tupla em um laço <code>for</code> para percorrer uma lista de tupla:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [('a', 1), ('b', 2), ('c', 3)];

julia&gt; for (letra, número) in t
           println(número, " ", letra)
       end
1 a
2 b
3 c</code></pre>
</div>
</div>
<div class="paragraph">
<p>A cada iteração do laço, o Julia seleciona a próxima tupla na lista e atribui os elementos à letra e ao número. Os parênteses em torno de <code>(letra, número)</code> são necessários.
</p>
</div>
<div class="paragraph">
<p>Se você combinar <code>zip</code>, <code>for</code> e a atribuição de tuplas, obtém-se uma função prática para analisar duas (ou mais) seqüências ao mesmo tempo. Por exemplo, <code>tem_combinação</code> considera duas seqüências, <code>t1</code> e <code>t2</code>, e devolve <code>true</code> se existir um índice <code>i</code> tal que <code>t1[i] == t2[i]</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function tem_combinação(t1, t2)
    for (x, y) in zip(t1, t2)
        if x == y
            return true
        end
    end
    false
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se você precisa percorrer os elementos de uma sequência e os seus índices, pode-se usar a função interna <code>enumerate</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; for (índice, elemento) in enumerate("abc")
           println(índice, " ", elemento)
       end
1 a
2 b
3 c</code></pre>
</div>
</div>
<div class="paragraph">
<p>O resultado de <code>enumerate</code> é um objeto enumerado, que itera sobre uma seqüência de pares onde cada par contém um índice (a partir de 1) e um elemento da seqüência dada.</p>
</div>
</div>
<div class="sect2">
<h3 id="_dicionários_e_tuplas">Dicionários e Tuplas</h3>
<div class="paragraph">
<p>Os dicionários podem ser usados como iteradores dos pares chave-valor. Você pode usá-lo em um laço <code>for</code> como este:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; d = Dict('a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3);

julia&gt; for (chave, valor) in d
           println(chave, " ", valor)
       end
a 1
c 3
b 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como é de se esperar de um dicionário, os itens não estão em nenhuma específica ordem.</p>
</div>
<div class="paragraph">
<p>Indo na outra direção, você pode usar uma lista de tuplas para inicializar um novo dicionário:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [('a', 1), ('c', 3), ('b', 2)];

julia&gt; d = Dict(t)
Dict{Char,Int64} with 3 entries:
  'a' =&gt; 1
  'c' =&gt; 3
  'b' =&gt; 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>A combinação de <code>Dict</code> com <code>zip</code> resulta numa maneira concisa de criar um dicionário:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; d = Dict(zip("abc", 1:3))
Dict{Char,Int64} with 3 entries:
  'a' =&gt; 1
  'c' =&gt; 3
  'b' =&gt; 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>É comum utilizar tuplas como chaves nos dicionários. Por exemplo, uma lista telefônica pode mapear os pares de sobrenome e nome até os números de telefone. Supondo que definimos <code>sobrenome</code>, <code>nome</code> e <code>número</code>, poderíamos escrever:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">diretório[sobrenome, nome] = número</code></pre>
</div>
</div>
<div class="paragraph">
<p>A expressão entre parênteses é uma tupla. Poderíamos usar a atribuição de tuplas para percorrer este dicionário.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for ((sobrenome, nome), número) in diretório
    println(nome, " ", sobrenome, " ", número)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este laço percorre os pares chave-valor em <code>diretório</code>, que são tuplas. Ele atribui os elementos da chave em cada tupla <code>sobrenome</code> e <code>nome</code> ao valor em <code>número</code>, e então imprime o nome completo e o número de telefone correspondente.</p>
</div>
<div class="paragraph">
<p>Existem duas maneiras de representar tuplas em um diagrama de estados. A versão mais detalhada mostra os índices e os elementos exatamente como eles aparecem em uma lista. Por exemplo, a tupla <code>("Carlos", "João")</code> apareceria como no <a href="#fig12-1">Diagrama de estado</a>.
</p>
</div>
<div id="fig12-1" class="imageblock">
<div class="content">
<img src="images/fig121.svg" alt="fig121">
</div>
<div class="title">Figura 18. Diagrama de estado</div>
</div>
<div class="paragraph">
<p>Mas em um diagrama maior, você pode ocultar os detalhes. Por exemplo, um diagrama da lista telefônica pode ser impresso como em <a href="#fig12-2">Diagrama de estado</a>.
</p>
</div>
<div id="fig12-2" class="imageblock">
<div class="content">
<img src="images/fig122.svg" alt="fig122">
</div>
<div class="title">Figura 19. Diagrama de estado</div>
</div>
<div class="paragraph">
<p>Aqui, as tuplas são mostradas com a sintaxe do Julia para simplificar o diagrama. O número de telefone no diagrama é a linha de reclamações da BBC; sendo assim, não ligue para lá.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sequências_de_sequências">Sequências de Sequências</h3>
<div class="paragraph">
<p>Temos focado nas listas de tuplas, mas quase todos os exemplos neste capítulo também funcionam com as listas de listas, tuplas de tuplas, e tuplas de listas. Para evitar enumerar as possíveis combinações, às vezes é mais fácil falar sobre seqüências de seqüências.
</p>
</div>
<div class="paragraph">
<p>Em muitos contextos, os diferentes tipos de sequências (strings, listas e tuplas) podem ser usados de forma intercambiável. Então, como você deve escolher um ao invés dos outros?
</p>
</div>
<div class="paragraph">
<p>Para começar com o óbvio, as strings são mais limitadas que as outras sequências porque os elementos precisam ser caracteres, além de serem imutáveis. Se você possivelmente precisar mudar os caracteres de uma string (ao invés de criar uma nova string), pode ser melhor usar uma lista de caracteres em seu lugar.
</p>
</div>
<div class="paragraph">
<p>As listas são mais comuns que tuplas, principalmente porque são mutáveis. Mas existem algumas situações em que você pode preferir as tuplas:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Em algumas circunstâncias, como uma declaração return, sintaticamente é mais simples criar uma tupla do que uma lista.</p>
</li>
<li>
<p>Se você estiver passando uma sequência como argumento para uma função, o uso de tuplas reduz potencialmente o comportamento inesperado causado por um alias.
</p>
</li>
<li>
<p>Por motivos de desempenho. O compilador pode ser especializado neste tipo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como as tuplas são imutáveis, elas não dispõem de funções como <code>sort!</code> e <code>reverse!</code>, que modificam os arrays existentes. Mas o Julia possui a função interna <code>sort</code>, que recebe uma lista e devolve uma nova lista com os mesmos elementos na ordem classificada, e <code>reverse</code>, que recebe qualquer sequência e devolve uma sequência do mesmo tipo na ordem contrária.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_depuração_10">Depuração</h3>
<div class="paragraph">
<p>As listas, os dicionários e as tuplas são exemplos de <em>estruturas de dados</em>; neste capítulo, começamos a ver estruturas de dados compostas, como arrays de tuplas ou dicionários que contêm tuplas como chaves e arrays como valores. As estruturas de dados compostas são práticas, embora sejam propensas ao que chamamos de <em>erros de forma</em>; isto é, erros causados ​​quando uma estrutura de dados tem o tipo, tamanho ou estrutura incorreta. Por exemplo, se você está esperando uma lista com um número inteiro e for fornecido um número inteiro (que não é um lista), não funcionará.
</p>
</div>
<div class="paragraph">
<p>Julia permite anexar um tipo aos elementos de uma sequência. As informações de como isso é feito está em <a href="#chap17">Despacho Múltiplo</a>. A especificação do tipo elimina muitos erros de forma.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_12">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">tupla</dt>
<dd>
<p>Uma sequência imutável de elementos onde cada elemento pode ter seu próprio tipo.
</p>
</dd>
<dt class="hdlist1">atribuição de tupla</dt>
<dd>
<p>Uma atribuição com uma sequência no lado direito e uma tupla de variáveis no lado esquerdo. O lado direito é avaliado para que seus elementos sejam atribuídos às variáveis do lado esquerdo.
</p>
</dd>
<dt class="hdlist1">agrupamento</dt>
<dd>
<p>A operação de geração de uma tupla com argumentos de comprimento variável.
</p>
</dd>
<dt class="hdlist1">separação</dt>
<dd>
<p>A operação de tratamento de uma sequência como uma lista de argumentos.
</p>
</dd>
<dt class="hdlist1">objeto zip</dt>
<dd>
<p>O resultado da chamada de uma função interna <code>zip</code>; um objeto que itera através de uma sequência de tuplas.
</p>
</dd>
<dt class="hdlist1">iterador</dt>
<dd>
<p>Um objeto que pode iterar por uma sequência, mas que não dispõe de operadores e funções de lista.
</p>
</dd>
<dt class="hdlist1">estrutura de dados</dt>
<dd>
<p>Uma coleção de valores relacionados, frequentemente estruturados em lista, dicionários, tuplas, etc.
</p>
</dd>
<dt class="hdlist1">erro de forma</dt>
<dd>
<p>Um erro causado quando um valor tem a forma errada; ou seja, o tipo ou tamanho errado.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_14">Exercícios</h3>
<div class="sect4">
<h5 id="ex12-1">Exercício 12-2</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>mais_frequente</code> que recebe uma string e imprime as letras em ordem decrescente de frequência. Procure amostras de texto de diversos idiomas diferentes e verifique como a frequência das letras varia entre os idiomas. Compare seus resultados com as tabelas em <a href="https://pt.wikipedia.org/wiki/Frequência_de_letras" class="bare">https://pt.wikipedia.org/wiki/Frequência_de_letras</a>.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex12-2">Exercício 12-3</h5>
<div class="paragraph">
<p>Mais anagramas!</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escreva um programa que leia uma lista de palavras de um arquivo (veja <a href="#reading_word_lists">Lendo Listas de Palavras</a>) e mostre todos os conjuntos de palavras que são anagramas.</p>
<div class="paragraph">
<p>Aqui está um exemplo de como pode ser a saída:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">["deltas", "desalt", "lasted", "salted", "slated", "staled"]
["retainers", "ternaries"]
["generating", "greatening"]
["resmelts", "smelters", "termless"]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Você pode querer construir um dicionário que mapeia uma coleção de letras até uma lista de palavras que podem ser soletradas com essas letras. A questão é: como você pode representar a coleção de letras de uma forma que ela possa ser usada como chave?</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Modifique o programa anterior para imprimir primeiro a maior lista de anagramas, seguida pela segunda mais longa e assim por diante.</p>
</li>
<li>
<p>No Scrabble, um “bingo” é quando você joga usa as sete peças do seu suporte, juntamente com uma letra no tabuleiro, para formar uma palavra de oito letras. Qual é a coleção de oito letras que forma o maior número possível de bingos?</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="ex12-3">Exercício 12-4</h5>
<div class="paragraph">
<p>Duas palavras formam um “par de metátese” se você puder transformar uma na outra trocando duas letras, como no caso de “converse“ e “conserve”. Escreva um programa que encontre todos os pares de metáteses no dicionário.
</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Não teste todos os pares de palavras e nem todas as trocas possíveis.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Crédito: Este exercício é inspirado em um exemplo em <a href="http://puzzlers.org" class="bare">http://puzzlers.org</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex12-4">Exercício 12-5</h5>
<div class="paragraph">
<p>Aqui está outro desafio do programa Car Talk (<a href="https://www.cartalk.com/puzzler/browse" class="bare">https://www.cartalk.com/puzzler/browse</a>):
</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Qual é a palavra em Inglês mais longa, que permanece uma palavra válida em Inglês à medida que você remove as letras uma de cada vez?</p>
</div>
<div class="paragraph">
<p>Agora, as letras podem ser removidas de qualquer posição e você não pode rearranjar nenhuma das letras. Toda vez que você retirar uma letra, você termina com outra palavra em Inglês. Se você fizer isso, acabará terminando com uma letra e essa também será uma palavra em Inglês que pode ser encontrada no dicionário. Quero saber qual é a palavra mais longa e quantas letras ela tem?</p>
</div>
<div class="paragraph">
<p>Vou dar um exemplo modesto: Sprite. OK? Você começa com sprite, tira a letra r no meio da palavra e ficamos com a palavra spite, depois tiramos a letra e no final e ficamos com spit, tiramos a letra s e ficamos com pit, it e I.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Escreva um programa para encontrar todas as palavras em Inglês que podem ser reduzidas desta forma, e depois encontre a mais longa.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Este exercício é um pouco mais desafiador do que a maioria, então aqui vai algumas sugestões:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Você pode escrever uma função que recebe uma palavra e obtenha uma lista de todas as palavras que podem ser formadas removendo uma letra. Esta lista contém os “filhos” da palavra.</p>
</li>
<li>
<p>Recursivamente, uma palavra é redutível se algum de seus filhos for redutível. Como caso base, pode-se considerar a string vazia redutível.
</p>
</li>
<li>
<p>A lista de palavras que disponibilizei ( <em>palavras.txt</em> do cap. 9) não contém palavras com uma única letra. Então, você pode querer colocar “I”, “a” e a string vazia.</p>
</li>
<li>
<p>Para melhorar o desempenho do seu programa, convém guardar as palavras que são conhecidas por serem redutíveis.
</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap13">13. Estudo de Caso: Seleção de Estrutura de Dados</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A essa altura você deve ter aprendido sobre as estruturas de dados essenciais do Julia e também deve ter visto alguns dos algoritmos que usam elas.</p>
</div>
<div class="paragraph">
<p>Neste capítulo apresentaremos um estudo de caso com os exercícios que permitirão pensar na escolha de estruturas de dados e praticar o uso delas.</p>
</div>
<div class="sect2">
<h3 id="_análise_de_frequência_de_palavras">Análise de Frequência de Palavras</h3>
<div class="paragraph">
<p>Como sempre, você deve pelo menos tentar fazer os exercícios antes de ver as soluções.</p>
</div>
<div class="sect4">
<h5 id="ex13-1">Exercício 13-1</h5>
<div class="paragraph">
<p>Escreva um programa que leia um arquivo, separe cada linha em palavras, retire o espaço em branco e a pontuação das palavras e coloque-as em letras minúsculas.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>A função <code>isletter</code> verifica se o caractere é do alfabeto.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ex13-2">Exercício 13-2</h5>
<div class="paragraph">
<p>Va até o Projeto Gutenberg (<a href="https://guttenberg.org" class="bare">https://guttenberg.org</a>) e baixe seu livro favorito de domínio público em texto simples, isto é, texto sem formatação.
</p>
</div>
<div class="paragraph">
<p>Modifique o seu programa do exercício anterior para ler o livro que você baixou, pule a informação do cabeçalho no início do arquivo e trabalhe com o resto das palavras como no exercício anterior.</p>
</div>
<div class="paragraph">
<p>Depois, modifique o programa para contar o número total de palavras do livro e o número de vezes que cada palavra é usada.</p>
</div>
<div class="paragraph">
<p>Imprima o número das palavras diferentes usadas no livro. Compare outros livros de autores diferentes, escritos em épocas diferentes. Qual autor usa um vocabulário mais extenso?</p>
</div>
</div>
<div class="sect4">
<h5 id="ex13-3">Exercício 13-3</h5>
<div class="paragraph">
<p>Modifique o programa do exercício anterior para imprimir as 20 palavras mais frequentes utilizadas no livro.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex13-4">Exercício 13-4</h5>
<div class="paragraph">
<p>Modifique o programa anterior para ler uma lista de palavras e depois imprima todas as palavras do livro que não estão nessa lista. Quantas delas são erros de digitação? Quantas delas são palavras comuns que deveriam estar na lista de palavras e quantas delas são realmente obscuras?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_números_aleatórios">Números Aleatórios</h3>
<div class="paragraph">
<p>Dadas as mesmas entradas, a maioria dos programas de computadores sempre geram a mesma saída e por isso eles são ditos <em>determinísticos</em>. O determinismo é geralmente uma coisa boa pois esperamos que o mesmo cálculo produza o mesmo resultado. Mas para algumas aplicações, queremos que o computador seja imprevisível. Os jogos são um exemplo óbvio, porém há mais exemplos.
</p>
</div>
<div class="paragraph">
<p>Desenvolver um programa puramente não determinístico acaba sendo difícil, mas há maneiras de fazer pelo menos com que ele pareça não determinístico. Uma delas é usar algoritmos que geram números <em>pseudoaleatórios</em>. Os números pseudoaleatórios não são aleatórios de verdade porque eles são gerados por um cálculo determinístico, mas só olhando, é praticamente impossível distingui-los da aleatoriedade.
</p>
</div>
<div class="paragraph">
<p>A função <code>rand</code> retorna um ponto flutuante aleatório entre <code>0.0</code> e <code>1.0</code> (incluindo 0.0 mas não 1.0). Toda vez que se usa o comando <code>rand</code>, você obtém o próximo número de uma longa série. Para ver uma amostra disso, execute este laço:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for i in 1:10
    x = rand()
    println(x)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função <code>rand</code> pode receber um iterador ou uma lista como argumentos e retorna um elemento aleatório:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for i in 1:10
    x = rand(1:6)
    print(x, " ")
end</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="ex13-5">Exercício 13-5</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>escolhido_do_histograma</code> que recebe um histograma definido em <a href="#dictionary_collection_counters">Dicionários como uma Coleção de Contadores</a> e retorna um valor aleatório do histograma, escolhido conforme a probabilidade proporcional à frequência. Por exemplo, para este histograma:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'a', 'b'];

julia&gt; histograma(t)
Dict{Any,Any} with 2 entries:
  'a' =&gt; 2
  'b' =&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>a sua função deve retornar <code>'a'</code> com a probabilidade \(\frac{2}{3}\) e <code>'b'</code> com a probabilidade \(\frac{1}{3}\).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_histograma_de_palavra">Histograma de Palavra</h3>
<div class="paragraph">
<p>Você deve tentar fazer os exercícios anteriores antes de continuar. Você também precisará de <a href="https://github.com/JuliaIntro/JuliaIntroBR.jl/blob/master/data/emma.txt" class="bare">https://github.com/JuliaIntro/JuliaIntroBR.jl/blob/master/data/emma.txt</a>.</p>
</div>
<div class="paragraph">
<p>Logo abaixo, temos um programa que lê um arquivo e cria um histograma das palavras no arquivo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function processa_arquivo(nome_do_arquivo)
    hist = Dict()
    for linha in eachline(nome_do_arquivo)
        processa_linha(linha, hist)
    end
    hist
end;

function processa_linha(linha, hist)
    linha = replace(linha, '-' =&gt; ' ')
    for palavra in split(linha)
        palavra = string(filter(isletter, [palavra...])...)
        palavra = lowercase(palavra)
        hist[palavra] = get!(hist, palavra, 0) + 1
    end
end;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">hist = processa_arquivo("emma.txt");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse programa lê <em>emma.txt</em>, que contém o texto de <em>Emma</em> escrito por Jane Austen.
</p>
</div>
<div class="paragraph">
<p>A função <code>processa_arquivo</code> percorre as linhas do arquivo passando-as uma vez de cada para <code>processa_linha</code>. O histograma <code>hist</code> é utilizado como um acumulador.
</p>
</div>
<div class="paragraph">
<p>A função <code>processa_linha</code> usa a função <code>replace</code> para substituir os hífens e espaços antes de usar <code>split</code> para separar a linha em uma lista de strings. Ela percorre a lista de palavras e usa <code>filter</code>, <code>isletter</code> e <code>lowercase</code> para remover as pontuações e converter em letras minúsculas. (Apesar de dizer que as strings são “convertidas”, lembre-se de que as strings são imutáveis e portanto, uma função como <code>lowercase</code> retorna novas strings.)
</p>
</div>
<div class="paragraph">
<p>Finalmente, <code>processa_linha</code> atualiza o histograma criando um novo item ou incrementando um já existente.</p>
</div>
<div class="paragraph">
<p>Para contar o número total de palavras no arquivo, podemos adicionar as frequências no histograma:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function total_de_palavras(hist)
    sum(values(hist))
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O número de palavras diferentes é apenas o número de itens no dicionário:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function palavras_diferentes(hist)
    length(hist)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A seguir, um código que imprime os resultados:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; println("Número total de palavras: ", total_de_palavras(hist))
Número total de palavras: 162742

julia&gt; println("Número de palavras diferentes: ", palavras_diferentes(hist))
Número de palavras diferentes: 7380</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_palavras_mais_frequentes">Palavras Mais Frequentes</h3>
<div class="paragraph">
<p>Para encontrar as palavras mais frequentes, podemos fazer uma lista de tuplas, onde cada tupla contém uma palavra e a sua respectiva frequência e fazemos a ordenação. A função seguinte recebe um histograma e retorna uma lista de tuplas que contém a frequência de palavras.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function mais_comum(hist)
    t = []
    for (chave, valor) in hist
        push!(t, (valor, chave))
    end
    reverse(sort(t))
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em cada tupla, a frequência aparece primeiro, então o resultado da lista é ordenada pela frequência. Aqui está um laço que imprime as 10 palavras mais frequentes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">t = mais_comum(hist)
println("As palavras mais frequentes são: ")
for (freq, palavra) in t[1:10]
    println(palavra, "\t", freq)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usamos o caractere tab (<code>'\t'</code>) como um “separador”, ao invés de um espaço, fazendo com que a segunda coluna fique alinhada. Abaixo, os resultados de <em>Emma</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre>As palavras mais frequentes são:
to	5295
the	5266
and	4931
of	4339
i	3191
a	3155
it	2546
her	2483
was	2400
she	2364</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Esse código pode ser simplificado usando a palavra-chave <code>rev</code> como argumento da função <code>sort</code>. Você pode ler mais sobre isto em <a href="https://docs.julialang.org/en/v1/base/sort/#Base.sort" class="bare">https://docs.julialang.org/en/v1/base/sort/#Base.sort</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parâmetros_opcionais">Parâmetros Opcionais</h3>
<div class="paragraph">
<p>Temos visto funções embutidas que recebem argumentos opcionais. É possível escrever as funções com argumentos opcionais também. Por exemplo, eis uma função que imprime as palavras mais frequentes em um histograma:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprime_mais_frequentes(hist, num=10)
    t = mais_comum(hist)
    println("As palavras mais frequentes são: ")
    for (freq, palavra) in t[1:num]
        println(palavra, "\t", freq)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O primeiro parâmetro é obrigatório, enquanto que o segundo é opcional. O <em>valor padrão</em> de <code>num</code> é <code>10</code>.
</p>
</div>
<div class="paragraph">
<p>Se você fornecer apenas um argumento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">imprime_mais_frequentes(hist)</code></pre>
</div>
</div>
<div class="paragraph">
<p>o argumento <code>num</code> recebe o valor padrão. Se você fornecer dois argumentos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">imprime_mais_frequentes(hist, 20)</code></pre>
</div>
</div>
<div class="paragraph">
<p>o argumento <code>num</code> fica com o valor passado no argumento. Em outras palavras, o valor opcional <em>sobrepõe</em> o valor padrão.
</p>
</div>
<div class="paragraph">
<p>Se uma função possui tanto os argumentos obrigatórios e os opcionais, todos os parâmetros obrigatórios deverão ficar entre os primeiros, seguido dos opcionais.</p>
</div>
</div>
<div class="sect2">
<h3 id="dictionary_subtraction">Subtração de Dicionário</h3>
<div class="paragraph">
<p>Encontrar as palavras do livro que não estão na lista de palavras em <code>palavras.txt</code> é um problema que você pode reconhecer como subtração de conjuntos, isto é, queremos encontrar todas as palavras de um conjunto (as palavras do livro) que não estão no outro (as palavras da lista).</p>
</div>
<div class="paragraph">
<p>A função <code>subtrair</code> recebe os dicionários <code>d1</code> e <code>d2</code> e retorna um novo dicionário que contém todas as chaves de <code>d1</code> que não estão em <code>d2</code>. Como realmente não nos importamos com os valores, definimos todos como <code>nothing</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function subtrair(d1, d2)
    res = Dict()
    for chave in keys(d1)
        if chave ∉ keys(d2)
            res[chave] = nothing
        end
    end
    res
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para encontrar as palavras do livro que não estão em <code>palavras.txt</code>, podemos usar <code>processa_arquivo</code> para construir um histograma para <code>palavras.txt</code>, e depois <code>subtrair</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">palavras = processa_arquivo("palavras.txt")
diferença = subtrair(hist, palavras)

println("Palavras do livro que não estão na lista de palavras: ")
for palavra in keys(diferença)
    print(palavra, " ")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eis alguns resultados de <em>Emma</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Palavras do livro que não estão na lista de palavras:
outree quicksighted outwardly adelaide rencontre jeffereys unreserved dixons betweens ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Algumas dessas palavras são nomes e preposições. Outros, como “rencontre” não são mais usados. Mas algumas são as palavras comuns que realmente devem estar na lista!</p>
</div>
<div class="sect4">
<h5 id="ex13-6">Exercício 13-6</h5>
<div class="paragraph">
<p>O Julia fornece uma estrutura de dados chamado <code>Set</code> que fornece várias operações usuais de conjuntos. Você pode ler mais sobre elas em <a href="#collections_and_data_structures">Coleções e Estruturas de Dados</a>, ou ler a documentação em <a href="https://docs.julialang.org/en/v1/base/collections/#Set-Like-Collections-1" class="bare">https://docs.julialang.org/en/v1/base/collections/#Set-Like-Collections-1</a>.</p>
</div>
<div class="paragraph">
<p>Escreva um programa que usa a subtração de conjuntos para encontrar as palavras do livro que não estão na lista de palavras.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_palavras_aleatórias">Palavras Aleatórias</h3>
<div class="paragraph">
<p>Para escolher uma palavra aleatória do histograma, o algoritmo mais simples é construir uma lista com múltiplas cópias de cada palavra, de acordo com a frequêcia observada e depois escolher da lista:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function palavra_aleatória(h)
    t = []
    for (palavra, freq) in h
        for i in 1:freq
            push!(t, palavra)
        end
    end
    rand(t)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse algoritmo funciona, mas não é muito eficiente; toda vez que você escolhe uma palavra aleatória, ele reconstrói a lista, o que é tão grande quanto o livro original. Uma melhoria óbvia é construir uma lista uma vez e então realizar múltiplas seleções, mas a lista continua grande.</p>
</div>
<div class="paragraph">
<p>Uma alternativa é:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Usar <code>keys</code> para obter uma lista das palavras do livro.</p>
</li>
<li>
<p>Construir uma lista que contenha uma soma acumulativa da frequência da palavra (veja <a href="#ex10-2">Exercício 10-2</a>). O último item nesta lista é o número total de palavras no livro, \(n\).</p>
</li>
<li>
<p>Escolher um número aleatório de 1 até \(n\). Usar uma busca por bissecção (veja <a href="#ex10-10">Exercício 10-10</a>) para encontrar o índice no qual o número aleatório deverá ser inserido na soma acumulativa.
</p>
</li>
<li>
<p>Usar o índice para encontrar a palavra correspondente na lista de palavras.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="ex13-7">Exercício 13-7</h5>
<div class="paragraph">
<p>Escreva um programa que usa esse algoritmo para escolher uma palavra aleatória do livro.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="markov-analysis">Análise de Markov</h3>
<div class="paragraph">
<p>Se você escolher as palavras do livro aleatoriamente, pode-se obter um senso de vocabulário, mas você provavelmente não obterá uma sentença:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>this the small regard harriet which knightley's it most things</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma série de palavras aleatórias raramente faz sentido pois não há relação com as palavras sucessivas. Por exemplo, numa sentença real você esperaria um artigo como “the” ser seguido por um adjetivo ou um substantivo, e provávelmente não um verbo ou advérbio.</p>
</div>
<div class="paragraph">
<p>Um jeito de medir essa relação é através da análise de Markov, que caracteriza, para uma sequência de palavras dadas, a probabilidade das palavras que possam vir a seguir. Por exemplo, a música <em>Amor Pra Recomeçar</em> (do Frejat) tem o seguinte trecho:
</p>
</div>
<div class="verseblock">
<pre class="content">Eu te desejo não parar tão cedo
Pois toda idade tem prazer e medo
E com os que erram feio e bastante
Que você consiga ser tolerante

Quando você ficar triste
Que seja por um dia, e não o ano inteiro
E que você descubra que rir é bom,
mas que rir de tudo é desespero

Desejo que você tenha a quem amar
E quando estiver bem cansado
Ainda, exista amor pra recomeçar
Pra recomeçar

Eu te desejo muitos amigos
Mas que em um você possa confiar
E que tenha até inimigos
Pra você não deixar de duvidar
Quando você ficar triste</pre>
</div>
<div class="paragraph">
<p>No texto, o trecho “eu te” é sempre seguido da palavra “desejo”, mas o trecho “te desejo” pode ser seguido de “não” ou “muitos”.</p>
</div>
<div class="paragraph">
<p>O resultado da análise de Markov é um mapeamento de cada prefixo (como “eu te” e “te desejo”) a todos os possíveis sufixos (como “não” ou “muitos”).
</p>
</div>
<div class="paragraph">
<p>Dado esse mapeamento, você pode gerar um texto aleatório começando com qualquer prefixo e escolhendo aleatoriamente dentre os possíveis sufixos. Em seguida, você pode combinar o final do prefixo e o novo sufixo para formar o próximo prefixo, e repetir.</p>
</div>
<div class="paragraph">
<p>Por exemplo, se você começar com o prefixo “eu te”, então a próxima palavra deverá ser “desejo”, pois é o prefixo que aparece apenas uma vez no texto. O próximo prefixo é “te desejo”, então o próximo sufixo poderá ser “não” ou “muitos”.</p>
</div>
<div class="paragraph">
<p>Nesse exemplo o tamanho do prefixo é sempre dois, mas você pode fazer uma análise de Markov com qualquer tamanho de prefixo.</p>
</div>
<div class="sect4">
<h5 id="ex13-8">Exercício 13-8</h5>
<div class="paragraph">
<p>Análise de Markov:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escreva um programa que leia um texto de um arquivo e realize a análise de Markov. O resultado deverá ser um dicionário que mapeia os prefixos a uma coleção dos possíveis sufixos. A coleção poderá ser uma lista, tupla ou um dicionário; cabe a você fazer uma escolha apropriada. Você pode testar seu programa com o comprimento do prefixo dois, mas deve escrever o programa de uma maneira que facilite a tentativa de outros comprimentos.</p>
</li>
<li>
<p>Adicione uma função ao programa anterior para gerar textos aleatórios baseados na análise de Markov. Aqui vai um exemplo de Emma com prefixo de tamanho 2:</p>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>“He was very clever, be it sweetness or be angry, ashamed or only amused, at such a stroke. She had never thought of Hannah till you were never meant for me?" "I cannot make speeches, Emma:" he soon cut it all himself.”</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Nesse exemplo, eu deixei a pontuação anexada às palavras. O resultado é quase sintaticamente correto, mas não exatamente. Semanticamente, quase faz sentido, mas não completamente.</p>
</div>
<div class="paragraph">
<p>O que aconteceria se você aumentasse o tamanho dos prefixos? Será que o texto aleatório faria mais sentido?</p>
</div>
</li>
<li>
<p>Depois que o programa estiver funcionando, convém tentar uma combinação: se você combinar textos de dois ou mais livros, o texto aleatório gerado irá mesclar o vocabulário e as frases das fontes de maneiras interessantes.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Crédito: Esse estudo de caso é baseado em um exemplo de Kernighan e Pike, The Practice of Programming, Addison-Wesley, 1999.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Você deveria tentar fazer esse execício antes de continuar.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estruturas_de_dados">Estruturas de Dados</h3>
<div class="paragraph">
<p>Usar a análise de Markov para gerar textos aleatórios é divertido, mas há também um propósito para este exercício: a seleção da estrutura de dados. Na sua solução para os exercícios anteriores, você teve que escolher:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Como representar os prefixos.</p>
</li>
<li>
<p>Como representar a coleção dos possíveis sufixos.</p>
</li>
<li>
<p>Como representar um mapeamento de cada prefixo à coleção dos possíveis sufixos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A última é fácil: Um dicionário é a escolha óbvia para um mapeamento de chaves aos valores correspondentes.</p>
</div>
<div class="paragraph">
<p>Para os prefixos, as opções mais óbvias são as strings, listas de strings ou tuplas de strings.</p>
</div>
<div class="paragraph">
<p>Para os sufixos, uma opção é uma lista; outra é um histograma (dicionário).</p>
</div>
<div class="paragraph">
<p>Como você deve escolher? O primeiro passo é pensar nas operações que você precisará implementar para cada estrutura de dados. Para os prefixos, precisamos remover palavras do começo e adicionar ao final. Por exemplo, se o prefixo atual é “eu te” e a próxima palavra é “desejo”, você precisa formar o próximo prefixo, “te desejo”.</p>
</div>
<div class="paragraph">
<p>Sua primeira escolha pode ser uma lista, pois é fácil adicionar e remover os elementos.</p>
</div>
<div class="paragraph">
<p>Para a coleta dos sufixos, as operações que precisamos executar incluem a adição de um novo sufixo (ou aumento da frequência de um existente) e a seleção de um sufixo aleatório.</p>
</div>
<div class="paragraph">
<p>Adicionar um novo sufixo é igualmente fácil para a implementação da lista ou do histograma. Escolher um elemento aleatório de uma lista é fácil enquanto que escolher de um histograma é mais difícil de ser feito eficientemente (veja <a href="#ex13-7">Exercício 13-7</a>).</p>
</div>
<div class="paragraph">
<p>Até agora, conversamos principalmente sobre a facilidade de implementação, mas há outros fatores a serem considerados na escolha das estruturas de dados. Um deles é o tempo de execução. Às vezes, existe uma razão teórica para esperar que uma estrutura de dados seja mais rápida que outra; por exemplo, mencionamos que o operador <code>in</code> é mais rápido para os dicionários do que para as listas, pelo menos quando o número de elementos é grande.</p>
</div>
<div class="paragraph">
<p>Mas muitas vezes você não sabe antecipadamente qual implementação será mais rápida. Uma opção é implementar os dois e ver qual é o melhor. Essa abordagem é chamado de <em>benchmarking</em>. Uma alternativa prática é escolher a estrutura de dados mais fácil de implementar e verificar se é rápida o suficiente para a aplicação pretendida. Se sim, não há necessidade de continuar. Caso contrário, existem ferramentas, como o módulo <code>Profile</code>, que podem identificar os locais em um programa que mais demoram.
</p>
</div>
<div class="paragraph">
<p>O outro fator a considerar é o espaço de armazenamento. Por exemplo, o uso de um histograma para a coleção de sufixos pode exigir menos espaço, pois você só precisa armazenar cada palavra uma vez, não importa quantas vezes apareça no texto. Em alguns casos, economizar espaço também pode fazer com que seu programa seja executado mais rapidamente e, em um caso extremo, seu programa poderá não executar se você ficar sem memória. Porém, para muitos aplicativos, o espaço é uma consideração secundária após o tempo de execução.</p>
</div>
<div class="paragraph">
<p>Uma indagação final: nesta discussão, sugerimos que devemos usar uma estrutura de dados para a análise e geração. Mas como essas fases são separadas, também seria possível usar uma estrutura para a análise e depois converter em outra estrutura para a geração. Isso seria uma vitória se o tempo economizado durante a geração excedesse o tempo gasto na conversão.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>O pacote <code>DataStructures</code> do Julia (consulte <a href="https://github.com/JuliaCollections/DataStructures.jl" class="bare">https://github.com/JuliaCollections/DataStructures.jl</a>) implementa uma variedade de estruturas de dados.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_depuração_11">Depuração</h3>
<div class="paragraph">
<p>Quando você está depurando um programa, e especialmente se você está trabalhando em um erro difícil, existem cinco atividades para se tentar:
</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Leitura</dt>
<dd>
<p>Examine o seu código, leia para si mesmo e verifique se está condizendo com o que você quis dizer.</p>
</dd>
<dt class="hdlist1">Execução</dt>
<dd>
<p>Experimente fazer as alterações e executar versões diferentes. Geralmente se você exibe a coisa certa no lugar certo no programa, o problema se torna óbvio, apesar de às vezes você ter que construir andaimes.</p>
</dd>
<dt class="hdlist1">Ruminação</dt>
<dd>
<p>Tire algum tempo para pensar! Qual o tipo de erro é: sintaxe, tempo de execução ou semântica? Quais informações você pode obter das mensagens de erro ou da saída do programa? Que tipo de erro pode causar o problema que você está tendo? O que você mudou por último, antes que o problema aparecesse?</p>
</dd>
<dt class="hdlist1">Conversa com o Pato de Borracha (rubberducking)</dt>
<dd>
<p>Se você explicar o problema para outra pessoa, às vezes encontrará a resposta antes de terminar de fazer a pergunta. Muitas vezes você não precisa da outra pessoa, poderia apenas conversar com um pato de borracha. E essa é a origem da familiar estratégia chamada depuração com o pato de borracha. Não estamos inventando isso, veja <a href="https://pt.wikipedia.org/wiki/Debug_com_Pato_de_Borracha" class="bare">https://pt.wikipedia.org/wiki/Debug_com_Pato_de_Borracha</a>.
</p>
</dd>
<dt class="hdlist1">Recuo</dt>
<dd>
<p>Em um determinado ponto, a melhor coisa a fazer é voltar atrás e desfazer as alterações recentes, até voltar a ter um programa que funcione e que você entenda. Então você pode começar a reconstruir.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Programadores iniciantes às vezes ficam presos em uma dessas atividades e esquecem das outras. Cada atividade tem a sua própria maneira de falhar.</p>
</div>
<div class="paragraph">
<p>Por exemplo, a leitura do seu código pode ajudar se o problema é um erro tipográfico, mas não se o problema for conceitual. Se você não entende o que o seu programa faz, pode lê-lo cem vezes e nunca verá o erro, porque o erro está na sua cabeça.</p>
</div>
<div class="paragraph">
<p>Realizar experimentos pode ajudar, especialmente se você executar testes pequenos e simples. No entanto, se você executar experimentos sem pensar ou ler seu código, pode cair em um padrão que eu chamo de “programação aleatória”, que é o processo de fazer alterações aleatórias até que o programa faça a coisa certa. Obviamente, a programação aleatória pode levar muito tempo.
</p>
</div>
<div class="paragraph">
<p>Você precisa ter um tempo para pensar. Depuração é como um experimento científico. Deve haver pelo menos uma hipótese sobre qual é o problema. Se houver duas ou mais possibilidades, tente pensar em um teste que eliminaria uma delas.</p>
</div>
<div class="paragraph">
<p>Mas até mesmo as melhores técnicas de depuração falham se houver erros demais, ou se o código que você está tentando corrigir for muito grande e complicado. Às vezes, a melhor opção é voltar atrás, simplificando o programa até chegar a algo que funcione e que você entenda.</p>
</div>
<div class="paragraph">
<p>Programadores iniciantes muitas vezes relutam em voltar atrás porque não conseguem eliminar uma linha de código (mesmo se estiver errada). Se isso faz você se sentir melhor, copie seu programa para um outro arquivo antes de começar a desmontá-lo. Então você pode copiar as partes de volta, uma a uma.</p>
</div>
<div class="paragraph">
<p>Encontrar um erro difícil exige a leitura, execução, ruminação, e, às vezes, o recuo. Se você empacar em alguma dessas atividades, tente as outras.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_13">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">determinístico</dt>
<dd>
<p>Referente a um programa que faz a mesma coisa toda vez que é executado quando se é fornecida a mesma entrada.
</p>
</dd>
<dt class="hdlist1">pseudoaleatório</dt>
<dd>
<p>Referente a uma sequência de números que parecem ser aleatórios, mas é gerada por um programa determinístico.
</p>
</dd>
<dt class="hdlist1">valor padrão</dt>
<dd>
<p>O valor dado a um parâmetro opcional se nenhum argumento é fornecido.
</p>
</dd>
<dt class="hdlist1">sobreposição</dt>
<dd>
<p>A sobreposição de um valor padrão por um argumento.
</p>
</dd>
<dt class="hdlist1">benchmarking</dt>
<dd>
<p>O processo de seleção das estruturas de dados ao implementar as alternativas e testá-las em uma amostra com as possíveis entradas.
</p>
</dd>
<dt class="hdlist1">depuração com pato de borracha</dt>
<dd>
<p>Depuração ao explicar seu problema a um objeto inanimado como um pato de borracha. Articular o problema pode te ajudar a resolvê-lo, mesmo que o pato de borracha não conheça o Julia.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_15">Exercícios</h3>
<div class="sect4">
<h5 id="ex13-9">Exercício 13-9</h5>
<div class="paragraph">
<p>O “ranque” de uma palavra é a sua posição em uma lista ordenada pela frequência: a palavra mais comum tem ranque 1, a segunda mais comum tem ranque 2, etc.</p>
</div>
<div class="paragraph">
<p>A lei de Zipf descreve a relação entre os ranque e as frequências das palavras nas linguagens naturais (<a href="https://pt.wikipedia.org/wiki/Lei_de_Zipf" class="bare">https://pt.wikipedia.org/wiki/Lei_de_Zipf</a>). Especificamente, ela prediz que a frequência \(f\) da palavra com o ranque \(r\) é dada por:
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{f = c r^{-s}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>onde \(s\) e \(c\) são os parâmetros que dependem da linguagem e do texto. Se você pegar o logaritmo em ambos os lados desta equação, obtém-se:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{\log f = \log c - s \log r}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Se você plotar \(\log f\) por \(\log r\), obterá uma linha reta com a inclinação \(-s\) e o intercepto \(\log c\).</p>
</div>
<div class="paragraph">
<p>Escreva um programa que leia um texto em um arquivo, conta as frequências das palavras e exibe uma linha para cada palavra, em ordem decrescente da frequência, com \(\log f\) e \(\log r\).</p>
</div>
<div class="paragraph">
<p>Instale uma biblioteca para plotar os gráficos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">(v1.0) pkg&gt; add Plots</code></pre>
</div>
</div>
<div class="paragraph">
<p>Seu uso é muito simples:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">using Plots
x = 1:10
y = x.^2
plot(x, y)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use a biblioteca <code>Plots</code> para plotar os resultados e verificar se eles formam ou não uma linha reta.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap14">14. Arquivos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo introduz a ideia de programas “persistentes” que mantêm dados permanentemente armazenados e mostra como usar tipos diferentes de armazenamentos permanentes, como arquivos e banco de dados.</p>
</div>
<div class="sect2">
<h3 id="_persistência">Persistência</h3>
<div class="paragraph">
<p>A maioria dos programas que nós vimos até agora são transitórios no sentido de que eles executam por um tempo e produzem alguma saída, mas ao finalizarem, seus dados desaparecem. Se você executar o programa novamente, ele inicia com um estado limpo.
</p>
</div>
<div class="paragraph">
<p>Outros programas são <em>persistentes</em>: eles executam por um longo tempo (ou toda hora); eles mantém pelo menos um pouco dos dados em um armazenamento permanente (um disco rígido, por exemplo); e se eles forem encerrados e reiniciados, eles retornam aonde pararam.
</p>
</div>
<div class="paragraph">
<p>Exemplos de programas persistentes são sistemas operacionais, que são executados toda vez que um computador é ligado e servidores web, que são executados toda hora, aguardando solicitações vindas da rede.</p>
</div>
<div class="paragraph">
<p>Uma das maneiras mais simples que os programas usam para manter seus dados é lendo e escrevendo <em>arquivos de texto</em>. Nós já vimos programas que leem arquivos de texto; neste capítulo nós veremos programas que os escrevem.</p>
</div>
<div class="paragraph">
<p>Uma alternativa é armazenar o estado do programa em um banco de dados. Neste capítulo, iremos apresentar como usar um banco de dados simples.</p>
</div>
</div>
<div class="sect2">
<h3 id="reading_and_writing">Lendo e Escrevendo</h3>
<div class="paragraph">
<p>Um arquivo de texto é uma sequência de caracteres armazenado em um meio permanente como um disco rígido ou memória flash. Nós vimos como abrir e ler um arquivo em <a href="#reading_word_lists">Lendo Listas de Palavras</a>.</p>
</div>
<div class="paragraph">
<p>Para escrever em um arquivo, você tem que abri-lo com modo <code>"w"</code> como segundo parâmetro:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fout = open("saida.txt", "w")
IOStream(&lt;file saida.txt&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se o arquivo já existe, abri-lo em modo escrita limpa os dados antigos e começa de novo, então tome cuidado! Se o arquivo não existe, um novo é criado. <code>open</code> retorna um objeto arquivo e a função <code>write</code> coloca dados dentro do arquivo.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; linha1 = "No meio do caminho tinha uma pedra,\n";

julia&gt; write(fout, linha1)
36</code></pre>
</div>
</div>
<div class="paragraph">
<p>O valor de retorno é o número de caracteres que foram escritos. O arquivo objeto acompanha aonde ele está, então se você chamar <code>write</code> novamente, ela adiciona novos dados ao final do arquivo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; linha2 = "tinha uma pedra no meio do caminho.\n";

julia&gt; write(fout, linha2)
36</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quando você terminar de escrever no arquivo, ele deve ser fechado.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; close(fout)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se você não fechar o arquivo, ele é fechado quando o programa encerra.</p>
</div>
</div>
<div class="sect2">
<h3 id="_formatação">Formatação</h3>
<div class="paragraph">
<p>O argumento da função write precisa ser uma string, então se quisermos colocar outros valores no arquivo, temos que convertê-los para string. A maneira mais fácil de fazer isso é usando <code>string</code> ou interpolação de strings:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fout = open("saida.txt", "w")
IOStream(&lt;file saida.txt&gt;)
julia&gt; write(fout, string(150))
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma alternativa é usar a familia de funções <code>print(ln)</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; camelos = 42
42
julia&gt; println(fout, "Eu vi $camelos camelos.")</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Uma alternativa mais poderosa é a macro <code>@printf</code> que imprime usando uma string de especificação de formato de estilo C, você pode ler mais a respeito em <a href="https://docs.julialang.org/en/v1/stdlib/Printf/" class="bare">https://docs.julialang.org/en/v1/stdlib/Printf/</a>
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_nomes_de_arquivos_e_caminhos">Nomes de Arquivos e Caminhos</h3>
<div class="paragraph">
<p>Arquivos são organizados em <em>diretórios</em> (também chamados de “pastas”). Todo programa em execução possui um “diretório atual”, que é o diretório padrão para a maioria das operações. Por exemplo, quando você abre um arquivo para leitura, o Julia a procura no diretório atual.
</p>
</div>
<div class="paragraph">
<p>A função <code>pwd</code> retorna o nome do diretório atual:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; cwd = pwd()
"/home/ben"</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>cwd</code> significa “current working directory” (diretório de trabalho atual). O resultado nesse exemplo é <code>home/ben</code>, que é o diretório home do usuário chamado <code>ben</code>.</p>
</div>
<div class="paragraph">
<p>Uma string como <code>"/home/ben"</code> que identifica um arquivo ou diretório é chamada de <em>caminho</em>.
</p>
</div>
<div class="paragraph">
<p>Um nome de arquivo simples, como <code>memo.txt</code> também é considerado um caminho, mas é um <em>caminho relativo</em> porque se refere ao diretório atual. Se o diretório atual é <code>/home/ben</code>, o nome do arquivo <code>memo.txt</code> se referiria à <code>/home/ben/memo.txt</code>.
</p>
</div>
<div class="paragraph">
<p>Um caminho que começa com <code>/</code> não depende do diretório atual; ele é chamado de <em>caminho absoluto</em>. Para encontrar um caminho absoluto para um arquivo, você pode usar <code>abspath</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; abspath("memo.txt")
"/home/ben/memo.txt"</code></pre>
</div>
</div>
<div class="paragraph">
<p>O Julia fornece outras funções para trabalhar com nomes de arquivos e caminhos. Por exemplo, <code>ispath</code> verifica se um arquivo ou diretório existe:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ispath("memo.txt")
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se ele existe, <code>isdir</code> verifica se é um diretório:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; isdir("memo.txt")
false
julia&gt; isdir("/home/ben")
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>De forma similar, <code>isfile</code> verifica se é um arquivo.
</p>
</div>
<div class="paragraph">
<p><code>readdir</code> retorna uma lista de arquivos (e outros diretórios) no diretório dado:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; readdir(cwd)
3-element Array{String,1}:
 "memo.txt"
 "música"
 "fotos"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para demonstrar estas funções, o exemplo a seguir “caminha” por um diretório, exibe os nomes de todos os arquivos e chama a si mesmo recursivamente em todos os diretórios.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function caminha(nomedir)
    for nome in readdir(nomedir)
        path = joinpath(nomedir, nome)
        if isfile(path)
            println(path)
        else
            caminha(path)
        end
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>joinpath</code> recebe um diretório e um nome de arquivo e junta-os em um caminho completo.
</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>O Julia fornece uma função chamada <code>walkdir</code> (consulte <a href="https://docs.julialang.org/en/v1/base/file/#Base.Filesystem.walkdir" class="bare">https://docs.julialang.org/en/v1/base/file/#Base.Filesystem.walkdir</a>) que é similar a esta, porém, é mais versátil. Como um exercício, leia a documentação e a use para imprimir os nomes dos arquivos em um dado diretório e seus subdiretórios.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="catching_exceptions">Capturando Exceções</h3>
<div class="paragraph">
<p>Muitas coisas podem dar errado quando você tenta ler e escrever arquivos. Se você tentar abrir um arquivo que não existe, você recebe um <code>SystemError</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fin = open("arquivo_ruim")
ERROR: SystemError: opening file "arquivo_ruim": No such file or directory</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se você não tem permissão para acessar o arquivo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fout = open("/etc/passwd", "w")
ERROR: SystemError: opening file "/etc/passwd": Permission denied</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para evitar estes erros, você pode usar funções como <code>ispath</code> e <code>isfile</code>, porém, tomaria muito tempo e código para verificar todas as possibilidades.</p>
</div>
<div class="paragraph">
<p>É mais fácil tentar de uma vez—e lidar com os problemas se eles ocorrerem—que é exatamente o que a declaração <code>try</code> faz. A sintaxe é similar a uma declaração <code>if</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">try
    fin = open("arquivo_ruim.txt")
catch exc
    println("Algo deu errado: $exc")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O Julia inicia executando a cláusula <code>try</code>. Se tudo der certo, ele pula a cláusula <code>catch</code> e segue adiante. Se ocorrer alguma exceção, ele pula fora da cláusula <code>try</code> e executa a cláusula <code>catch</code>.</p>
</div>
<div class="paragraph">
<p>Lidar com uma exceção com uma declaração <code>try</code> é chamado de <em>capturar</em> uma exceção. Neste exemplo, a cláusula de exceção imprime uma mensagem de erro que não é muito útil. Em geral, capturar uma exceção nos da uma chance de consertar o problema, ou tentar novamente ou pelo menos encerrar o programa graciosamente.
</p>
</div>
<div class="paragraph">
<p>Em código que realiza mudanças de estado ou usa recursos como arquivos, geralmente há um trabalho de limpeza (como fechar arquivos) que precisa ser feito quando o código é encerrado. Exceções potencialmente complicam esta tarefa, já que elas podem causar a saída de um bloco de código antes dele atingir seu fim normal. A palavra-chave <code>finally</code> fornece uma maneira de executar código quando um dado bloco de código sai, independente de como ele saiu:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">f = open("output.txt")
try
    line = readline(f)
    println(line)
finally
    close(f)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função <code>close</code> sempre será executada.</p>
</div>
<div class="paragraph">
<p>[[banco de dados]]
=== Banco de Dados</p>
</div>
<div class="paragraph">
<p>Um <em>banco de dados</em> é um arquivo que é organizado para guardar dados. Muitos bancos de dados são organizados como um dicionário no sentido de que eles mapeiam chave para valores. A maior diferença entre um banco de dados e um dicionário é de que o banco de dados está em disco (ou em armazenamento permanente), então ele persiste após o programa encerrar.
</p>
</div>
<div class="paragraph">
<p>O JuliaIntroBR fornece uma interface para <code>GDBM</code> (GNU dbm) para criar e atualizar arquivos de bancos de dados. Como um exemplo, irei criar um banco de dados que contém legendas para arquivos de imagens.
</p>
</div>
<div class="paragraph">
<p>Abrir um banco de dados é similar a abrir outros arquivos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; using JuliaIntroBR

julia&gt; db = DBM("legendas", "c")
DBM(&lt;legendas&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>O modo "c" significa que o banco de dados deve ser criado se ele ainda não existe. O resultado é um objeto banco de dados que pode ser usado (para a maioria das operações) como um dicionário.</p>
</div>
<div class="paragraph">
<p>Quando você cria um novo item, <code>GDBM</code> atualiza o arquivo banco de dados:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; db["cleese.png"] = "Foto de John Cleese."
"Foto de John Cleese."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quando você acessa um de seus itens, <code>GDBM</code> lê o arquivo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; db["cleese.png"]
"Foto de John Cleese."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se você faz outra atribuição para uma chave já existente, <code>GDBM</code> substitui o valor antigo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; db["cleese.png"] = "Foto de John Cleese fazendo uma caminhada engraçada."
"Foto de John Cleese fazendo uma caminhada engraçada."
julia&gt; db["cleese.png"]
"Foto de John Cleese fazendo uma caminhada engraçada."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Algumas funções que tem um dicionário como argumento, como <code>keys</code> e <code>values</code>, não funcionam com objetos banco de dados. Mas iteração com o laço <code>for</code> funciona:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for (chave, valor) in db
    println(chave, ": ", valor)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como outros arquivos, você deve fechar o banco de dados quando acabar:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; close(db)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_serialização">Serialização</h3>
<div class="paragraph">
<p>A limitação do <code>GDBM</code> é de que as chaves e valores precisam ser strings ou listas de bytes. Se você tentar usar qualquer outro tipo, você recebe um erro.</p>
</div>
<div class="paragraph">
<p>As funções <code>serialize</code> e <code>deserialize</code> podem ajudar. Elas traduzem quase todo tipo de objeto em uma lista de bytes (um iobuffer) adequado para armazenamento em um banco de dados e em seguida traduz a lista de bytes em objetos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; using Serialization

julia&gt; io = IOBuffer();

julia&gt; t = [1, 2, 3];

julia&gt; serialize(io, t)
24
julia&gt; print(take!(io))
UInt8[0x37, 0x4a, 0x4c, 0x09, 0x04, 0x00, 0x00, 0x00, 0x15, 0x00, 0x08, 0xe2, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</code></pre>
</div>
</div>
<div class="paragraph">
<p>O formato não é óbvio para humanos; ele tem o propósito de ser fácil para o Julia interpretá-lo. <code>deserialize</code> reconstitui o objeto:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; io = IOBuffer();

julia&gt; t1 = [1, 2, 3];

julia&gt; serialize(io, t1)
24
julia&gt; s = take!(io);

julia&gt; t2 = deserialize(IOBuffer(s));

julia&gt; print(t2)
[1, 2, 3]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>serialize</code> e <code>deserialize</code> escrevem para e leem de um objeto iobuffer que representa um fluxo I/O em memória. A função <code>take!</code> busca os conteúdos do iobuffer como uma lista de bytes e reinicia o iobuffer para seu estado inicial.</p>
</div>
<div class="paragraph">
<p>Apesar do novo objeto ter o mesmo valor do antigo, ele não é (em geral) o mesmo objeto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t1 == t2
true
julia&gt; t1 ≡ t2
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em outras palavras, serialização e em seguida desserialização tem o mesmo efeito de copiar o objeto.
</p>
</div>
<div class="paragraph">
<p>Você pode usar isso para guardar coisas diferentes de strings em um banco de dados.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Na verdade, o armazenamento de coisas diferentes de string em um banco de dados é tão comum que ele foi encapsulado em um pacote chamado <code>JLD2</code> (ver <a href="https://github.com/JuliaIO/JLD2.jl" class="bare">https://github.com/JuliaIO/JLD2.jl</a>).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_objetos_de_comando">Objetos de Comando</h3>
<div class="paragraph">
<p>A maioria dos sistemas operacionais fornecem uma interface de linha de comando, também conhecida como uma <em>shell</em>. Shells geralmente fornecem comandos para navegar o sistema de arquivos e iniciar aplicações. Por exemplo, no Unix você pode mudar de diretório com o comando <code>cd</code>, exibir o conteúdo do diretório com <code>ls</code> e iniciar o web browser digitando (por exemplo) <code>firefox</code>.
</p>
</div>
<div class="paragraph">
<p>Qualquer programa que você inicia do shell também pode ser iniciado do Julia usando um <em>objeto de comando</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; cmd = `echo olá`
`echo olá`</code></pre>
</div>
</div>
<div class="paragraph">
<p>Acentos graves são usados para delimitar o comando.</p>
</div>
<div class="paragraph">
<p>A função <code>run</code> executa o comando:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; run(cmd);
olá</code></pre>
</div>
</div>
<div class="paragraph">
<p>O <code>olá</code> é o resultado do comando echo, mandado para <code>STDOUT</code>. A função <code>run</code> retorna um objeto de processo, e gera um <code>ErrorException</code> se o comando externo falha ao executar com sucesso.</p>
</div>
<div class="paragraph">
<p>Se você quer ler a saída do comando externo, <code>read</code> pode ser usado como alternativa:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = read(cmd, String)
"olá\n"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por exemplo, a maioria dos sistemas Unix fornecem um comando chamado <code>md5sum</code> ou <code>md5</code> que lê o conteúdo de um arquivo e calcula uma “soma de verificação” para checar a integridade dos dados. Você pode ler mais sobre MD5 em <a href="https://pt.wikipedia.org/wiki/MD5" class="bare">https://pt.wikipedia.org/wiki/MD5</a>. Este comando fornece uma maneira eficiente de verificar se dois arquivos possuem o mesmo conteúdo. A probabilidade de que conteúdos diferentes produzem a mesma soma de verificação é muito pequena (isto é, improvável de acontecer antes que o universo entre em colapso).
</p>
</div>
<div class="paragraph">
<p>Você pode usar um objeto comando para executar <code>md5</code> do Julia e gerar o resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; nomedoarquivo = "saida.txt"
"saida.txt"
julia&gt; cmd = `md5 $nomedoarquivo`
`md5 saida.txt`
julia&gt; res = read(cmd, String)
ERROR: IOError: could not spawn `md5 saida.txt`: no such file or directory (ENOENT)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_módulos">Módulos</h3>
<div class="paragraph">
<p>Suponha que você tenha um arquivo chamado <code>"wc.jl"</code> com o seguinte código:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function contalinha(nomedoarquivo)
    contador = 0
    for linha in eachline(nomedoarquivo)
        contador += 1
    end
    contador
end

print(contalinha("wc.jl"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se você executar esse programa, ele lê a si mesmo e imprime o número de linhas de um arquivo, que é 9. Você também pode incluir ele no REPL assim:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jl-con" data-lang="jl-con">julia&gt; include("wc.jl")
9</code></pre>
</div>
</div>
<div class="paragraph">
<p>O Julia introduz módulos para criar uma área de trabalho de variáveis separada, isto é, novos escopos globais.</p>
</div>
<div class="paragraph">
<p>Um módulo inicia com a palavra-chave <code>module</code> e termina com <code>end</code>. Conflitos de nomes são evitados entre suas próprias definições de alto nível e aquelas encontradas em código de outra pessoa. <code>import</code> permite o controle de quais nomes de outros módulos são visíveis e <code>export</code> específica quais nomes são públicos, isto é, podem ser usados fora do módulo sem a necessidade de serem prefixados com o nome do módulo.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">module ContaLinha
    export contalinha

    function contalinha(nomedoarquivo)
        contador = 0
        for linha in eachline(nomedoarquivo)
            contador += 1
        end
        contador
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O objeto de tipo módulo <code>ContaLinha</code> fornece <code>contalinha</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">julia&gt; using ContaLinha

julia&gt; contalinha("wc.jl")
11</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_exercício_14_1">Exercício 14-1</h5>
<div class="paragraph">
<p>Digite este exemplo em um arquivo chamado <em>wc.jl</em>, inclua-o no REPL e insira <code>using ContaLinha</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Atenção</div>
</td>
<td class="content">
<div class="paragraph">
<p>Se você importar um módulo que já foi importado, o Julia não faz nada. Ele não relê o arquivo, mesmo que ele tenha sido alterado.</p>
</div>
<div class="paragraph">
<p>Se você quer recarregar o módulo, você tem que reiniciar o REPL. O pacote <code>Revise</code> existe para que você possa manter suas sessões rodando por mais tempo (ver <a href="https://github.com/timholy/Revise.jl" class="bare">https://github.com/timholy/Revise.jl</a>).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_depuração_12">Depuração</h3>
<div class="paragraph">
<p>Quando você está lendo ou escrevendo arquivos, você pode encontrar problemas com o espaço em branco. Estes erros podem ser dificéis de depurar por causa de espaços, tabs e novas linhas que são normalmente invisivéis.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; s = "1 2\t 3\n 4";

julia&gt; println(s)
1 2     3
 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>As funções internas <code>repr</code> ou <code>dump</code> podem ajudar. Elas recebem qualquer objeto como argumento e retornam uma string representando o objeto.</p>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; repr(s)
"\"1 2\\t 3\\n 4\""
julia&gt; dump(s)
String "1 2\t 3\n 4"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isso pode ser útil para depurar.
</p>
</div>
<div class="paragraph">
<p>Um outro problema que você pode encontrar é que sistemas diferentes usam caracteres diferentes para indicar o final da linha. Alguns sistemas usam uma nova linha, representada por <code>\n</code>. Outros usam um caractere de retorno, representado por <code>\r</code>. Alguns usam ambos. Se você mover arquivos entre sistemas diferentes, essas inconsistências podem causar problemas.
</p>
</div>
<div class="paragraph">
<p>Para a maioria dos sistemas, existem aplicações que convertem de um formato para o outro. Você pode achá-los (e ler mais a respeito deste problema) em <a href="https://pt.wikipedia.org/wiki/Nova_linha" class="bare">https://pt.wikipedia.org/wiki/Nova_linha</a>. Ou, é claro, você pode escrever um por conta própria.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_14">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">persistente</dt>
<dd>
<p>Referente a um programa que é executado indefinidamente e mantém pelo menos alguns de seus dados em armazenamento permanente.
</p>
</dd>
<dt class="hdlist1">arquivo de texto</dt>
<dd>
<p>Uma sequência de caracteres guardados em armazenamento permanente como um disco rígido.
</p>
</dd>
<dt class="hdlist1">diretório</dt>
<dd>
<p>Uma coleção de arquivos com nome, também chamada de pasta.
</p>
</dd>
<dt class="hdlist1">caminho</dt>
<dd>
<p>Uma string que identifica um arquivo.
</p>
</dd>
<dt class="hdlist1">caminho relativo</dt>
<dd>
<p>Um caminho que inicia no diretório atual.
</p>
</dd>
<dt class="hdlist1">caminho absoluto</dt>
<dd>
<p>Um caminho que inicia do diretório mais acima no sistema de arquivos.
</p>
</dd>
<dt class="hdlist1">catch</dt>
<dd>
<p>Prevenir uma exceção de terminar um programa usando as declarações <code>try ... catch ... finally</code>.
</p>
</dd>
<dt class="hdlist1">banco de dados</dt>
<dd>
<p>Um arquivo cujo conteúdo está organizado como um dicionário com chaves que correspondem a valores.
</p>
</dd>
<dt class="hdlist1">shell</dt>
<dd>
<p>Um programa que permite usuários a digitar comandos e em seguida executá-los iniciando outros programas.
</p>
</dd>
<dt class="hdlist1">objeto comando</dt>
<dd>
<p>Um objeto que representa um comando shell, permitindo um programa em Julia a executar comandos e ler os resultados.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_16">Exercícios</h3>
<div class="sect4">
<h5 id="ex14-1">Exercício 14-2</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>sed</code> que recebe como argumento uma string padrão, uma string de substituição e dois nomes de arquivos; ela deve ler o primeiro arquivo e escrever o conteúdo no segundo arquivo (o criando se for necessário). Se o padrão aparece em qualquer lugar no arquivo, ele deve ser substituido pela string de substituição.
</p>
</div>
<div class="paragraph">
<p>Se um erro ocorre durante a abertura, leitura, escrita ou fechamento dos arquivos, seu programa deve capturar a exceção, exibir a mensagem de erro e sair.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex14-2">Exercício 14-3</h5>
<div class="paragraph">
<p>Se você fez <a href="#ex12-2">Exercício 12-3</a>, você verá que um dicionário é criado que mapeia uma string ordenada de letras para uma lista de palavras que podem ser escritas com estas letras. Por exemplo, <code>"opst"</code> é mapeado para a lista <code>["opts", "post", "pots", "spot", "stop", "tops"]</code>.</p>
</div>
<div class="paragraph">
<p>Escreva um módulo que importe <code>anagramsets</code> e forneça duas novas funções: <code>guardaanagramas</code> deve guardar o dicionário de anagramas usando <code>JLD2</code>; <code>leranagrams</code> deve buscar uma palavra e retornar uma lista de seus anagramas.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex14-3">Exercício 14-4</h5>
<div class="paragraph">
<p>Em uma grande coleção de arquivos MP3, podem haver mais de uma cópia da mesma música, guardada em diretórios diferentes ou com nomes de arquivo diferentes. O objetivo deste exercício é procurar por duplicatas.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escreva um programa que busca um diretório e todos seus subdiretórios, recursivamente, e retorna uma lista de paths completos para todos os arquivos com um dado sufixo (como <em>.mp3</em>).</p>
</li>
<li>
<p>Para reconhecer duplicatas, você pode usar <code>md5sum</code> ou <code>md5</code> para computar a “checksum” de cada arquivo. Se dois arquivos tem a mesma checksum, eles provavelmente tem o mesmo conteúdo.</p>
</li>
<li>
<p>Para verificar novamente, você pode usar o comando Unix <code>diff</code>.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap15">15. Estruturas e Objetos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A esta altura, você sabe como usar funções para organizar o código e os tipos internos para organizar os dados. O próximo passo é aprender a criar os seus próprios tipos para organizar tanto o código como os dados. Este é um tópico importante e serão necessários alguns capítulos para abordar o tema.</p>
</div>
<div class="sect2">
<h3 id="_tipos_compostos">Tipos Compostos</h3>
<div class="paragraph">
<p>Temos usado muitos tipos internos do Julia e agora definiremos um novo tipo. Como exemplo, vamos criar um tipo chamado <code>Ponto</code> que representa um ponto no espaço bidimensional.
</p>
</div>
<div class="paragraph">
<p>Na notação matemática, os pontos geralmente são escritos entre parênteses com uma vírgula separando as coordenadas. Por exemplo, \(\left(0,0\right)\) representa a origem e \(\left(x,y\right)\) representa o ponto \(x\) unidades à direita e \(y\) unidades acima da origem, se o ponto estiver no 1o. quadrante.</p>
</div>
<div class="paragraph">
<p>Existem diversas maneiras de representar pontos no Julia:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Poderíamos armazenar as coordenadas separadamente em duas variáveis, <code>x</code> e <code>y</code>.</p>
</li>
<li>
<p>Poderíamos armazenar as coordenadas como elementos de um vetor ou de uma tupla.</p>
</li>
<li>
<p>Poderíamos criar um novo tipo para representar os pontos como objetos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Criar um novo tipo é mais complicado que as outras opções, mas possui vantagens que serão mostradas em breve.</p>
</div>
<div class="paragraph">
<p>Um <em>tipo composto</em> definido pelo programador também é denominado de <em>estrutura</em> (struct). A definição <code>struct</code> pode ser representada da seguinte maneira:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Ponto
    x
    y
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O cabeçalho indica que a nova struct é chamada de <code>Ponto</code> enquanto o corpo define os <em>atributos</em> ou os <em>campos</em> da struct. Nesse caso, a struct <code>Ponto</code> possui dois campos: <code>x</code> e <code>y</code>.
</p>
</div>
<div class="paragraph">
<p>Uma struct é como uma fábrica que cria objetos. Para criar um ponto, chama-se <code>Ponto</code> como se fosse uma função que tem os valores dos campos como argumentos. Quando <code>Ponto</code> é usado como uma função, ele é chamado de <em>construtor</em>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; p = Ponto(3.0, 4.0)
Ponto(3.0, 4.0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>O valor de retorno é uma referência a um objeto <code>Ponto</code>, que atribuímos a <code>p</code>.
</p>
</div>
<div class="paragraph">
<p>A criação de um novo objeto é chamada <em>instanciação</em>, e o objeto é uma <em>instância</em> do tipo.
</p>
</div>
<div class="paragraph">
<p>Quando você imprime uma instância, o Julia informa a que tipo pertence e quais os valores dos atributos.</p>
</div>
<div class="paragraph">
<p>Todo objeto é uma instância de algum tipo; portanto, “objeto” e “instância” são permutáveis. Mas neste capítulo, eu uso “instância” para indicar que estou falando de um tipo definido pelo programador.</p>
</div>
<div class="paragraph">
<p>Um diagrama de estado que mostra um objeto e os seus campos é denominado <em>diagrama do objeto</em>, conforme <a href="#fig15-1">Diagrama do objeto</a>.
</p>
</div>
<div id="fig15-1" class="imageblock">
<div class="content">
<img src="images/fig151.svg" alt="fig151">
</div>
<div class="title">Figura 20. Diagrama do objeto</div>
</div>
</div>
<div class="sect2">
<h3 id="_structs_são_imutáveis">Structs são Imutáveis</h3>
<div class="paragraph">
<p>Você pode acessar os valores dos campos usando a notação <code>.</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = p.x
3.0
julia&gt; p.y
4.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>A expressão <code>p.x</code> significa: “Vá até a referência do objeto <code>p</code> e obtenha o valor de <code>x</code>.” No exemplo, atribuímos esse valor a uma variável denominada <code>x</code>. Não há conflito entre a variável <code>x</code> e o campo <code>x</code>.</p>
</div>
<div class="paragraph">
<p>Você pode usar a notação do ponto como parte de qualquer expressão. Por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; distância = sqrt(p.x^2 + p.y^2)
5.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por padrão, as structs são imutáveis, isto é, após a construção, os campos não podem mudar de valor:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; p.y = 1.0
ERROR: setfield! immutable struct of type Ponto cannot be changed</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isso pode parecer estranho de início, mas tem várias vantagens:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Pode ser mais eficiente.</p>
</li>
<li>
<p>Não é possível violar os invariantes dos construtores do tipo (veja <a href="#constructor">Construtores</a>).</p>
</li>
<li>
<p>O código que usa os objetos imutáveis pode ser mais fácil de ler e entender.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_structs_mutáveis">Structs Mutáveis</h3>
<div class="paragraph">
<p>Quando necessário, os tipos compostos mutáveis podem ser declarados com a palavra-chave <code>mutable struct</code>. Aqui está a definição de um ponto mutável:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">mutable struct MPonto
    x
    y
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Você pode atribuir valores a uma instância de uma struct mutável usando a notação de ponto:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; lacuna = MPonto(0.0, 0.0)
MPonto(0.0, 0.0)
julia&gt; lacuna.x = 3.0
3.0
julia&gt; lacuna.y = 4.0
4.0</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_retângulos">Retângulos</h3>
<div class="paragraph">
<p>Às vezes, é óbvio quais devem ser os campos de um objeto, mas outras vezes você precisa escolher entre as opções. Por exemplo, imagine que você está estruturando um tipo para representar retângulos. Quais campos você usaria para especificar a localização e o tamanho de um retângulo? Desconsidere o ângulo e para simplificar, suponha que o retângulo seja vertical ou horizontal.</p>
</div>
<div class="paragraph">
<p>Existem pelo menos duas possibilidades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Você poderia especificar um vértice do retângulo (ou o centro), a largura e a altura.</p>
</li>
<li>
<p>Você poderia especificar dois vértices opostos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Nesse momento, é difícil dizer se uma é melhor que a outra e portanto, implementaremos a primeira, apenas como exemplo.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">"""
Representa um retângulo.

campos: largura, altura, vértice.
"""
struct Retângulo
    largura
    altura
    vértice
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O docstring lista os campos: a largura e a altura, que são números, e o vértice, que é um objeto <code>Ponto</code> que indica o vértice inferior esquerdo.
</p>
</div>
<div class="paragraph">
<p>Para representar um retângulo, você precisa instanciar um objeto <code>Retângulo</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; origem = MPonto(0.0, 0.0)
MPonto(0.0, 0.0)
julia&gt; caixa = Retângulo(100.0, 200.0, origem)
Retângulo(100.0, 200.0, MPonto(0.0, 0.0))</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#fig15-2">Diagrama do objeto</a> mostra o estado deste objeto. Um objeto que é um campo de outro objeto é <em>embutido</em>. Perceba que o atributo <code>vértice</code> se refere a um objeto mutável, por isso ele é desenhado fora do objeto <code>Retângulo</code>.
</p>
</div>
<div id="fig15-2" class="imageblock">
<div class="content">
<img src="images/fig152.svg" alt="fig152">
</div>
<div class="title">Figura 21. Diagrama do objeto</div>
</div>
</div>
<div class="sect2">
<h3 id="_instâncias_como_argumentos">Instâncias como Argumentos</h3>
<div class="paragraph">
<p>Você pode passar uma instância como um argumento da maneira tradicional. Por exemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprimir_ponto(p)
    println("($(p.x), $(p.y))")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função <code>imprimir_ponto</code> recebe como argumento um <code>Ponto</code> e apresenta-o em notação matemática. Para chamá-lo, você pode passar <code>p</code> como argumento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; imprimir_ponto(lacuna)
(3.0, 4.0)</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_exercício_15_1">Exercício 15-1</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>distância_entre_pontos</code> que recebe dois pontos como argumentos e retorna a distância entre eles.
</p>
</div>
<div class="paragraph">
<p>Se um objeto da struct mutável for passado para uma função como argumento, a função poderá modificar os campos do objeto. Por exemplo, <code>move_ponto!</code> recebe um objeto mutável <code>MPonto</code> e dois números <code>dx</code> e <code>dy</code>, e adiciona os números respectivamente aos atributos <code>x</code> e <code>y</code> de <code>MPonto</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function move_ponto!(p, dx, dy)
    p.x += dx
    p.y += dy
    nothing
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aqui está um exemplo que mostra o resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; origem = MPonto(0.0, 0.0)
MPonto(0.0, 0.0)
julia&gt; move_ponto!(origem, 1.0, 2.0)

julia&gt; origem
MPonto(1.0, 2.0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dentro da função, <code>p</code> é um alias (ou uma referência) para <code>origem</code>, então quando a função modifica <code>p</code>, <code>origem</code> também muda.
</p>
</div>
<div class="paragraph">
<p>Passar um objeto <code>Ponto</code> imutável para <code>move_ponto!</code> gera um erro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; move_ponto!(p, 1.0, 2.0)
ERROR: setfield! immutable struct of type Ponto cannot be changed</code></pre>
</div>
</div>
<div class="paragraph">
<p>No entanto, você pode modificar o valor de um atributo mutável de um objeto imutável. Por exemplo, <code>move_retângulo!</code> tem como argumentos um objeto <code>Retângulo</code> e dois números <code>dx</code> e <code>dy</code>, e usa <code>move_ponto!</code> para mover o canto do retângulo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function move_retângulo!(ret, dx, dy)
  move_ponto!(ret.vértice, dx, dy)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora <code>p</code> em <code>move_ponto!</code> é uma referência para <code>ret.vértice</code>, então quando <code>p</code> é modificado, <code>ret.vértice</code> também muda:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; caixa
Retângulo(100.0, 200.0, MPonto(0.0, 0.0))
julia&gt; move_retângulo!(caixa, 1.0, 2.0)

julia&gt; caixa
Retângulo(100.0, 200.0, MPonto(1.0, 2.0))</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Atenção</div>
</td>
<td class="content">
<div class="paragraph">
<p>Você não pode reatribuir um atributo mutável a um objeto imutável:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; caixa.vértice = MPonto(1.0, 2.0)
ERROR: setfield! immutable struct of type Retângulo cannot be changed</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_instâncias_como_valores_de_retorno">Instâncias como Valores de Retorno</h3>
<div class="paragraph">
<p>Funções podem retornar instâncias. Por exemplo, <code>encontra_centro</code> recebe um <code>Retângulo</code> como argumento e retorna um <code>Ponto</code> que contém as coordenadas do centro do retângulo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function encontra_centro(ret)
    Ponto(ret.vértice.x + ret.largura / 2, ret.vértice.y + ret.altura / 2)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A expressão <code>ret.vértice.x</code> significa: “Vá ao objeto <code>ret</code> e selecione o campo <code>vértice</code>; depois vá até esse objeto e selecione o campo <code>x</code>.”</p>
</div>
<div class="paragraph">
<p>Aqui está um exemplo que passa <code>caixa</code> como argumento e atribui o <code>Ponto</code> recebido ao <code>centro</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; centro = encontra_centro(caixa)
Ponto(51.0, 102.0)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_copiando_objetos">Copiando Objetos</h3>
<div class="paragraph">
<p>Usar um alias pode dificultar a leitura de um programa, pois as alterações em um local podem ter efeitos inesperados em outro local. É difícil acompanhar todas as variáveis que podem se referir a um objeto dado.
</p>
</div>
<div class="paragraph">
<p>A cópia de um objeto é muitas vezes uma alternativa ao aliasing. O Julia possui uma função chamada <code>deepcopy</code> que pode duplicar qualquer objeto:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; p1 = MPonto(3.0, 4.0)
MPonto(3.0, 4.0)
julia&gt; p2 = deepcopy(p1)
MPonto(3.0, 4.0)
julia&gt; p1 ≡ p2
false
julia&gt; p1 == p2
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>O operador <code>≡</code> indica que <code>p1</code> e <code>p2</code> não são o mesmo objeto, que é o que imaginávamos. Mas você pode ter pensado que <code>==</code> devolvesse <code>true</code> porque esses pontos contêm os mesmos dados. Nesse caso, você ficará desapontado ao saber que, para objetos mutáveis, o comportamento padrão do operador <code>==</code> é o mesmo do operador <code>===</code> pois verifica-se a identidade do objeto e não a equivalência do objeto. Isso ocorre porque, para tipos compostos mutáveis, o Julia não sabe o que deve ser considerado equivalente. Pelo menos, ainda não.
</p>
</div>
<div class="sect4">
<h5 id="_exercício_15_2">Exercício 15-2</h5>
<div class="paragraph">
<p>Crie uma instância <code>Ponto</code>, faça uma cópia dela e verifique a equivalência e a igualdade de ambas. O resultado pode surpreendê-lo, além de explicar porque o alias não é um problema para um objeto imutável.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_depuração_13">Depuração</h3>
<div class="paragraph">
<p>Quando você começa a trabalhar com os objetos, é provável que encontre algumas novas exceções. Se você tentar acessar um campo que não existe, tem-se:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; p = Ponto(3.0, 4.0)
Ponto(3.0, 4.0)
julia&gt; p.z = 1.0
ERROR: type Ponto has no field z</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se você não tem certeza de qual é o tipo de objeto, pode-se perguntar:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; typeof(p)
Ponto</code></pre>
</div>
</div>
<div class="paragraph">
<p>Você também pode usar <code>isa</code> para verificar se um objeto é uma instância de um certo tipo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; p isa Ponto
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se você não tem certeza se um objeto possui um determinado atributo, pode-se usar a função interna <code>fieldnames</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fieldnames(Ponto)
(:x, :y)</code></pre>
</div>
</div>
<div class="paragraph">
<p>ou a função <code>isdefined</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; isdefined(p, :x)
true
julia&gt; isdefined(p, :z)
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>O primeiro argumento pode ser qualquer objeto enquanto o segundo argumento é um símbolo <code>:</code> seguido do nome do campo.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_15">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">struct</dt>
<dd>
<p>Um tipo composto.
</p>
</dd>
<dt class="hdlist1">construtor</dt>
<dd>
<p>Uma função que tem o mesmo nome que um tipo e que cria as instâncias deste tipo.
</p>
</dd>
<dt class="hdlist1">instância</dt>
<dd>
<p>Um objeto que pertence a um tipo.
</p>
</dd>
<dt class="hdlist1">instanciar</dt>
<dd>
<p>Criar um novo objeto.
</p>
</dd>
<dt class="hdlist1">atributo ou campo</dt>
<dd>
<p>Um dos valores nomeados associados a um objeto.
</p>
</dd>
<dt class="hdlist1">objeto embutido</dt>
<dd>
<p>Um objeto que é armazenado como um campo de outro objeto.
</p>
</dd>
<dt class="hdlist1">cópia profunda</dt>
<dd>
<p>Cópia do conteúdo de um objeto, bem como quaisquer objetos embutidos e quaisquer objetos embutidos a eles, e assim por diante; é implementado pela função <code>deepcopy</code>.
</p>
</dd>
<dt class="hdlist1">diagrama de objetos</dt>
<dd>
<p>Um diagrama que mostra os objetos, os seus campos e os respectivos valores dos campos.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_17">Exercícios</h3>
<div class="sect4">
<h5 id="ex15-1">Exercício 15-3</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escreva uma definição para um tipo chamado <code>Círculo</code> com os campos <code>centro</code> e <code>raio</code>, em que <code>centro</code> é um objeto <code>Ponto</code> e <code>raio</code> é um número.
</p>
</li>
<li>
<p>Instancie um objeto círculo que represente um círculo com seu centro em \(\left(150, 100\right)\) e raio 75.</p>
</li>
<li>
<p>Escreva uma função denominada <code>ponto_no_círculo</code> que recebe um objeto <code>Círculo</code> e um objeto <code>Ponto</code> e retorna <code>true</code> se o ponto estiver dentro ou no contorno do círculo.
</p>
</li>
<li>
<p>Escreva uma função denominada <code>ret_no_círculo</code> que recebe um objeto <code>Círculo</code> e um objeto <code>Retângulo</code> e retorna <code>true</code> se o retângulo estiver inteiramente dentro ou nos contornos do círculo.
</p>
</li>
<li>
<p>Escreva uma função denominada <code>ret_círc_sobreposição</code> que recebe um objeto <code>Círculo</code> e um objeto <code>Retângulo</code> e devolve <code>true</code> se algum dos vértices do retângulo estiver dentro do círculo. Ou, como uma versão mais desafiadora, devolva <code>true</code> se alguma parte do retângulo estiver dentro do círculo.
</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="ex15-2">Exercício 15-4</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escreva uma função chamada <code>desenha_ret</code> que recebe um objeto do tipo turtle e um objeto <code>Retângulo</code> e use a tartaruga para desenhar o retângulo. Verifique o Capítulo 4 para os exemplos que usam os objetos <code>Turtle</code>.
</p>
</li>
<li>
<p>Escreva uma função chamada <code>desenha_círculo</code> que recebe um objeto <code>Turtle</code> e um objeto <code>Círculo</code> e desenha o círculo.
</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap16">16. Estruturas e Funções</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Agora que sabemos como criar novos tipos compostos, o próximo passo é escrever funções que recebem objetos definidos pelo programador como parâmetro e retornam estes objetos como resultado. Neste capítulo apresentaremos um “estilo de programação funcional” e dois novos planos de desenvolvimento de programa.</p>
</div>
<div class="sect2">
<h3 id="time">Horário</h3>
<div class="paragraph">
<p>Como outro exemplo de um tipo composto, definiremos uma <code>struct</code> chamada <code>MeuHorário</code> que guarda o horário do dia. A definição da estrutura se parece como:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">"""
Representa o horário do dia.

campos: hora, minuto, segundo
"""
struct MeuHorário
    hora
    minuto
    segundo
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O nome <code>Time</code> já é utilizado no Julia e para evitar um conflito de nomes, escolhemos <code>MeuHorário</code>. Podemos criar um novo objeto <code>MeuHorário</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; horario = MeuHorário(11, 59, 30)
MeuHorário(11, 59, 30)</code></pre>
</div>
</div>
<div class="paragraph">
<p>O diagrama de objeto para <code>MeuHorário</code> se parece com a <a href="#fig16-1">Diagrama de objeto</a>.</p>
</div>
<div id="fig16-1" class="imageblock">
<div class="content">
<img src="images/fig161.svg" alt="fig161">
</div>
<div class="title">Figura 22. Diagrama de objeto</div>
</div>
<div class="sect4">
<h5 id="_exercício_16_1">Exercício 16-1</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>imprime_horário</code> que recebe um objeto <code>MeuHorário</code> e imprima-o em forma de <code>hora:minuto:segundo</code>. A instrução <code>@printf</code> do módulo StdLib <code>Printf</code> imprime um inteiro com o formato de sequência <code>"%02d"</code> usando pelo menos dois dígitos, incluindo um zero inicial se necessário.
</p>
</div>
</div>
<div class="sect4">
<h5 id="_exercício_16_2">Exercício 16-2</h5>
<div class="paragraph">
<p>Escreva uma função booleana chamada <code>é_depois</code> que recebe dois objetos <code>MeuHorário</code>, <code>t1</code> e <code>t2</code>, e retorna <code>true</code> se <code>t1</code> segue <code>t2</code> cronologicamente e <code>false</code> caso contrário. Desafio: não use uma declaração <code>if</code>.
</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_funções_puras">Funções Puras</h3>
<div class="paragraph">
<p>Nas próximas seções, escreveremos duas funções que adicionam valores de tempo. Elas demonstrarão dois tipos de funções: funções puras e modificadoras. Elas também demonstrarão um plano de desenvolvimento que chamaremos de <em>protótipo e correção</em>, que é uma forma de combater um problema complexo começando com um protótipo simples e aos poucos lidar com as complicações.
</p>
</div>
<div class="paragraph">
<p>Aqui vai um simples protótipo de <code>soma_horário</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function soma_horário(t1, t2)
    MeuHorário(t1.hora + t2.hora, t1.minuto + t2.minuto, t1.segundo + t2.segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função cria um novo objeto <code>MeuHorário</code>, inicializando os seus campos e retornando uma referência ao novo objeto. Isso é chamado de <em>função pura</em> pois não modifica nenhum dos objetos que são passados como argumentos e não tem efeito, como exibir um valor ou obter entrada do usuário, além de retornar um valor.</p>
</div>
<div class="paragraph">
<p>Para testar essa função, criaremos dois objetos <code>MeuHorário</code>: <code>início</code> que contém a hora de início de um filme, como <em>Monthy Python: Em Busca do Cálice Sagrado</em>, e <code>duração</code> que contém o tempo de duração do filme, que é de uma hora e 35 minutos.</p>
</div>
<div class="paragraph">
<p><code>soma_horário</code> descobre quando o filme irá terminar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; início = MeuHorário(9, 45, 0);

julia&gt; duração = MeuHorário(1, 35, 0);

julia&gt; fim = soma_horário(início, duração);

julia&gt; imprime_horário(fim)
10:80:00</code></pre>
</div>
</div>
<div class="paragraph">
<p>O resultado, <code>10:80:00</code> talvez não seja o que esperávamos. O problema é que essa função não lida com casos no qual o número de segundos ou minutos ultrapassam sessenta. Quando isso ocorre, temos que “carregar” os segundos extras para a coluna de minutos ou os minutos extras para a coluna de horas. Aqui vai uma versão aprimorada:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@julia-setup chap16" data-lang="@julia-setup chap16">function soma_horário(t1, t2)
    segundo = t1.segundo + t2.segundo
    minuto = t1.minuto + t2.minuto
    hora = t1.hora + t2.hora
    if segundo &gt;= 60
        segundo -= 60
        minuto += 1
    end
    if minuto &gt;= 60
        minuto -= 60
        hora += 1
    end
    MeuHorário(hora, minuto, segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Apesar desta função estar correta, ela está começando a ficar grande. Veremos uma alternativa mais concisa em breve.</p>
</div>
</div>
<div class="sect2">
<h3 id="modifiers">Modificadores</h3>
<div class="paragraph">
<p>Em certos momentos, é útil para uma função modificar os objetos que recebe como parâmetros. Neste caso, as mudanção são visíveis para quem a chama. Funções que funcionam dessa maneira são chamadas de <em>modificadoras</em>.
</p>
</div>
<div class="paragraph">
<p><code>incrementa!</code>, que adiciona um dado número de segundos à um objeto <code>MeuHorário</code>, pode ser escrito naturalmente como um modificador. Aqui está um rascunho:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function incrementa!(tempo, segundos)
    tempo.segundo += segundos
    if tempo.segundo &gt;= 60
        tempo.segundo -= 60
        tempo.minuto += 1
    end
    if tempo.minuto &gt;= 60
        tempo.minuto -= 60
        tempo.hora += 1
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A primeira linha executa a operação básica, o resto lida com os casos especiais que vimos anteriormente.</p>
</div>
<div class="paragraph">
<p>Essa função está correta? O que acontece se <code>segundos</code> for muito maior que 60?</p>
</div>
<div class="paragraph">
<p>Neste caso, não basta carregar uma vez; temos que continuar a fazer isso até que <code>tempo.segundo</code> seja menor que 60. Uma solução é substituir as declarações <code>if</code> por declarações <code>while</code>. O que fará com que a função fique correta, porém, não muito eficiente.</p>
</div>
<div class="sect4">
<h5 id="_exercício_16_3">Exercício 16-3</h5>
<div class="paragraph">
<p>Escreva uma versão correta de <code>incrementa!</code> que não contenha nenhum laço.</p>
</div>
<div class="paragraph">
<p>Qualquer coisa que pode ser feita com modificadores também pode ser feita com funções puras. De fato, algumas linguagens de programação permitem apenas funções puras. Há algumas evidências de que programas que usam funções puras são mais rápidos para serem desenvolvidos e menos propensos a erros do que programas que usam modificadores. Porém, às vezes modificadores são convenientes e programas funcionais tendem a ser menos eficientes.</p>
</div>
<div class="paragraph">
<p>Em geral, recomendamos que você escreva funções puras sempre que for razoável e recorrer a modificadores apenas se há uma vantagem atraente. Essa abordagem pode ser chamada de <em>estilo de programação funcional</em>.
</p>
</div>
</div>
<div class="sect4">
<h5 id="_exercício_16_4">Exercício 16-4</h5>
<div class="paragraph">
<p>Escreva uma versão “pura” de <code>incrementa</code> que cria e retorna um novo objeto <code>MeuHorário</code> ao invéz de modificar o parâmetro.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="prototyping_versus_planning">Prototipagem Versus Planejamento</h3>
<div class="paragraph">
<p>O plano de desenvolvimento que estamos demonstrando é chamado de “protótipo e correção”. Para cada função, escrevemos um protótipo que executava os cálculos básicos e depois testavamos-o, corrigindo os erros ao longo do caminho.
</p>
</div>
<div class="paragraph">
<p>Essa abordagem pode ser efetiva, especialmente quando você ainda não tem um entendimento profundo acerca do problema. Mas correções incrementais podem gerar código que é desnecessariamente complicado, já que ele lida com muitos casos especiais, e também que não é confiável, já que é difícil saber se você encontrou todos os erros.</p>
</div>
<div class="paragraph">
<p>Uma alternativa é o <em>desenvolvimento projetado</em>, no qual obter uma visão de alto nível do problema pode facilitar muito a programação. Neste caso, podemos perceber que um objeto Time é na verdade um número de três dígitos na base 60 (consulte <a href="https://pt.wikipedia.org/wiki/Sistema_de_numera%C3%A7%C3%A3o_sexagesimal)!" class="bare">https://pt.wikipedia.org/wiki/Sistema_de_numera%C3%A7%C3%A3o_sexagesimal)!</a> O atributo dos segundos é a “coluna de uns”, o atributo de munutos é a “coluna de sessentas” e o atributo da hora é a “coluna de três mil e seiscentos”.
</p>
</div>
<div class="paragraph">
<p>Quando escrevemos <code>soma_horário</code> e <code>incrementa!</code>, efetivamente estavamos realizando uma adição na base 60, que é a razão de termos carregado de uma coluna para a próxima.</p>
</div>
<div class="paragraph">
<p>Essa observação nos sugere uma outra abordagem para todo o problema—podemos converter objetos <code>MeuHorário</code> para inteiros e obter uma vantagem do fato de que o computador sabe como realizar artimética inteira.</p>
</div>
<div class="paragraph">
<p>Abaixo temos uma função que converte um objeto MeuHorário para inteiros.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@julia-setup chap16" data-lang="@julia-setup chap16">function hora_para_int(tempo)
    minutos = tempo.hora * 60 + tempo.minuto
    segundos = minutos * 60 + tempo.segundo
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aqui temos uma função que converte um inteiro para <code>MeuHorário</code> (lembre-se que <code>divrem</code> divide o primeiro argumento pelo segundo e retorna o quociente e o resto como uma tupla):
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function int_para_hora()
    (minutos, segundo) = divrem(segundos, 60)
    hora, minuto = divrem(minutos, 60)
    MeuHorário(hora, minuto, segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Talvez você tenha que pensar um pouco e executar alguns testes para se convencer de que essas funções estão corretas. Uma forma de testar é verificar que <code>hora_para_int(int_para_hora(x)) == x</code> para quaisquer valores de <code>x</code>. Esse é um exemplo de verificação de consistência.</p>
</div>
<div class="paragraph">
<p>Uma vez que você esteja convencido de que elas estão corretas, você poderá usá-las para reescrever <code>soma_horário</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function soma_horário(t1, t2)
    segundos = hora_para_int(t1) + hora_para_int(t2)
    int_para_hora(segundos)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Essa versão é mais curta que a original e mais fácil de verificar.</p>
</div>
<div class="sect4">
<h5 id="_exercício_16_5">Exercício 16-5</h5>
<div class="paragraph">
<p>Reescreva <code>incrementa!</code> usando <code>hora_para_int</code> e <code>int_para_hora</code>.</p>
</div>
<div class="paragraph">
<p>Algumas vezes, converter da base 60 para a base 10 e vice-versa é mais difícil do que lidar com tempo. A conversão de base é mais abstrata; a nossa intuição para lidar com valores de tempo é melhor.</p>
</div>
<div class="paragraph">
<p>Mas se nós tivermos a ideia de tratar horas como número de base 60 e investir na escrita de funções de conversão (<code>hora_para_int</code> e <code>int_para_hora</code>), nós temos um programa que é menor, mais fácil de ler e depurar, e mais confiável.</p>
</div>
<div class="paragraph">
<p>Também é mais fácil acrescentar característica depois. Por exemplo, imagine subtrair dois objetos <code>MeuHorário</code> para encontrar a duração entre eles. Uma abordagem ingênua seria implementar a subtração com empréstimo. Porém, usar funções de conversão seria mais fácil e, provavelmente, mais correto.</p>
</div>
<div class="paragraph">
<p>Ironicamente, as vezes tornar um problema mais difícil (ou mais geral) facilita (porque há menos casos especiais e menos oportunidades de erro).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="chap16_debugging">Depurando</h3>
<div class="paragraph">
<p>Um objeto <code>MeuHorário</code> é bem formado se os valores de <code>minuto</code> e <code>segundo</code> estão entre 0 e 60 (incluindo 0 mas não 60) e se <code>hora</code> é positivo. <code>hora</code> e <code>minuto</code> devem ser valores integrais mas talvez devessemos permitir que <code>segundo</code> tenha uma parte fracional.
</p>
</div>
<div class="paragraph">
<p>Requisitos como esses são ditos <em>invariantes</em> porque eles sempre devem ser verdadeiros. Para dizer de outra forma, se eles não forem verdadeiros, algo deu errado.
</p>
</div>
<div class="paragraph">
<p>Escrever código para verificar requisitos invariantes pode ajudar a descobrir erros e encontrar suas causas. Por exemplo, você pode ter uma função como <code>hora_válida</code>, que receba um objeto <code>MeuHorário</code> e retorna <code>false</code> se ela violar um requisito invariante:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function hora_válida(tempo)
    if tempo.hora &lt; 0 || tempo.minuto &lt; 0 || tempo.segundo &lt; 0
        return false
    end
    if tempo.minuto &gt;= 60 || tempo.segundo &gt;= 60
        return false
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>No início de cada função você deve checar os argumentos para ter certeza de que eles são válidos.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function soma_horário(t1,t2)
    if !hora_válida(t1) || !hora_válida(t2)
        error("objeto MeuHorário inválido em soma_horário")
    end
    segundos = hora_para_int(t1) + hora_para_int(t2)
   int_para_hora(segundos)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ou você pode usar uma instrução <code>@assert</code>, que verifica determinado requisito invariável e gera uma exceção se ele falhar:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function soma_horário(t1, t2)
    @assert(hora_válida(t1) &amp;&amp; hora_válida(t2), "objeto MeuHorário inválido em soma_horário")
    segundos = hora_para_int(t1) + hora_para_int(t2)
    int_para_hora(segundos)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Macros <code>@assert</code> são úteis porque distinguem o código que lida com condições normais do código que verifica erros.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_16">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">protótipo e correção</dt>
<dd>
<p>Um plano de desenvolvimento que envolve escrever um rascunho de um programa, testar e corrigir erros que são encontrados.
</p>
</dd>
<dt class="hdlist1">desenvolvimento projetado</dt>
<dd>
<p>Plano de desenvolvimento que implica uma compreensão de alto nível do problema e mais planejamento do que desenvolvimento incremental ou desenvolvimento prototipado.
</p>
</dd>
<dt class="hdlist1">funções puras</dt>
<dd>
<p>Função que não altera nenhum dos objetos que recebe como argumento. A maior parte das funções puras gera resultado.
</p>
</dd>
<dt class="hdlist1">modificador</dt>
<dd>
<p>Função que modifica um ou vários dos objetos que recebe como argumento. A maior parte dos modificadores são nulos; isto é, retornam <code>nothing</code>.
</p>
</dd>
<dt class="hdlist1">programa funcional</dt>
<dd>
<p>Um estilo de projeto de programa no qual a maioria das funções são puras.
</p>
</dd>
<dt class="hdlist1">invariante</dt>
<dd>
<p>Uma condição que nunca deve mudar durante a execução de um programa.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_18">Exercícios</h3>
<div class="sect4">
<h5 id="ex16-1">Exercício 16-6</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>mult_horário</code> que pega um objeto <code>MeuHorário</code> e um número, e retorna um novo objeto <code>MeuHorário</code> que contém o produto do <code>MeuHorário</code> original e do número.
</p>
</div>
<div class="paragraph">
<p>Em seguida use <code>mult_horário</code> para escrever uma função que receba um objeto <code>MeuHorário</code> representando o tempo até o fim de uma corrida e um número que represente a distância e retorne um objeto <code>MeuHorário</code> com o ritmo médio (tempo por quilômetro).</p>
</div>
</div>
<div class="sect4">
<h5 id="ex16-2">Exercício 16-7</h5>
<div class="paragraph">
<p>O Julia fornece objetos de tempo que são similares aos objetos <code>MeuHorário</code> desse capítulo, mas eles fornecem um conjunto rico de funções e operadores. Leia a documentação em <a href="https://docs.julialang.org/en/v1/stdlib/Dates/" class="bare">https://docs.julialang.org/en/v1/stdlib/Dates/</a>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escreva um programa que obtenha a data atual e imprima o dia da semana.</p>
</li>
<li>
<p>Escreva um programa que aceite um aniversário como entrada e imprima a idade do usuário e o número de dias, horas, minutos e segundos até o próximo aniversário.</p>
</li>
<li>
<p>Para duas pessoas nascidas em dias diferentes, há um dia em que uma tem o dobro da idade da outra. Esse é o Dia do Dobro deles. Escreva um programa que receba dois aniversários e calcula o Dia do Dobro.</p>
</li>
<li>
<p>Para lhe desafiar um pouco, escreva a versão mais geral que calcula o dia em que uma pessoa é \(n\) vezes mais velha que a outra.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap17">17. Despacho Múltiplo</h2>
<div class="sectionbody">
<div class="paragraph">
<p>No Julia você tem a habilidade de escrever código que opera em tipos diferentes. Esta habilidade é chamada de programação genérica.</p>
</div>
<div class="paragraph">
<p>Neste capítulo, discutiremos o uso de declarações de tipo em Julia, e também introduziremos métodos que implementam os comportamentos diferentes para uma função, dependendo dos tipos de seus argumentos. Isto é chamado de despacho múltiplo.</p>
</div>
<div class="sect2">
<h3 id="_declarações_de_tipo">Declarações de Tipo</h3>
<div class="paragraph">
<p>O operador <code>::</code> anexa <em>anotações de tipo</em> às expressões e variáveis:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; (1 + 2) :: Float64
ERROR: TypeError: in typeassert, expected Float64, got Int64
julia&gt; (1 + 2) :: Int64
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isso ajuda a confirmar que o seu programa funciona do jeito esperado.</p>
</div>
<div class="paragraph">
<p>O operador <code>::</code> também pode ser acrescentado ao fim do lado esquerdo de uma atribuição, ou como uma parte de uma declaração.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; function retorna_float()
           x::Float64 = 100
           x
       end
retorna_float (generic function with 1 method)
julia&gt; x = retorna_float()
100.0
julia&gt; typeof(x)
Float64</code></pre>
</div>
</div>
<div class="paragraph">
<p>A variável <code>x</code> é sempre do tipo <code>Float64</code> e o valor é convertido para um ponto flutuante, quando necessário.</p>
</div>
<div class="paragraph">
<p>Uma anotação de tipo também pode ser anexada ao cabeçalho de uma definição de função:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function sinc(x)::Float64
    if x == 0
        return 1
    end
    sin(x)/(x)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O valor de retorno de <code>sinc</code> é sempre convertido para o tipo <code>Float64</code>.</p>
</div>
<div class="paragraph">
<p>Quando os tipos são omitidos, o comportamento padrão em Julia é permitir que os valores sejam de qualquer tipo (<code>Any</code>).
</p>
</div>
</div>
<div class="sect2">
<h3 id="_métodos">Métodos</h3>
<div class="paragraph">
<p>Em <a href="#chap16">Estruturas e Funções</a>, nós definimos uma struct chamada <code>MeuHorário</code> e em <a href="#time">Horário</a>, você escreveu uma função chamada <code>imprima_horário</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">using Printf

struct MeuHorário
    hora :: Int64
    minuto :: Int64
    segundo :: Int64
end

function imprima_horário(tempo)
    @printf("%02d:%02d:%02d", tempo.hora, tempo.minuto, tempo.segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como você pode ver, as declarações de tipo podem e devem ser adicionadas nos campos da definição da struct por questões de performance.</p>
</div>
<div class="paragraph">
<p>Para chamar esta função, você deve passar um objeto <code>MeuHorário</code> como um argumento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; início = MeuHorário(9, 45, 0)
MeuHorário(9, 45, 0)
julia&gt; imprima_horário(início)
09:45:00</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para adicionar um <em>método</em> à função <code>imprima_horário</code> que apenas aceita um objeto <code>MeuHorário</code> como argumento, tudo que precisamos fazer é acrescentar <code>::</code> seguido de <code>MeuHorário</code> no final do argumento <code>tempo</code> na definição de função:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprima_horário(tempo::MeuHorário)
    @printf("%02d:%02d:%02d", tempo.hora, tempo.minuto, tempo.segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um método é uma definição de função com uma <em>assinatura</em> específica: <code>imprima_horário</code> possui um argumento do tipo <code>MeuHorário</code>.
</p>
</div>
<div class="paragraph">
<p>Chamar a função <code>imprima_horário</code> com um objeto <code>MeuHorário</code> produz o mesmo resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; imprima_horário(início)
09:45:00</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nós podemos agora redefinir o primeiro método sem a anotação de tipo <code>::</code>, permitindo um argumento de qualquer tipo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprima_horário(tempo)
    println("Eu não sei como imprimir o argumento tempo.")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se você chamar a função <code>imprima_horário</code> com um objeto diferente de <code>MeuHorário</code>, agora recebe-se:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; imprima_horário(150)
Eu não sei como imprimir o argumento tempo.</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_exercício_17_1">Exercício 17-1</h5>
<div class="paragraph">
<p>Reescreva <code>horário_para_int</code> e <code>int_para_horário</code> (de <a href="#prototyping_versus_planning">Prototipagem Versus Planejamento</a>) para especificar os seus argumentos.
</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exemplos_adicionais">Exemplos Adicionais</h3>
<div class="paragraph">
<p>Aqui está uma versão de <code>incrementa</code> (de <a href="#modifiers">Modificadores</a>) reescrita para especificar seus argumentos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function incrementa(tempo::MeuHorário, segundos::Int64)
    segundos += horário_para_int(tempo)
    int_para_horário(segundos)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note que agora ela é uma função pura, e não um modificador.</p>
</div>
<div class="paragraph">
<p>Você pode invocar incrementa da seguinte maneira:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; início = MeuHorário(9, 45, 0)
MeuHorário(9, 45, 0)
julia&gt; incrementa(início, 1337)
MeuHorário(10, 7, 17)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se você colocar os argumentos na ordem errada, um erro é gerado:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; incrementa(1337, início)
ERROR: MethodError: no method matching incrementa(::Int64, ::MeuHorário)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A assinatura do método é <code>incrementa(tempo::MeuHorário, segundos::Int64)</code> e não <code>incrementa(segundos::Int64, tempo::MeuHorário)</code>.</p>
</div>
<div class="paragraph">
<p>Reescrever <code>é_depois</code> para operar somente com objetos <code>MeuHorário</code> é fácil:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function é_depois(t1::MeuHorário, t2::MeuHorário)
    (t1.hora, t1.minuto, t1.segundo) &gt; (t2.hora, t2.minuto, t2.segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aliás, os argumentos opcionais são implementados como sintaxe para as múltiplas definições do método. Por exemplo, essa definição:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function f(a=1, b=2)
    a + 2b
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>é equivalente aos seguintes três métodos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">f(a, b) = a + 2b
f(a) = f(a, 2)
f() = f(1, 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Estas expressões são definições de método válidas em Julia. E é uma notação mais enxuta para definir funções/métodos.</p>
</div>
</div>
<div class="sect2">
<h3 id="constructor">Construtores</h3>
<div class="paragraph">
<p>Um <em>construtor</em> é uma função especial chamada para criar um objeto. Os métodos construtores padrões de <code>MeuHorário</code> têm a seguinte assinatura:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">MeuHorário(hora, minuto, segundo)
MeuHorário(hora::Int64, minuto::Int64, segundo::Int64)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nós podemos também adicionar os nossos próprios métodos <em>construtores externos</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function MeuHorário(tempo::MeuHorário)
    MeuHorário(tempo.hora, tempo.minuto, tempo.segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse método é chamado de <em>construtor cópia</em> pois o novo objeto <code>MeuHorário</code> é uma cópia do seu argumento.
</p>
</div>
<div class="paragraph">
<p>Para impor as invariantes, nós precisamos de métodos <em>construtores internos</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct MeuHorário
    hora :: Int64
    minuto :: Int64
    segundo :: Int64
    function MeuHorário(hora::Int64=0, minuto::Int64=0, segundo::Int64=0)
        @assert(0 ≤ minuto &lt; 60, "Minuto não está entre 0 e 60.")
        @assert(0 ≤ segundo &lt; 60, "Segundo não está entre 0 e 60.")
        new(hora, minuto, segundo)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A struct <code>MeuHorário</code> agora tem 4 métodos construtores internos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">MeuHorário()
MeuHorário(hora::Int64)
MeuHorário(hora::Int64, minuto::Int64)
MeuHorário(hora::Int64, minuto::Int64, segundo::Int64)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um método construtor interno é sempre definido dentro do bloco de uma declaração de tipo e tem acesso a uma função especial chamada <code>new</code> que cria os objetos de um novo tipo declarado.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Atenção</div>
</td>
<td class="content">
<div class="paragraph">
<p>O construtor padrão não é disponibilizado se qualquer construtor interno for definido. Você deve escrever explicitamente todos os construtores internos de que você precisa.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Um segundo método sem argumentos da função local <code>new</code> existe:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">mutable struct MeuHorário
    hora :: Int
    minuto :: Int
    segundo :: Int
    function MeuHorário(hora::Int64=0, minuto::Int64=0, segundo::Int64=0)
        @assert(0 ≤ minuto &lt; 60, "Minuto está entre 0 e 60.")
        @assert(0 ≤ segundo &lt; 60, "Segundo está entre 0 e 60.")
        tempo = new()
        tempo.hora = hora
        tempo.minuto = minuto
        tempo.segundo = segundo
        tempo
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isso permite a criação das estruturas de dados recorrentes, isto é, uma struct no qual um dos campos é a própria struct. Neste caso, a struct precisa ser mutável pois os seus campos são modificados após serem instanciados.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_show"><code>show</code></h3>
<div class="paragraph">
<p><code>show</code> é uma função especial que retorna uma representação de string de um objeto. Por exemplo, aqui está um método <code>show</code> para os objetos <code>MeuHorário</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">using Printf

function Base.show(io::IO, tempo::MeuHorário)
    @printf(io, "%02d:%02d:%02d", tempo.hora, tempo.minuto, tempo.segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O prefixo <code>Base</code> é necessário pois nós queremos adicionar um novo método à função <code>Base.show</code>.</p>
</div>
<div class="paragraph">
<p>Quando você imprime um objeto, o Julia invoca a função <code>show</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; tempo = MeuHorário(9, 45)
09:45:00</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quando eu crio um novo tipo composto, eu quase sempre começo criando um construtor externo, que facilita a instanciação dos objetos, e <code>show</code>, que é útil para a depuração.</p>
</div>
<div class="sect4">
<h5 id="_exercício_17_2">Exercício 17-2</h5>
<div class="paragraph">
<p>Escreva um método construtor externo para a classe <code>Ponto</code> que recebe <code>x</code> e <code>y</code> como parâmetros adicionais e que são atribuídos aos campos correspondentes.
</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sobrecarga_de_operador">Sobrecarga de Operador</h3>
<div class="paragraph">
<p>Ao definir métodos para os operadores, você pode especificar o comportamento dos operadores em tipos definidos pelo programador. Por exemplo, ao definir um método chamado <code>+</code> com dois argumentos <code>MeuHorário</code>, você pode usar o operador <code>+</code> em objetos <code>MeuHorário</code>.</p>
</div>
<div class="paragraph">
<p>A definição deve se parecer com algo como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">import Base.+

function +(t1::MeuHorário, t2::MeuHorário)
    segundos = horário_para_int(t1) + horário_para_int(t2)
    int_para_horário(segundos)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A declaração import adiciona o operador <code>+</code> ao escopo local para que os métodos possam ser adicionados.</p>
</div>
<div class="paragraph">
<p>E você poderia usá-lo como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; início = MeuHorário(9, 45)
09:45:00
julia&gt; duração = MeuHorário(1, 35, 0)
01:35:00
julia&gt; início + duração
11:20:00</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quando você aplica o operador <code>+</code> aos objetos <code>MeuHorário</code>, o Julia invoca o novo método adicionado. Quando o REPL mostra o resultado, o Julia invoca <code>show</code>. Então muita coisa acontece por trás das cortinas!</p>
</div>
<div class="paragraph">
<p>Adicionar ao comportamento de um operador para que funcione com tipos definidos pelo programador é chamado de <em>sobrecarga de operador</em>.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_despacho_múltiplo">Despacho Múltiplo</h3>
<div class="paragraph">
<p>Na seção anterior, nós adicionamos dois objetos <code>MeuHorário</code>, mas você também pode adicionar um inteiro ao objeto <code>MeuHorário</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function +(tempo::MeuHorário, segundos::Int64)
    incrementa(tempo, segundos)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aqui está um exemplo que usa o operador <code>+</code> com um objeto <code>MeuHorário</code> e um inteiro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; início = MeuHorário(9, 45)
09:45:00
julia&gt; início + 1337
10:07:17</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adição é um operador comutativo, por isso temos que adicionar outro método.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function +(segundos::Int64, tempo::MeuHorário)
  tempo + segundos
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>E nós obtemos o mesmo resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 1337 + início
10:07:17</code></pre>
</div>
</div>
<div class="paragraph">
<p>A escolha de qual método executar quando a função é aplicada é chamada de <em>despacho</em>. O Julia permite que o processo de despacho escolha qual método de uma função chamar baseado no número de argumentos dados, e nos tipos de todos os argumentos da função. Usar todos os argumentos de uma função para escolher qual método deve ser invocado é conhecido como <em>despacho múltiplo</em>.
</p>
</div>
<div class="sect4">
<h5 id="_exercício_17_3">Exercício 17-3</h5>
<div class="paragraph">
<p>Escreva métodos <code>+</code> para os objetos ponto:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se ambos operandos são objetos ponto, o método deve retornar um novo objeto ponto cuja coordenada <code>x</code> é a soma das coordenadas <code>x</code> dos operandos, e deve proceder da mesma forma para as coordenadas <code>y</code>.</p>
</li>
<li>
<p>Se o primeiro ou o segundo operando é uma tupla, o método deve somar o primeiro elemento da tupla à coordenada <code>x</code> e o segundo elemento à coordenada <code>y</code>, e retornar um novo objeto ponto com o resultado.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_programação_genérica">Programação Genérica</h3>
<div class="paragraph">
<p>O despacho múltiplo é útil quando é necessário, apesar de (felizmente) ele não ser sempre necessário. Muitas vezes você pode evitá-lo escrevendo funções que funcionam corretamente para os argumentos com os tipos diferentes.</p>
</div>
<div class="paragraph">
<p>Muitas das funções que nós escrevemos para as strings também funcionam para os outros tipos de sequência. Por exemplo, em <a href="#dictionary_collection_counters">Dicionários como uma Coleção de Contadores</a> nós usamos <code>histograma</code> para contar o número de vezes de cada letra que aparece em uma palavra.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function histograma(s)
    d = Dict()
    for c in s
        if c ∉ keys(d)
            d[c] = 1
        else
            d[c] += 1
        end
    end
    d
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta função também funciona para as listas, as tuplas, e até mesmo os dicionários, contanto que para os elementos de <code>s</code> exista uma função hash, para que eles possam ser usados como chaves em <code>d</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ("presunto", "ovo", "presunto", "presunto", "bacon", "presunto")
("presunto", "ovo", "presunto", "presunto", "bacon", "presunto")
julia&gt; histograma(t)
Dict{Any,Any} with 3 entries:
  "bacon"    =&gt; 1
  "presunto" =&gt; 4
  "ovo"      =&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Funções que funcionam com vários tipos são chamadas de <em>polimórficas</em>. Polimorfismo pode facilitar o reuso de código.
</p>
</div>
<div class="paragraph">
<p>Por exemplo, a função embutida <code>sum</code>, que soma os elementos de uma sequência, funciona contanto que os elementos da sequência possam realizar a adição.
</p>
</div>
<div class="paragraph">
<p>Já que um método <code>+</code> é fornecido para os objetos <code>MeuHorário</code>, eles funcionam com <code>sum</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t1 = MeuHorário(1, 7, 2)
01:07:02
julia&gt; t2 = MeuHorário(1, 5, 8)
01:05:08
julia&gt; t3 = MeuHorário(1, 5, 0)
01:05:00
julia&gt; sum((t1, t2, t3))
03:17:10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em geral, se todos as operações dentro da função funcionam com um dado tipo, a função funciona com qualquer tipo.</p>
</div>
<div class="paragraph">
<p>O melhor tipo de polimorfismo é o tipo não intencional, no qual se descobre que uma função que você escreveu pode ser aplicada a um tipo que você nunca planejou.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_interface_e_implementação">Interface e Implementação</h3>
<div class="paragraph">
<p>Um dos objetivos do despacho múltiplo é facilitar a manutenção do software, o que significa que você pode manter o programa funcionando quando as outras partes do sistema mudam, e modificar o programa para cumprir novos requisitos.</p>
</div>
<div class="paragraph">
<p>Um princípio de design que ajuda alcançar esse objetivo é manter as interfaces separadas das implementações. Isto significa que os métodos que possuem os argumentos denotados com um tipo não devem depender de como os campos daquele tipo são representados.
</p>
</div>
<div class="paragraph">
<p>Por exemplo, neste capítulo nós desenvolvemos uma struct que representa um horário do dia. E os métodos que possuem argumentos indicados com este tipo incluem <code>horário_para_int</code>, <code>é_depois</code> e <code>+</code>.</p>
</div>
<div class="paragraph">
<p>Nós poderíamos implementar estes métodos de muitas maneiras. Os detalhes da implementação dependem de como representamos <code>MeuHorário</code>. Neste capítulo, os campos de um objeto <code>MeuHorário</code> são <code>hora</code>, <code>minuto</code> e <code>segundo</code>.</p>
</div>
<div class="paragraph">
<p>Como uma alternativa, nós poderiamos substituir estes campos com um único inteiro representando o número de segundos a partir da meia-noite. Esta implementação faria com que algumas funções, como +é_depois, sejam mais facéis de escrever, mas também faz com que outras funções sejam mais dificéis.</p>
</div>
<div class="paragraph">
<p>Depois de configurar um novo tipo, você pode descobrir uma implementação melhor. Se outras partes do programas estão usando o seu tipo, pode ser que mudar a interface consuma muito tempo e esteja sujeita a erros.</p>
</div>
<div class="paragraph">
<p>Mas se você tivesse projetado a interface com cuidado, pode-se mudar a implementação sem mudar a interface, o que significa que outras partes do programa não precisam ser alteradas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_depuração_14">Depuração</h3>
<div class="paragraph">
<p>Chamar uma função com os argumentos corretos pode ser difícil quando mais de um método para a função é específicada. O Julia permite examinar as assinaturas dos métodos de uma função.</p>
</div>
<div class="paragraph">
<p>Para saber quais os métodos disponíveis para uma dada função, você pode usar a função <code>methods</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; methods(imprima_horário)
# 2 methods for generic function "imprima_horário":
[1] imprima_horário(tempo::MeuHorário) in Main at REPL[3]:2
[2] imprima_horário(tempo) in Main at REPL[4]:2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Neste exemplo, a função <code>imprima_horário</code> tem 2 métodos: um com o argumento <code>MeuHorário</code> e um com o argumento <code>Any</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_17">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">anotação de tipo</dt>
<dd>
<p>O operador <code>::</code> seguido por um tipo indicando que a expressão ou variável é daquele tipo.
</p>
</dd>
<dt class="hdlist1">método</dt>
<dd>
<p>Uma definição de um possível comportamento para uma função.
</p>
</dd>
<dt class="hdlist1">despacho</dt>
<dd>
<p>A escolha de qual método executar quando uma função é executada.
</p>
</dd>
<dt class="hdlist1">assinatura</dt>
<dd>
<p>O número e tipo dos argumentos de um método permitindo o despacho escolher o método mais específico de uma função durante uma chamada da função.
</p>
</dd>
<dt class="hdlist1">construtor externo</dt>
<dd>
<p>Um construtor definido fora da definição de tipo para indicar os métodos convenientes para a criação de um objeto.
</p>
</dd>
<dt class="hdlist1">construtor interno</dt>
<dd>
<p>Um construtor definido dentro da definição de tipo para impor as invariantes ou para construir os objetos que referem a si mesmos.
</p>
</dd>
<dt class="hdlist1">construtor padrão</dt>
<dd>
<p>Um construtor interno que está disponível quando nenhum construtor interno definido pelo programador é fornecido.
</p>
</dd>
<dt class="hdlist1">construtor cópia</dt>
<dd>
<p>Um método construtor externo de um tipo que tem como único argumento um objeto daquele tipo. Ele cria um novo objeto que é uma cópia do seu argumento.
</p>
</dd>
<dt class="hdlist1">sobrecarga de operador</dt>
<dd>
<p>Adicionar a um comportamento de um operador como <code>+</code> para que funcione com um tipo definido pelo programador.
</p>
</dd>
<dt class="hdlist1">despacho múltiplo</dt>
<dd>
<p>Despacho baseado em todos os argumentos de uma função.
</p>
</dd>
<dt class="hdlist1">programação genérica</dt>
<dd>
<p>Escrever código que pode funcionar com mais de um tipo.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_19">Exercícios</h3>
<div class="sect4">
<h5 id="ex17-1">Exercício 17-4</h5>
<div class="paragraph">
<p>Mude os campos de <code>MeuHorário</code> para ter apenas um único campo representando os segundos passados após a meia-noite. Em seguida modifique os métodos definidos neste capítulo para funcionar com a nova implementação.</p>
</div>
</div>
<div class="sect4">
<h5 id="ex17-2">Exercício 17-5</h5>
<div class="paragraph">
<p>Escreva uma definição para um tipo chamado <code>Canguru</code> com um campo chamado <code>conteúdo_bolso</code> do tipo <code>Array</code> e os seguintes métodos:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Um construtor que inicializa <code>conteúdo_bolso</code> com uma lista vazia.</p>
</li>
<li>
<p>Um método chamado <code>coloca_no_bolso</code> que recebe um objeto <code>Canguru</code> e um objeto de qualquer tipo e adiciona-o a <code>conteúdo_bolso</code>.
</p>
</li>
<li>
<p>Um método <code>show</code> que retorna uma representação string de um objeto <code>Canguru</code> e o conteúdo do bolso.
</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Teste seu código criando dois objetos <code>Canguru</code>, atribuindo-os a variáveis chamadas <code>cangu</code> e <code>ru</code>, e em seguida adicionando <code>ru</code> ao conteúdo do bolso de <code>cangu</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap18">18. Subtipagem</h2>
<div class="sectionbody">
<div class="paragraph">
<p>No capítulo anterior, introduzimos o mecanismo de despacho múltiplo e o polimorfismo. A ausência da especificação dos tipos dos argumentos resulta em um método que pode ser chamado com argumentos de qualquer tipo. A especificação de um subconjunto dos tipos permitidos na assinatura de um método é um próximo passo lógico.</p>
</div>
<div class="paragraph">
<p>Neste capítulo, demonstramos a subtipagem utilizando os tipos que representam as cartas de jogo, os baralhos de cartas e as mãos de pôquer.</p>
</div>
<div class="paragraph">
<p>Se você não joga pôquer, pode ler sobre isso em <a href="https://pt.wikipedia.org/wiki/P%C3%B4quer" class="bare">https://pt.wikipedia.org/wiki/P%C3%B4quer</a>, mas não precisa pois vamos lhe dizer o que se tem que saber para os exercícios.</p>
</div>
<div class="sect2">
<h3 id="_cartas">Cartas</h3>
<div class="paragraph">
<p>Há 52 cartas em um baralho, cada uma pertencendo a um dos quatro naipes e uma das treze cartas de valores diferentes. Os naipes são Espadas (<code>♠</code>), Copas (<code>♥</code>), Ouro (<code>♦</code>) e Paus (<code>♣</code>). Os valores são Ás (A), 2, 3, 4, 5, 6, 7, 8, 9, 10, Valete (J), Rainha (Q) e Rei (K). Dependendo do jogo que você está jogando, um Ás pode ser maior que o rei ou menor que 2.</p>
</div>
<div class="paragraph">
<p>Se queremos definir um novo objeto para representar uma carta de baralho, é óbvio quais devem ser os atributos: o valor e o naipe. Mas não é tão óbvio que tipo de atributo deve ser. Uma possibilidade é usar strings contendo palavras como <code>"Espadas"</code> para os naipes e <code>"Rainha"</code> para os valores. Um problema com essa implementação é que não seria fácil comparar as cartas para ver quais teriam maior valor ou naipe.</p>
</div>
<div class="paragraph">
<p>Uma alternativa é usar números inteiros para <em>codificar</em> os valores e os naipes. Nesse contexto, “codificar” significa que vamos definir um mapeamento entre os números e naipes, ou entre os números e valores do baralho. Esse tipo de codificação não é para ser secreto (isso seria “criptografia”).
</p>
</div>
<div class="paragraph">
<p>Por exemplo, esta tabela mostra os naipes e os números inteiros correspondentes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>♠</code>  \(\mapsto\)  4</p>
</li>
<li>
<p><code>♥</code>  \(\mapsto\)  3</p>
</li>
<li>
<p><code>♦</code>  \(\mapsto\)  2</p>
</li>
<li>
<p><code>♣</code>  \(\mapsto\)  1</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este código facilita a comparação das cartas, já que os naipes mais valorizados estão relacionados com números mais altos e podemos comparar os naipes comparando os seus números.</p>
</div>
<div class="paragraph">
<p>Estamos usando o símbolo \(\mapsto\) para deixar claro que essas correspondências não fazem parte do programa Julia. Elas fazem parte da formulação do programa, e não aparecem explicitamente no código.</p>
</div>
<div class="paragraph">
<p>A definição para a struct <code>Carta</code> é parecida com esta:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Carta
    naipe :: Int64
    valor :: Int64
    function Carta(naipe::Int64, valor::Int64)
        @assert(1 ≤ naipe ≤ 4, "naipe não está entre 1 e 4")
        @assert(1 ≤ valor ≤ 13, "valor não está entre 1 e 13")
        new(naipe, valor)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para criar uma <code>Carta</code>, você chama <code>Carta</code> com o naipe e o valor desejado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; rainha_de_ouro = Carta(2, 12)
Carta(2, 12)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_variáveis_globais">Variáveis Globais</h3>
<div class="paragraph">
<p>Para imprimir objetos <code>Carta</code> de uma forma que as pessoas possam ler facilmente, precisamos de um mapeamento dos códigos inteiros até os valores e naipes correspondentes. Uma maneira natural de fazer isso é com as listas de strings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">const nomes_naipes = ["♣", "♦", "♥", "♠"]
const nomes_valores = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>As variáveis <code>nomes_naipes</code> e <code>nomes_valores</code> são variáveis globais. A declaração <code>const</code> significa que a variável só pode ser atribuída uma vez. Isso resolve o problema de desempenho das variáveis globais.
</p>
</div>
<div class="paragraph">
<p>Agora podemos implementar um método <code>show</code> apropriado:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function Base.show(io::IO, carta::Carta)
    print(io, nomes_valores[carta.valor], nomes_naipes[carta.naipe])
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A expressão <code>nomes_valores[carta.valor]</code> significa “use o campo <code>valor</code> do objeto <code>carta</code> como um índice na matriz <code>nomes_valores</code> e selecione a string apropriada.”</p>
</div>
<div class="paragraph">
<p>Com os métodos que temos até agora, podemos criar e imprimir as cartas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; Carta(3, 11)
J♥</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_comparando_cartas">Comparando Cartas</h3>
<div class="paragraph">
<p>Para os tipos embutidos, existem operadores relacionais (<code>&lt;</code>, <code>&gt;</code>, <code>==</code> etc.) que comparam os valores e determinam quando um é maior que, menor que ou igual ao outro. Para os tipos definidos pelo programador, podemos sobrepor o comportamento dos operadores embutidos ao estabelecer um método chamado <code>&lt;</code>.</p>
</div>
<div class="paragraph">
<p>A ordenação correta das cartas não é óbvia. Por exemplo, qual é o melhor, o 3 de Paus ou o 2 de Ouros? Um tem um valor mais alto, mas o outro tem um naipe mais alto. A fim de comparar as cartas, você tem que decidir se o valor ou o naipe é mais importante.</p>
</div>
<div class="paragraph">
<p>A resposta pode depender de qual jogo você está jogando, mas para simplificar, faremos a escolha arbitrária de que naipe é mais importante, significando que todas cartas de Espadas são superiores as cartas de Diamantes e assim por diante.</p>
</div>
<div class="paragraph">
<p>Decidido isso, podemos escrever <code>&lt;</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">import Base.&lt;

function &lt;(c1::Carta, c2::Carta)
    (c1.naipe, c1.valor) &lt; (c2.naipe, c2.valor)
end</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_exercício_18_1">Exercício 18-1</h5>
<div class="paragraph">
<p>Escreva um método <code>&lt;</code> para os objetos <code>MeuHorário</code>. Você pode usar a comparação de tupla, mas também pode considerar a comparação de inteiros.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_teste_unitário">Teste Unitário```</h3>
<div class="paragraph">
<p><em>Testes unitários</em> permitem verificar a corretude do seu código, comparando os resultados do seu código com o que você espera. Isso pode ser útil para garantir que seu código ainda esteja correto após as modificações, e também é uma maneira de predefinir o comportamento correto do seu código durante o desenvolvimento.
</p>
</div>
<div class="paragraph">
<p>Os testes unitários simples podem ser realizados com as macros <code>@test</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; using Test

julia&gt; @test Carta(1, 4) &lt; Carta(2, 4)
Test Passed
julia&gt; @test Carta(1, 3) &lt; Carta(1, 4)
Test Passed</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@test</code> retorna <code>"Test Passed"</code> se a expressão seguinte for <code>true</code>, <code>"Test Failed"</code> se for <code>false</code>, e <code>"Error Result"</code> se não puder ser avaliado.</p>
</div>
</div>
<div class="sect2">
<h3 id="_baralhos">Baralhos</h3>
<div class="paragraph">
<p>Agora que temos Cartas, o próximo passo é a definição do Baralhos. Como um baralho é composto de cartas, é natural que cada Baralho contenha uma lista de cartas como um atributo.</p>
</div>
<div class="paragraph">
<p>A seguir, define-se uma struct para <code>Baralho</code>. O construtor cria os campos das cartas e gera o conjunto padrão das cinquenta e dois cartas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Baralho
    cartas :: Array{Carta, 1}
end

function Baralho()
    baralho = Baralho(Carta[])
    for naipe in 1:4
        for valor in 1:13
            push!(baralho.cartas, Carta(naipe, valor))
        end
    end
    baralho
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A maneira mais fácil de preencher o baralho é com um laço aninhado. O laço externo enumera os naipes de 1 a 4. O laço interno enumera os valores de 1 a 13. Cada iteração cria uma nova <code>Carta</code> com o naipe e o valor correntes e envia-a para <code>baralho.cartas</code>.</p>
</div>
<div class="paragraph">
<p>Aqui está um método <code>show</code> para <code>Baralho</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function Base.show(io::IO, baralho::Baralho)
    for carta in baralho.cartas
        print(io, carta, " ")
    end
    println()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Veja como ficou o resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; Baralho()
A♣ 2♣ 3♣ 4♣ 5♣ 6♣ 7♣ 8♣ 9♣ 10♣ J♣ Q♣ K♣ A♦ 2♦ 3♦ 4♦ 5♦ 6♦ 7♦ 8♦ 9♦ 10♦ J♦ Q♦ K♦ A♥ 2♥ 3♥ 4♥ 5♥ 6♥ 7♥ 8♥ 9♥ 10♥ J♥ Q♥ K♥ A♠ 2♠ 3♠ 4♠ 5♠ 6♠ 7♠ 8♠ 9♠ 10♠ J♠ Q♠ K♠</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_adicionar_remover_embaralhar_e_ordenar">Adicionar, Remover, Embaralhar e Ordenar</h3>
<div class="paragraph">
<p>Para distribuir as cartas, gostaríamos de uma função que remove uma carta do baralho e devolve-a. A função <code>pop!</code> fornece uma maneira apropriada de fazer isso:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function Base.pop!(baralho::Baralho)
    pop!(baralho.cartas)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como <code>pop!</code> remove a última carta do baralho, estamos distribuindo a partir do fundo do baralho.</p>
</div>
<div class="paragraph">
<p>Para adicionar uma carta, podemos usar a função <code>push!</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function Base.push!(baralho::Baralho, carta::Carta)
    push!(baralho.cartas, carta)
    baralho
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um método como esse, que usa outro método sem fazer muito trabalho, às vezes é chamado de <em>folheado</em>. A metáfora vem do trabalho com madeira, onde um folheado de madeira é uma fina camada de madeira de boa qualidade colada à superfície de um pedaço de madeira mais barato para melhorar a aparência.
</p>
</div>
<div class="paragraph">
<p>Neste caso, <code>push!</code> é um método “fino” que expressa uma operação de lista relativamente apropriado para baralhos. Ele melhora a aparência, ou interface, da implementação.</p>
</div>
<div class="paragraph">
<p>Como um outro exemplo, podemos escrever um método chamado <code>shuffle!</code> usando a função <code>Random.shuffle!</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">using Random

function Random.shuffle!(baralho::Baralho)
    shuffle!(baralho.cartas)
    baralho
end</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_exercício_18_2">Exercício 18-2</h5>
<div class="paragraph">
<p>Escreva uma função chamada <code>sort!</code> que usa a função <code>sort!</code> para ordenar as cartas em um Baralho. A função <code>sort!</code> usa o método <code>isless</code> na nossa definição para a ordenação.
</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tipos_abstratos_e_subtipagem">Tipos Abstratos e Subtipagem</h3>
<div class="paragraph">
<p>Queremos um tipo que represente uma “mão”, ou seja, as cartas que estão nas mãos de um jogador. Uma mão é semelhante a um baralho: ambas são compostas de uma coleção de cartas, e ambas precisam de operações como adicionar e remover cartas.</p>
</div>
<div class="paragraph">
<p>Uma mão também é diferente de um baralho; existem operações que queremos para as mãos de cartas que não faz sentido para um baralho. Por exemplo, no pôquer, podemos comparar duas mãos para ver qual delas vence. No bridge, podemos calcular uma pontuação para uma mão para fazer um lance.</p>
</div>
<div class="paragraph">
<p>Portanto, precisamos de uma maneira de agrupar os <em>tipos concretos</em> relacionados. No Julia, isso é feito ao definir um <em>tipo abstrato</em> que serve como o progenitor de <code>Baralho</code> e <code>Mão</code>. Isso é chamado <em>subtipagem</em>.
</p>
</div>
<div class="paragraph">
<p>Vamos nomear esse tipo abstrato de <code>Conjunto_Carta</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">abstract type Conjunto_Carta end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um novo tipo abstrato é criado com a palavra-chave <code>abstract type</code>. Um tipo “progenitor” opcional pode ser especificado colocando <code>&lt;:</code> após o nome seguido do nome de um tipo abstrato já existente.
</p>
</div>
<div class="paragraph">
<p>Quando nenhum <em>supertipo</em> é dado, o supertipo padrão é <code>Any</code> - um tipo abstrato predefinido do qual todos os objetos são instâncias e todos os tipos são <em>subtipos</em>.
</p>
</div>
<div class="paragraph">
<p>Agora podemos expressar que <code>Baralho</code> é um descendente de <code>Conjunto_Carta</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Baralho &lt;: Conjunto_Carta
    cartas :: Array{Carta, 1}
end

function Baralho()
    baralho = Baralho(Carta[])
    for naipe in 1:4
        for valor in 1:13
            push!(baralho.cartas, Carta(naipe, valor))
        end
    end
    baralho
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O operador <code>isa</code> verifica se um objeto é de um determinado tipo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; baralho = Baralho();

julia&gt; baralho isa Conjunto_Carta
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma mão também é um tipo de <code>Conjunto_Carta</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Mão &lt;: Conjunto_Carta
    cartas :: Array{Carta, 1}
    identificação :: String
end

function Mão(identificação::String="")
    Mão(Carta[], identificação)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em vez de encher a mão com 52 novas cartas, o construtor de <code>Mão</code> inicializa <code>cartas</code> com uma lista vazia. Um argumento opcional pode ser passado para o construtor, atribuindo uma identificação para a <code>Mão</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; mão = Mão("nova mão")
Mão(Carta[], "nova mão")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tipos_abstratos_e_funções">Tipos Abstratos e Funções</h3>
<div class="paragraph">
<p>Agora podemos expressar as operações comuns entre <code>Baralho</code> e <code>Mão</code> como funções tendo como argumento <code>Conjunto_Carta</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function Base.show(io::IO, cc::Conjunto_Carta)
    for carta in cc.cartas
        print(io, carta, " ")
    end
end

function Base.pop!(cc::Conjunto_Carta)
    pop!(cc.cartas)
end

function Base.push!(cc::Conjunto_Carta, carta::Carta)
    push!(cc.cartas, carta)
    nothing
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Podemos usar <code>pop!</code> e <code>push!</code> para dar uma carta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; baralho = Baralho()
A♣ 2♣ 3♣ 4♣ 5♣ 6♣ 7♣ 8♣ 9♣ 10♣ J♣ Q♣ K♣ A♦ 2♦ 3♦ 4♦ 5♦ 6♦ 7♦ 8♦ 9♦ 10♦ J♦ Q♦ K♦ A♥ 2♥ 3♥ 4♥ 5♥ 6♥ 7♥ 8♥ 9♥ 10♥ J♥ Q♥ K♥ A♠ 2♠ 3♠ 4♠ 5♠ 6♠ 7♠ 8♠ 9♠ 10♠ J♠ Q♠ K♠
julia&gt; shuffle!(baralho)
7♣ J♠ J♦ 5♦ 3♦ 8♠ 6♦ 4♥ 4♣ 2♠ J♣ 7♥ K♦ 5♠ 2♥ 5♥ Q♣ J♥ 10♣ 10♠ K♠ A♣ Q♠ Q♦ 3♥ 4♦ 10♥ 6♣ 8♥ 3♣ 2♣ A♦ 10♦ 7♦ 7♠ 4♠ K♥ A♠ 8♣ 5♣ 2♦ 9♣ 6♠ K♣ 9♦ Q♥ 6♥ 8♦ 9♠ 9♥ 3♠ A♥
julia&gt; carta = pop!(baralho)
A♥
julia&gt; push!(mão, carta)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um próximo passo natural é encapsular esse código em uma função chamada <code>move!</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function move!(cc1::Conjunto_Carta, cc2::Conjunto_Carta, n::Int)
    @assert 1 ≤ n ≤ length(cc1.cartas)
    for i in 1:n
        carta = pop!(cc1)
        push!(cc2, carta)
    end
    nothing
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função <code>move!</code> recebe três argumentos, dois objetos <code>Conjunto_Carta</code> e o número de cartas a serem distribuídas. Ela modifica os objetos <code>Conjunto_Carta</code> e retorna <code>nothing</code>.</p>
</div>
<div class="paragraph">
<p>Em alguns jogos, as cartas são transferidas de uma mão para outra ou de uma mão para o baralho. Você pode usar <code>move!</code> para qualquer uma dessas operações já que <code>cc1</code> e <code>cc2</code> podem ser ou um <code>Baralho</code> ou uma <code>Mão</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_diagramas_de_tipos">Diagramas de Tipos</h3>
<div class="paragraph">
<p>Até agora temos visto os diagramas de pilha, que mostram o estado de um programa, e os diagramas de objeto, que mostram os atributos de um objeto e os seus valores. Estes diagramas são como um retrato na execução de um programa, portanto eles mudam conforme o programa é executado.</p>
</div>
<div class="paragraph">
<p>Eles também são muito detalhados e dependendo de alguns propósitos, demasiadamente detalhados. Um <em>diagrama de tipo</em> é uma representação mais abstrata da estrutura de um programa. Ao invés de mostrar objetos individuais, ele mostra os tipos e as relações entre eles.
</p>
</div>
<div class="paragraph">
<p>Existem vários tipos de relacionamento entre os tipos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Objetos de um tipo concreto podem conter referências a objetos de outro tipo. Por exemplo, cada Retângulo contém uma referência a um Ponto, e cada Baralho contém referências a uma lista de Cartas. Este tipo de relacionamento é chamado de <em>TEM-UM</em>, como em “um Retângulo tem um Ponto”.
</p>
</li>
<li>
<p>Um tipo concreto pode ter um tipo abstrato como um supertipo. Esse relacionamento é chamado de <em>É-UM</em>, como em “uma Mão é uma espécie de Conjunto_Carta”.
</p>
</li>
<li>
<p>Um tipo pode depender do outro no sentido de que os objetos de um tipo recebem os objetos do segundo tipo como parâmetros ou usam os objetos do segundo tipo como parte de um cálculo. Esse tipo de relacionamento é denominado <em>dependência</em>.
</p>
</li>
</ul>
</div>
<div id="fig18-1" class="imageblock">
<div class="content">
<img src="images/fig181.svg" alt="fig181">
</div>
<div class="title">Figura 23. Diagrama de Tipo</div>
</div>
<div class="paragraph">
<p>A flecha com uma ponta de triângulo oco representa um relacionamento É-UM; e neste caso, indica que a Mão tem como supertipo o Conjunto_Carta.</p>
</div>
<div class="paragraph">
<p>A ponta da seta padrão representa um relacionamento TEM-UM e neste caso, um Baralho tem referências aos objetos de Carta.</p>
</div>
<div class="paragraph">
<p>A estrela (<code>*</code>) perto da ponta da seta é uma <em>multiplicidade</em> que indica a quantidade de Cartas que um Baralho tem. Uma multiplicidade pode ser um número simples, como <code>52</code>, um intervalo, <code>como 5:7</code> ou uma estrela, que indica que um Baralho pode ter qualquer número de Cartas.
</p>
</div>
<div class="paragraph">
<p>Não há dependências neste diagrama. Elas usualmente seriam mostradas com uma seta tracejada. E caso haja muitas dependências, elas são às vezes omitidas.</p>
</div>
<div class="paragraph">
<p>Um diagrama mais detalhado pode mostrar que um Baralho realmente contém uma lista de Cartas, mas tipos internos como uma lista e dicionários geralmente não são inclusos nos diagramas de tipo.</p>
</div>
</div>
<div class="sect2">
<h3 id="interactive">Depuração</h3>
<div class="paragraph">
<p>A subtipagem pode dificultar a depuração, porque quando você chama uma função com um objeto como argumento, pode ser difícil descobrir qual método será chamado.</p>
</div>
<div class="paragraph">
<p>Suponha que você está escrevendo uma função que funciona com os objetos <code>Mão</code>. Você gostaria que ela funcionasse com todos os tipos de <code>Mão+s, como +Mãos de Pôquer</code>, <code>Mãos de Bridge</code>, etc. Se você chamar um método como <code>sort!</code>, pode ter chamado o que foi definido para um tipo abstrato <code>Mão</code>, mas se um método <code>sort!</code> com qualquer um dos subtipos como argumento existir, você terá essa versão em seu lugar. Este comportamento é normalmente uma coisa boa, mas pode ser confuso.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function Base.sort!(mão::Mão)
    sort!(mão.cartas)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sempre que você não tiver certeza sobre o fluxo de execução do seu programa, a solução mais simples é adicionar comandos de impressão no início dos métodos relevantes. Se <code>shuffle!</code> imprime uma mensagem que diz algo como <code>Executando shuffle! Baralho</code>, à medida que o programa é executado, rastreia-se o fluxo de execução.</p>
</div>
<div class="paragraph">
<p>Como uma alternativa melhor, você também pode usar a macro <code>@which</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; @which sort!(mão)
sort!(mão::Mão) in Main at REPL[5]:1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Portanto, o método <code>sort!</code> para <code>mão</code> recebe como argumento um objeto do tipo <code>Mão</code>.</p>
</div>
<div class="paragraph">
<p>Eis uma sugestão de design: quando você substitui um método, a interface do novo método deve ser a mesma que a do antigo. Ele deve receber os mesmos parâmetros, retornar o mesmo tipo e obedecer às mesmas precondições e pós-condições. Se você seguir esta regra, verá que qualquer função elaborada para trabalhar com uma instância de um supertipo, como um <code>Conjunto_Carta</code>, também funcionará com instâncias de seus subtipos <code>Baralho</code> e <code>Mão</code>.</p>
</div>
<div class="paragraph">
<p>Se você violar essa regra, chamada de “princípio de substituição de Liskov”, seu código tombará como (desculpa) um castelo de cartas.
</p>
</div>
<div class="paragraph">
<p>A função <code>supertype</code> pode ser usada para encontrar o supertipo direto de um tipo.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; supertype(Baralho)
Conjunto_Carta</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_encapsulamento_de_dados">Encapsulamento de Dados</h3>
<div class="paragraph">
<p>Os capítulos anteriores apresentam um plano de desenvolvimento que podemos chamar de “design orientado a tipos”. Identificamos os objetos de que precisamos—como <code>Ponto</code>, <code>Retângulo</code> e <code>MeuHorário</code>— e definimos estruturas para representá-los. Em cada caso, há uma correspondência óbvia entre o objeto e alguma entidade no mundo real (ou pelo menos em um mundo matemático).
</p>
</div>
<div class="paragraph">
<p>Mas, às vezes, é menos óbvio de quais objetos você precisa e como eles devem interagir. Nesse caso, precisa-se de um plano de desenvolvimento diferente. Da mesma maneira que descobrimos funções de interface por encapsulamento e generalização, podemos descobrir os tipos de interface por <em>encapsulamento de dados</em>.
</p>
</div>
<div class="paragraph">
<p>A análise de Markov, de <a href="#markov_analysis">[markov_analysis]</a>, fornece um bom exemplo. Se você baixar meu código em <a href="https://github.com/JuliaIntro/JuliaIntroBR.jl/blob/master/src/solutions/chap13.jl" class="bare">https://github.com/JuliaIntro/JuliaIntroBR.jl/blob/master/src/solutions/chap13.jl</a>, verá que ele usa duas variáveis globais—<code>suffixos</code> and <code>prefixo</code>—que são lidos e escritos a partir de várias funções.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">sufixos = Dict()
prefixo = []</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como estas variáveis são globais, podemos fazer só uma análise por vez. Se lermos dois textos, os seus prefixos e sufixos seriam adicionados às mesmas estruturas de dados (o que faz com que algum texto gerado seja interessante).</p>
</div>
<div class="paragraph">
<p>Para rodar várias análises e mantê-las separadas, podemos encapsular o estado de cada análise em um objeto. Eis o que isso parece:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Markov
    ordem :: Int64
    sufixos :: Dict{Tuple{String,Vararg{String}}, Array{String, 1}}
    prefixos :: Array{String, 1}
end

function Markov(ordem::Int64=2)
    new(ordem, Dict{Tuple{String,Vararg{String}}, Array{String, 1}}(), Array{String, 1}())
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, transformamos as funções em métodos. Por exemplo, aqui está <code>processa_palavra</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function processa_palavra(markov::Markov, palavra::String)
    if length(markov.prefixo) &lt; markov.ordem
        push!(markov.prefixo, palavra)
        return
    end
    get!(markov.sufixos, (markov.prefixo...,), Array{String, 1}())
    push!(markov.sufixos[(markov.prefixo...,)], palavra)
    popfirst!(markov.prefixo)
    push!(markov.prefixo, palavra)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Transformar um programa como esse—alterando o design sem alterar o comportamento—é outro exemplo de refatoração (veja <a href="#refactoring">[refactoring]</a>).
</p>
</div>
<div class="paragraph">
<p>Este exemplo sugere um plano de desenvolvimento para elaborar os tipos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Comece por escrever funções que leem e escrevem variáveis globais (quando necessário).</p>
</li>
<li>
<p>Uma vez que o programa esteja funcionando, procure por associações entre variáveis globais e as funções que as utilizam.</p>
</li>
<li>
<p>Encapsule as variáveis relacionadas como os campos de uma estrutura.</p>
</li>
<li>
<p>Transforme as funções associadas em métodos que recebem objetos do novo tipo como argumento.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_exercício_18_3">Exercício 18-3</h5>
<div class="paragraph">
<p>Faça o download do meu código Markov em <a href="https://github.com/JuliaIntro/JuliaIntroBR.jl/blob/master/src/solutions/chap13.jl" class="bare">https://github.com/JuliaIntro/JuliaIntroBR.jl/blob/master/src/solutions/chap13.jl</a> e siga os passos descritos acima para encapsular as variáveis globais como atributos de uma nova estrutura denominada <code>Markov</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_18">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">codificação</dt>
<dd>
<p>Representação de um conjunto de valores usando outro conjunto de valores através da construção de um mapeamento entre eles.
</p>
</dd>
<dt class="hdlist1">teste unitário</dt>
<dd>
<p>Procedimento padronizado para testar o corretismo do código.
</p>
</dd>
<dt class="hdlist1">folheado</dt>
<dd>
<p>Um método ou uma função que disponibiliza uma interface diferente para outra função sem fazer muito cálculo.
</p>
</dd>
<dt class="hdlist1">subtipagem</dt>
<dd>
<p>A capacidade de definir uma hierarquia de tipos relacionados.
</p>
</dd>
<dt class="hdlist1">tipo abstrato</dt>
<dd>
<p>Um tipo que pode atuar como progenitor de outro tipo.
</p>
</dd>
<dt class="hdlist1">tipo concreto</dt>
<dd>
<p>Um tipo que pode ser construído.
</p>
</dd>
<dt class="hdlist1">subtipo</dt>
<dd>
<p>Um tipo que tem como progenitor um tipo abstrato.
</p>
</dd>
<dt class="hdlist1">supertipo</dt>
<dd>
<p>Um tipo abstrato que é o progenitor de outro tipo.
</p>
</dd>
<dt class="hdlist1">Relacionamento É-UM</dt>
<dd>
<p>Um relacionamento entre um subtipo e seu supertipo.
</p>
</dd>
<dt class="hdlist1">Relacionamento TEM-UM</dt>
<dd>
<p>Um relacionamento entre dois tipos em que as instâncias de um tipo contêm referências às instâncias do outro.
</p>
</dd>
<dt class="hdlist1">dependência</dt>
<dd>
<p>Um relacionamento entre dois tipos em que instâncias de um tipo usam as instâncias do outro tipo, sem armazená-las como campos.
</p>
</dd>
<dt class="hdlist1">diagrama de tipo</dt>
<dd>
<p>Um diagrama que mostra os tipos de um programa e as relações entre eles.
</p>
</dd>
<dt class="hdlist1">multiplicidade</dt>
<dd>
<p>Uma notação em um diagrama de tipos que mostra, em um relacionamento TEM-UM, a quantidade de referências para as instâncias de outra classe.
</p>
</dd>
<dt class="hdlist1">encapsulamento de dados</dt>
<dd>
<p>Um plano de desenvolvimento de programa, que consiste em um protótipo que usa variáveis ​​globais e uma versão final que transforma as variáveis ​​globais em campos de uma instância.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios_20">Exercícios</h3>
<div class="sect4">
<h5 id="ex18-1">Exercício 18-4</h5>
<div class="paragraph">
<p>Para o programa seguinte, desenhe um diagrama de tipos que mostre os seus tipos e as relações entre eles.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">abstract type PingPongProgenitor end

struct Ping &lt;: PingPongProgenitor
    pong :: PingPongProgenitor
end

struct Pong &lt;: PingPongProgenitor
    pings :: Array{Ping, 1}
    function Pong(pings=Array{Ping, 1}())
        new(pings)
    end
end

function addping(pong::Pong, ping::Ping)
    push!(pong.pings, ping)
    nothing
end

pong = Pong()
ping = Ping(pong)
addping(pong, ping)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ex18-2">Exercício 18-5</h5>
<div class="paragraph">
<p>Escreva um método chamado <code>dar_carta!</code> que recebe três parâmetros, o <code>Baralho</code>, o número de mãos e o número de cartas por mão. Ele deve criar o número apropriado de objetos <code>Mão</code>, distribuir o número compatível de cartas por mão e retornar uma lista de +Mão+s.
</p>
</div>
</div>
<div class="sect4">
<h5 id="ex18-3">Exercício 18-6</h5>
<div class="paragraph">
<p>Seguem as jogadas possíveis no pôquer, em ordem crescente de valor e ordem decrescente de probabilidade:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">par</dt>
<dd>
<p>duas cartas com o mesmo valor</p>
</dd>
<dt class="hdlist1">dois pares</dt>
<dd>
<p>dois pares de cartas com o mesmo valor</p>
</dd>
<dt class="hdlist1">trinca de um tipo</dt>
<dd>
<p>três cartas com o mesmo valor</p>
</dd>
<dt class="hdlist1">sequência</dt>
<dd>
<p>cinco cartas com valores em sequência (os Ases podem ser altos ou baixos, então Ás-2-3-4-5 é uma sequência bem como 10-Valete-Rainha-Rei-Ás, mas Rainha-Rei-Ás-2-3 não é.)</p>
</dd>
<dt class="hdlist1">flush</dt>
<dd>
<p>cinco cartas com o mesmo naipe</p>
</dd>
<dt class="hdlist1">full house</dt>
<dd>
<p>três cartas com um valor, duas cartas com outro</p>
</dd>
<dt class="hdlist1">quadra de um tipo</dt>
<dd>
<p>quatro cartas com o mesmo valor</p>
</dd>
<dt class="hdlist1">sequência de mesmo naipe</dt>
<dd>
<p>cinco cartas em sequência (conforme definido acima) e com o mesmo naipe</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>O objetivo deste exercício é estimar as probabilidades de se tirar estas várias jogadas.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Adicione métodos chamados <code>tem_par</code>, <code>tem_2pares</code>, etc. que retornam <code>true</code> ou <code>false</code> se a mão cumpre ou não as regras relevantes. Seu código deve funcionar corretamente para as “mãos” que contém qualquer número de cartas (embora 5 e 7 sejam a quantidade mais comuns).
</p>
</li>
<li>
<p>Escreva um método chamado <code>classificar</code> que calcula a classificação do valor mais alto para uma mão e identifica adequadamente o campo <code>jogada</code>. Por exemplo, um mão de 7 cartas pode conter um flush e um par e ele deve ser identificado como “flush”.
</p>
</li>
<li>
<p>Quando você estiver convencido de que seus métodos de classificação estão funcionando, o próximo passo é estimar as probabilidades das várias jogadas. Escreva uma função que embaralha um baralho de cartas, divide-o em mãos, classifica as mãos e conta o número de vezes que as várias classificações aparecem.</p>
</li>
<li>
<p>Imprima uma tabela de classificações e suas probabilidades. Execute seu programa com uma quantidade de mãos cada vez maiores até que os valores de saída convirjam para um grau razoável de precisão. Compare os seus resultados com os valores em <a href="https://pt.wikipedia.org/wiki/Lista_de_jogadas_do_p%C3%B4quer" class="bare">https://pt.wikipedia.org/wiki/Lista_de_jogadas_do_p%C3%B4quer</a>.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap19">19. Extras: Sintaxe</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Uma das nossas metas para este livro é ensinar o mínimo possível de Julia. Quando havia duas formas de fazer algo, escolhíamos uma e evitávamos mencionar a outra. Ou às vezes, a segunda forma era proposta como exercício.</p>
</div>
<div class="paragraph">
<p>Agora queremos retornar a algumas coisas boas que ficaram pra trás. O Julia oferece uma variedade de recursos que não são realmente necessários—você pode escrever um bom código sem eles—mas com eles pode-se escrever um código mais conciso, legível ou eficiente e, às vezes, todos os três.</p>
</div>
<div class="paragraph">
<p>Neste e no próximo capítulo, iremos discutir coisas dos capítulos anteriores que deixamos para trás:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>os suplementos de sintaxe</p>
</li>
<li>
<p>as funções, os tipos e as macros diretamente disponíveis em <code>Base</code>
</p>
</li>
<li>
<p>as funções, os tipos e as macros da Biblioteca Padrão
</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_tuplas_nomeadas">Tuplas Nomeadas</h3>
<div class="paragraph">
<p>Você pode nomear os componentes de uma tupla, criando uma tupla nomeada.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = (a=1, b=1+1)
(a = 1, b = 2)
julia&gt; x.a
1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nas tuplas nomeadas, os campos podem ser acessados pelo nome usando a sintaxe do ponto <code>(x.a)</code>.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_funções">Funções</h3>
<div class="paragraph">
<p>Uma função no Julia pode ser definida por uma sintaxe compacta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; f(x,y) = x + y
f (generic function with 1 method)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="anonymous_functions">Funções Anônimas</h4>
<div class="paragraph">
<p>Podemos definir uma função sem especificar um nome:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x -&gt; x^2 + 2x - 1
#1 (generic function with 1 method)
julia&gt; function (x)
           x^2 + 2x - 1
       end
#3 (generic function with 1 method)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Estes são os exemplos de <em>funções anônimas</em>. E elas geralmente são usadas como argumentos para outras funções:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; using Plots

julia&gt; plot(x -&gt; x^2 + 2x - 1, 0, 10, xlabel="x", ylabel="y")</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#fig19-1">Plot</a> mostra a saída do comando plot.</p>
</div>
<div id="fig19-1" class="imageblock">
<div class="content">
<img src="images/fig191.svg" alt="fig191">
</div>
<div class="title">Figura 24. Plot</div>
</div>
</div>
<div class="sect3">
<h4 id="_argumentos_de_palavras_chave">Argumentos de Palavras-Chave</h4>
<div class="paragraph">
<p>Argumentos de funções também podem ser nomeadas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; function meu_plot(x, y; style="solid", width=1, color="black")
           ###
       end
meu_plot (generic function with 1 method)
julia&gt; meu_plot(0:10, 0:10, style="dotted", color="blue")</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Argumentos de palavras-chave</em> em uma função são especificados depois de um ponto e vírgula na assinatura, apesar de poder ser chamado com uma vírgula.
</p>
</div>
</div>
<div class="sect3">
<h4 id="_fechamentos">Fechamentos</h4>
<div class="paragraph">
<p>Um <em>fechamento</em> é uma técnica que permite uma função capturar uma variável definida fora do escopo da chamada da função.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; foo(x) = ()-&gt;x
foo (generic function with 1 method)

julia&gt; bar = foo(1)
#1 (generic function with 1 method)

julia&gt; bar()
1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nesse exemplo, a função <code>foo</code> retorna uma função anônima que possui acesso ao argumento <code>x</code> da função <code>foo</code>. A variável <code>bar</code> aponta para a função anônima e retorna o valor do argumento de <code>foo</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_blocos">Blocos</h3>
<div class="paragraph">
<p>Um <em>bloco</em> é uma forma de agrupar diversos comandos. Um bloco começa com a palavra-chave <code>begin</code> e termina com <code>end</code>.
</p>
</div>
<div class="paragraph">
<p>No <a href="#chap04">Estudo de Caso: Design de Interface</a>, a macro <code>@svg</code> foi introduzida:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">🐢 = Turtle()
@svg begin
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Neste exemplo, a macro <code>@svg</code> possui um argumento único, i.e. um bloco que está agrupando 3 chamadas de função.</p>
</div>
<div class="sect3">
<h4 id="_blocos_let">Blocos <code>let</code></h4>
<div class="paragraph">
<p>Um bloco <code>let</code> é útil para criar novas ligações, i.e. locais que podem se referir a valores.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x, y, z = -1, -1, -1;

julia&gt; let x = 1, z
           @show x y z;
       end
x = 1
y = -1
ERROR: UndefVarError: z not defined
julia&gt; @show x y z;
x = -1
y = -1
z = -1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nesse exemplo, a primeira macro <code>@show</code> mostra o <code>x</code> local, a global <code>y</code> e a local indefinida <code>z</code>. As variáveis globais não são tocadas.</p>
</div>
</div>
<div class="sect3">
<h4 id="_blocos_do">Blocos <code>do</code></h4>
<div class="paragraph">
<p>Em <a href="#reading_and_writing">Lendo e Escrevendo</a>, tivemos que fechar o arquivo após o término da escrita. Isso pode ser feito automaticamente usando um <em>bloco do</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; dado = "O meu nome é Severino, \nnão tenho outro de pia.\n"
"O meu nome é Severino, \nnão tenho outro de pia.\n"
julia&gt; open("output.txt", "w") do fout
           write(fout, dado)
       end
50</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nesse exemplo, <code>fout</code> é um fluxo de arquivo usado para a saída.</p>
</div>
<div class="paragraph">
<p>Essa funcionalidade é equivalente a</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; f = fout -&gt; begin
           write(fout, dado)
       end
#3 (generic function with 1 method)
julia&gt; open(f, "output.txt", "w")
50</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função anônima é usada como o primeiro argumento da função <code>open</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um bloco <code>do</code> pode “capturar” as variáveis do escopo que o circunda. Por exemplo, a variável <code>dado</code> em <code>open ... do</code> no exemplo acima é capturada de escopo externo.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_controle_de_fluxo">Controle de Fluxo</h3>
<div class="sect3">
<h4 id="_operador_ternário">Operador Ternário</h4>
<div class="paragraph">
<p>O <em>operador ternário</em> <code>?:</code> é uma alternativa para uma declaração <code>if-else</code> usada quando você precisa fazer uma escolha entre valores de expressão única.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = 150
150
julia&gt; a % 2 == 0 ? println("par") : println("ímpar")
par</code></pre>
</div>
</div>
<div class="paragraph">
<p>A expressão antes de <code>?</code> é uma condição. Se a condição for verdadeira (<code>true</code>), a expressão antes de <code>:</code> é avaliada, caso contrário, a expressão depois de <code>:</code> é avaliada.</p>
</div>
</div>
<div class="sect3">
<h4 id="_avaliação_de_curto_circuíto">Avaliação de Curto-Circuíto</h4>
<div class="paragraph">
<p>Os operadores <code>&amp;&amp;</code> e <code>||</code> fazem uma <em>avaliação de curto-circuito</em>: o próximo argumento só é avaliado quando é necessário determinar o valor final.
</p>
</div>
<div class="paragraph">
<p>Por exemplo, uma rotina recursiva do fatorial pode ser definida da seguinte maneira:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fat(n::Integer)
    n &gt;= 0 || error("n deve ser inteiro não negativo")
    n == 0 &amp;&amp; return 1
    n * fat(n-1)
end</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tarefas_também_conhecidas_como_corrotinas">Tarefas (também conhecidas como Corrotinas)</h4>
<div class="paragraph">
<p>Uma <em>tarefa</em> é uma estrutura de controle que pode passar o controle cooperativamente sem retornar. Em Julia, uma tarefa pode ser implementada como uma função tendo como o primeiro argumento um objeto de canal (<code>Channel</code>). Um canal é usado para passar valores de uma função para quem a chamou.</p>
</div>
<div class="paragraph">
<p>A sequência de Fibonnaci pode ser gerada por uma tarefa.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fib(c::Channel)
    a = 0
    b = 1
    put!(c, a)
    while true
        put!(c, b)
        (a, b) = (b, a+b)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>put</code> armazena os valores em um objeto de canal e <code>take!</code> lê os valores dele:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fib_gen = Channel(fib);

julia&gt; take!(fib_gen)
0
julia&gt; take!(fib_gen)
1
julia&gt; take!(fib_gen)
1
julia&gt; take!(fib_gen)
2
julia&gt; take!(fib_gen)
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>O construtor <code>Channel</code> cria a tarefa. A função <code>fib</code> é suspendida aṕos cada chamada para <code>put!</code> e retorna depois de <code>take!</code>. Por questões de performance, diversos valores da sequência são armazenados temporariamente no objeto de canal durante um ciclo de retomada/suspensão.</p>
</div>
<div class="paragraph">
<p>Um objeto de canal também pode ser usado como um iterador:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; for val in Channel(fib)
           print(val, " ")
           val &gt; 20 &amp;&amp; break
       end
0 1 1 2 3 5 8 13 21</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tipos">Tipos</h3>
<div class="sect3">
<h4 id="_tipos_primitivos">Tipos Primitivos</h4>
<div class="paragraph">
<p>Um tipo concreto que consiste simplesmente de bits é chamado de <em>tipo primitivo</em>. Ao contrário da maioria das linguagens, no Julia você pode declarar os seus próprios tipos primitivos. Os tipos primitivos padrões são definidos da mesma maneira:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">primitive type Float64 &lt;: AbstractFloat 64 end
primitive type Bool &lt;: Integer 8 end
primitive type Char &lt;: AbstractChar 32 end
primitive type Int64 &lt;: Signed 64 end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O número nos comandos especificam quantos bits são necessários.</p>
</div>
<div class="paragraph">
<p>O exemplo a seguir cria um tipo primitivo <code>Byte</code> e um construtor:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; primitive type Byte 8 end

julia&gt; Byte(val::UInt8) = reinterpret(Byte, val)
Byte
julia&gt; b = Byte(0x01)
Byte(0x01)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função <code>reinterpret</code> é usada para armazenar os bits de um inteiro não assinado com 8 bits (<code>UInt8</code>) no byte.
</p>
</div>
</div>
<div class="sect3">
<h4 id="_tipos_paramétricos">Tipos Paramétricos</h4>
<div class="paragraph">
<p>O tipo de sistema do Julia é <em>paramétrico</em>, significando que os tipos podem possuir parâmetros.</p>
</div>
<div class="paragraph">
<p>Parâmetros de tipo são introduzidos depois do nome do tipo, cercado por chaves:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Ponto{T&lt;:Real}
    x::T
    y::T
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isso define um novo tipo paramétrico, <code>Ponto{T&lt;:Real}</code>, segurando duas "coordenadas" do tipo <code>T</code>, da qual pode ser de qualquer tipo desde que tenha <code>Real</code> como supertipo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; Ponto(0.0, 0.0)
Ponto{Float64}(0.0, 0.0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Além dos tipos compostos, tipos abstratos e tipos primitivos também podem ter um parâmetro de tipo.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Ter tipos concretos nos campos da struct é absolutamente recomendado por motivos de desempenho, portanto essa é uma boa maneira de tornar <code>Ponto</code> rápido e flexível.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_união_de_tipo">União de Tipo</h4>
<div class="paragraph">
<p>Uma <em>união de tipo</em> é um tipo paramétrico abstrato que pode atuar como qualquer um dos tipos do seu argumento:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; IntOuString = Union{Int64, String}
Union{Int64, String}
julia&gt; 150 :: IntOuString
150
julia&gt; "Julia" :: IntOuString
"Julia"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma união de tipo é na maioria das linguagens de computador uma construção interna para pensar sobre os tipos. O Julia, no entanto, expõe esse recurso aos seus usuários porque um código eficiente pode ser gerado quando a união de tipo possui um pequeno número de tipos. Esse recurso oferece ao programador do Julia uma tremenda flexibilidade para controlar o despacho.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_métodos_2">Métodos</h3>
<div class="sect3">
<h4 id="_métodos_paramétricos">Métodos Paramétricos</h4>
<div class="paragraph">
<p>As definições de método também podem ter parâmetros de tipo que qualificam sua assinatura:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; é_ponto_int(p::Ponto{T}) where {T} = (T === Int64)
é_ponto_int (generic function with 1 method)
julia&gt; p = Ponto(1, 2)
Ponto{Int64}(1, 2)
julia&gt; é_ponto_int(p)
true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_objetos_semelhantes_a_funções">Objetos Semelhantes a Funções</h4>
<div class="paragraph">
<p>Qualquer objeto arbitrário de Julia pode ser “chamado”. Tais objetos “chamáveis” às vezes são denominados  <em>functores</em>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Polinômio{R}
    coef::Vector{R}
end

function (p::Polinômio)(x)
    val = p.coef[end]
    for coef in p.coef[end-1:-1:1]
        val = val * x + coef
    end
    val
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para calcular o polinômio, basta chamá-lo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; p = Polinômio([1,10,100])
Polinômio{Int64}([1, 10, 100])
julia&gt; p(3)
931</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_construtores">Construtores</h3>
<div class="paragraph">
<p>Tipos paramétricos podem ser construídos explicitamente ou implicitamente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; Ponto(1,2)         # T implícito
Ponto{Int64}(1, 2)
julia&gt; Ponto{Int64}(1, 2) # T explícito
Ponto{Int64}(1, 2)
julia&gt; Ponto(1,2.5)       # T implícito
ERROR: MethodError: no method matching Ponto(::Int64, ::Float64)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Construtores internos e externos padrões são gerados para cada <code>T</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Ponto{T&lt;:Real}
    x::T
    y::T
    Ponto{T}(x,y) where {T&lt;:Real} = new(x,y)
end

Ponto(x::T, y::T) where {T&lt;:Real} = Ponto{T}(x,y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>e ambos <code>x</code> e <code>y</code> devem ser do mesmo tipo.</p>
</div>
<div class="paragraph">
<p>Quando <code>x</code> e <code>y</code> possuem tipos diferentes, o construtor externo a seguir pode ser definido:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">Ponto(x::Real, y::Real) = Ponto(promote(x,y)...);</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função <code>promote</code> é detalhada em <a href="#promotion">Promoção</a>.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_conversão_e_promoção">Conversão e Promoção</h3>
<div class="paragraph">
<p>O Julia tem um sistema para promover argumentos para um tipo comum. Isso não é feito automaticamente, mas pode ser facilmente realizado.</p>
</div>
<div class="sect3">
<h4 id="_conversão">Conversão</h4>
<div class="paragraph">
<p>Um valor pode ser convertido de um tipo para o outro:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = 12
12
julia&gt; typeof(x)
Int64
julia&gt; convert(UInt8, x)
0x0c
julia&gt; typeof(ans)
UInt8</code></pre>
</div>
</div>
<div class="paragraph">
<p>Podemos adicionar os nossos próprios métodos <code>convert</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; Base.convert(::Type{Ponto{T}}, x::Array{T, 1}) where {T&lt;:Real} = Ponto(x...)

julia&gt; convert(Ponto{Int64}, [1, 2])
Ponto{Int64}(1, 2)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="promotion">Promoção</h4>
<div class="paragraph">
<p><em>Promoção</em> é a conversão de valores dos tipos mistos para um único tipo comum:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; promote(1, 2.5, 3)
(1.0, 2.5, 3.0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em geral, os métodos para a função <code>promote</code> não são diretamente definidos, mas a função auxiliar <code>promote_rule</code> é usada para especificar as regras da promoção:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">promote_rule(::Type{Float64}, ::Type{Int32}) = Float64</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_metaprogramação">Metaprogramação</h3>
<div class="paragraph">
<p>O código Julia pode ser representado como uma estrutura de dados da própria linguagem. Isso permite que um programa transforme e gere o seu próprio código.</p>
</div>
<div class="sect3">
<h4 id="_expressões">Expressões</h4>
<div class="paragraph">
<p>Todo programa do Julia começa como uma string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; prog = "1 + 2"
"1 + 2"</code></pre>
</div>
</div>
<div class="paragraph">
<p>A próxima etapa é traduzir cada string em um objeto chamado <em>expressão</em>, representado pelo tipo <code>Expr</code> do Julia:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ex = Meta.parse(prog)
:(1 + 2)
julia&gt; typeof(ex)
Expr
julia&gt; dump(ex)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função <code>dump</code> detalha os objetos expr.
</p>
</div>
<div class="paragraph">
<p>Expressões podem ser diretamente construídas prefixando <code>:</code> entre parênteses ou usando uma citação em bloco
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ex = quote
           1 + 2
       end;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_eval"><code>eval</code></h4>
<div class="paragraph">
<p>O Julia pode avaliar um objeto de expressão usando <code>eval</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; eval(ex)
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cada módulo possui sua própria função <code>eval</code> que avalia as expressões em seu escopo.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Atenção</div>
</td>
<td class="content">
<div class="paragraph">
<p>Quando você está usando muitas chamadas para a função <code>eval</code>, geralmente isso significa que algo está errado. A função <code>eval</code> é considerada do “mal”.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_macros">Macros</h4>
<div class="paragraph">
<p>Macros podem incluir o código gerado em um programa. Uma <em>macro</em> mapeia uma tupla de objetos <code>Expr</code> diretamente para uma expressão compilada:
</p>
</div>
<div class="paragraph">
<p>Aqui está uma macro simples:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">macro recipiente_variável(recipiente, elemento)
    return esc(:($(Symbol(recipiente,elemento)) = $recipiente[$elemento]))
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>As macros são chamadas ao colocar o prefixo <code>@</code> (sinal de arroba) em seus nomes. A chamada de macro <code>@recipiente_variável letras 1</code> é substituída por:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">:(letras1 = letras[1])</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@macroexpand @recipiente_variável letras 1</code> retorna essa expressão que é extremamente útil para a depuração.
</p>
</div>
<div class="paragraph">
<p>Este exemplo ilustra como uma macro pode acessar o nome dos seus argumentos, algo que uma função não pode fazer. O comando return precisa ser “circundado” com <code>esc</code>, pois precisa ser resolvido no ambiente da chamada da macro.
</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Nota</div>
</td>
<td class="content">
<div class="paragraph">
<p>Por que macros?</p>
</div>
<div class="paragraph">
<p>As macros geram e incluem fragmentos de código personalizado durante o tempo de interpretação, portanto, <em>antes</em> da execução do programa completo.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_funções_geradas">Funções Geradas</h4>
<div class="paragraph">
<p>A macro <code>@generated</code> cria código especializado para os métodos, dependendo dos tipos dos argumentos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">@generated function quadrado(x)
    println(x)
    :(x * x)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O corpo retorna uma expressão entre aspas como uma macro.</p>
</div>
<div class="paragraph">
<p>Para quem chama, a <em>função gerada</em> se comporta como uma função regular:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = quadrado(2); # nota: a saída é da declaração println() no corpo
Int64
julia&gt; x                # agora imprimimos x
4
julia&gt; y = quadrado("spam");
String
julia&gt; y
"spamspam"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_valores_ausentes">Valores Ausentes</h3>
<div class="paragraph">
<p><em>Valores ausentes</em> podem ser representados através do objeto <code>missing</code>, que é a instância singleton (única) do tipo <code>Missing</code>.
</p>
</div>
<div class="paragraph">
<p>As listas podem conter valores ausentes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = [1, missing]
2-element Array{Union{Missing, Int64},1}:
 1
  missing</code></pre>
</div>
</div>
<div class="paragraph">
<p>O tipo de elemento dessa lista é <code>Union{Missing, T}</code>, sendo <code>T</code> o tipo de valores não ausentes.</p>
</div>
<div class="paragraph">
<p>As funções de redução retornam <code>missing</code> quando chamadas nas listas que contêm valores ausentes</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; sum(a)
missing</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nessa situação, use a função <code>skipmissing</code> para ignorar os valores ausentes:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; sum(skipmissing([1, missing]))
1</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_chamando_códigos_em_c_e_fortran">Chamando Códigos em C e Fortran</h3>
<div class="paragraph">
<p>Muitos códigos estão escritos em C ou Fortran. Reutilizar o código testado geralmente é melhor do que escrever sua própria versão de um algoritmo. Julia pode chamar diretamente as bibliotecas existentes em C ou Fortran usando a sintaxe <code>ccall</code>.
</p>
</div>
<div class="paragraph">
<p>Em <a href="#databases">[databases]</a>, introduzimos uma interface Julia para a biblioteca GDBM de funções de banco de dados. A biblioteca está escrita em C. Para fechar o banco de dados, uma chamada de função para <code>close(db)</code> teve que ser feita:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">Base.close(dbm::DBM) = gdbm_close(dbm.handle)

function gdbm_close(handle::Ptr{Cvoid})
    ccall((:gdbm_close, "libgdbm"), Cvoid, (Ptr{Cvoid},), handle)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um objeto dbm possui um campo <code>handle</code> do tipo <code>Ptr{Cvoid}</code>. Este campo guarda um ponteiro C que se refere ao banco de dados. Para fechar o banco de dados, a função C <code>gdbm_close</code> deve ser chamada tendo como único argumento o ponteiro C apontando para o banco de dados e sem valor de retorno. O Julia faz isso diretamente com a função <code>ccall</code> tendo como argumentos:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>uma tupla que consiste em um símbolo que contém o nome da função que queremos chamar: <code>:gdbm_close</code> e a biblioteca compartilhada especificada como uma string: <code>"libgdm"</code>,</p>
</li>
<li>
<p>o tipo de retorno: <code>Cvoid</code>,</p>
</li>
<li>
<p>uma tupla com os tipos de argumentos: <code>(Ptr{Cvoid},)</code> e</p>
</li>
<li>
<p>os valores do argumento: <code>handle</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>O mapeamento completo da biblioteca GDBM pode ser encontrado como um exemplo no repositório do JuliaIntroBR.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_19">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">fechamento</dt>
<dd>
<p>Função que captura as variáveis do seu escopo definido.
</p>
</dd>
<dt class="hdlist1">bloco let</dt>
<dd>
<p>Bloco que aloca novas ligações de variáveis.
</p>
</dd>
<dt class="hdlist1">função anônima</dt>
<dd>
<p>Função definida sem ter um nome.
</p>
</dd>
<dt class="hdlist1">tupla nomeada</dt>
<dd>
<p>Tupla com componentes nomeados.
</p>
</dd>
<dt class="hdlist1">argumentos de palavra-chave</dt>
<dd>
<p>Argumentos identificados pelo nome e não só pela posição.
</p>
</dd>
<dt class="hdlist1">bloco do</dt>
<dd>
<p>Construção de sintaxe usada para definir e chamar uma função anônima que se parece com um bloco de código normal.
</p>
</dd>
<dt class="hdlist1">operador ternário</dt>
<dd>
<p>Operador de fluxo de controle que usa três operandos para especificar uma condição, uma expressão a ser executada quando a condição produz <code>true</code> e uma expressão a ser executada quando a condição produz <code>false</code>.
</p>
</dd>
<dt class="hdlist1">avaliação de curto-circuíto</dt>
<dd>
<p>Avaliação de um operador booleano na qual o segundo argumento é executado ou avaliado apenas se o primeiro argumento não for suficiente para determinar o valor da expressão.
</p>
</dd>
<dt class="hdlist1">tarefa (também conhecida como corrotina)</dt>
<dd>
<p>Recurso de fluxo de controle que permite a suspensão e a retomada dos cálculos de maneira flexível.
</p>
</dd>
<dt class="hdlist1">tipo primitivo</dt>
<dd>
<p>Tipo concreto cujos dados consistem simplesmente de bits.
</p>
</dd>
<dt class="hdlist1">união de tipo</dt>
<dd>
<p>Tipo que inclui como objetos todas as instâncias de qualquer um dos seus parâmetros de tipo.
</p>
</dd>
<dt class="hdlist1">tipo paramétrico</dt>
<dd>
<p>Tipo que é parametrizado.
</p>
</dd>
<dt class="hdlist1">functor</dt>
<dd>
<p>Objeto com um método associado, para que ele possa ser chamado.
</p>
</dd>
<dt class="hdlist1">conversão</dt>
<dd>
<p>A conversão permite converter um valor de um tipo para outro.
</p>
</dd>
<dt class="hdlist1">promoção</dt>
<dd>
<p>Conversão de valores de tipos mistos em um único tipo comum.
</p>
</dd>
<dt class="hdlist1">expressão</dt>
<dd>
<p>Tipo do Julia que contém uma construção de linguagem.
</p>
</dd>
<dt class="hdlist1">macro</dt>
<dd>
<p>Forma de incluir o código gerado no corpo final de um programa.
</p>
</dd>
<dt class="hdlist1">funções geradas</dt>
<dd>
<p>Funções capazes de gerar código especializado, dependendo dos tipos dos argumentos.
</p>
</dd>
<dt class="hdlist1">valores ausentes</dt>
<dd>
<p>Instâncias que representam informações sem valor.
</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap20">20. Extras: Base e a Biblioteca Padrão</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O Julia vem com baterias inclusas. O módulo <code>Base</code> contém as funções, tipos e macros mais utéis. Eles estão diretamente disponíveis no Julia.
</p>
</div>
<div class="paragraph">
<p>O Julia também fornece um grande número de módulos especializados em sua Biblioteca Padrão (Datas, Computação Distribuida, Álgebra Linear, Profiling, Números Aleatórios, &#8230;&#8203;). Funções, tipos e macros definidas na Biblioteca Padrão precisam ser importados antes de poderem ser usados:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>import <em>Módulo</em></code> importa o módulo, e <code><em>Módulo.fn(x)</em></code> chama a função <code><em>fn</em></code>
</p>
</li>
<li>
<p><code>using <em>Módulo</em></code> importa todas as funções, tipos e macros exportadas de <code><em>Módulo</em></code>.
</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Funcionalidades extras podem ser adicionadas a partir de uma crescente coleção de pacotes (<a href="https://juliaobserver.com" class="bare">https://juliaobserver.com</a>).</p>
</div>
<div class="paragraph">
<p>Este capítulo não é uma substituição à documentação oficial do Julia. Apenas damos alguns exemplos para ilustrar o que é possível sem tornar o processo exaustivo. Funções já introduzidas em algum outro lugar não estão inclusas. Uma visão geral pode ser encontrada em <a href="https://docs.julialang.org" class="bare">https://docs.julialang.org</a>.</p>
</div>
<div class="sect2">
<h3 id="_mensurando_performance">Mensurando Performance</h3>
<div class="paragraph">
<p>Nós vimos que alguns algoritmos executam melhor que outros. <code>fibonnaci</code> em <a href="#memos">Memos</a> é muito mais rápido que <code>fib</code> em <a href="#one_more_example">Mais Um Exemplo</a>. A macro <code>@time</code> permite quantificar a diferença:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fib(1)
1
julia&gt; fibonacci(1)
1
julia&gt; @time fib(40)
  0.567546 seconds (5 allocations: 176 bytes)
102334155
julia&gt; @time fibonacci(40)
  0.000012 seconds (8 allocations: 1.547 KiB)
102334155</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@time</code> exibe o tempo que a função levou para executar, o número de alocações (allocations) e a memória alocada antes de retornar o resultado. A versão memoizada é efetivamente muito mais rápida, mas requer mais memória.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Não existem almoços grátis!</p>
</div>
</blockquote>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Dica</div>
</td>
<td class="content">
<div class="paragraph">
<p>Uma função no Julia é compilada na primeira vez que é executada. Então para comparar dois algoritmos, eles devem ser implementados como funções para serem compilados e a primeira vez que são chamadas precisa ser excluída da medida de performance, caso contrário o tempo de compilação também é medido.</p>
</div>
<div class="paragraph">
<p>O pacote <code>BenchmarkTools</code> (<a href="https://github.com/JuliaCI/BenchmarkTools.jl" class="bare">https://github.com/JuliaCI/BenchmarkTools.jl</a>) fornece a macro <code>@btime</code> que faz benchmarking da maneira certa. Então use-a!</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="collections_and_data_structures">Coleções e Estruturas de Dados</h3>
<div class="paragraph">
<p>Em <a href="#dictionary_subtraction">Subtração de Dicionário</a> nós usamos dicionários para achar palavras que aparecem em um documento mas não em uma lista de palavra. A função que escrevemos recebe <code>d1</code>, que contém as palavras do documento como chaves, e <code>d2</code>, que contém a lista de palavras. Ela retorna um dicionário que contém chaves de <code>d1</code> que não estão em <code>d2</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function subtrai(d1, d2)
    res = Dict()
    for chave in keys(d1)
        if chave ∉ keys(d2)
            res[chave] = nothing
        end
    end
    res
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em todos estes dicionários, os valores são <code>nothing</code> porque nós nunca usamos eles. Como resultado, nós desperdiçamos um pouco de espaço de armazenamento.</p>
</div>
<div class="paragraph">
<p>O Julia fornece outro tipo embutido, chamado de conjunto (Set), que se comporta como uma coleção de chaves de dicionário mas sem valores. Adicionar elementos à um conjunto é rápido; assim como verificar que um elemento pertence à ele. Além disso, conjuntos fornecem funções e operadores para computar operações comuns de conjunto.
</p>
</div>
<div class="paragraph">
<p>Por exemplo, a subtração de conjuntos está disponível em uma função chamada <code>setdiff</code>. Então podemos reescrever <code>subtrai</code> assim:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function subtrai(d1, d2)
    setdiff(d1, d2)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O resultado é um conjunto ao invés de um dicionário.</p>
</div>
<div class="paragraph">
<p>Alguns dos exercicíos deste livro podem ser feitos de forma concisa e eficientemente utilizando conjuntos. Por exemplo, aqui está uma solução para <code>tem_duplicatas</code>, de <a href="#ex10-7">Exercise 10-7</a>, que usa um dicionário:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function tem_duplicatas(t)
    d = Dict()
    for x in t
        if x ∈ d
            return true
        end
        d[x] = nothing
    end
    false
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quando um elemento aparece pela primeira vez, ele é adicionado ao dicionário. Se o mesmo elemento aparece novamente, a função retorna <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Utilizando conjuntos, nós podemos escrever a mesma função assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function tem_duplicatas(t)
    length(Set(t)) &lt; length(t)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um elemento pode aparecer somente uma vez no conjunto, então se um elemento em <code>t</code> aparece mais de uma vez, o conjunto será menor que <code>t</code>. Se não há duplicatas, o conjunto terá o mesmo tamanho que <code>t</code>.</p>
</div>
<div class="paragraph">
<p>Nós também podemos usar conjuntos para fazer alguns exercícios de <a href="#chap09">Estudo de Caso: Jogo de Palavras</a>. Por exemplo, aqui está uma versão de <code>usa_somente</code> com um laço:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function usa_somente(palavra, disponível)
    for letra in palavra
        if letra ∉ disponível
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>usa_somente</code> verifica se todas as letras em <code>palavra</code> estão em <code>disponível</code>. Nós podemos reescreve-la da seguinte forma:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function usa_somente(palavra, disponível)
    Set(palavra) ⊆ Set(disponível)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O operador <code>⊆</code> (<strong><code>\subseteq TAB</code></strong>) verifica se um conjunto é um subconjunto ou algum outro conjunto, incluindo a possibilidade deles serem iguais, que ocorre se todas as letras em <code>palavra</code> aparecem em <code>disponível</code>.
</p>
</div>
<div class="sect4">
<h5 id="_exercício_20_1">Exercício 20-1</h5>
<div class="paragraph">
<p>Reescreva <code>evita</code> utilizando conjuntos.
</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_matemática">Matemática</h3>
<div class="paragraph">
<p>Números complexos também são suportados pelo Julia. A constante global <code>im</code> é vinculada ao número complexo \(\mathrm{i}\), representando a raiz quadrada de \(-1\).
</p>
</div>
<div class="paragraph">
<p>Nós podemos agora verificar a identidade de Euler.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ℯ^(im*π)+1
0.0 + 1.2246467991473532e-16im</code></pre>
</div>
</div>
<div class="paragraph">
<p>O símbolo <code>ℯ</code> (<strong><code>\euler TAB</code></strong>) é a base dos logaritmos naturais.
</p>
</div>
<div class="paragraph">
<p>Vamos ilustrar a natureza complexa de funções trigonométricas:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{\cos\left(x\right)=\frac{\mathrm{e}^{\mathrm{i}x}+\mathrm{e}^{-\mathrm{i}x}}{2}\,.}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Nós podemos agora testar esta fórmula para valores diferentes de \(x\).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = 0:0.1:2π
0.0:0.1:6.2
julia&gt; cos.(x) == 0.5*(ℯ.^(im*x)+ℯ.^(-im*x))
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aqui, outro exemplo do uso do operador ponto é mostrado. O Julia também permite que literais numéricos sejam justapostos com identificadores e coeficientes, como em <code>2π</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_strings">Strings</h3>
<div class="paragraph">
<p>Em <a href="#chap08">Strings</a> e <a href="#chap09">Estudo de Caso: Jogo de Palavras</a>, nós fizemos algumas buscas elementares com objetos string. O Julia pode no entanto, lidar com expressões regulares (<em>regexes</em>) compatíveis com o Perl, que facilita a tarefa de achar padrões complexos em objetos string.
</p>
</div>
<div class="paragraph">
<p>A função <code>usa_somente</code> pode ser implementada como uma expressão regular:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function usa_somente(palavra, disponível)
  r = Regex("[^$(disponível)]")
  !occursin(r, palavra)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A expressão regular procura um caractere que não está na string <code>disponível</code> e <code>occursin</code> retorna <code>true</code> se o padrão é achado em <code>palavra</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; usa_somente("banana", "abn")
true
julia&gt; usa_somente("bananas", "abn")
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Expressões regulares também podem ser construídas como literais strings não padronizadas prefixadas com <code>r</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; match(r"[^abn]", "banana")

julia&gt; m = match(r"[^abn]", "bananas")
RegexMatch("s")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Interpolação de strings não é permitada neste caso. A função <code>match</code> retorna nada se o padrão (um comando) não é achado, e retorna um objeto regexmatch caso contrário.
</p>
</div>
<div class="paragraph">
<p>Nós podemos extrair a seguinte informação de um objeto regexmatch:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A substring correspondente inteira: <code>m.match</code></p>
</li>
<li>
<p>as substrings capturadas como um lista de strings: <code>m.captures</code></p>
</li>
<li>
<p>o deslocamento no qual toda a correspondência inicia: <code>m.offset</code></p>
</li>
<li>
<p>os deslocamentos das substrings capturadas como uma lista: <code>m.offsets</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; m.match
"s"
julia&gt; m.offset
7</code></pre>
</div>
</div>
<div class="paragraph">
<p>Expressões regulares são extremamente poderosas e a página do manual PERL <a href="http://perldoc.perl.org/perlre.html" class="bare">http://perldoc.perl.org/perlre.html</a> fornece todos os detalhes para construir buscas bastante exóticas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arrays">Arrays</h3>
<div class="paragraph">
<p>Em <a href="#chap10">Listas</a> nós usamos um objeto lista como um container unidimensional com um índice para endereçar seus elementos. No entanto, no Julia as listas são do tipo Array, (em Inglês, não há distinção no nome) que são coleções multidimensionais.</p>
</div>
<div class="paragraph">
<p>Vamos criar uma <em>matriz</em> 2 por 3 preenchida com zeros:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; z = zeros(Float64, 2, 3)
2×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
julia&gt; typeof(z)
Array{Float64,2}</code></pre>
</div>
</div>
<div class="paragraph">
<p>O tipo desta matriz é um array que guarda pontos flutuantes com duas dimensões.
</p>
</div>
<div class="paragraph">
<p>A função <code>size</code> retorna uma tupla com seus elementos sendo o número de elementos em cada dimensão da matriz:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; size(z)
(2, 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A função <code>ones</code> constrói uma matriz com valores unitários:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; s = ones(String, 1, 3)
1×3 Array{String,2}:
 ""  ""  ""</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma string unitária é uma string vazia.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Atenção</div>
</td>
<td class="content">
<div class="paragraph">
<p><code>s</code> não é um array unidimensional:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; s ==  ["", "", ""]
false</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>s</code> é uma matriz linha e <code>["", "", ""]</code> é uma matriz coluna.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Uma matriz pode ser digitada diretamente usando a barra de espaço para separar os elementos em uma linha e um ponto e vírgula <code>;</code> para separar as linhas.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6</code></pre>
</div>
</div>
<div class="paragraph">
<p>Você pode usar os colchetes para endereçar elementos individuais:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; z[1,2] = 1
1
julia&gt; z[2,3] = 1
1
julia&gt; z
2×3 Array{Float64,2}:
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fatias podem ser usadas para cada dimensão para selecionar um subgrupo de elementos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; u = z[:,2:end]
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>O operador <code>.</code> transmite a operação para todas as dimensões:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ℯ.^(im*u)
2×2 Array{Complex{Float64},2}:
 0.540302+0.841471im       1.0+0.0im
      1.0+0.0im       0.540302+0.841471im</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interfaces">Interfaces</h3>
<div class="paragraph">
<p>O Julia específica algumas interfaces informais para definir comportamentos, isto é, métodos com um objetivo específico. Quando você extende um destes métodos para um tipo, objetos daquele tipo podem ser usados para desenvolver estes comportamentos.
</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Se algo se parece com um pato, nada como um pato e soa como um pato, então provavelmente <em>é</em> um pato.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Em <a href="#one_more_example">Mais Um Exemplo</a> nós implementamos a função <code>fib</code> retornando o \(n\)-ésimo elemento da sequência de Fibonnaci.</p>
</div>
<div class="paragraph">
<p>Percorrer os valores de uma coleção, chamada iteração, é essa interface. Vamos criar um iterando que retorna preguiçosamente a sequência de Fibonacci:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Fibonacci{T&lt;:Real} end
Fibonacci(d::DataType) = d&lt;:Real ? Fibonacci{d}() : error("Não é um tipo real!")

Base.iterate(::Fibonacci{T}) where {T&lt;:Real} = (zero(T), (one(T), one(T)))
Base.iterate(::Fibonacci{T}, estado::Tuple{T, T}) where {T&lt;:Real} = (estado[1], (estado[2], estado[1] + estado[2]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nós implementamos um tipo parametrizado sem nenhum campo chamado <code>Fibonacci</code>, um construtor externo e dois métodos <code>iterate</code>. O primeiro é chamado para inicializar o iterando e retornar a tupla consistindo do primeiro valor, 0, e o estado. O estado neste caso é uma tupla contendo o segundo e o terceiro valor, 1 e 1.</p>
</div>
<div class="paragraph">
<p>O segundo é chamado para obter o próximo valor da sequência de Fibonacci e retornar a tupla tendo como primeiro elemento o próximo valor e o segundo elemento o estado que é uma tupla com os dois próximos valores.</p>
</div>
<div class="paragraph">
<p>Nós podemos usar <code>Fibonacci</code> agora em um laço <code>for</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; for e in Fibonacci(Int64)
           e &gt; 100 &amp;&amp; break
           print(e, " ")
       end
0 1 1 2 3 5 8 13 21 34 55 89</code></pre>
</div>
</div>
<div class="paragraph">
<p>Parece que alguma mágica aconteceu, mas a explicação é simples. Um laço <code>for</code> em Julia</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for i in iter
    # corpo
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>é traduzido para:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">próximo = iterate(iter)
while próximo !== nothing
    (i, estado) = próximo
    # corpo
    próximo = iterate(iter, estado)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isto é um bom exemplo de como uma interface bem definida permite uma implementação usar todas as funções que estão cientes da interface.</p>
</div>
</div>
<div class="sect2">
<h3 id="_utilidades_interativas">Utilidades Interativas</h3>
<div class="paragraph">
<p>Nós já conhecemos o módulo <code>InteractiveUtils</code> em <a href="#interactive">Depuração</a>. A macro <code>@which</code> é somente a ponta do iceberg.
</p>
</div>
<div class="paragraph">
<p>O código Julia é transformado pela biblioteca LLVM para código de máquina em múltiplos passos. Nós podemos diretamente visualizar a saída de cada etapa.</p>
</div>
<div class="paragraph">
<p>Aqui está um exemplo simples:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function soma_de_quadrados(a::Float64, b::Float64)
    a^2 + b^2
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O primeiro passo é ver o código em nível mais baixo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; using InteractiveUtils

julia&gt; @code_lowered soma_de_quadrados(3.0, 4.0)
CodeInfo(
1 ─ %1 = Core.apply_type(Base.Val, 2)
│   %2 = (%1)()
│   %3 = Base.literal_pow(:^, a, %2)
│   %4 = Core.apply_type(Base.Val, 2)
│   %5 = (%4)()
│   %6 = Base.literal_pow(:^, b, %5)
│   %7 = %3 + %6
└──      return %7
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A macro <code>@code_lowered</code> retorna uma lista de <em>representações intermediárias</em> do código que é usado pelo compilador para gerar código otimizado.
</p>
</div>
<div class="paragraph">
<p>O próximo passo é adicionar a informação de tipo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; @code_typed soma_de_quadrados(3.0, 4.0)
CodeInfo(
1 ─ %1 = Base.mul_float(a, a)::Float64
│   %2 = Base.mul_float(b, b)::Float64
│   %3 = Base.add_float(%1, %2)::Float64
└──      return %3
) =&gt; Float64</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nós podemos ver o tipo dos resultados intermediários e o valor de retorno é corretamente inferido.</p>
</div>
<div class="paragraph">
<p>A representação do código a seguir é transformada em código LLVM:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; @code_llvm soma_de_quadrados(3.0, 4.0)
;  @ none:2 within `soma_de_quadrados'
define double @julia_soma_de_quadrados_20369(double, double) {
top:
; ┌ @ intfuncs.jl:261 within `literal_pow'
; │┌ @ float.jl:405 within `*'
    %2 = fmul double %0, %0
    %3 = fmul double %1, %1
; └└
; ┌ @ float.jl:401 within `+'
   %4 = fadd double %2, %3
; └
  ret double %4
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>E finalmente, o <em>código de máquina</em> é gerado:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; @code_native soma_de_quadrados(3.0, 4.0)
    .text
; ┌ @ none:2 within `soma_de_quadrados'
; │┌ @ intfuncs.jl:261 within `literal_pow'
; ││┌ @ none:2 within `*'
        vmulsd  %xmm0, %xmm0, %xmm0
        vmulsd  %xmm1, %xmm1, %xmm1
; │└└
; │┌ @ float.jl:401 within `+'
        vaddsd  %xmm1, %xmm0, %xmm0
; │└
        retq
        nopl    (%rax)
; └</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_depuração_15">Depuração</h3>
<div class="paragraph">
<p>As macros <code>Logging</code> fornecem uma alternativa a andaimes com declarações print:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; @warn "Abandone a depuração com printf, vós que entrais aqui!"
┌ Warning: Abandone a depuração com printf, vós que entrais aqui!
└ @ Main REPL[1]:1</code></pre>
</div>
</div>
<div class="paragraph">
<p>As declarações debug não precisam ser removidas da fonte. Por exemplo, em contraste com o <code>@warn</code> acima:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; @debug "A soma de alguns valores é $(sum(rand(100)))"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Não irá gerar nenhuma saída por padrão. Neste caso <code>sum(rand(100))</code> nunca ira ser avaliada a não ser que o <em>debug logging</em> esteja habilitado.
</p>
</div>
<div class="paragraph">
<p>O nível de logging pode ser selecionado por uma variável de ambiente chamada <code>JULIA_DEBUG</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>$ JULIA_DEBUG=all julia -e '@debug "A soma de alguns valores é $(sum(rand(100)))"'
┌ Debug:  A soma de alguns valores é 47.116520814555024
└ @ Main none:1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aqui, nós usamos <code>all</code> para obter toda informação de depuração, mas você também pode escolher gerar somente a saída para um arquivo ou módulo específico.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossário_20">Glossário</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">regex</dt>
<dd>
<p>Expressão regular, uma sequência de caracteres que definem um padrão de busca;
</p>
</dd>
<dt class="hdlist1">matriz</dt>
<dd>
<p>Um array bidimensional.
</p>
</dd>
<dt class="hdlist1">representação intermediária</dt>
<dd>
<p>Uma estrutura de dados usada internamente pelo compilador para representar código fonte.
</p>
</dd>
<dt class="hdlist1">código de máquina</dt>
<dd>
<p>Instruções de linguagem que podem ser executadas diretamente por uma unidade central de processamento (CPU) de um computador.
</p>
</dd>
<dt class="hdlist1">debug logging</dt>
<dd>
<p>Guardar mensagem de depuração em um log
</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap21">21. Depuração</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Na depuração, você deve distinguir os diferentes tipos de erros a fim de rastreá-los mais rapidamente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Os erros de sintaxe são descobertos pelo interpretador quando ele está traduzindo o código fonte para código byte. Eles sinalizam que há algo errado com a estrutura do programa. Exemplo: omitir a palavra-chave <code>end</code> no final de um bloco de função gera a mensagem um tanto redundante <code>ERROR: LoadError: syntax: incomplete: function requires end</code>.
</p>
</li>
<li>
<p>Os erros de tempo de execução são produzidos pelo interpretador se algo der errado durante a execução do programa. A maioria das mensagens de erro de tempo de execução inclui as informações sobre o local da ocorrência do erro e quais as funções que estavam sendo executadas. Exemplo: Uma recursão infinita eventualmente gera o erro de tempo de execução <code>ERROR: StackOverflowError</code>.
</p>
</li>
<li>
<p>Os erros semânticos são problemas com um programa que embora rode sem produzir mensagens de erro, não faz a coisa certa. Exemplo: Uma expressão pode não ser avaliada na ordem que você espera, levando a um resultado incorreto.
</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>O primeiro passo na depuração é descobrir com qual o tipo de erro você está lidando. Apesar das seções seguintes serem organizadas pelo tipo de erro, algumas técnicas são aplicáveis em mais de uma situação.</p>
</div>
<div class="sect2">
<h3 id="_erros_de_sintaxe">Erros de Sintaxe</h3>
<div class="paragraph">
<p>Geralmente os erros de sintaxe são fáceis de corrigir depois de você descobrir quais são eles. E infelizmente as mensagens de erro muitas vezes não são úteis. As mensagens mais comuns são <code>ERROR: LoadError: syntax: incomplete: premature end of input</code> e <code>ERROR: LoadError: syntax: unexpected "="</code>, que não são muito informativas.</p>
</div>
<div class="paragraph">
<p>Por outro lado, a mensagem te informa onde o problema ocorreu no programa. Na verdade, ela informa onde o Julia notou um problema, que não é necessariamente onde está o erro. Às vezes, o erro é anterior ao local da mensagem de erro, em geral na linha anterior.</p>
</div>
<div class="paragraph">
<p>Se você está construindo o programa de forma incremental, deve ter uma boa ideia de onde o erro está. Ele estará na última linha que você adicionou.</p>
</div>
<div class="paragraph">
<p>Caso você esteja copiando o código de um livro, comece comparando seu código com o código do livro com muito cuidado. Verifique todos os caracteres. Ao mesmo tempo, lembre-se de que o livro pode estar errado, portanto, se você perceber algo que parece um erro de sintaxe, talvez seja.</p>
</div>
<div class="paragraph">
<p>Eis algumas maneiras de evitar os erros de sintaxe mais comuns:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Certifique-se que você não está usando uma palavra-chave do Julia para um nome de variável.</p>
</li>
<li>
<p>Certifique-se que você tem a palavra-chave <code>end</code> no final de cada comando composto, incluindo os blocos <code>for</code>, <code>while</code>, <code>if</code>, e <code>function</code>.</p>
</li>
<li>
<p>Assegure-se que quaisquer strings no código estejam entre aspas correspondentes. Certifique-se de que todas as aspas são "aspas retas", e não as “aspas encaracoladas” (ou “aspas inglesas”).</p>
</li>
<li>
<p>Se você tiver strings de múltiplas linhas com aspas triplas, confira se a string foi finalizada corretamente. Uma string não finalizada pode causar um erro de token inválido no final do seu programa, ou pode tratar a parte seguinte do programa como uma string até chegar à próxima string. No segundo caso, ela pode não produzir uma mensagem de erro!</p>
</li>
<li>
<p>Um operador de abertura não fechado —<code>(</code>, <code>{</code>, ou <code>[</code>—faz com que o Julia continue com a próxima linha como parte do comando atual. Geralmente, um erro ocorre quase imediatamente na próxima linha.</p>
</li>
<li>
<p>Confira o clássico <code>=</code> em vez de <code>==</code> dentro de um condicional.</p>
</li>
<li>
<p>Se você tem caracteres não ASCII no código (incluindo as strings e os comentários), isso pode causar um problema, embora o Julia geralmente lide com caracteres não ASCII. Tenha cuidado quando você colar texto de uma página da web ou de outra fonte.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Se nada funcionar, passe para a próxima seção&#8230;&#8203;</p>
</div>
<div class="sect3">
<h4 id="_eu_continuo_fazendo_mudanças_e_não_há_diferença">Eu Continuo Fazendo Mudanças e Não Há Diferença</h4>
<div class="paragraph">
<p>Se o REPL diz que há um erro e você não o vê, talvez seja porque você e o REPL não estão visualizando o mesmo código. Verifique o seu ambiente de programação para garantir que o programa que você está editando é o mesmo que o Julia está tentando executar.</p>
</div>
<div class="paragraph">
<p>Se você não tiver certeza, tente colocar um erro de sintaxe óbvio e intencional no início do programa. Agora execute-o novamente. No caso do REPL não encontrar o novo erro, então você não está executando o novo código.</p>
</div>
<div class="paragraph">
<p>Existem alguns prováveis culpados:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Você editou o arquivo e esqueceu de salvar as alterações antes de executá-lo novamente. Alguns ambientes de programação fazem isso por você, mas outros não.</p>
</li>
<li>
<p>Você alterou o nome do arquivo, mas ainda está executando o nome antigo.</p>
</li>
<li>
<p>Algo em seu ambiente de desenvolvimento está configurado erroneamente.</p>
</li>
<li>
<p>Se você estiver escrevendo um módulo e usando <code>using</code>, certifique-se de não nomear o seu módulo com o mesmo nome de um dos módulos padrões do Julia.</p>
</li>
<li>
<p>Caso você esteja utilizando <code>using</code> para importar um módulo, lembre-se de que é necessário reiniciar o REPL ao modificar o código no módulo. Se você importar o módulo novamente, ele não faz nada.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Se você ficar preso e não conseguir descobrir o que está acontecendo, uma abordagem é começar novamente com um novo programa como “Olá, Mundo!”, e ter certeza de que você consegue executar um programa conhecido. Depois, acrescente gradualmente as peças do programa original ao novo programa.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_erros_de_tempo_de_execução">Erros de Tempo de Execução</h3>
<div class="paragraph">
<p>Quando seu programa estiver sintaticamente correto, o Julia poderá lê-lo e, pelo menos, começar a executá-lo. O que poderia dar de errado?</p>
</div>
<div class="sect3">
<h4 id="_meu_programa_não_faz_absolutamente_nada">Meu programa Não Faz Absolutamente Nada</h4>
<div class="paragraph">
<p>Esse problema é mais comum quando seu arquivo consiste de funções e classes, mas não chama uma função para iniciar a execução. Isto pode ser intencional se você planeja importar este módulo apenas para fornecer as classes e as funções.</p>
</div>
<div class="paragraph">
<p>Se não for intencional, certifique-se que há uma chamada de função no programa, e que o fluxo de execução chega até ele (veja <a href="#flow_of_execution">Fluxo de Execução</a>).
</p>
</div>
</div>
<div class="sect3">
<h4 id="_meu_programa_trava">Meu Programa Trava</h4>
<div class="paragraph">
<p>Se um programa para e parece não estar fazendo nada, ele está “travado”. Frequentemente isso significa que ele está detido em um laço infinito ou em uma repetição infinita.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se houver um laço em particular que você suspeita ser o problema, adicione um comando de impressão logo antes do laço que diz “entrando no laço” e outra logo depois que diz “saindo do laço”.</p>
<div class="paragraph">
<p>Execute o programa. Caso receba a primeira mensagem e não a segunda, então você tem um laço infinito. Vá para a subseção <a href="#infinite_loop">Laço Infinito</a> mais adiante.
</p>
</div>
</li>
<li>
<p>Na maioria das vezes, uma recursão infinita fará com que o programa funcione por um tempo e em seguida gere uma mensagem de erro <code>ERROR: LoadError: StackOverflowError</code>. Se isso acontecer, vá para a subseção <a href="#infinite_recursion">Recursão Infinita</a> mais adiante.</p>
<div class="paragraph">
<p>Se você não estiver recebendo esse erro, mas desconfia que há um problema com um método ou uma função recursiva, você ainda pode usar as técnicas descritas em <a href="#infinite_recursion">Recursão Infinita</a>.
</p>
</div>
</li>
<li>
<p>No caso de nenhum desses passos dar certo, comece a testar outros laços e outras funções e métodos recursivos.</p>
</li>
<li>
<p>Caso isso não funcione, então é possível que você não esteja entendendo o fluxo de execução do seu programa. Vá para <a href="#flow_of_execution">Fluxo de Execução</a> mais adiante.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="infinite_loop">Laço Infinito</h5>
<div class="paragraph">
<p>Se você acha que tem um laço infinito e acha que sabe qual laço está causando o problema, adicione um comando de impressão no final do laço que imprime os valores das variáveis na condição e o valor da condição.</p>
</div>
<div class="paragraph">
<p>Por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">while x &gt; 0 &amp;&amp; y &lt; 0
    # faça algo para x
    # faça algo para y
    @debug "variáveis" x y
    @debug "condições" x &gt; 0 &amp;&amp; y &lt; 0
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora, quando você executar o programa no modo de depuração, verá o valor das variáveis e a condição a cada iteração do laço. A última vez que o laço for percorrido, a condição deve ser <code>false</code>. Se o laço continuar, você poderá ver os valores de <code>x</code> e <code>y</code> e poderá descobrir por que eles não estão sendo atualizados corretamente.</p>
</div>
</div>
<div class="sect4">
<h5 id="infinite_recursion">Recursão Infinita</h5>
<div class="paragraph">
<p>Na maioria das vezes, a recursão infinita faz com que o programa funcione por um tempo e em seguida gere uma mensagem de erro <code>ERROR: LoadError: StackOverflowError</code>.
</p>
</div>
<div class="paragraph">
<p>Se você desconfia que uma função está causando uma recursão infinita, certifique-se que há um caso base. Deve haver alguma condição que causa o retorno da função sem fazer uma chamada recursiva. Caso contrário, você precisa repensar o algoritmo e identificar um caso base.</p>
</div>
<div class="paragraph">
<p>Se existe um caso base mas o programa não parece alcançá-lo, adicione um comando de impressão no começo da função para imprimir os parâmetros. E quando você executar o programa, verá algumas linhas de saída toda vez que a função for chamada, e verá também os valores dos parâmetros. Se os parâmetros não se moverem em direção ao caso base, você terá algumas idéias sobre o porquê disso ocorrer.</p>
</div>
</div>
<div class="sect4">
<h5 id="flow_of_execution">Fluxo de Execução</h5>
<div class="paragraph">
<p>Se você não tem certeza de como o fluxo de execução está se movendo pelo seu programa, adicione comandos de impressão no início de cada função com uma mensagem como “entrando na função foo”, sendo foo o nome da função.</p>
</div>
<div class="paragraph">
<p>E quando você executar o programa, um rastro de cada função que for chamada será exibido.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_quando_executo_o_programa_recebo_uma_exceção">Quando Executo o Programa, Recebo uma Exceção</h4>
<div class="paragraph">
<p>Se algo der errado durante o tempo de execução, o Julia imprime uma mensagem que inclui o nome da exceção, a linha do programa onde o problema ocorreu e um rastreamento de pilha.</p>
</div>
<div class="paragraph">
<p>O rastreamento de pilha identifica a função que está em execução no momento, e depois a função que a chamou, e depois a função que chamou essa e assim por diante. Em outras palavras, ele rastreia a sequência de chamadas de função que o levaram aonde você está, juntamente com o número da linha no seu arquivo onde cada chamada ocorreu.</p>
</div>
<div class="paragraph">
<p>O primeiro passo é examinar o local no programa onde ocorreu o erro e verificar se você consegue descobrir o que aconteceu. Listamos alguns dos erros de tempo de execução mais comuns:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">ArgumentError</dt>
<dd>
<p>Um dos argumentos para uma chamada de função não está no estado esperado.
</p>
</dd>
<dt class="hdlist1">BoundsError</dt>
<dd>
<p>Uma operação de indexação em uma lista que tentou acessar um elemento fora dos limites.
</p>
</dd>
<dt class="hdlist1">DomainError</dt>
<dd>
<p>O argumento para uma função ou construtor está fora do domínio válido.
</p>
</dd>
<dt class="hdlist1">DivideError</dt>
<dd>
<p>Tentativa de divisão inteira por um denominador de valor 0.
</p>
</dd>
<dt class="hdlist1">EOFError</dt>
<dd>
<p>Não havia mais dados disponíveis para a leitura de um arquivo ou fluxo.
</p>
</dd>
<dt class="hdlist1">InexactError</dt>
<dd>
<p>Não é possível converter exatamente para um tipo.
</p>
</dd>
<dt class="hdlist1">KeyError</dt>
<dd>
<p>Uma operação de indexação em um objeto do tipo <code>AbstractDict</code> (<code>Dict</code>) ou <code>Set</code> tentou acessar ou apagar um elemento inexistente.
</p>
</dd>
<dt class="hdlist1">MethodError</dt>
<dd>
<p>Um método com a assinatura de tipo requerida não existe na função genérica em questão. Como alternativa, não existe um método mais específico.
</p>
</dd>
<dt class="hdlist1">OutOfMemoryError</dt>
<dd>
<p>Uma operação com muita memória alocada tanto para o sistema quanto para o coletor de lixo para manusear corretamente.
</p>
</dd>
<dt class="hdlist1">OverflowError</dt>
<dd>
<p>O resultado de uma expressão é muito grande para o tipo especificado e causará uma explosão.
</p>
</dd>
<dt class="hdlist1">StackOverflowError</dt>
<dd>
<p>A chamada de função cresceu além do tamanho da pilha de chamadas. Isso geralmente acontece quando uma chamada cai em uma recursão infinita.
</p>
</dd>
<dt class="hdlist1">StringIndexError</dt>
<dd>
<p>Ocorrência de um erro ao tentar acessar um índice inválido em uma string.
</p>
</dd>
<dt class="hdlist1">SystemError</dt>
<dd>
<p>Uma chamada de sistema falhou com um código de erro.
</p>
</dd>
<dt class="hdlist1">TypeError</dt>
<dd>
<p>Uma falha de asserção de tipo ou chamada de uma função intrínseca com um tipo de argumento incorreto.
</p>
</dd>
<dt class="hdlist1">UndefVarError</dt>
<dd>
<p>Um símbolo no escopo atual que não está definido.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_adicionei_tantos_comandos_de_impressão_que_sou_inundado_com_a_saída">Adicionei Tantos Comandos de Impressão que Sou Inundado com a Saída</h4>
<div class="paragraph">
<p>Um dos problemas com o uso dos comandos de impressão para a depuração é que você pode acabar soterrado pelas mensagens na saída. Existem duas maneiras de proceder: simplificar a saída ou o programa.</p>
</div>
<div class="paragraph">
<p>Para simplificar a saída, você pode remover ou comentar os comandos de impressão que não estão ajudando, ou combiná-los, ou formatar a saída para facilitar a compreensão.</p>
</div>
<div class="paragraph">
<p>Para simplificar o programa, existem muitas coisas que se pode fazer. Primeiro, reduza o problema no qual o programa está trabalhando. Por exemplo, se você estiver fazendo uma busca em uma lista, busque em uma lista pequena. No caso do programa receber a entrada do usuário, passe a entrada mais simples que cause o problema.</p>
</div>
<div class="paragraph">
<p>Segundo, limpe o programa. Remova o código morto e reorganize o programa para torná-lo o mais fácil possível de ler. Por exemplo, se você suspeita que o problema está em uma parte profundamente aninhada do programa, tente reescrever essa parte com uma estrutura mais simples. Mas se você suspeitar de uma função grande, tente dividi-la em funções menores e testá-las separadamente.
</p>
</div>
<div class="paragraph">
<p>Freqüentemente, o processo de encontrar o menor caso de teste leva você ao erro. Se você achar que um programa funciona em uma situação, mas não em outra, isso lhe dará uma pista sobre o que está acontecendo.</p>
</div>
<div class="paragraph">
<p>Da mesma forma, reescrever uma parte do código pode te ajudar a encontrar os erros sutis. Se você fizer uma mudança que você acha que não deve afetar o programa, e ela afeta, isso pode te dar uma dica.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_erros_semânticos">Erros Semânticos</h3>
<div class="paragraph">
<p>De certa forma, os erros semânticos são os mais difíceis de depurar, porque o interpretador não fornece informações sobre o que está errado. Só você sabe o que o programa deve fazer.</p>
</div>
<div class="paragraph">
<p>O primeiro passo é conectar o texto do programa ao comportamento que você está vendo. Você precisa de uma hipótese sobre o que o programa está realmente fazendo. Um dos fatores que dificulta isso é que os computadores executam muito rápido.</p>
</div>
<div class="paragraph">
<p>Muitas vezes você vai desejar diminuir a velocidade do programa para a velocidade humana. Inserir alguns bem colocados comandos de impressão é muitas vezes mais rápido do que configurar um depurador, inserir e remover pontos de interrupção e “andar” pelo programa até onde o erro está ocorrendo.</p>
</div>
<div class="sect3">
<h4 id="_meu_programa_não_funciona">Meu Programa Não Funciona</h4>
<div class="paragraph">
<p>Você deve fazer estas perguntas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Existe algo que o programa deveria fazer, mas parece que não está fazendo? Encontre a seção do código que executa essa função e verifique se ela está executando quando você acha que deve.</p>
</li>
<li>
<p>Está acontecendo algo que não deveria? Encontre o código no seu programa que executa essa função e veja se ela está sendo executada quando não deveria.</p>
</li>
<li>
<p>Uma seção do código resulta em algo que não é o que você esperava? Certifique-se que você entende o código em questão, especialmente se ele envolve as funções ou os métodos em outros módulos do Julia. Leia a documentação para as funções que você chama. Experimente-as escrevendo casos de teste simples e verificando os resultados.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para programar, é preciso um modelo mental de como os programas funcionam. Se você escreve um programa que não faz o que você deseja, com frequência o problema não está no programa e sim, no seu modelo mental.
</p>
</div>
<div class="paragraph">
<p>A melhor maneira de reparar o seu modelo mental é particionar o programa em seus componentes (geralmente as funções e os métodos) e testar cada componente isoladamente. Uma vez encontrada a discrepância entre o seu modelo e a realidade, você pode resolver o problema.</p>
</div>
<div class="paragraph">
<p>É claro que você deve criar e testar componentes à medida que desenvolve o seu programa. Então ao encontrar um problema, deve haver apenas uma pequena quantidade de código novo que não se sabe se está ou não correto.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tenho_uma_grande_expressão_bizarra_e_ela_não_faz_o_que_eu_espero">Tenho uma Grande Expressão Bizarra e Ela Não Faz o Que Eu Espero</h4>
<div class="paragraph">
<p>Escrever expressões complexas é bom desde que sejam legíveis, mas podem ser difíceis de depurar. Muitas vezes é uma boa ideia dividir uma expressão complexa em uma série de atribuições a variáveis temporárias.</p>
</div>
<div class="paragraph">
<p>Por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">adicionar_carta(jogo.mãos[i], remover_carta(jogo.mãos[achar_vizinho(jogo, i)]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>pode ser rescrito como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">vizinho = achar_vizinho(jogo, i)
carta_escolhida = remover_carta(jogo.mãos[vizinho])
adicionar_carta(jogo.mãos[i], carta_escolhida)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A versão explícita é mais fácil de ler, já que os nomes das variáveis fornecem documentação adicional, e mais fácil de depurar, porque você pode verificar os tipos das variáveis intermediárias e exibir os seus valores.</p>
</div>
<div class="paragraph">
<p>Outro problema que pode ocorrer com as grandes expressões é que a ordem da avaliação pode não ser a que se espera. Por exemplo, se você estiver traduzindo a expressão \(\frac{x}{2\pi}\) para o Julia, pode-se escrever:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">y = x / 2 * π</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isto não está correto porque a multiplicação e a divisão têm a mesma precedência e são avaliadas da esquerda para a direita. Portanto, essa expressão calcula \(\frac{x\pi}{2}\).</p>
</div>
<div class="paragraph">
<p>Uma boa maneira de depurar expressões é adicionando parênteses para tornar explícita a ordem da avaliação:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">y = x / (2 * π)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sempre que você não tiver certeza da ordem da avaliação, use parênteses. O programa não apenas estará correto (no sentido de fazer o que você deseja), como também será mais legível para outras pessoas que não memorizaram a ordem das operações.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tenho_uma_função_que_não_retorna_o_que_eu_espero">Tenho uma Função Que Não Retorna o Que Eu Espero</h4>
<div class="paragraph">
<p>No caso de uma declaração return com uma expressão complexa, você não poderá imprimir o resultado antes de retornar. Mais uma vez, pode-se usar uma variável temporária. Por exemplo, em vez de:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">return remove_combinações(jogo.mãos[i])</code></pre>
</div>
</div>
<div class="paragraph">
<p>você poderia escrever:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">contagem = remove_combinações(jogo.mãos[i])
return contagem</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora você tem a oportunidade de mostrar o valor de <code>contagem</code> antes de retornar.</p>
</div>
</div>
<div class="sect3">
<h4 id="_estou_muito_muito_empacado_e_preciso_de_ajuda">Estou Muito, Muito Empacado e Preciso de Ajuda</h4>
<div class="paragraph">
<p>Primeiro, tente ficar longe do computador por alguns minutos. Trabalhar com um computador pode causar estes sintomas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Frustração e raiva.</p>
</li>
<li>
<p>Crenças supersticiosas (“o computador me odeia”) e o pensamento mágico (“o programa só funciona quando eu uso meu chapéu para trás”).</p>
</li>
<li>
<p>Programação aleatória (a tentativa de programar escrevendo todos os programas possíveis e escolhendo o que faz a coisa certa).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Caso você esteja sofrendo algum desses sintomas, levante-se e dê um passeio. No momento que se acalmar, pense no programa. O que isso está fazendo? Quais são algumas das causas possíveis desse comportamento? Quando foi a última vez que você teve um programa funcional e o que fez a seguir?</p>
</div>
<div class="paragraph">
<p>Às vezes leva tempo para encontrar um erro. Muitas vezes encontro os erros quando estou longe do computador e deixo a minha mente vaguear. Alguns dos melhores lugares para encontrar os erros são os trens, os chuveiros, e na cama, pouco antes de dormir.</p>
</div>
</div>
<div class="sect3">
<h4 id="_não_eu_realmente_preciso_de_ajuda">Não, Eu Realmente Preciso de Ajuda</h4>
<div class="paragraph">
<p>Acontece. Mesmo os melhores programadores ocasionalmente ficam empacados. Às vezes você trabalha em um programa por tanto tempo que não consegue ver o erro. E precisa de um novo par de olhos.</p>
</div>
<div class="paragraph">
<p>Antes de trazer alguém, esteja preparado. Seu programa deve ser o mais simples possível e você deve trabalhar na menor entrada que causa o erro. Você também deve ter comandos de impressão nos locais apropriados (e as saídas geradas devem ser compreensíveis). Além disso, deve-se entender bem o problema para descrevê-lo de forma concisa.</p>
</div>
<div class="paragraph">
<p>Ao trazer alguém para te ajudar, não deixe de fornecer as informações de que eles precisam:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se houver uma mensagem de erro, qual é e para qual parte do programa indica?</p>
</li>
<li>
<p>Qual foi a última coisa que foi feita antes deste erro aparecer? Quais foram as últimas linhas de código escritas, ou qual é o novo caso de teste que falha?</p>
</li>
<li>
<p>O que você tentou até agora, e o que você aprendeu?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ao encontrar o erro, pense um pouco no que você poderia ter feito para encontrá-lo mais rapidamente. Da próxima vez que vir algo semelhante, poderá encontrar o erro com mais agilidade.</p>
</div>
<div class="paragraph">
<p>Lembre-se, o objetivo não é apenas fazer o programa funcionar. O objetivo é aprender como fazer o programa funcionar.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_entrada_unicode">Apêndice A: Entrada Unicode</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A tabela a seguir lista alguns caracteres Unicode de muitos que podem ser introduzios usando completamente por TAB de abreviações tipo LaTeX no REPL do Julia (e em vários editores).
</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Caractere</th>
<th class="tableblock halign-left valign-top">Sequência de completamento com TAB</th>
<th class="tableblock halign-left valign-top">representação ASCII</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>²</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\^2</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>₁</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\_1</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>₂</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\_2</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>🍎</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\:apple:</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>🍌</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\:banana:</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>🐫</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\:camel:</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>🍐</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\:pear:</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>🐢</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\:turtle:</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>∩</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\cap</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>≡</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\equiv</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>===</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ℯ</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\euler</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>∈</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\in</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>in</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>≥</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\ge</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;=</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>≤</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\le</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;=</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>≠</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\ne</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!=</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>∉</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\notin</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>π</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\pi</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pi</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>⊆</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\subseteq</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ε</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\varepsilon</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="editores-online">Apêndice B: Editores online</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Listamos algumas alternativas para a execução de código Julia online aqui. A lista não é exaustiva.
Nossa preferência é o Repl.it, por ser o recomendado pelo organização do Julia.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://repl.it">Repl.it</a></p>
</li>
<li>
<p><a href="https://nextjournal.com/">NextJournal</a></p>
</li>
<li>
<p><a href="https://binder.org">Binder</a></p>
</li>
<li>
<p><a href="https://codeocean.com">CodeOcean</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="diferencas-ptbr">Apêndice C: Diferenças na tradução</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Esta é uma tradução do <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html">ThinkJulia</a>.
Tanto o original quanto este livro estão disponíveis sob a licença <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.pt_BR">Creative Commons Atribuição-NãoComercial 3.0 Não Adaptada</a>.</p>
</div>
<div class="paragraph">
<p>As diferenças significatives do ThinkJulia para esta versão são:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Esta versão é uma tradução do inglês para o português brasileiro.</p>
</li>
<li>
<p>Muitas frases idiomáticas foram adaptadas ou removidas, por não fazerem sentido literal no Brasil.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_index">Index</h2>
<div class="sectionbody">

</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Reeves, Byron, e Clifford Ivar Nass. 1996. “The Media Equation: How People Treat Computers, Television, and New Media Like Real People and Places.” Chicago, IL: Center for the Study of Language and Information; New York: Cambridge University Press.
</div>
</div>
<div id="footer">
<div id="footer-text">
Última atualização 2020-07-24 01:03:15 UTC
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>